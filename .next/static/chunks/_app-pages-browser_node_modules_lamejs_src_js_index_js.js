/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_lamejs_src_js_index_js"],{

/***/ "(app-pages-browser)/./node_modules/lamejs/src/js/ATH.js":
/*!*******************************************!*\
  !*** ./node_modules/lamejs/src/js/ATH.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var common = __webpack_require__(/*! ./common.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/common.js\");\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\nvar Encoder = __webpack_require__(/*! ./Encoder.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/Encoder.js\");\n\n/**\n * ATH related stuff, if something new ATH related has to be added, please plug\n * it here into the ATH.\n */\nfunction ATH() {\n    /**\n     * Method for the auto adjustment.\n     */\n    this.useAdjust = 0;\n    /**\n     * factor for tuning the (sample power) point below which adaptive threshold\n     * of hearing adjustment occurs\n     */\n    this.aaSensitivityP = 0.;\n    /**\n     * Lowering based on peak volume, 1 = no lowering.\n     */\n    this.adjust = 0.;\n    /**\n     * Limit for dynamic ATH adjust.\n     */\n    this.adjustLimit = 0.;\n    /**\n     * Determined to lower x dB each second.\n     */\n    this.decay = 0.;\n    /**\n     * Lowest ATH value.\n     */\n    this.floor = 0.;\n    /**\n     * ATH for sfbs in long blocks.\n     */\n    this.l = new_float(Encoder.SBMAX_l);\n    /**\n     * ATH for sfbs in short blocks.\n     */\n    this.s = new_float(Encoder.SBMAX_s);\n    /**\n     * ATH for partitioned sfb21 in long blocks.\n     */\n    this.psfb21 = new_float(Encoder.PSFB21);\n    /**\n     * ATH for partitioned sfb12 in short blocks.\n     */\n    this.psfb12 = new_float(Encoder.PSFB12);\n    /**\n     * ATH for long block convolution bands.\n     */\n    this.cb_l = new_float(Encoder.CBANDS);\n    /**\n     * ATH for short block convolution bands.\n     */\n    this.cb_s = new_float(Encoder.CBANDS);\n    /**\n     * Equal loudness weights (based on ATH).\n     */\n    this.eql_w = new_float(Encoder.BLKSIZE / 2);\n}\n\nmodule.exports = ATH;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL0FUSC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsK0VBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLG1CQUFPLENBQUMsaUZBQWM7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xhbWVqcy9zcmMvanMvQVRILmpzP2RhZDkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uLmpzJyk7XG52YXIgU3lzdGVtID0gY29tbW9uLlN5c3RlbTtcbnZhciBWYnJNb2RlID0gY29tbW9uLlZick1vZGU7XG52YXIgRmxvYXQgPSBjb21tb24uRmxvYXQ7XG52YXIgU2hvcnRCbG9jayA9IGNvbW1vbi5TaG9ydEJsb2NrO1xudmFyIFV0aWwgPSBjb21tb24uVXRpbDtcbnZhciBBcnJheXMgPSBjb21tb24uQXJyYXlzO1xudmFyIG5ld19hcnJheV9uID0gY29tbW9uLm5ld19hcnJheV9uO1xudmFyIG5ld19ieXRlID0gY29tbW9uLm5ld19ieXRlO1xudmFyIG5ld19kb3VibGUgPSBjb21tb24ubmV3X2RvdWJsZTtcbnZhciBuZXdfZmxvYXQgPSBjb21tb24ubmV3X2Zsb2F0O1xudmFyIG5ld19mbG9hdF9uID0gY29tbW9uLm5ld19mbG9hdF9uO1xudmFyIG5ld19pbnQgPSBjb21tb24ubmV3X2ludDtcbnZhciBuZXdfaW50X24gPSBjb21tb24ubmV3X2ludF9uO1xudmFyIGFzc2VydCA9IGNvbW1vbi5hc3NlcnQ7XG5cbnZhciBFbmNvZGVyID0gcmVxdWlyZSgnLi9FbmNvZGVyLmpzJyk7XG5cbi8qKlxuICogQVRIIHJlbGF0ZWQgc3R1ZmYsIGlmIHNvbWV0aGluZyBuZXcgQVRIIHJlbGF0ZWQgaGFzIHRvIGJlIGFkZGVkLCBwbGVhc2UgcGx1Z1xuICogaXQgaGVyZSBpbnRvIHRoZSBBVEguXG4gKi9cbmZ1bmN0aW9uIEFUSCgpIHtcbiAgICAvKipcbiAgICAgKiBNZXRob2QgZm9yIHRoZSBhdXRvIGFkanVzdG1lbnQuXG4gICAgICovXG4gICAgdGhpcy51c2VBZGp1c3QgPSAwO1xuICAgIC8qKlxuICAgICAqIGZhY3RvciBmb3IgdHVuaW5nIHRoZSAoc2FtcGxlIHBvd2VyKSBwb2ludCBiZWxvdyB3aGljaCBhZGFwdGl2ZSB0aHJlc2hvbGRcbiAgICAgKiBvZiBoZWFyaW5nIGFkanVzdG1lbnQgb2NjdXJzXG4gICAgICovXG4gICAgdGhpcy5hYVNlbnNpdGl2aXR5UCA9IDAuO1xuICAgIC8qKlxuICAgICAqIExvd2VyaW5nIGJhc2VkIG9uIHBlYWsgdm9sdW1lLCAxID0gbm8gbG93ZXJpbmcuXG4gICAgICovXG4gICAgdGhpcy5hZGp1c3QgPSAwLjtcbiAgICAvKipcbiAgICAgKiBMaW1pdCBmb3IgZHluYW1pYyBBVEggYWRqdXN0LlxuICAgICAqL1xuICAgIHRoaXMuYWRqdXN0TGltaXQgPSAwLjtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVkIHRvIGxvd2VyIHggZEIgZWFjaCBzZWNvbmQuXG4gICAgICovXG4gICAgdGhpcy5kZWNheSA9IDAuO1xuICAgIC8qKlxuICAgICAqIExvd2VzdCBBVEggdmFsdWUuXG4gICAgICovXG4gICAgdGhpcy5mbG9vciA9IDAuO1xuICAgIC8qKlxuICAgICAqIEFUSCBmb3Igc2ZicyBpbiBsb25nIGJsb2Nrcy5cbiAgICAgKi9cbiAgICB0aGlzLmwgPSBuZXdfZmxvYXQoRW5jb2Rlci5TQk1BWF9sKTtcbiAgICAvKipcbiAgICAgKiBBVEggZm9yIHNmYnMgaW4gc2hvcnQgYmxvY2tzLlxuICAgICAqL1xuICAgIHRoaXMucyA9IG5ld19mbG9hdChFbmNvZGVyLlNCTUFYX3MpO1xuICAgIC8qKlxuICAgICAqIEFUSCBmb3IgcGFydGl0aW9uZWQgc2ZiMjEgaW4gbG9uZyBibG9ja3MuXG4gICAgICovXG4gICAgdGhpcy5wc2ZiMjEgPSBuZXdfZmxvYXQoRW5jb2Rlci5QU0ZCMjEpO1xuICAgIC8qKlxuICAgICAqIEFUSCBmb3IgcGFydGl0aW9uZWQgc2ZiMTIgaW4gc2hvcnQgYmxvY2tzLlxuICAgICAqL1xuICAgIHRoaXMucHNmYjEyID0gbmV3X2Zsb2F0KEVuY29kZXIuUFNGQjEyKTtcbiAgICAvKipcbiAgICAgKiBBVEggZm9yIGxvbmcgYmxvY2sgY29udm9sdXRpb24gYmFuZHMuXG4gICAgICovXG4gICAgdGhpcy5jYl9sID0gbmV3X2Zsb2F0KEVuY29kZXIuQ0JBTkRTKTtcbiAgICAvKipcbiAgICAgKiBBVEggZm9yIHNob3J0IGJsb2NrIGNvbnZvbHV0aW9uIGJhbmRzLlxuICAgICAqL1xuICAgIHRoaXMuY2JfcyA9IG5ld19mbG9hdChFbmNvZGVyLkNCQU5EUyk7XG4gICAgLyoqXG4gICAgICogRXF1YWwgbG91ZG5lc3Mgd2VpZ2h0cyAoYmFzZWQgb24gQVRIKS5cbiAgICAgKi9cbiAgICB0aGlzLmVxbF93ID0gbmV3X2Zsb2F0KEVuY29kZXIuQkxLU0laRSAvIDIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEFUSDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lamejs/src/js/ATH.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lamejs/src/js/BitStream.js":
/*!*************************************************!*\
  !*** ./node_modules/lamejs/src/js/BitStream.js ***!
  \*************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var common = __webpack_require__(/*! ./common.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/common.js\");\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\nvar Takehiro = __webpack_require__(/*! ./Takehiro.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/Takehiro.js\");\nvar Tables = __webpack_require__(/*! ./Tables.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/Tables.js\");\nvar Encoder = __webpack_require__(/*! ./Encoder.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/Encoder.js\");\nvar LameInternalFlags = __webpack_require__(/*! ./LameInternalFlags.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/LameInternalFlags.js\");\n\nBitStream.EQ = function (a, b) {\n    return (Math.abs(a) > Math.abs(b)) ? (Math.abs((a) - (b)) <= (Math\n        .abs(a) * 1e-6))\n        : (Math.abs((a) - (b)) <= (Math.abs(b) * 1e-6));\n};\n\nBitStream.NEQ = function (a, b) {\n    return !BitStream.EQ(a, b);\n};\n\nfunction BitStream() {\n    var Lame = __webpack_require__(/*! ./Lame.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/Lame.js\");\n    var self = this;\n    var CRC16_POLYNOMIAL = 0x8005;\n\n    /*\n     * we work with ints, so when doing bit manipulation, we limit ourselves to\n     * MAX_LENGTH-2 just to be on the safe side\n     */\n    var MAX_LENGTH = 32;\n\n    //GainAnalysis ga;\n    //MPGLib mpg;\n    //Version ver;\n    //VBRTag vbr;\n    var ga = null;\n    var mpg = null;\n    var ver = null;\n    var vbr = null;\n\n    //public final void setModules(GainAnalysis ga, MPGLib mpg, Version ver,\n    //\tVBRTag vbr) {\n\n    this.setModules = function (_ga, _mpg, _ver, _vbr) {\n        ga = _ga;\n        mpg = _mpg;\n        ver = _ver;\n        vbr = _vbr;\n    };\n\n    /**\n     * Bit stream buffer.\n     */\n    //private byte[] buf;\n    var buf = null;\n    /**\n     * Bit counter of bit stream.\n     */\n    var totbit = 0;\n    /**\n     * Pointer to top byte in buffer.\n     */\n    var bufByteIdx = 0;\n    /**\n     * Pointer to top bit of top byte in buffer.\n     */\n    var bufBitIdx = 0;\n\n    /**\n     * compute bitsperframe and mean_bits for a layer III frame\n     */\n    this.getframebits = function (gfp) {\n        var gfc = gfp.internal_flags;\n        var bit_rate;\n\n        /* get bitrate in kbps [?] */\n        if (gfc.bitrate_index != 0)\n            bit_rate = Tables.bitrate_table[gfp.version][gfc.bitrate_index];\n        else\n            bit_rate = gfp.brate;\n        assert(8 <= bit_rate && bit_rate <= 640);\n\n        /* main encoding routine toggles padding on and off */\n        /* one Layer3 Slot consists of 8 bits */\n        var bytes = 0 | (gfp.version + 1) * 72000 * bit_rate / gfp.out_samplerate + gfc.padding;\n        return 8 * bytes;\n    };\n\n    function putheader_bits(gfc) {\n        System.arraycopy(gfc.header[gfc.w_ptr].buf, 0, buf, bufByteIdx, gfc.sideinfo_len);\n        bufByteIdx += gfc.sideinfo_len;\n        totbit += gfc.sideinfo_len * 8;\n        gfc.w_ptr = (gfc.w_ptr + 1) & (LameInternalFlags.MAX_HEADER_BUF - 1);\n    }\n\n    /**\n     * write j bits into the bit stream\n     */\n    function putbits2(gfc, val, j) {\n        assert(j < MAX_LENGTH - 2);\n\n        while (j > 0) {\n            var k;\n            if (bufBitIdx == 0) {\n                bufBitIdx = 8;\n                bufByteIdx++;\n                assert(bufByteIdx < Lame.LAME_MAXMP3BUFFER);\n                assert(gfc.header[gfc.w_ptr].write_timing >= totbit);\n                if (gfc.header[gfc.w_ptr].write_timing == totbit) {\n                    putheader_bits(gfc);\n                }\n                buf[bufByteIdx] = 0;\n            }\n\n            k = Math.min(j, bufBitIdx);\n            j -= k;\n\n            bufBitIdx -= k;\n\n            assert(j < MAX_LENGTH);\n            /* 32 too large on 32 bit machines */\n            assert(bufBitIdx < MAX_LENGTH);\n\n            buf[bufByteIdx] |= ((val >> j) << bufBitIdx);\n            totbit += k;\n        }\n    }\n\n    /**\n     * write j bits into the bit stream, ignoring frame headers\n     */\n    function putbits_noheaders(gfc, val, j) {\n        assert(j < MAX_LENGTH - 2);\n\n        while (j > 0) {\n            var k;\n            if (bufBitIdx == 0) {\n                bufBitIdx = 8;\n                bufByteIdx++;\n                assert(bufByteIdx < Lame.LAME_MAXMP3BUFFER);\n                buf[bufByteIdx] = 0;\n            }\n\n            k = Math.min(j, bufBitIdx);\n            j -= k;\n\n            bufBitIdx -= k;\n\n            assert(j < MAX_LENGTH);\n            /* 32 too large on 32 bit machines */\n            assert(bufBitIdx < MAX_LENGTH);\n\n            buf[bufByteIdx] |= ((val >> j) << bufBitIdx);\n            totbit += k;\n        }\n    }\n\n    /**\n     * Some combinations of bitrate, Fs, and stereo make it impossible to stuff\n     * out a frame using just main_data, due to the limited number of bits to\n     * indicate main_data_length. In these situations, we put stuffing bits into\n     * the ancillary data...\n     */\n    function drain_into_ancillary(gfp, remainingBits) {\n        var gfc = gfp.internal_flags;\n        var i;\n        assert(remainingBits >= 0);\n\n        if (remainingBits >= 8) {\n            putbits2(gfc, 0x4c, 8);\n            remainingBits -= 8;\n        }\n        if (remainingBits >= 8) {\n            putbits2(gfc, 0x41, 8);\n            remainingBits -= 8;\n        }\n        if (remainingBits >= 8) {\n            putbits2(gfc, 0x4d, 8);\n            remainingBits -= 8;\n        }\n        if (remainingBits >= 8) {\n            putbits2(gfc, 0x45, 8);\n            remainingBits -= 8;\n        }\n\n        if (remainingBits >= 32) {\n            var version = ver.getLameShortVersion();\n            if (remainingBits >= 32)\n                for (i = 0; i < version.length && remainingBits >= 8; ++i) {\n                    remainingBits -= 8;\n                    putbits2(gfc, version.charAt(i), 8);\n                }\n        }\n\n        for (; remainingBits >= 1; remainingBits -= 1) {\n            putbits2(gfc, gfc.ancillary_flag, 1);\n            gfc.ancillary_flag ^= (!gfp.disable_reservoir ? 1 : 0);\n        }\n\n        assert(remainingBits == 0);\n\n    }\n\n    /**\n     * write N bits into the header\n     */\n    function writeheader(gfc, val, j) {\n        var ptr = gfc.header[gfc.h_ptr].ptr;\n\n        while (j > 0) {\n            var k = Math.min(j, 8 - (ptr & 7));\n            j -= k;\n            assert(j < MAX_LENGTH);\n            /* >> 32 too large for 32 bit machines */\n\n            gfc.header[gfc.h_ptr].buf[ptr >> 3] |= ((val >> j)) << (8 - (ptr & 7) - k);\n            ptr += k;\n        }\n        gfc.header[gfc.h_ptr].ptr = ptr;\n    }\n\n    function CRC_update(value, crc) {\n        value <<= 8;\n        for (var i = 0; i < 8; i++) {\n            value <<= 1;\n            crc <<= 1;\n\n            if ((((crc ^ value) & 0x10000) != 0))\n                crc ^= CRC16_POLYNOMIAL;\n        }\n        return crc;\n    }\n\n    this.CRC_writeheader = function (gfc, header) {\n        var crc = 0xffff;\n        /* (jo) init crc16 for error_protection */\n\n        crc = CRC_update(header[2] & 0xff, crc);\n        crc = CRC_update(header[3] & 0xff, crc);\n        for (var i = 6; i < gfc.sideinfo_len; i++) {\n            crc = CRC_update(header[i] & 0xff, crc);\n        }\n\n        header[4] = (byte)(crc >> 8);\n        header[5] = (byte)(crc & 255);\n    };\n\n    function encodeSideInfo2(gfp, bitsPerFrame) {\n        var gfc = gfp.internal_flags;\n        var l3_side;\n        var gr, ch;\n\n        l3_side = gfc.l3_side;\n        gfc.header[gfc.h_ptr].ptr = 0;\n        Arrays.fill(gfc.header[gfc.h_ptr].buf, 0, gfc.sideinfo_len, 0);\n        if (gfp.out_samplerate < 16000)\n            writeheader(gfc, 0xffe, 12);\n        else\n            writeheader(gfc, 0xfff, 12);\n        writeheader(gfc, (gfp.version), 1);\n        writeheader(gfc, 4 - 3, 2);\n        writeheader(gfc, (!gfp.error_protection ? 1 : 0), 1);\n        writeheader(gfc, (gfc.bitrate_index), 4);\n        writeheader(gfc, (gfc.samplerate_index), 2);\n        writeheader(gfc, (gfc.padding), 1);\n        writeheader(gfc, (gfp.extension), 1);\n        writeheader(gfc, (gfp.mode.ordinal()), 2);\n        writeheader(gfc, (gfc.mode_ext), 2);\n        writeheader(gfc, (gfp.copyright), 1);\n        writeheader(gfc, (gfp.original), 1);\n        writeheader(gfc, (gfp.emphasis), 2);\n        if (gfp.error_protection) {\n            writeheader(gfc, 0, 16);\n            /* dummy */\n        }\n\n        if (gfp.version == 1) {\n            /* MPEG1 */\n            assert(l3_side.main_data_begin >= 0);\n            writeheader(gfc, (l3_side.main_data_begin), 9);\n\n            if (gfc.channels_out == 2)\n                writeheader(gfc, l3_side.private_bits, 3);\n            else\n                writeheader(gfc, l3_side.private_bits, 5);\n\n            for (ch = 0; ch < gfc.channels_out; ch++) {\n                var band;\n                for (band = 0; band < 4; band++) {\n                    writeheader(gfc, l3_side.scfsi[ch][band], 1);\n                }\n            }\n\n            for (gr = 0; gr < 2; gr++) {\n                for (ch = 0; ch < gfc.channels_out; ch++) {\n                    var gi = l3_side.tt[gr][ch];\n                    writeheader(gfc, gi.part2_3_length + gi.part2_length, 12);\n                    writeheader(gfc, gi.big_values / 2, 9);\n                    writeheader(gfc, gi.global_gain, 8);\n                    writeheader(gfc, gi.scalefac_compress, 4);\n\n                    if (gi.block_type != Encoder.NORM_TYPE) {\n                        writeheader(gfc, 1, 1);\n                        /* window_switching_flag */\n                        writeheader(gfc, gi.block_type, 2);\n                        writeheader(gfc, gi.mixed_block_flag, 1);\n\n                        if (gi.table_select[0] == 14)\n                            gi.table_select[0] = 16;\n                        writeheader(gfc, gi.table_select[0], 5);\n                        if (gi.table_select[1] == 14)\n                            gi.table_select[1] = 16;\n                        writeheader(gfc, gi.table_select[1], 5);\n\n                        writeheader(gfc, gi.subblock_gain[0], 3);\n                        writeheader(gfc, gi.subblock_gain[1], 3);\n                        writeheader(gfc, gi.subblock_gain[2], 3);\n                    } else {\n                        writeheader(gfc, 0, 1);\n                        /* window_switching_flag */\n                        if (gi.table_select[0] == 14)\n                            gi.table_select[0] = 16;\n                        writeheader(gfc, gi.table_select[0], 5);\n                        if (gi.table_select[1] == 14)\n                            gi.table_select[1] = 16;\n                        writeheader(gfc, gi.table_select[1], 5);\n                        if (gi.table_select[2] == 14)\n                            gi.table_select[2] = 16;\n                        writeheader(gfc, gi.table_select[2], 5);\n\n                        assert(0 <= gi.region0_count && gi.region0_count < 16);\n                        assert(0 <= gi.region1_count && gi.region1_count < 8);\n                        writeheader(gfc, gi.region0_count, 4);\n                        writeheader(gfc, gi.region1_count, 3);\n                    }\n                    writeheader(gfc, gi.preflag, 1);\n                    writeheader(gfc, gi.scalefac_scale, 1);\n                    writeheader(gfc, gi.count1table_select, 1);\n                }\n            }\n        } else {\n            /* MPEG2 */\n            assert(l3_side.main_data_begin >= 0);\n            writeheader(gfc, (l3_side.main_data_begin), 8);\n            writeheader(gfc, l3_side.private_bits, gfc.channels_out);\n\n            gr = 0;\n            for (ch = 0; ch < gfc.channels_out; ch++) {\n                var gi = l3_side.tt[gr][ch];\n                writeheader(gfc, gi.part2_3_length + gi.part2_length, 12);\n                writeheader(gfc, gi.big_values / 2, 9);\n                writeheader(gfc, gi.global_gain, 8);\n                writeheader(gfc, gi.scalefac_compress, 9);\n\n                if (gi.block_type != Encoder.NORM_TYPE) {\n                    writeheader(gfc, 1, 1);\n                    /* window_switching_flag */\n                    writeheader(gfc, gi.block_type, 2);\n                    writeheader(gfc, gi.mixed_block_flag, 1);\n\n                    if (gi.table_select[0] == 14)\n                        gi.table_select[0] = 16;\n                    writeheader(gfc, gi.table_select[0], 5);\n                    if (gi.table_select[1] == 14)\n                        gi.table_select[1] = 16;\n                    writeheader(gfc, gi.table_select[1], 5);\n\n                    writeheader(gfc, gi.subblock_gain[0], 3);\n                    writeheader(gfc, gi.subblock_gain[1], 3);\n                    writeheader(gfc, gi.subblock_gain[2], 3);\n                } else {\n                    writeheader(gfc, 0, 1);\n                    /* window_switching_flag */\n                    if (gi.table_select[0] == 14)\n                        gi.table_select[0] = 16;\n                    writeheader(gfc, gi.table_select[0], 5);\n                    if (gi.table_select[1] == 14)\n                        gi.table_select[1] = 16;\n                    writeheader(gfc, gi.table_select[1], 5);\n                    if (gi.table_select[2] == 14)\n                        gi.table_select[2] = 16;\n                    writeheader(gfc, gi.table_select[2], 5);\n\n                    assert(0 <= gi.region0_count && gi.region0_count < 16);\n                    assert(0 <= gi.region1_count && gi.region1_count < 8);\n                    writeheader(gfc, gi.region0_count, 4);\n                    writeheader(gfc, gi.region1_count, 3);\n                }\n\n                writeheader(gfc, gi.scalefac_scale, 1);\n                writeheader(gfc, gi.count1table_select, 1);\n            }\n        }\n\n        if (gfp.error_protection) {\n            /* (jo) error_protection: add crc16 information to header */\n            CRC_writeheader(gfc, gfc.header[gfc.h_ptr].buf);\n        }\n\n        {\n            var old = gfc.h_ptr;\n            assert(gfc.header[old].ptr == gfc.sideinfo_len * 8);\n\n            gfc.h_ptr = (old + 1) & (LameInternalFlags.MAX_HEADER_BUF - 1);\n            gfc.header[gfc.h_ptr].write_timing = gfc.header[old].write_timing\n                + bitsPerFrame;\n\n            if (gfc.h_ptr == gfc.w_ptr) {\n                /* yikes! we are out of header buffer space */\n                System.err\n                    .println(\"Error: MAX_HEADER_BUF too small in bitstream.c \\n\");\n            }\n\n        }\n    }\n\n    function huffman_coder_count1(gfc, gi) {\n        /* Write count1 area */\n        var h = Tables.ht[gi.count1table_select + 32];\n        var i, bits = 0;\n\n        var ix = gi.big_values;\n        var xr = gi.big_values;\n        assert(gi.count1table_select < 2);\n\n        for (i = (gi.count1 - gi.big_values) / 4; i > 0; --i) {\n            var huffbits = 0;\n            var p = 0, v;\n\n            v = gi.l3_enc[ix + 0];\n            if (v != 0) {\n                p += 8;\n                if (gi.xr[xr + 0] < 0)\n                    huffbits++;\n                assert(v <= 1);\n            }\n\n            v = gi.l3_enc[ix + 1];\n            if (v != 0) {\n                p += 4;\n                huffbits *= 2;\n                if (gi.xr[xr + 1] < 0)\n                    huffbits++;\n                assert(v <= 1);\n            }\n\n            v = gi.l3_enc[ix + 2];\n            if (v != 0) {\n                p += 2;\n                huffbits *= 2;\n                if (gi.xr[xr + 2] < 0)\n                    huffbits++;\n                assert(v <= 1);\n            }\n\n            v = gi.l3_enc[ix + 3];\n            if (v != 0) {\n                p++;\n                huffbits *= 2;\n                if (gi.xr[xr + 3] < 0)\n                    huffbits++;\n                assert(v <= 1);\n            }\n\n            ix += 4;\n            xr += 4;\n            putbits2(gfc, huffbits + h.table[p], h.hlen[p]);\n            bits += h.hlen[p];\n        }\n        return bits;\n    }\n\n    /**\n     * Implements the pseudocode of page 98 of the IS\n     */\n    function Huffmancode(gfc, tableindex, start, end, gi) {\n        var h = Tables.ht[tableindex];\n        var bits = 0;\n\n        assert(tableindex < 32);\n        if (0 == tableindex)\n            return bits;\n\n        for (var i = start; i < end; i += 2) {\n            var cbits = 0;\n            var xbits = 0;\n            var linbits = h.xlen;\n            var xlen = h.xlen;\n            var ext = 0;\n            var x1 = gi.l3_enc[i];\n            var x2 = gi.l3_enc[i + 1];\n\n            if (x1 != 0) {\n                if (gi.xr[i] < 0)\n                    ext++;\n                cbits--;\n            }\n\n            if (tableindex > 15) {\n                /* use ESC-words */\n                if (x1 > 14) {\n                    var linbits_x1 = x1 - 15;\n                    assert(linbits_x1 <= h.linmax);\n                    ext |= linbits_x1 << 1;\n                    xbits = linbits;\n                    x1 = 15;\n                }\n\n                if (x2 > 14) {\n                    var linbits_x2 = x2 - 15;\n                    assert(linbits_x2 <= h.linmax);\n                    ext <<= linbits;\n                    ext |= linbits_x2;\n                    xbits += linbits;\n                    x2 = 15;\n                }\n                xlen = 16;\n            }\n\n            if (x2 != 0) {\n                ext <<= 1;\n                if (gi.xr[i + 1] < 0)\n                    ext++;\n                cbits--;\n            }\n\n            assert((x1 | x2) < 16);\n\n            x1 = x1 * xlen + x2;\n            xbits -= cbits;\n            cbits += h.hlen[x1];\n\n            assert(cbits <= MAX_LENGTH);\n            assert(xbits <= MAX_LENGTH);\n\n            putbits2(gfc, h.table[x1], cbits);\n            putbits2(gfc, ext, xbits);\n            bits += cbits + xbits;\n        }\n        return bits;\n    }\n\n    /**\n     * Note the discussion of huffmancodebits() on pages 28 and 29 of the IS, as\n     * well as the definitions of the side information on pages 26 and 27.\n     */\n    function ShortHuffmancodebits(gfc, gi) {\n        var region1Start = 3 * gfc.scalefac_band.s[3];\n        if (region1Start > gi.big_values)\n            region1Start = gi.big_values;\n\n        /* short blocks do not have a region2 */\n        var bits = Huffmancode(gfc, gi.table_select[0], 0, region1Start, gi);\n        bits += Huffmancode(gfc, gi.table_select[1], region1Start,\n            gi.big_values, gi);\n        return bits;\n    }\n\n    function LongHuffmancodebits(gfc, gi) {\n        var bigvalues, bits;\n        var region1Start, region2Start;\n\n        bigvalues = gi.big_values;\n        assert(0 <= bigvalues && bigvalues <= 576);\n\n        var i = gi.region0_count + 1;\n        assert(0 <= i);\n        assert(i < gfc.scalefac_band.l.length);\n        region1Start = gfc.scalefac_band.l[i];\n        i += gi.region1_count + 1;\n        assert(0 <= i);\n        assert(i < gfc.scalefac_band.l.length);\n        region2Start = gfc.scalefac_band.l[i];\n\n        if (region1Start > bigvalues)\n            region1Start = bigvalues;\n\n        if (region2Start > bigvalues)\n            region2Start = bigvalues;\n\n        bits = Huffmancode(gfc, gi.table_select[0], 0, region1Start, gi);\n        bits += Huffmancode(gfc, gi.table_select[1], region1Start,\n            region2Start, gi);\n        bits += Huffmancode(gfc, gi.table_select[2], region2Start, bigvalues,\n            gi);\n        return bits;\n    }\n\n    function writeMainData(gfp) {\n        var gr, ch, sfb, data_bits, tot_bits = 0;\n        var gfc = gfp.internal_flags;\n        var l3_side = gfc.l3_side;\n\n        if (gfp.version == 1) {\n            /* MPEG 1 */\n            for (gr = 0; gr < 2; gr++) {\n                for (ch = 0; ch < gfc.channels_out; ch++) {\n                    var gi = l3_side.tt[gr][ch];\n                    var slen1 = Takehiro.slen1_tab[gi.scalefac_compress];\n                    var slen2 = Takehiro.slen2_tab[gi.scalefac_compress];\n                    data_bits = 0;\n                    for (sfb = 0; sfb < gi.sfbdivide; sfb++) {\n                        if (gi.scalefac[sfb] == -1)\n                            continue;\n                        /* scfsi is used */\n                        putbits2(gfc, gi.scalefac[sfb], slen1);\n                        data_bits += slen1;\n                    }\n                    for (; sfb < gi.sfbmax; sfb++) {\n                        if (gi.scalefac[sfb] == -1)\n                            continue;\n                        /* scfsi is used */\n                        putbits2(gfc, gi.scalefac[sfb], slen2);\n                        data_bits += slen2;\n                    }\n                    assert(data_bits == gi.part2_length);\n\n                    if (gi.block_type == Encoder.SHORT_TYPE) {\n                        data_bits += ShortHuffmancodebits(gfc, gi);\n                    } else {\n                        data_bits += LongHuffmancodebits(gfc, gi);\n                    }\n                    data_bits += huffman_coder_count1(gfc, gi);\n                    /* does bitcount in quantize.c agree with actual bit count? */\n                    assert(data_bits == gi.part2_3_length + gi.part2_length);\n                    tot_bits += data_bits;\n                }\n                /* for ch */\n            }\n            /* for gr */\n        } else {\n            /* MPEG 2 */\n            gr = 0;\n            for (ch = 0; ch < gfc.channels_out; ch++) {\n                var gi = l3_side.tt[gr][ch];\n                var i, sfb_partition, scale_bits = 0;\n                assert(gi.sfb_partition_table != null);\n                data_bits = 0;\n                sfb = 0;\n                sfb_partition = 0;\n\n                if (gi.block_type == Encoder.SHORT_TYPE) {\n                    for (; sfb_partition < 4; sfb_partition++) {\n                        var sfbs = gi.sfb_partition_table[sfb_partition] / 3;\n                        var slen = gi.slen[sfb_partition];\n                        for (i = 0; i < sfbs; i++, sfb++) {\n                            putbits2(gfc,\n                                Math.max(gi.scalefac[sfb * 3 + 0], 0), slen);\n                            putbits2(gfc,\n                                Math.max(gi.scalefac[sfb * 3 + 1], 0), slen);\n                            putbits2(gfc,\n                                Math.max(gi.scalefac[sfb * 3 + 2], 0), slen);\n                            scale_bits += 3 * slen;\n                        }\n                    }\n                    data_bits += ShortHuffmancodebits(gfc, gi);\n                } else {\n                    for (; sfb_partition < 4; sfb_partition++) {\n                        var sfbs = gi.sfb_partition_table[sfb_partition];\n                        var slen = gi.slen[sfb_partition];\n                        for (i = 0; i < sfbs; i++, sfb++) {\n                            putbits2(gfc, Math.max(gi.scalefac[sfb], 0), slen);\n                            scale_bits += slen;\n                        }\n                    }\n                    data_bits += LongHuffmancodebits(gfc, gi);\n                }\n                data_bits += huffman_coder_count1(gfc, gi);\n                /* does bitcount in quantize.c agree with actual bit count? */\n                assert(data_bits == gi.part2_3_length);\n                assert(scale_bits == gi.part2_length);\n                tot_bits += scale_bits + data_bits;\n            }\n            /* for ch */\n        }\n        /* for gf */\n        return tot_bits;\n    }\n\n    /* main_data */\n\n    function TotalBytes() {\n        this.total = 0;\n    }\n\n    /*\n     * compute the number of bits required to flush all mp3 frames currently in\n     * the buffer. This should be the same as the reservoir size. Only call this\n     * routine between frames - i.e. only after all headers and data have been\n     * added to the buffer by format_bitstream().\n     *\n     * Also compute total_bits_output = size of mp3 buffer (including frame\n     * headers which may not have yet been send to the mp3 buffer) + number of\n     * bits needed to flush all mp3 frames.\n     *\n     * total_bytes_output is the size of the mp3 output buffer if\n     * lame_encode_flush_nogap() was called right now.\n     */\n    function compute_flushbits(gfp, total_bytes_output) {\n        var gfc = gfp.internal_flags;\n        var flushbits, remaining_headers;\n        var bitsPerFrame;\n        var last_ptr, first_ptr;\n        first_ptr = gfc.w_ptr;\n        /* first header to add to bitstream */\n        last_ptr = gfc.h_ptr - 1;\n        /* last header to add to bitstream */\n        if (last_ptr == -1)\n            last_ptr = LameInternalFlags.MAX_HEADER_BUF - 1;\n\n        /* add this many bits to bitstream so we can flush all headers */\n        flushbits = gfc.header[last_ptr].write_timing - totbit;\n        total_bytes_output.total = flushbits;\n\n        if (flushbits >= 0) {\n            /* if flushbits >= 0, some headers have not yet been written */\n            /* reduce flushbits by the size of the headers */\n            remaining_headers = 1 + last_ptr - first_ptr;\n            if (last_ptr < first_ptr)\n                remaining_headers = 1 + last_ptr - first_ptr\n                    + LameInternalFlags.MAX_HEADER_BUF;\n            flushbits -= remaining_headers * 8 * gfc.sideinfo_len;\n        }\n\n        /*\n         * finally, add some bits so that the last frame is complete these bits\n         * are not necessary to decode the last frame, but some decoders will\n         * ignore last frame if these bits are missing\n         */\n        bitsPerFrame = self.getframebits(gfp);\n        flushbits += bitsPerFrame;\n        total_bytes_output.total += bitsPerFrame;\n        /* round up: */\n        if ((total_bytes_output.total % 8) != 0)\n            total_bytes_output.total = 1 + (total_bytes_output.total / 8);\n        else\n            total_bytes_output.total = (total_bytes_output.total / 8);\n        total_bytes_output.total += bufByteIdx + 1;\n\n        if (flushbits < 0) {\n            System.err.println(\"strange error flushing buffer ... \\n\");\n        }\n        return flushbits;\n    }\n\n    this.flush_bitstream = function (gfp) {\n        var gfc = gfp.internal_flags;\n        var l3_side;\n        var flushbits;\n        var last_ptr = gfc.h_ptr - 1;\n        /* last header to add to bitstream */\n        if (last_ptr == -1)\n            last_ptr = LameInternalFlags.MAX_HEADER_BUF - 1;\n        l3_side = gfc.l3_side;\n\n        if ((flushbits = compute_flushbits(gfp, new TotalBytes())) < 0)\n            return;\n        drain_into_ancillary(gfp, flushbits);\n\n        /* check that the 100% of the last frame has been written to bitstream */\n        assert(gfc.header[last_ptr].write_timing + this.getframebits(gfp) == totbit);\n\n        /*\n         * we have padded out all frames with ancillary data, which is the same\n         * as filling the bitreservoir with ancillary data, so :\n         */\n        gfc.ResvSize = 0;\n        l3_side.main_data_begin = 0;\n\n        /* save the ReplayGain value */\n        if (gfc.findReplayGain) {\n            var RadioGain = ga.GetTitleGain(gfc.rgdata);\n            assert(NEQ(RadioGain, GainAnalysis.GAIN_NOT_ENOUGH_SAMPLES));\n            gfc.RadioGain = Math.floor(RadioGain * 10.0 + 0.5) | 0;\n            /* round to nearest */\n        }\n\n        /* find the gain and scale change required for no clipping */\n        if (gfc.findPeakSample) {\n            gfc.noclipGainChange = Math.ceil(Math\n                        .log10(gfc.PeakSample / 32767.0) * 20.0 * 10.0) | 0;\n            /* round up */\n\n            if (gfc.noclipGainChange > 0) {\n                /* clipping occurs */\n                if (EQ(gfp.scale, 1.0) || EQ(gfp.scale, 0.0))\n                    gfc.noclipScale = (Math\n                        .floor((32767.0 / gfc.PeakSample) * 100.0) / 100.0);\n                /* round down */\n                else {\n                    /*\n                     * the user specified his own scaling factor. We could\n                     * suggest the scaling factor of\n                     * (32767.0/gfp.PeakSample)*(gfp.scale) but it's usually\n                     * very inaccurate. So we'd rather not advice him on the\n                     * scaling factor.\n                     */\n                    gfc.noclipScale = -1;\n                }\n            } else\n            /* no clipping */\n                gfc.noclipScale = -1;\n        }\n    };\n\n    this.add_dummy_byte = function (gfp, val, n) {\n        var gfc = gfp.internal_flags;\n        var i;\n\n        while (n-- > 0) {\n            putbits_noheaders(gfc, val, 8);\n\n            for (i = 0; i < LameInternalFlags.MAX_HEADER_BUF; ++i)\n                gfc.header[i].write_timing += 8;\n        }\n    };\n\n    /**\n     * This is called after a frame of audio has been quantized and coded. It\n     * will write the encoded audio to the bitstream. Note that from a layer3\n     * encoder's perspective the bit stream is primarily a series of main_data()\n     * blocks, with header and side information inserted at the proper locations\n     * to maintain framing. (See Figure A.7 in the IS).\n     */\n    this.format_bitstream = function (gfp) {\n        var gfc = gfp.internal_flags;\n        var l3_side;\n        l3_side = gfc.l3_side;\n\n        var bitsPerFrame = this.getframebits(gfp);\n        drain_into_ancillary(gfp, l3_side.resvDrain_pre);\n\n        encodeSideInfo2(gfp, bitsPerFrame);\n        var bits = 8 * gfc.sideinfo_len;\n        bits += writeMainData(gfp);\n        drain_into_ancillary(gfp, l3_side.resvDrain_post);\n        bits += l3_side.resvDrain_post;\n\n        l3_side.main_data_begin += (bitsPerFrame - bits) / 8;\n\n        /*\n         * compare number of bits needed to clear all buffered mp3 frames with\n         * what we think the resvsize is:\n         */\n        if (compute_flushbits(gfp, new TotalBytes()) != gfc.ResvSize) {\n            System.err.println(\"Internal buffer inconsistency. flushbits <> ResvSize\");\n        }\n\n        /*\n         * compare main_data_begin for the next frame with what we think the\n         * resvsize is:\n         */\n        if ((l3_side.main_data_begin * 8) != gfc.ResvSize) {\n            System.err.printf(\"bit reservoir error: \\n\"\n                + \"l3_side.main_data_begin: %d \\n\"\n                + \"Resvoir size:             %d \\n\"\n                + \"resv drain (post)         %d \\n\"\n                + \"resv drain (pre)          %d \\n\"\n                + \"header and sideinfo:      %d \\n\"\n                + \"data bits:                %d \\n\"\n                + \"total bits:               %d (remainder: %d) \\n\"\n                + \"bitsperframe:             %d \\n\",\n                8 * l3_side.main_data_begin, gfc.ResvSize,\n                l3_side.resvDrain_post, l3_side.resvDrain_pre,\n                8 * gfc.sideinfo_len, bits - l3_side.resvDrain_post - 8\n                * gfc.sideinfo_len, bits, bits % 8, bitsPerFrame);\n\n            System.err.println(\"This is a fatal error.  It has several possible causes:\");\n            System.err.println(\"90%%  LAME compiled with buggy version of gcc using advanced optimizations\");\n            System.err.println(\" 9%%  Your system is overclocked\");\n            System.err.println(\" 1%%  bug in LAME encoding library\");\n\n            gfc.ResvSize = l3_side.main_data_begin * 8;\n        }\n        //;\n        assert(totbit % 8 == 0);\n\n        if (totbit > 1000000000) {\n            /*\n             * to avoid totbit overflow, (at 8h encoding at 128kbs) lets reset\n             * bit counter\n             */\n            var i;\n            for (i = 0; i < LameInternalFlags.MAX_HEADER_BUF; ++i)\n                gfc.header[i].write_timing -= totbit;\n            totbit = 0;\n        }\n\n        return 0;\n    };\n\n    /**\n     * <PRE>\n     * copy data out of the internal MP3 bit buffer into a user supplied\n     *       unsigned char buffer.\n     *\n     *       mp3data=0      indicates data in buffer is an id3tags and VBR tags\n     *       mp3data=1      data is real mp3 frame data.\n     * </PRE>\n     */\n    this.copy_buffer = function (gfc, buffer, bufferPos, size, mp3data) {\n        var minimum = bufByteIdx + 1;\n        if (minimum <= 0)\n            return 0;\n        if (size != 0 && minimum > size) {\n            /* buffer is too small */\n            return -1;\n        }\n        System.arraycopy(buf, 0, buffer, bufferPos, minimum);\n        bufByteIdx = -1;\n        bufBitIdx = 0;\n\n        if (mp3data != 0) {\n            var crc = new_int(1);\n            crc[0] = gfc.nMusicCRC;\n            vbr.updateMusicCRC(crc, buffer, bufferPos, minimum);\n            gfc.nMusicCRC = crc[0];\n\n            /**\n             * sum number of bytes belonging to the mp3 stream this info will be\n             * written into the Xing/LAME header for seeking\n             */\n            if (minimum > 0) {\n                gfc.VBR_seek_table.nBytesWritten += minimum;\n            }\n\n            if (gfc.decode_on_the_fly) { /* decode the frame */\n                var pcm_buf = new_float_n([2, 1152]);\n                var mp3_in = minimum;\n                var samples_out = -1;\n                var i;\n\n                /* re-synthesis to pcm. Repeat until we get a samples_out=0 */\n                while (samples_out != 0) {\n\n                    samples_out = mpg.hip_decode1_unclipped(gfc.hip, buffer,\n                        bufferPos, mp3_in, pcm_buf[0], pcm_buf[1]);\n                    /*\n                     * samples_out = 0: need more data to decode samples_out =\n                     * -1: error. Lets assume 0 pcm output samples_out = number\n                     * of samples output\n                     */\n\n                    /*\n                     * set the lenght of the mp3 input buffer to zero, so that\n                     * in the next iteration of the loop we will be querying\n                     * mpglib about buffered data\n                     */\n                    mp3_in = 0;\n\n                    if (samples_out == -1) {\n                        /*\n                         * error decoding. Not fatal, but might screw up the\n                         * ReplayGain tag. What should we do? Ignore for now\n                         */\n                        samples_out = 0;\n                    }\n                    if (samples_out > 0) {\n                        /* process the PCM data */\n\n                        /*\n                         * this should not be possible, and indicates we have\n                         * overflown the pcm_buf buffer\n                         */\n                        assert(samples_out <= 1152);\n\n                        if (gfc.findPeakSample) {\n                            for (i = 0; i < samples_out; i++) {\n                                if (pcm_buf[0][i] > gfc.PeakSample)\n                                    gfc.PeakSample = pcm_buf[0][i];\n                                else if (-pcm_buf[0][i] > gfc.PeakSample)\n                                    gfc.PeakSample = -pcm_buf[0][i];\n                            }\n                            if (gfc.channels_out > 1)\n                                for (i = 0; i < samples_out; i++) {\n                                    if (pcm_buf[1][i] > gfc.PeakSample)\n                                        gfc.PeakSample = pcm_buf[1][i];\n                                    else if (-pcm_buf[1][i] > gfc.PeakSample)\n                                        gfc.PeakSample = -pcm_buf[1][i];\n                                }\n                        }\n\n                        if (gfc.findReplayGain)\n                            if (ga.AnalyzeSamples(gfc.rgdata, pcm_buf[0], 0,\n                                    pcm_buf[1], 0, samples_out,\n                                    gfc.channels_out) == GainAnalysis.GAIN_ANALYSIS_ERROR)\n                                return -6;\n\n                    }\n                    /* if (samples_out>0) */\n                }\n                /* while (samples_out!=0) */\n            }\n            /* if (gfc.decode_on_the_fly) */\n\n        }\n        /* if (mp3data) */\n        return minimum;\n    };\n\n    this.init_bit_stream_w = function (gfc) {\n        buf = new_byte(Lame.LAME_MAXMP3BUFFER);\n\n        gfc.h_ptr = gfc.w_ptr = 0;\n        gfc.header[gfc.h_ptr].write_timing = 0;\n        bufByteIdx = -1;\n        bufBitIdx = 0;\n        totbit = 0;\n    };\n\n    // From machine.h\n\n\n}\n\nmodule.exports = BitStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL0JpdFN0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsK0VBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLG1CQUFPLENBQUMsbUZBQWU7QUFDdEMsYUFBYSxtQkFBTyxDQUFDLCtFQUFhO0FBQ2xDLGNBQWMsbUJBQU8sQ0FBQyxpRkFBYztBQUNwQyx3QkFBd0IsbUJBQU8sQ0FBQyxxR0FBd0I7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLDJFQUFXO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBDQUEwQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0EsK0JBQStCLFVBQVU7QUFDekM7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixRQUFRO0FBQ2pDLDZCQUE2Qix1QkFBdUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrREFBa0QsT0FBTztBQUN6RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakMsNkJBQTZCLHVCQUF1QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxvQkFBb0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixtQkFBbUI7QUFDOUM7QUFDQTtBQUNBLG9DQUFvQyxVQUFVO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLDJCQUEyQixtQkFBbUI7QUFDOUM7QUFDQTtBQUNBLG9DQUFvQyxVQUFVO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCLHNDQUFzQztBQUM5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQ0FBc0M7QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QyxpQkFBaUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGlCQUFpQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL0JpdFN0cmVhbS5qcz9iMzA4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbi5qcycpO1xudmFyIFN5c3RlbSA9IGNvbW1vbi5TeXN0ZW07XG52YXIgVmJyTW9kZSA9IGNvbW1vbi5WYnJNb2RlO1xudmFyIEZsb2F0ID0gY29tbW9uLkZsb2F0O1xudmFyIFNob3J0QmxvY2sgPSBjb21tb24uU2hvcnRCbG9jaztcbnZhciBVdGlsID0gY29tbW9uLlV0aWw7XG52YXIgQXJyYXlzID0gY29tbW9uLkFycmF5cztcbnZhciBuZXdfYXJyYXlfbiA9IGNvbW1vbi5uZXdfYXJyYXlfbjtcbnZhciBuZXdfYnl0ZSA9IGNvbW1vbi5uZXdfYnl0ZTtcbnZhciBuZXdfZG91YmxlID0gY29tbW9uLm5ld19kb3VibGU7XG52YXIgbmV3X2Zsb2F0ID0gY29tbW9uLm5ld19mbG9hdDtcbnZhciBuZXdfZmxvYXRfbiA9IGNvbW1vbi5uZXdfZmxvYXRfbjtcbnZhciBuZXdfaW50ID0gY29tbW9uLm5ld19pbnQ7XG52YXIgbmV3X2ludF9uID0gY29tbW9uLm5ld19pbnRfbjtcbnZhciBhc3NlcnQgPSBjb21tb24uYXNzZXJ0O1xuXG52YXIgVGFrZWhpcm8gPSByZXF1aXJlKCcuL1Rha2VoaXJvLmpzJyk7XG52YXIgVGFibGVzID0gcmVxdWlyZSgnLi9UYWJsZXMuanMnKTtcbnZhciBFbmNvZGVyID0gcmVxdWlyZSgnLi9FbmNvZGVyLmpzJyk7XG52YXIgTGFtZUludGVybmFsRmxhZ3MgPSByZXF1aXJlKCcuL0xhbWVJbnRlcm5hbEZsYWdzLmpzJyk7XG5cbkJpdFN0cmVhbS5FUSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIChNYXRoLmFicyhhKSA+IE1hdGguYWJzKGIpKSA/IChNYXRoLmFicygoYSkgLSAoYikpIDw9IChNYXRoXG4gICAgICAgIC5hYnMoYSkgKiAxZS02KSlcbiAgICAgICAgOiAoTWF0aC5hYnMoKGEpIC0gKGIpKSA8PSAoTWF0aC5hYnMoYikgKiAxZS02KSk7XG59O1xuXG5CaXRTdHJlYW0uTkVRID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gIUJpdFN0cmVhbS5FUShhLCBiKTtcbn07XG5cbmZ1bmN0aW9uIEJpdFN0cmVhbSgpIHtcbiAgICB2YXIgTGFtZSA9IHJlcXVpcmUoJy4vTGFtZS5qcycpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgQ1JDMTZfUE9MWU5PTUlBTCA9IDB4ODAwNTtcblxuICAgIC8qXG4gICAgICogd2Ugd29yayB3aXRoIGludHMsIHNvIHdoZW4gZG9pbmcgYml0IG1hbmlwdWxhdGlvbiwgd2UgbGltaXQgb3Vyc2VsdmVzIHRvXG4gICAgICogTUFYX0xFTkdUSC0yIGp1c3QgdG8gYmUgb24gdGhlIHNhZmUgc2lkZVxuICAgICAqL1xuICAgIHZhciBNQVhfTEVOR1RIID0gMzI7XG5cbiAgICAvL0dhaW5BbmFseXNpcyBnYTtcbiAgICAvL01QR0xpYiBtcGc7XG4gICAgLy9WZXJzaW9uIHZlcjtcbiAgICAvL1ZCUlRhZyB2YnI7XG4gICAgdmFyIGdhID0gbnVsbDtcbiAgICB2YXIgbXBnID0gbnVsbDtcbiAgICB2YXIgdmVyID0gbnVsbDtcbiAgICB2YXIgdmJyID0gbnVsbDtcblxuICAgIC8vcHVibGljIGZpbmFsIHZvaWQgc2V0TW9kdWxlcyhHYWluQW5hbHlzaXMgZ2EsIE1QR0xpYiBtcGcsIFZlcnNpb24gdmVyLFxuICAgIC8vXHRWQlJUYWcgdmJyKSB7XG5cbiAgICB0aGlzLnNldE1vZHVsZXMgPSBmdW5jdGlvbiAoX2dhLCBfbXBnLCBfdmVyLCBfdmJyKSB7XG4gICAgICAgIGdhID0gX2dhO1xuICAgICAgICBtcGcgPSBfbXBnO1xuICAgICAgICB2ZXIgPSBfdmVyO1xuICAgICAgICB2YnIgPSBfdmJyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBCaXQgc3RyZWFtIGJ1ZmZlci5cbiAgICAgKi9cbiAgICAvL3ByaXZhdGUgYnl0ZVtdIGJ1ZjtcbiAgICB2YXIgYnVmID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBCaXQgY291bnRlciBvZiBiaXQgc3RyZWFtLlxuICAgICAqL1xuICAgIHZhciB0b3RiaXQgPSAwO1xuICAgIC8qKlxuICAgICAqIFBvaW50ZXIgdG8gdG9wIGJ5dGUgaW4gYnVmZmVyLlxuICAgICAqL1xuICAgIHZhciBidWZCeXRlSWR4ID0gMDtcbiAgICAvKipcbiAgICAgKiBQb2ludGVyIHRvIHRvcCBiaXQgb2YgdG9wIGJ5dGUgaW4gYnVmZmVyLlxuICAgICAqL1xuICAgIHZhciBidWZCaXRJZHggPSAwO1xuXG4gICAgLyoqXG4gICAgICogY29tcHV0ZSBiaXRzcGVyZnJhbWUgYW5kIG1lYW5fYml0cyBmb3IgYSBsYXllciBJSUkgZnJhbWVcbiAgICAgKi9cbiAgICB0aGlzLmdldGZyYW1lYml0cyA9IGZ1bmN0aW9uIChnZnApIHtcbiAgICAgICAgdmFyIGdmYyA9IGdmcC5pbnRlcm5hbF9mbGFncztcbiAgICAgICAgdmFyIGJpdF9yYXRlO1xuXG4gICAgICAgIC8qIGdldCBiaXRyYXRlIGluIGticHMgWz9dICovXG4gICAgICAgIGlmIChnZmMuYml0cmF0ZV9pbmRleCAhPSAwKVxuICAgICAgICAgICAgYml0X3JhdGUgPSBUYWJsZXMuYml0cmF0ZV90YWJsZVtnZnAudmVyc2lvbl1bZ2ZjLmJpdHJhdGVfaW5kZXhdO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBiaXRfcmF0ZSA9IGdmcC5icmF0ZTtcbiAgICAgICAgYXNzZXJ0KDggPD0gYml0X3JhdGUgJiYgYml0X3JhdGUgPD0gNjQwKTtcblxuICAgICAgICAvKiBtYWluIGVuY29kaW5nIHJvdXRpbmUgdG9nZ2xlcyBwYWRkaW5nIG9uIGFuZCBvZmYgKi9cbiAgICAgICAgLyogb25lIExheWVyMyBTbG90IGNvbnNpc3RzIG9mIDggYml0cyAqL1xuICAgICAgICB2YXIgYnl0ZXMgPSAwIHwgKGdmcC52ZXJzaW9uICsgMSkgKiA3MjAwMCAqIGJpdF9yYXRlIC8gZ2ZwLm91dF9zYW1wbGVyYXRlICsgZ2ZjLnBhZGRpbmc7XG4gICAgICAgIHJldHVybiA4ICogYnl0ZXM7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHB1dGhlYWRlcl9iaXRzKGdmYykge1xuICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KGdmYy5oZWFkZXJbZ2ZjLndfcHRyXS5idWYsIDAsIGJ1ZiwgYnVmQnl0ZUlkeCwgZ2ZjLnNpZGVpbmZvX2xlbik7XG4gICAgICAgIGJ1ZkJ5dGVJZHggKz0gZ2ZjLnNpZGVpbmZvX2xlbjtcbiAgICAgICAgdG90Yml0ICs9IGdmYy5zaWRlaW5mb19sZW4gKiA4O1xuICAgICAgICBnZmMud19wdHIgPSAoZ2ZjLndfcHRyICsgMSkgJiAoTGFtZUludGVybmFsRmxhZ3MuTUFYX0hFQURFUl9CVUYgLSAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB3cml0ZSBqIGJpdHMgaW50byB0aGUgYml0IHN0cmVhbVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1dGJpdHMyKGdmYywgdmFsLCBqKSB7XG4gICAgICAgIGFzc2VydChqIDwgTUFYX0xFTkdUSCAtIDIpO1xuXG4gICAgICAgIHdoaWxlIChqID4gMCkge1xuICAgICAgICAgICAgdmFyIGs7XG4gICAgICAgICAgICBpZiAoYnVmQml0SWR4ID09IDApIHtcbiAgICAgICAgICAgICAgICBidWZCaXRJZHggPSA4O1xuICAgICAgICAgICAgICAgIGJ1ZkJ5dGVJZHgrKztcbiAgICAgICAgICAgICAgICBhc3NlcnQoYnVmQnl0ZUlkeCA8IExhbWUuTEFNRV9NQVhNUDNCVUZGRVIpO1xuICAgICAgICAgICAgICAgIGFzc2VydChnZmMuaGVhZGVyW2dmYy53X3B0cl0ud3JpdGVfdGltaW5nID49IHRvdGJpdCk7XG4gICAgICAgICAgICAgICAgaWYgKGdmYy5oZWFkZXJbZ2ZjLndfcHRyXS53cml0ZV90aW1pbmcgPT0gdG90Yml0KSB7XG4gICAgICAgICAgICAgICAgICAgIHB1dGhlYWRlcl9iaXRzKGdmYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJ1ZltidWZCeXRlSWR4XSA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGsgPSBNYXRoLm1pbihqLCBidWZCaXRJZHgpO1xuICAgICAgICAgICAgaiAtPSBrO1xuXG4gICAgICAgICAgICBidWZCaXRJZHggLT0gaztcblxuICAgICAgICAgICAgYXNzZXJ0KGogPCBNQVhfTEVOR1RIKTtcbiAgICAgICAgICAgIC8qIDMyIHRvbyBsYXJnZSBvbiAzMiBiaXQgbWFjaGluZXMgKi9cbiAgICAgICAgICAgIGFzc2VydChidWZCaXRJZHggPCBNQVhfTEVOR1RIKTtcblxuICAgICAgICAgICAgYnVmW2J1ZkJ5dGVJZHhdIHw9ICgodmFsID4+IGopIDw8IGJ1ZkJpdElkeCk7XG4gICAgICAgICAgICB0b3RiaXQgKz0gaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHdyaXRlIGogYml0cyBpbnRvIHRoZSBiaXQgc3RyZWFtLCBpZ25vcmluZyBmcmFtZSBoZWFkZXJzXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHV0Yml0c19ub2hlYWRlcnMoZ2ZjLCB2YWwsIGopIHtcbiAgICAgICAgYXNzZXJ0KGogPCBNQVhfTEVOR1RIIC0gMik7XG5cbiAgICAgICAgd2hpbGUgKGogPiAwKSB7XG4gICAgICAgICAgICB2YXIgaztcbiAgICAgICAgICAgIGlmIChidWZCaXRJZHggPT0gMCkge1xuICAgICAgICAgICAgICAgIGJ1ZkJpdElkeCA9IDg7XG4gICAgICAgICAgICAgICAgYnVmQnl0ZUlkeCsrO1xuICAgICAgICAgICAgICAgIGFzc2VydChidWZCeXRlSWR4IDwgTGFtZS5MQU1FX01BWE1QM0JVRkZFUik7XG4gICAgICAgICAgICAgICAgYnVmW2J1ZkJ5dGVJZHhdID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgayA9IE1hdGgubWluKGosIGJ1ZkJpdElkeCk7XG4gICAgICAgICAgICBqIC09IGs7XG5cbiAgICAgICAgICAgIGJ1ZkJpdElkeCAtPSBrO1xuXG4gICAgICAgICAgICBhc3NlcnQoaiA8IE1BWF9MRU5HVEgpO1xuICAgICAgICAgICAgLyogMzIgdG9vIGxhcmdlIG9uIDMyIGJpdCBtYWNoaW5lcyAqL1xuICAgICAgICAgICAgYXNzZXJ0KGJ1ZkJpdElkeCA8IE1BWF9MRU5HVEgpO1xuXG4gICAgICAgICAgICBidWZbYnVmQnl0ZUlkeF0gfD0gKCh2YWwgPj4gaikgPDwgYnVmQml0SWR4KTtcbiAgICAgICAgICAgIHRvdGJpdCArPSBrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU29tZSBjb21iaW5hdGlvbnMgb2YgYml0cmF0ZSwgRnMsIGFuZCBzdGVyZW8gbWFrZSBpdCBpbXBvc3NpYmxlIHRvIHN0dWZmXG4gICAgICogb3V0IGEgZnJhbWUgdXNpbmcganVzdCBtYWluX2RhdGEsIGR1ZSB0byB0aGUgbGltaXRlZCBudW1iZXIgb2YgYml0cyB0b1xuICAgICAqIGluZGljYXRlIG1haW5fZGF0YV9sZW5ndGguIEluIHRoZXNlIHNpdHVhdGlvbnMsIHdlIHB1dCBzdHVmZmluZyBiaXRzIGludG9cbiAgICAgKiB0aGUgYW5jaWxsYXJ5IGRhdGEuLi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcmFpbl9pbnRvX2FuY2lsbGFyeShnZnAsIHJlbWFpbmluZ0JpdHMpIHtcbiAgICAgICAgdmFyIGdmYyA9IGdmcC5pbnRlcm5hbF9mbGFncztcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGFzc2VydChyZW1haW5pbmdCaXRzID49IDApO1xuXG4gICAgICAgIGlmIChyZW1haW5pbmdCaXRzID49IDgpIHtcbiAgICAgICAgICAgIHB1dGJpdHMyKGdmYywgMHg0YywgOCk7XG4gICAgICAgICAgICByZW1haW5pbmdCaXRzIC09IDg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbWFpbmluZ0JpdHMgPj0gOCkge1xuICAgICAgICAgICAgcHV0Yml0czIoZ2ZjLCAweDQxLCA4KTtcbiAgICAgICAgICAgIHJlbWFpbmluZ0JpdHMgLT0gODtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVtYWluaW5nQml0cyA+PSA4KSB7XG4gICAgICAgICAgICBwdXRiaXRzMihnZmMsIDB4NGQsIDgpO1xuICAgICAgICAgICAgcmVtYWluaW5nQml0cyAtPSA4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZW1haW5pbmdCaXRzID49IDgpIHtcbiAgICAgICAgICAgIHB1dGJpdHMyKGdmYywgMHg0NSwgOCk7XG4gICAgICAgICAgICByZW1haW5pbmdCaXRzIC09IDg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVtYWluaW5nQml0cyA+PSAzMikge1xuICAgICAgICAgICAgdmFyIHZlcnNpb24gPSB2ZXIuZ2V0TGFtZVNob3J0VmVyc2lvbigpO1xuICAgICAgICAgICAgaWYgKHJlbWFpbmluZ0JpdHMgPj0gMzIpXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZlcnNpb24ubGVuZ3RoICYmIHJlbWFpbmluZ0JpdHMgPj0gODsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZ0JpdHMgLT0gODtcbiAgICAgICAgICAgICAgICAgICAgcHV0Yml0czIoZ2ZjLCB2ZXJzaW9uLmNoYXJBdChpKSwgOCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICg7IHJlbWFpbmluZ0JpdHMgPj0gMTsgcmVtYWluaW5nQml0cyAtPSAxKSB7XG4gICAgICAgICAgICBwdXRiaXRzMihnZmMsIGdmYy5hbmNpbGxhcnlfZmxhZywgMSk7XG4gICAgICAgICAgICBnZmMuYW5jaWxsYXJ5X2ZsYWcgXj0gKCFnZnAuZGlzYWJsZV9yZXNlcnZvaXIgPyAxIDogMCk7XG4gICAgICAgIH1cblxuICAgICAgICBhc3NlcnQocmVtYWluaW5nQml0cyA9PSAwKTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHdyaXRlIE4gYml0cyBpbnRvIHRoZSBoZWFkZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cml0ZWhlYWRlcihnZmMsIHZhbCwgaikge1xuICAgICAgICB2YXIgcHRyID0gZ2ZjLmhlYWRlcltnZmMuaF9wdHJdLnB0cjtcblxuICAgICAgICB3aGlsZSAoaiA+IDApIHtcbiAgICAgICAgICAgIHZhciBrID0gTWF0aC5taW4oaiwgOCAtIChwdHIgJiA3KSk7XG4gICAgICAgICAgICBqIC09IGs7XG4gICAgICAgICAgICBhc3NlcnQoaiA8IE1BWF9MRU5HVEgpO1xuICAgICAgICAgICAgLyogPj4gMzIgdG9vIGxhcmdlIGZvciAzMiBiaXQgbWFjaGluZXMgKi9cblxuICAgICAgICAgICAgZ2ZjLmhlYWRlcltnZmMuaF9wdHJdLmJ1ZltwdHIgPj4gM10gfD0gKCh2YWwgPj4gaikpIDw8ICg4IC0gKHB0ciAmIDcpIC0gayk7XG4gICAgICAgICAgICBwdHIgKz0gaztcbiAgICAgICAgfVxuICAgICAgICBnZmMuaGVhZGVyW2dmYy5oX3B0cl0ucHRyID0gcHRyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIENSQ191cGRhdGUodmFsdWUsIGNyYykge1xuICAgICAgICB2YWx1ZSA8PD0gODtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlIDw8PSAxO1xuICAgICAgICAgICAgY3JjIDw8PSAxO1xuXG4gICAgICAgICAgICBpZiAoKCgoY3JjIF4gdmFsdWUpICYgMHgxMDAwMCkgIT0gMCkpXG4gICAgICAgICAgICAgICAgY3JjIF49IENSQzE2X1BPTFlOT01JQUw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyYztcbiAgICB9XG5cbiAgICB0aGlzLkNSQ193cml0ZWhlYWRlciA9IGZ1bmN0aW9uIChnZmMsIGhlYWRlcikge1xuICAgICAgICB2YXIgY3JjID0gMHhmZmZmO1xuICAgICAgICAvKiAoam8pIGluaXQgY3JjMTYgZm9yIGVycm9yX3Byb3RlY3Rpb24gKi9cblxuICAgICAgICBjcmMgPSBDUkNfdXBkYXRlKGhlYWRlclsyXSAmIDB4ZmYsIGNyYyk7XG4gICAgICAgIGNyYyA9IENSQ191cGRhdGUoaGVhZGVyWzNdICYgMHhmZiwgY3JjKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDY7IGkgPCBnZmMuc2lkZWluZm9fbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNyYyA9IENSQ191cGRhdGUoaGVhZGVyW2ldICYgMHhmZiwgY3JjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhlYWRlcls0XSA9IChieXRlKShjcmMgPj4gOCk7XG4gICAgICAgIGhlYWRlcls1XSA9IChieXRlKShjcmMgJiAyNTUpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBlbmNvZGVTaWRlSW5mbzIoZ2ZwLCBiaXRzUGVyRnJhbWUpIHtcbiAgICAgICAgdmFyIGdmYyA9IGdmcC5pbnRlcm5hbF9mbGFncztcbiAgICAgICAgdmFyIGwzX3NpZGU7XG4gICAgICAgIHZhciBnciwgY2g7XG5cbiAgICAgICAgbDNfc2lkZSA9IGdmYy5sM19zaWRlO1xuICAgICAgICBnZmMuaGVhZGVyW2dmYy5oX3B0cl0ucHRyID0gMDtcbiAgICAgICAgQXJyYXlzLmZpbGwoZ2ZjLmhlYWRlcltnZmMuaF9wdHJdLmJ1ZiwgMCwgZ2ZjLnNpZGVpbmZvX2xlbiwgMCk7XG4gICAgICAgIGlmIChnZnAub3V0X3NhbXBsZXJhdGUgPCAxNjAwMClcbiAgICAgICAgICAgIHdyaXRlaGVhZGVyKGdmYywgMHhmZmUsIDEyKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCAweGZmZiwgMTIpO1xuICAgICAgICB3cml0ZWhlYWRlcihnZmMsIChnZnAudmVyc2lvbiksIDEpO1xuICAgICAgICB3cml0ZWhlYWRlcihnZmMsIDQgLSAzLCAyKTtcbiAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCAoIWdmcC5lcnJvcl9wcm90ZWN0aW9uID8gMSA6IDApLCAxKTtcbiAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCAoZ2ZjLmJpdHJhdGVfaW5kZXgpLCA0KTtcbiAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCAoZ2ZjLnNhbXBsZXJhdGVfaW5kZXgpLCAyKTtcbiAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCAoZ2ZjLnBhZGRpbmcpLCAxKTtcbiAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCAoZ2ZwLmV4dGVuc2lvbiksIDEpO1xuICAgICAgICB3cml0ZWhlYWRlcihnZmMsIChnZnAubW9kZS5vcmRpbmFsKCkpLCAyKTtcbiAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCAoZ2ZjLm1vZGVfZXh0KSwgMik7XG4gICAgICAgIHdyaXRlaGVhZGVyKGdmYywgKGdmcC5jb3B5cmlnaHQpLCAxKTtcbiAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCAoZ2ZwLm9yaWdpbmFsKSwgMSk7XG4gICAgICAgIHdyaXRlaGVhZGVyKGdmYywgKGdmcC5lbXBoYXNpcyksIDIpO1xuICAgICAgICBpZiAoZ2ZwLmVycm9yX3Byb3RlY3Rpb24pIHtcbiAgICAgICAgICAgIHdyaXRlaGVhZGVyKGdmYywgMCwgMTYpO1xuICAgICAgICAgICAgLyogZHVtbXkgKi9cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnZnAudmVyc2lvbiA9PSAxKSB7XG4gICAgICAgICAgICAvKiBNUEVHMSAqL1xuICAgICAgICAgICAgYXNzZXJ0KGwzX3NpZGUubWFpbl9kYXRhX2JlZ2luID49IDApO1xuICAgICAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCAobDNfc2lkZS5tYWluX2RhdGFfYmVnaW4pLCA5KTtcblxuICAgICAgICAgICAgaWYgKGdmYy5jaGFubmVsc19vdXQgPT0gMilcbiAgICAgICAgICAgICAgICB3cml0ZWhlYWRlcihnZmMsIGwzX3NpZGUucHJpdmF0ZV9iaXRzLCAzKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB3cml0ZWhlYWRlcihnZmMsIGwzX3NpZGUucHJpdmF0ZV9iaXRzLCA1KTtcblxuICAgICAgICAgICAgZm9yIChjaCA9IDA7IGNoIDwgZ2ZjLmNoYW5uZWxzX291dDsgY2grKykge1xuICAgICAgICAgICAgICAgIHZhciBiYW5kO1xuICAgICAgICAgICAgICAgIGZvciAoYmFuZCA9IDA7IGJhbmQgPCA0OyBiYW5kKyspIHtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCBsM19zaWRlLnNjZnNpW2NoXVtiYW5kXSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGdyID0gMDsgZ3IgPCAyOyBncisrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjaCA9IDA7IGNoIDwgZ2ZjLmNoYW5uZWxzX291dDsgY2grKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ2kgPSBsM19zaWRlLnR0W2dyXVtjaF07XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlaGVhZGVyKGdmYywgZ2kucGFydDJfM19sZW5ndGggKyBnaS5wYXJ0Ml9sZW5ndGgsIDEyKTtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCBnaS5iaWdfdmFsdWVzIC8gMiwgOSk7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlaGVhZGVyKGdmYywgZ2kuZ2xvYmFsX2dhaW4sIDgpO1xuICAgICAgICAgICAgICAgICAgICB3cml0ZWhlYWRlcihnZmMsIGdpLnNjYWxlZmFjX2NvbXByZXNzLCA0KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZ2kuYmxvY2tfdHlwZSAhPSBFbmNvZGVyLk5PUk1fVFlQRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCAxLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIHdpbmRvd19zd2l0Y2hpbmdfZmxhZyAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCBnaS5ibG9ja190eXBlLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlaGVhZGVyKGdmYywgZ2kubWl4ZWRfYmxvY2tfZmxhZywgMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnaS50YWJsZV9zZWxlY3RbMF0gPT0gMTQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2kudGFibGVfc2VsZWN0WzBdID0gMTY7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZWhlYWRlcihnZmMsIGdpLnRhYmxlX3NlbGVjdFswXSwgNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2kudGFibGVfc2VsZWN0WzFdID09IDE0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdpLnRhYmxlX3NlbGVjdFsxXSA9IDE2O1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCBnaS50YWJsZV9zZWxlY3RbMV0sIDUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZWhlYWRlcihnZmMsIGdpLnN1YmJsb2NrX2dhaW5bMF0sIDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCBnaS5zdWJibG9ja19nYWluWzFdLCAzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlaGVhZGVyKGdmYywgZ2kuc3ViYmxvY2tfZ2FpblsyXSwgMyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZWhlYWRlcihnZmMsIDAsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogd2luZG93X3N3aXRjaGluZ19mbGFnICovXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2kudGFibGVfc2VsZWN0WzBdID09IDE0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdpLnRhYmxlX3NlbGVjdFswXSA9IDE2O1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCBnaS50YWJsZV9zZWxlY3RbMF0sIDUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdpLnRhYmxlX3NlbGVjdFsxXSA9PSAxNClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnaS50YWJsZV9zZWxlY3RbMV0gPSAxNjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlaGVhZGVyKGdmYywgZ2kudGFibGVfc2VsZWN0WzFdLCA1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnaS50YWJsZV9zZWxlY3RbMl0gPT0gMTQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2kudGFibGVfc2VsZWN0WzJdID0gMTY7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZWhlYWRlcihnZmMsIGdpLnRhYmxlX3NlbGVjdFsyXSwgNSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydCgwIDw9IGdpLnJlZ2lvbjBfY291bnQgJiYgZ2kucmVnaW9uMF9jb3VudCA8IDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydCgwIDw9IGdpLnJlZ2lvbjFfY291bnQgJiYgZ2kucmVnaW9uMV9jb3VudCA8IDgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCBnaS5yZWdpb24wX2NvdW50LCA0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlaGVhZGVyKGdmYywgZ2kucmVnaW9uMV9jb3VudCwgMyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCBnaS5wcmVmbGFnLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCBnaS5zY2FsZWZhY19zY2FsZSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlaGVhZGVyKGdmYywgZ2kuY291bnQxdGFibGVfc2VsZWN0LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvKiBNUEVHMiAqL1xuICAgICAgICAgICAgYXNzZXJ0KGwzX3NpZGUubWFpbl9kYXRhX2JlZ2luID49IDApO1xuICAgICAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCAobDNfc2lkZS5tYWluX2RhdGFfYmVnaW4pLCA4KTtcbiAgICAgICAgICAgIHdyaXRlaGVhZGVyKGdmYywgbDNfc2lkZS5wcml2YXRlX2JpdHMsIGdmYy5jaGFubmVsc19vdXQpO1xuXG4gICAgICAgICAgICBnciA9IDA7XG4gICAgICAgICAgICBmb3IgKGNoID0gMDsgY2ggPCBnZmMuY2hhbm5lbHNfb3V0OyBjaCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdpID0gbDNfc2lkZS50dFtncl1bY2hdO1xuICAgICAgICAgICAgICAgIHdyaXRlaGVhZGVyKGdmYywgZ2kucGFydDJfM19sZW5ndGggKyBnaS5wYXJ0Ml9sZW5ndGgsIDEyKTtcbiAgICAgICAgICAgICAgICB3cml0ZWhlYWRlcihnZmMsIGdpLmJpZ192YWx1ZXMgLyAyLCA5KTtcbiAgICAgICAgICAgICAgICB3cml0ZWhlYWRlcihnZmMsIGdpLmdsb2JhbF9nYWluLCA4KTtcbiAgICAgICAgICAgICAgICB3cml0ZWhlYWRlcihnZmMsIGdpLnNjYWxlZmFjX2NvbXByZXNzLCA5KTtcblxuICAgICAgICAgICAgICAgIGlmIChnaS5ibG9ja190eXBlICE9IEVuY29kZXIuTk9STV9UWVBFKSB7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlaGVhZGVyKGdmYywgMSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIC8qIHdpbmRvd19zd2l0Y2hpbmdfZmxhZyAqL1xuICAgICAgICAgICAgICAgICAgICB3cml0ZWhlYWRlcihnZmMsIGdpLmJsb2NrX3R5cGUsIDIpO1xuICAgICAgICAgICAgICAgICAgICB3cml0ZWhlYWRlcihnZmMsIGdpLm1peGVkX2Jsb2NrX2ZsYWcsIDEpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChnaS50YWJsZV9zZWxlY3RbMF0gPT0gMTQpXG4gICAgICAgICAgICAgICAgICAgICAgICBnaS50YWJsZV9zZWxlY3RbMF0gPSAxNjtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCBnaS50YWJsZV9zZWxlY3RbMF0sIDUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2kudGFibGVfc2VsZWN0WzFdID09IDE0KVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2kudGFibGVfc2VsZWN0WzFdID0gMTY7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlaGVhZGVyKGdmYywgZ2kudGFibGVfc2VsZWN0WzFdLCA1KTtcblxuICAgICAgICAgICAgICAgICAgICB3cml0ZWhlYWRlcihnZmMsIGdpLnN1YmJsb2NrX2dhaW5bMF0sIDMpO1xuICAgICAgICAgICAgICAgICAgICB3cml0ZWhlYWRlcihnZmMsIGdpLnN1YmJsb2NrX2dhaW5bMV0sIDMpO1xuICAgICAgICAgICAgICAgICAgICB3cml0ZWhlYWRlcihnZmMsIGdpLnN1YmJsb2NrX2dhaW5bMl0sIDMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlaGVhZGVyKGdmYywgMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIC8qIHdpbmRvd19zd2l0Y2hpbmdfZmxhZyAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2kudGFibGVfc2VsZWN0WzBdID09IDE0KVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2kudGFibGVfc2VsZWN0WzBdID0gMTY7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlaGVhZGVyKGdmYywgZ2kudGFibGVfc2VsZWN0WzBdLCA1KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdpLnRhYmxlX3NlbGVjdFsxXSA9PSAxNClcbiAgICAgICAgICAgICAgICAgICAgICAgIGdpLnRhYmxlX3NlbGVjdFsxXSA9IDE2O1xuICAgICAgICAgICAgICAgICAgICB3cml0ZWhlYWRlcihnZmMsIGdpLnRhYmxlX3NlbGVjdFsxXSwgNSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnaS50YWJsZV9zZWxlY3RbMl0gPT0gMTQpXG4gICAgICAgICAgICAgICAgICAgICAgICBnaS50YWJsZV9zZWxlY3RbMl0gPSAxNjtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCBnaS50YWJsZV9zZWxlY3RbMl0sIDUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydCgwIDw9IGdpLnJlZ2lvbjBfY291bnQgJiYgZ2kucmVnaW9uMF9jb3VudCA8IDE2KTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KDAgPD0gZ2kucmVnaW9uMV9jb3VudCAmJiBnaS5yZWdpb24xX2NvdW50IDwgOCk7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlaGVhZGVyKGdmYywgZ2kucmVnaW9uMF9jb3VudCwgNCk7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlaGVhZGVyKGdmYywgZ2kucmVnaW9uMV9jb3VudCwgMyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCBnaS5zY2FsZWZhY19zY2FsZSwgMSk7XG4gICAgICAgICAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCBnaS5jb3VudDF0YWJsZV9zZWxlY3QsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdmcC5lcnJvcl9wcm90ZWN0aW9uKSB7XG4gICAgICAgICAgICAvKiAoam8pIGVycm9yX3Byb3RlY3Rpb246IGFkZCBjcmMxNiBpbmZvcm1hdGlvbiB0byBoZWFkZXIgKi9cbiAgICAgICAgICAgIENSQ193cml0ZWhlYWRlcihnZmMsIGdmYy5oZWFkZXJbZ2ZjLmhfcHRyXS5idWYpO1xuICAgICAgICB9XG5cbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIG9sZCA9IGdmYy5oX3B0cjtcbiAgICAgICAgICAgIGFzc2VydChnZmMuaGVhZGVyW29sZF0ucHRyID09IGdmYy5zaWRlaW5mb19sZW4gKiA4KTtcblxuICAgICAgICAgICAgZ2ZjLmhfcHRyID0gKG9sZCArIDEpICYgKExhbWVJbnRlcm5hbEZsYWdzLk1BWF9IRUFERVJfQlVGIC0gMSk7XG4gICAgICAgICAgICBnZmMuaGVhZGVyW2dmYy5oX3B0cl0ud3JpdGVfdGltaW5nID0gZ2ZjLmhlYWRlcltvbGRdLndyaXRlX3RpbWluZ1xuICAgICAgICAgICAgICAgICsgYml0c1BlckZyYW1lO1xuXG4gICAgICAgICAgICBpZiAoZ2ZjLmhfcHRyID09IGdmYy53X3B0cikge1xuICAgICAgICAgICAgICAgIC8qIHlpa2VzISB3ZSBhcmUgb3V0IG9mIGhlYWRlciBidWZmZXIgc3BhY2UgKi9cbiAgICAgICAgICAgICAgICBTeXN0ZW0uZXJyXG4gICAgICAgICAgICAgICAgICAgIC5wcmludGxuKFwiRXJyb3I6IE1BWF9IRUFERVJfQlVGIHRvbyBzbWFsbCBpbiBiaXRzdHJlYW0uYyBcXG5cIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGh1ZmZtYW5fY29kZXJfY291bnQxKGdmYywgZ2kpIHtcbiAgICAgICAgLyogV3JpdGUgY291bnQxIGFyZWEgKi9cbiAgICAgICAgdmFyIGggPSBUYWJsZXMuaHRbZ2kuY291bnQxdGFibGVfc2VsZWN0ICsgMzJdO1xuICAgICAgICB2YXIgaSwgYml0cyA9IDA7XG5cbiAgICAgICAgdmFyIGl4ID0gZ2kuYmlnX3ZhbHVlcztcbiAgICAgICAgdmFyIHhyID0gZ2kuYmlnX3ZhbHVlcztcbiAgICAgICAgYXNzZXJ0KGdpLmNvdW50MXRhYmxlX3NlbGVjdCA8IDIpO1xuXG4gICAgICAgIGZvciAoaSA9IChnaS5jb3VudDEgLSBnaS5iaWdfdmFsdWVzKSAvIDQ7IGkgPiAwOyAtLWkpIHtcbiAgICAgICAgICAgIHZhciBodWZmYml0cyA9IDA7XG4gICAgICAgICAgICB2YXIgcCA9IDAsIHY7XG5cbiAgICAgICAgICAgIHYgPSBnaS5sM19lbmNbaXggKyAwXTtcbiAgICAgICAgICAgIGlmICh2ICE9IDApIHtcbiAgICAgICAgICAgICAgICBwICs9IDg7XG4gICAgICAgICAgICAgICAgaWYgKGdpLnhyW3hyICsgMF0gPCAwKVxuICAgICAgICAgICAgICAgICAgICBodWZmYml0cysrO1xuICAgICAgICAgICAgICAgIGFzc2VydCh2IDw9IDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2ID0gZ2kubDNfZW5jW2l4ICsgMV07XG4gICAgICAgICAgICBpZiAodiAhPSAwKSB7XG4gICAgICAgICAgICAgICAgcCArPSA0O1xuICAgICAgICAgICAgICAgIGh1ZmZiaXRzICo9IDI7XG4gICAgICAgICAgICAgICAgaWYgKGdpLnhyW3hyICsgMV0gPCAwKVxuICAgICAgICAgICAgICAgICAgICBodWZmYml0cysrO1xuICAgICAgICAgICAgICAgIGFzc2VydCh2IDw9IDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2ID0gZ2kubDNfZW5jW2l4ICsgMl07XG4gICAgICAgICAgICBpZiAodiAhPSAwKSB7XG4gICAgICAgICAgICAgICAgcCArPSAyO1xuICAgICAgICAgICAgICAgIGh1ZmZiaXRzICo9IDI7XG4gICAgICAgICAgICAgICAgaWYgKGdpLnhyW3hyICsgMl0gPCAwKVxuICAgICAgICAgICAgICAgICAgICBodWZmYml0cysrO1xuICAgICAgICAgICAgICAgIGFzc2VydCh2IDw9IDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2ID0gZ2kubDNfZW5jW2l4ICsgM107XG4gICAgICAgICAgICBpZiAodiAhPSAwKSB7XG4gICAgICAgICAgICAgICAgcCsrO1xuICAgICAgICAgICAgICAgIGh1ZmZiaXRzICo9IDI7XG4gICAgICAgICAgICAgICAgaWYgKGdpLnhyW3hyICsgM10gPCAwKVxuICAgICAgICAgICAgICAgICAgICBodWZmYml0cysrO1xuICAgICAgICAgICAgICAgIGFzc2VydCh2IDw9IDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpeCArPSA0O1xuICAgICAgICAgICAgeHIgKz0gNDtcbiAgICAgICAgICAgIHB1dGJpdHMyKGdmYywgaHVmZmJpdHMgKyBoLnRhYmxlW3BdLCBoLmhsZW5bcF0pO1xuICAgICAgICAgICAgYml0cyArPSBoLmhsZW5bcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50cyB0aGUgcHNldWRvY29kZSBvZiBwYWdlIDk4IG9mIHRoZSBJU1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEh1ZmZtYW5jb2RlKGdmYywgdGFibGVpbmRleCwgc3RhcnQsIGVuZCwgZ2kpIHtcbiAgICAgICAgdmFyIGggPSBUYWJsZXMuaHRbdGFibGVpbmRleF07XG4gICAgICAgIHZhciBiaXRzID0gMDtcblxuICAgICAgICBhc3NlcnQodGFibGVpbmRleCA8IDMyKTtcbiAgICAgICAgaWYgKDAgPT0gdGFibGVpbmRleClcbiAgICAgICAgICAgIHJldHVybiBiaXRzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAyKSB7XG4gICAgICAgICAgICB2YXIgY2JpdHMgPSAwO1xuICAgICAgICAgICAgdmFyIHhiaXRzID0gMDtcbiAgICAgICAgICAgIHZhciBsaW5iaXRzID0gaC54bGVuO1xuICAgICAgICAgICAgdmFyIHhsZW4gPSBoLnhsZW47XG4gICAgICAgICAgICB2YXIgZXh0ID0gMDtcbiAgICAgICAgICAgIHZhciB4MSA9IGdpLmwzX2VuY1tpXTtcbiAgICAgICAgICAgIHZhciB4MiA9IGdpLmwzX2VuY1tpICsgMV07XG5cbiAgICAgICAgICAgIGlmICh4MSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdpLnhyW2ldIDwgMClcbiAgICAgICAgICAgICAgICAgICAgZXh0Kys7XG4gICAgICAgICAgICAgICAgY2JpdHMtLTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRhYmxlaW5kZXggPiAxNSkge1xuICAgICAgICAgICAgICAgIC8qIHVzZSBFU0Mtd29yZHMgKi9cbiAgICAgICAgICAgICAgICBpZiAoeDEgPiAxNCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluYml0c194MSA9IHgxIC0gMTU7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydChsaW5iaXRzX3gxIDw9IGgubGlubWF4KTtcbiAgICAgICAgICAgICAgICAgICAgZXh0IHw9IGxpbmJpdHNfeDEgPDwgMTtcbiAgICAgICAgICAgICAgICAgICAgeGJpdHMgPSBsaW5iaXRzO1xuICAgICAgICAgICAgICAgICAgICB4MSA9IDE1O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh4MiA+IDE0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5iaXRzX3gyID0geDIgLSAxNTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGxpbmJpdHNfeDIgPD0gaC5saW5tYXgpO1xuICAgICAgICAgICAgICAgICAgICBleHQgPDw9IGxpbmJpdHM7XG4gICAgICAgICAgICAgICAgICAgIGV4dCB8PSBsaW5iaXRzX3gyO1xuICAgICAgICAgICAgICAgICAgICB4Yml0cyArPSBsaW5iaXRzO1xuICAgICAgICAgICAgICAgICAgICB4MiA9IDE1O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB4bGVuID0gMTY7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh4MiAhPSAwKSB7XG4gICAgICAgICAgICAgICAgZXh0IDw8PSAxO1xuICAgICAgICAgICAgICAgIGlmIChnaS54cltpICsgMV0gPCAwKVxuICAgICAgICAgICAgICAgICAgICBleHQrKztcbiAgICAgICAgICAgICAgICBjYml0cy0tO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhc3NlcnQoKHgxIHwgeDIpIDwgMTYpO1xuXG4gICAgICAgICAgICB4MSA9IHgxICogeGxlbiArIHgyO1xuICAgICAgICAgICAgeGJpdHMgLT0gY2JpdHM7XG4gICAgICAgICAgICBjYml0cyArPSBoLmhsZW5beDFdO1xuXG4gICAgICAgICAgICBhc3NlcnQoY2JpdHMgPD0gTUFYX0xFTkdUSCk7XG4gICAgICAgICAgICBhc3NlcnQoeGJpdHMgPD0gTUFYX0xFTkdUSCk7XG5cbiAgICAgICAgICAgIHB1dGJpdHMyKGdmYywgaC50YWJsZVt4MV0sIGNiaXRzKTtcbiAgICAgICAgICAgIHB1dGJpdHMyKGdmYywgZXh0LCB4Yml0cyk7XG4gICAgICAgICAgICBiaXRzICs9IGNiaXRzICsgeGJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm90ZSB0aGUgZGlzY3Vzc2lvbiBvZiBodWZmbWFuY29kZWJpdHMoKSBvbiBwYWdlcyAyOCBhbmQgMjkgb2YgdGhlIElTLCBhc1xuICAgICAqIHdlbGwgYXMgdGhlIGRlZmluaXRpb25zIG9mIHRoZSBzaWRlIGluZm9ybWF0aW9uIG9uIHBhZ2VzIDI2IGFuZCAyNy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTaG9ydEh1ZmZtYW5jb2RlYml0cyhnZmMsIGdpKSB7XG4gICAgICAgIHZhciByZWdpb24xU3RhcnQgPSAzICogZ2ZjLnNjYWxlZmFjX2JhbmQuc1szXTtcbiAgICAgICAgaWYgKHJlZ2lvbjFTdGFydCA+IGdpLmJpZ192YWx1ZXMpXG4gICAgICAgICAgICByZWdpb24xU3RhcnQgPSBnaS5iaWdfdmFsdWVzO1xuXG4gICAgICAgIC8qIHNob3J0IGJsb2NrcyBkbyBub3QgaGF2ZSBhIHJlZ2lvbjIgKi9cbiAgICAgICAgdmFyIGJpdHMgPSBIdWZmbWFuY29kZShnZmMsIGdpLnRhYmxlX3NlbGVjdFswXSwgMCwgcmVnaW9uMVN0YXJ0LCBnaSk7XG4gICAgICAgIGJpdHMgKz0gSHVmZm1hbmNvZGUoZ2ZjLCBnaS50YWJsZV9zZWxlY3RbMV0sIHJlZ2lvbjFTdGFydCxcbiAgICAgICAgICAgIGdpLmJpZ192YWx1ZXMsIGdpKTtcbiAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG9uZ0h1ZmZtYW5jb2RlYml0cyhnZmMsIGdpKSB7XG4gICAgICAgIHZhciBiaWd2YWx1ZXMsIGJpdHM7XG4gICAgICAgIHZhciByZWdpb24xU3RhcnQsIHJlZ2lvbjJTdGFydDtcblxuICAgICAgICBiaWd2YWx1ZXMgPSBnaS5iaWdfdmFsdWVzO1xuICAgICAgICBhc3NlcnQoMCA8PSBiaWd2YWx1ZXMgJiYgYmlndmFsdWVzIDw9IDU3Nik7XG5cbiAgICAgICAgdmFyIGkgPSBnaS5yZWdpb24wX2NvdW50ICsgMTtcbiAgICAgICAgYXNzZXJ0KDAgPD0gaSk7XG4gICAgICAgIGFzc2VydChpIDwgZ2ZjLnNjYWxlZmFjX2JhbmQubC5sZW5ndGgpO1xuICAgICAgICByZWdpb24xU3RhcnQgPSBnZmMuc2NhbGVmYWNfYmFuZC5sW2ldO1xuICAgICAgICBpICs9IGdpLnJlZ2lvbjFfY291bnQgKyAxO1xuICAgICAgICBhc3NlcnQoMCA8PSBpKTtcbiAgICAgICAgYXNzZXJ0KGkgPCBnZmMuc2NhbGVmYWNfYmFuZC5sLmxlbmd0aCk7XG4gICAgICAgIHJlZ2lvbjJTdGFydCA9IGdmYy5zY2FsZWZhY19iYW5kLmxbaV07XG5cbiAgICAgICAgaWYgKHJlZ2lvbjFTdGFydCA+IGJpZ3ZhbHVlcylcbiAgICAgICAgICAgIHJlZ2lvbjFTdGFydCA9IGJpZ3ZhbHVlcztcblxuICAgICAgICBpZiAocmVnaW9uMlN0YXJ0ID4gYmlndmFsdWVzKVxuICAgICAgICAgICAgcmVnaW9uMlN0YXJ0ID0gYmlndmFsdWVzO1xuXG4gICAgICAgIGJpdHMgPSBIdWZmbWFuY29kZShnZmMsIGdpLnRhYmxlX3NlbGVjdFswXSwgMCwgcmVnaW9uMVN0YXJ0LCBnaSk7XG4gICAgICAgIGJpdHMgKz0gSHVmZm1hbmNvZGUoZ2ZjLCBnaS50YWJsZV9zZWxlY3RbMV0sIHJlZ2lvbjFTdGFydCxcbiAgICAgICAgICAgIHJlZ2lvbjJTdGFydCwgZ2kpO1xuICAgICAgICBiaXRzICs9IEh1ZmZtYW5jb2RlKGdmYywgZ2kudGFibGVfc2VsZWN0WzJdLCByZWdpb24yU3RhcnQsIGJpZ3ZhbHVlcyxcbiAgICAgICAgICAgIGdpKTtcbiAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd3JpdGVNYWluRGF0YShnZnApIHtcbiAgICAgICAgdmFyIGdyLCBjaCwgc2ZiLCBkYXRhX2JpdHMsIHRvdF9iaXRzID0gMDtcbiAgICAgICAgdmFyIGdmYyA9IGdmcC5pbnRlcm5hbF9mbGFncztcbiAgICAgICAgdmFyIGwzX3NpZGUgPSBnZmMubDNfc2lkZTtcblxuICAgICAgICBpZiAoZ2ZwLnZlcnNpb24gPT0gMSkge1xuICAgICAgICAgICAgLyogTVBFRyAxICovXG4gICAgICAgICAgICBmb3IgKGdyID0gMDsgZ3IgPCAyOyBncisrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjaCA9IDA7IGNoIDwgZ2ZjLmNoYW5uZWxzX291dDsgY2grKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ2kgPSBsM19zaWRlLnR0W2dyXVtjaF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBzbGVuMSA9IFRha2VoaXJvLnNsZW4xX3RhYltnaS5zY2FsZWZhY19jb21wcmVzc107XG4gICAgICAgICAgICAgICAgICAgIHZhciBzbGVuMiA9IFRha2VoaXJvLnNsZW4yX3RhYltnaS5zY2FsZWZhY19jb21wcmVzc107XG4gICAgICAgICAgICAgICAgICAgIGRhdGFfYml0cyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoc2ZiID0gMDsgc2ZiIDwgZ2kuc2ZiZGl2aWRlOyBzZmIrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdpLnNjYWxlZmFjW3NmYl0gPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBzY2ZzaSBpcyB1c2VkICovXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXRiaXRzMihnZmMsIGdpLnNjYWxlZmFjW3NmYl0sIHNsZW4xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFfYml0cyArPSBzbGVuMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgc2ZiIDwgZ2kuc2ZibWF4OyBzZmIrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdpLnNjYWxlZmFjW3NmYl0gPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBzY2ZzaSBpcyB1c2VkICovXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXRiaXRzMihnZmMsIGdpLnNjYWxlZmFjW3NmYl0sIHNsZW4yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFfYml0cyArPSBzbGVuMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoZGF0YV9iaXRzID09IGdpLnBhcnQyX2xlbmd0aCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGdpLmJsb2NrX3R5cGUgPT0gRW5jb2Rlci5TSE9SVF9UWVBFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhX2JpdHMgKz0gU2hvcnRIdWZmbWFuY29kZWJpdHMoZ2ZjLCBnaSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhX2JpdHMgKz0gTG9uZ0h1ZmZtYW5jb2RlYml0cyhnZmMsIGdpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkYXRhX2JpdHMgKz0gaHVmZm1hbl9jb2Rlcl9jb3VudDEoZ2ZjLCBnaSk7XG4gICAgICAgICAgICAgICAgICAgIC8qIGRvZXMgYml0Y291bnQgaW4gcXVhbnRpemUuYyBhZ3JlZSB3aXRoIGFjdHVhbCBiaXQgY291bnQ/ICovXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydChkYXRhX2JpdHMgPT0gZ2kucGFydDJfM19sZW5ndGggKyBnaS5wYXJ0Ml9sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB0b3RfYml0cyArPSBkYXRhX2JpdHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIGZvciBjaCAqL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogZm9yIGdyICovXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvKiBNUEVHIDIgKi9cbiAgICAgICAgICAgIGdyID0gMDtcbiAgICAgICAgICAgIGZvciAoY2ggPSAwOyBjaCA8IGdmYy5jaGFubmVsc19vdXQ7IGNoKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZ2kgPSBsM19zaWRlLnR0W2dyXVtjaF07XG4gICAgICAgICAgICAgICAgdmFyIGksIHNmYl9wYXJ0aXRpb24sIHNjYWxlX2JpdHMgPSAwO1xuICAgICAgICAgICAgICAgIGFzc2VydChnaS5zZmJfcGFydGl0aW9uX3RhYmxlICE9IG51bGwpO1xuICAgICAgICAgICAgICAgIGRhdGFfYml0cyA9IDA7XG4gICAgICAgICAgICAgICAgc2ZiID0gMDtcbiAgICAgICAgICAgICAgICBzZmJfcGFydGl0aW9uID0gMDtcblxuICAgICAgICAgICAgICAgIGlmIChnaS5ibG9ja190eXBlID09IEVuY29kZXIuU0hPUlRfVFlQRSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgc2ZiX3BhcnRpdGlvbiA8IDQ7IHNmYl9wYXJ0aXRpb24rKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNmYnMgPSBnaS5zZmJfcGFydGl0aW9uX3RhYmxlW3NmYl9wYXJ0aXRpb25dIC8gMztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzbGVuID0gZ2kuc2xlbltzZmJfcGFydGl0aW9uXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZmJzOyBpKyssIHNmYisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHV0Yml0czIoZ2ZjLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1heChnaS5zY2FsZWZhY1tzZmIgKiAzICsgMF0sIDApLCBzbGVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXRiaXRzMihnZmMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KGdpLnNjYWxlZmFjW3NmYiAqIDMgKyAxXSwgMCksIHNsZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1dGJpdHMyKGdmYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoZ2kuc2NhbGVmYWNbc2ZiICogMyArIDJdLCAwKSwgc2xlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVfYml0cyArPSAzICogc2xlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkYXRhX2JpdHMgKz0gU2hvcnRIdWZmbWFuY29kZWJpdHMoZ2ZjLCBnaSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IHNmYl9wYXJ0aXRpb24gPCA0OyBzZmJfcGFydGl0aW9uKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZmJzID0gZ2kuc2ZiX3BhcnRpdGlvbl90YWJsZVtzZmJfcGFydGl0aW9uXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzbGVuID0gZ2kuc2xlbltzZmJfcGFydGl0aW9uXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZmJzOyBpKyssIHNmYisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHV0Yml0czIoZ2ZjLCBNYXRoLm1heChnaS5zY2FsZWZhY1tzZmJdLCAwKSwgc2xlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVfYml0cyArPSBzbGVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRhdGFfYml0cyArPSBMb25nSHVmZm1hbmNvZGViaXRzKGdmYywgZ2kpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRhX2JpdHMgKz0gaHVmZm1hbl9jb2Rlcl9jb3VudDEoZ2ZjLCBnaSk7XG4gICAgICAgICAgICAgICAgLyogZG9lcyBiaXRjb3VudCBpbiBxdWFudGl6ZS5jIGFncmVlIHdpdGggYWN0dWFsIGJpdCBjb3VudD8gKi9cbiAgICAgICAgICAgICAgICBhc3NlcnQoZGF0YV9iaXRzID09IGdpLnBhcnQyXzNfbGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBhc3NlcnQoc2NhbGVfYml0cyA9PSBnaS5wYXJ0Ml9sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRvdF9iaXRzICs9IHNjYWxlX2JpdHMgKyBkYXRhX2JpdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBmb3IgY2ggKi9cbiAgICAgICAgfVxuICAgICAgICAvKiBmb3IgZ2YgKi9cbiAgICAgICAgcmV0dXJuIHRvdF9iaXRzO1xuICAgIH1cblxuICAgIC8qIG1haW5fZGF0YSAqL1xuXG4gICAgZnVuY3Rpb24gVG90YWxCeXRlcygpIHtcbiAgICAgICAgdGhpcy50b3RhbCA9IDA7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBjb21wdXRlIHRoZSBudW1iZXIgb2YgYml0cyByZXF1aXJlZCB0byBmbHVzaCBhbGwgbXAzIGZyYW1lcyBjdXJyZW50bHkgaW5cbiAgICAgKiB0aGUgYnVmZmVyLiBUaGlzIHNob3VsZCBiZSB0aGUgc2FtZSBhcyB0aGUgcmVzZXJ2b2lyIHNpemUuIE9ubHkgY2FsbCB0aGlzXG4gICAgICogcm91dGluZSBiZXR3ZWVuIGZyYW1lcyAtIGkuZS4gb25seSBhZnRlciBhbGwgaGVhZGVycyBhbmQgZGF0YSBoYXZlIGJlZW5cbiAgICAgKiBhZGRlZCB0byB0aGUgYnVmZmVyIGJ5IGZvcm1hdF9iaXRzdHJlYW0oKS5cbiAgICAgKlxuICAgICAqIEFsc28gY29tcHV0ZSB0b3RhbF9iaXRzX291dHB1dCA9IHNpemUgb2YgbXAzIGJ1ZmZlciAoaW5jbHVkaW5nIGZyYW1lXG4gICAgICogaGVhZGVycyB3aGljaCBtYXkgbm90IGhhdmUgeWV0IGJlZW4gc2VuZCB0byB0aGUgbXAzIGJ1ZmZlcikgKyBudW1iZXIgb2ZcbiAgICAgKiBiaXRzIG5lZWRlZCB0byBmbHVzaCBhbGwgbXAzIGZyYW1lcy5cbiAgICAgKlxuICAgICAqIHRvdGFsX2J5dGVzX291dHB1dCBpcyB0aGUgc2l6ZSBvZiB0aGUgbXAzIG91dHB1dCBidWZmZXIgaWZcbiAgICAgKiBsYW1lX2VuY29kZV9mbHVzaF9ub2dhcCgpIHdhcyBjYWxsZWQgcmlnaHQgbm93LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXB1dGVfZmx1c2hiaXRzKGdmcCwgdG90YWxfYnl0ZXNfb3V0cHV0KSB7XG4gICAgICAgIHZhciBnZmMgPSBnZnAuaW50ZXJuYWxfZmxhZ3M7XG4gICAgICAgIHZhciBmbHVzaGJpdHMsIHJlbWFpbmluZ19oZWFkZXJzO1xuICAgICAgICB2YXIgYml0c1BlckZyYW1lO1xuICAgICAgICB2YXIgbGFzdF9wdHIsIGZpcnN0X3B0cjtcbiAgICAgICAgZmlyc3RfcHRyID0gZ2ZjLndfcHRyO1xuICAgICAgICAvKiBmaXJzdCBoZWFkZXIgdG8gYWRkIHRvIGJpdHN0cmVhbSAqL1xuICAgICAgICBsYXN0X3B0ciA9IGdmYy5oX3B0ciAtIDE7XG4gICAgICAgIC8qIGxhc3QgaGVhZGVyIHRvIGFkZCB0byBiaXRzdHJlYW0gKi9cbiAgICAgICAgaWYgKGxhc3RfcHRyID09IC0xKVxuICAgICAgICAgICAgbGFzdF9wdHIgPSBMYW1lSW50ZXJuYWxGbGFncy5NQVhfSEVBREVSX0JVRiAtIDE7XG5cbiAgICAgICAgLyogYWRkIHRoaXMgbWFueSBiaXRzIHRvIGJpdHN0cmVhbSBzbyB3ZSBjYW4gZmx1c2ggYWxsIGhlYWRlcnMgKi9cbiAgICAgICAgZmx1c2hiaXRzID0gZ2ZjLmhlYWRlcltsYXN0X3B0cl0ud3JpdGVfdGltaW5nIC0gdG90Yml0O1xuICAgICAgICB0b3RhbF9ieXRlc19vdXRwdXQudG90YWwgPSBmbHVzaGJpdHM7XG5cbiAgICAgICAgaWYgKGZsdXNoYml0cyA+PSAwKSB7XG4gICAgICAgICAgICAvKiBpZiBmbHVzaGJpdHMgPj0gMCwgc29tZSBoZWFkZXJzIGhhdmUgbm90IHlldCBiZWVuIHdyaXR0ZW4gKi9cbiAgICAgICAgICAgIC8qIHJlZHVjZSBmbHVzaGJpdHMgYnkgdGhlIHNpemUgb2YgdGhlIGhlYWRlcnMgKi9cbiAgICAgICAgICAgIHJlbWFpbmluZ19oZWFkZXJzID0gMSArIGxhc3RfcHRyIC0gZmlyc3RfcHRyO1xuICAgICAgICAgICAgaWYgKGxhc3RfcHRyIDwgZmlyc3RfcHRyKVxuICAgICAgICAgICAgICAgIHJlbWFpbmluZ19oZWFkZXJzID0gMSArIGxhc3RfcHRyIC0gZmlyc3RfcHRyXG4gICAgICAgICAgICAgICAgICAgICsgTGFtZUludGVybmFsRmxhZ3MuTUFYX0hFQURFUl9CVUY7XG4gICAgICAgICAgICBmbHVzaGJpdHMgLT0gcmVtYWluaW5nX2hlYWRlcnMgKiA4ICogZ2ZjLnNpZGVpbmZvX2xlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIGZpbmFsbHksIGFkZCBzb21lIGJpdHMgc28gdGhhdCB0aGUgbGFzdCBmcmFtZSBpcyBjb21wbGV0ZSB0aGVzZSBiaXRzXG4gICAgICAgICAqIGFyZSBub3QgbmVjZXNzYXJ5IHRvIGRlY29kZSB0aGUgbGFzdCBmcmFtZSwgYnV0IHNvbWUgZGVjb2RlcnMgd2lsbFxuICAgICAgICAgKiBpZ25vcmUgbGFzdCBmcmFtZSBpZiB0aGVzZSBiaXRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBiaXRzUGVyRnJhbWUgPSBzZWxmLmdldGZyYW1lYml0cyhnZnApO1xuICAgICAgICBmbHVzaGJpdHMgKz0gYml0c1BlckZyYW1lO1xuICAgICAgICB0b3RhbF9ieXRlc19vdXRwdXQudG90YWwgKz0gYml0c1BlckZyYW1lO1xuICAgICAgICAvKiByb3VuZCB1cDogKi9cbiAgICAgICAgaWYgKCh0b3RhbF9ieXRlc19vdXRwdXQudG90YWwgJSA4KSAhPSAwKVxuICAgICAgICAgICAgdG90YWxfYnl0ZXNfb3V0cHV0LnRvdGFsID0gMSArICh0b3RhbF9ieXRlc19vdXRwdXQudG90YWwgLyA4KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdG90YWxfYnl0ZXNfb3V0cHV0LnRvdGFsID0gKHRvdGFsX2J5dGVzX291dHB1dC50b3RhbCAvIDgpO1xuICAgICAgICB0b3RhbF9ieXRlc19vdXRwdXQudG90YWwgKz0gYnVmQnl0ZUlkeCArIDE7XG5cbiAgICAgICAgaWYgKGZsdXNoYml0cyA8IDApIHtcbiAgICAgICAgICAgIFN5c3RlbS5lcnIucHJpbnRsbihcInN0cmFuZ2UgZXJyb3IgZmx1c2hpbmcgYnVmZmVyIC4uLiBcXG5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZsdXNoYml0cztcbiAgICB9XG5cbiAgICB0aGlzLmZsdXNoX2JpdHN0cmVhbSA9IGZ1bmN0aW9uIChnZnApIHtcbiAgICAgICAgdmFyIGdmYyA9IGdmcC5pbnRlcm5hbF9mbGFncztcbiAgICAgICAgdmFyIGwzX3NpZGU7XG4gICAgICAgIHZhciBmbHVzaGJpdHM7XG4gICAgICAgIHZhciBsYXN0X3B0ciA9IGdmYy5oX3B0ciAtIDE7XG4gICAgICAgIC8qIGxhc3QgaGVhZGVyIHRvIGFkZCB0byBiaXRzdHJlYW0gKi9cbiAgICAgICAgaWYgKGxhc3RfcHRyID09IC0xKVxuICAgICAgICAgICAgbGFzdF9wdHIgPSBMYW1lSW50ZXJuYWxGbGFncy5NQVhfSEVBREVSX0JVRiAtIDE7XG4gICAgICAgIGwzX3NpZGUgPSBnZmMubDNfc2lkZTtcblxuICAgICAgICBpZiAoKGZsdXNoYml0cyA9IGNvbXB1dGVfZmx1c2hiaXRzKGdmcCwgbmV3IFRvdGFsQnl0ZXMoKSkpIDwgMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZHJhaW5faW50b19hbmNpbGxhcnkoZ2ZwLCBmbHVzaGJpdHMpO1xuXG4gICAgICAgIC8qIGNoZWNrIHRoYXQgdGhlIDEwMCUgb2YgdGhlIGxhc3QgZnJhbWUgaGFzIGJlZW4gd3JpdHRlbiB0byBiaXRzdHJlYW0gKi9cbiAgICAgICAgYXNzZXJ0KGdmYy5oZWFkZXJbbGFzdF9wdHJdLndyaXRlX3RpbWluZyArIHRoaXMuZ2V0ZnJhbWViaXRzKGdmcCkgPT0gdG90Yml0KTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiB3ZSBoYXZlIHBhZGRlZCBvdXQgYWxsIGZyYW1lcyB3aXRoIGFuY2lsbGFyeSBkYXRhLCB3aGljaCBpcyB0aGUgc2FtZVxuICAgICAgICAgKiBhcyBmaWxsaW5nIHRoZSBiaXRyZXNlcnZvaXIgd2l0aCBhbmNpbGxhcnkgZGF0YSwgc28gOlxuICAgICAgICAgKi9cbiAgICAgICAgZ2ZjLlJlc3ZTaXplID0gMDtcbiAgICAgICAgbDNfc2lkZS5tYWluX2RhdGFfYmVnaW4gPSAwO1xuXG4gICAgICAgIC8qIHNhdmUgdGhlIFJlcGxheUdhaW4gdmFsdWUgKi9cbiAgICAgICAgaWYgKGdmYy5maW5kUmVwbGF5R2Fpbikge1xuICAgICAgICAgICAgdmFyIFJhZGlvR2FpbiA9IGdhLkdldFRpdGxlR2FpbihnZmMucmdkYXRhKTtcbiAgICAgICAgICAgIGFzc2VydChORVEoUmFkaW9HYWluLCBHYWluQW5hbHlzaXMuR0FJTl9OT1RfRU5PVUdIX1NBTVBMRVMpKTtcbiAgICAgICAgICAgIGdmYy5SYWRpb0dhaW4gPSBNYXRoLmZsb29yKFJhZGlvR2FpbiAqIDEwLjAgKyAwLjUpIHwgMDtcbiAgICAgICAgICAgIC8qIHJvdW5kIHRvIG5lYXJlc3QgKi9cbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGZpbmQgdGhlIGdhaW4gYW5kIHNjYWxlIGNoYW5nZSByZXF1aXJlZCBmb3Igbm8gY2xpcHBpbmcgKi9cbiAgICAgICAgaWYgKGdmYy5maW5kUGVha1NhbXBsZSkge1xuICAgICAgICAgICAgZ2ZjLm5vY2xpcEdhaW5DaGFuZ2UgPSBNYXRoLmNlaWwoTWF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgLmxvZzEwKGdmYy5QZWFrU2FtcGxlIC8gMzI3NjcuMCkgKiAyMC4wICogMTAuMCkgfCAwO1xuICAgICAgICAgICAgLyogcm91bmQgdXAgKi9cblxuICAgICAgICAgICAgaWYgKGdmYy5ub2NsaXBHYWluQ2hhbmdlID4gMCkge1xuICAgICAgICAgICAgICAgIC8qIGNsaXBwaW5nIG9jY3VycyAqL1xuICAgICAgICAgICAgICAgIGlmIChFUShnZnAuc2NhbGUsIDEuMCkgfHwgRVEoZ2ZwLnNjYWxlLCAwLjApKVxuICAgICAgICAgICAgICAgICAgICBnZmMubm9jbGlwU2NhbGUgPSAoTWF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgLmZsb29yKCgzMjc2Ny4wIC8gZ2ZjLlBlYWtTYW1wbGUpICogMTAwLjApIC8gMTAwLjApO1xuICAgICAgICAgICAgICAgIC8qIHJvdW5kIGRvd24gKi9cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICogdGhlIHVzZXIgc3BlY2lmaWVkIGhpcyBvd24gc2NhbGluZyBmYWN0b3IuIFdlIGNvdWxkXG4gICAgICAgICAgICAgICAgICAgICAqIHN1Z2dlc3QgdGhlIHNjYWxpbmcgZmFjdG9yIG9mXG4gICAgICAgICAgICAgICAgICAgICAqICgzMjc2Ny4wL2dmcC5QZWFrU2FtcGxlKSooZ2ZwLnNjYWxlKSBidXQgaXQncyB1c3VhbGx5XG4gICAgICAgICAgICAgICAgICAgICAqIHZlcnkgaW5hY2N1cmF0ZS4gU28gd2UnZCByYXRoZXIgbm90IGFkdmljZSBoaW0gb24gdGhlXG4gICAgICAgICAgICAgICAgICAgICAqIHNjYWxpbmcgZmFjdG9yLlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgZ2ZjLm5vY2xpcFNjYWxlID0gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAvKiBubyBjbGlwcGluZyAqL1xuICAgICAgICAgICAgICAgIGdmYy5ub2NsaXBTY2FsZSA9IC0xO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuYWRkX2R1bW15X2J5dGUgPSBmdW5jdGlvbiAoZ2ZwLCB2YWwsIG4pIHtcbiAgICAgICAgdmFyIGdmYyA9IGdmcC5pbnRlcm5hbF9mbGFncztcbiAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgd2hpbGUgKG4tLSA+IDApIHtcbiAgICAgICAgICAgIHB1dGJpdHNfbm9oZWFkZXJzKGdmYywgdmFsLCA4KTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IExhbWVJbnRlcm5hbEZsYWdzLk1BWF9IRUFERVJfQlVGOyArK2kpXG4gICAgICAgICAgICAgICAgZ2ZjLmhlYWRlcltpXS53cml0ZV90aW1pbmcgKz0gODtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGNhbGxlZCBhZnRlciBhIGZyYW1lIG9mIGF1ZGlvIGhhcyBiZWVuIHF1YW50aXplZCBhbmQgY29kZWQuIEl0XG4gICAgICogd2lsbCB3cml0ZSB0aGUgZW5jb2RlZCBhdWRpbyB0byB0aGUgYml0c3RyZWFtLiBOb3RlIHRoYXQgZnJvbSBhIGxheWVyM1xuICAgICAqIGVuY29kZXIncyBwZXJzcGVjdGl2ZSB0aGUgYml0IHN0cmVhbSBpcyBwcmltYXJpbHkgYSBzZXJpZXMgb2YgbWFpbl9kYXRhKClcbiAgICAgKiBibG9ja3MsIHdpdGggaGVhZGVyIGFuZCBzaWRlIGluZm9ybWF0aW9uIGluc2VydGVkIGF0IHRoZSBwcm9wZXIgbG9jYXRpb25zXG4gICAgICogdG8gbWFpbnRhaW4gZnJhbWluZy4gKFNlZSBGaWd1cmUgQS43IGluIHRoZSBJUykuXG4gICAgICovXG4gICAgdGhpcy5mb3JtYXRfYml0c3RyZWFtID0gZnVuY3Rpb24gKGdmcCkge1xuICAgICAgICB2YXIgZ2ZjID0gZ2ZwLmludGVybmFsX2ZsYWdzO1xuICAgICAgICB2YXIgbDNfc2lkZTtcbiAgICAgICAgbDNfc2lkZSA9IGdmYy5sM19zaWRlO1xuXG4gICAgICAgIHZhciBiaXRzUGVyRnJhbWUgPSB0aGlzLmdldGZyYW1lYml0cyhnZnApO1xuICAgICAgICBkcmFpbl9pbnRvX2FuY2lsbGFyeShnZnAsIGwzX3NpZGUucmVzdkRyYWluX3ByZSk7XG5cbiAgICAgICAgZW5jb2RlU2lkZUluZm8yKGdmcCwgYml0c1BlckZyYW1lKTtcbiAgICAgICAgdmFyIGJpdHMgPSA4ICogZ2ZjLnNpZGVpbmZvX2xlbjtcbiAgICAgICAgYml0cyArPSB3cml0ZU1haW5EYXRhKGdmcCk7XG4gICAgICAgIGRyYWluX2ludG9fYW5jaWxsYXJ5KGdmcCwgbDNfc2lkZS5yZXN2RHJhaW5fcG9zdCk7XG4gICAgICAgIGJpdHMgKz0gbDNfc2lkZS5yZXN2RHJhaW5fcG9zdDtcblxuICAgICAgICBsM19zaWRlLm1haW5fZGF0YV9iZWdpbiArPSAoYml0c1BlckZyYW1lIC0gYml0cykgLyA4O1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIGNvbXBhcmUgbnVtYmVyIG9mIGJpdHMgbmVlZGVkIHRvIGNsZWFyIGFsbCBidWZmZXJlZCBtcDMgZnJhbWVzIHdpdGhcbiAgICAgICAgICogd2hhdCB3ZSB0aGluayB0aGUgcmVzdnNpemUgaXM6XG4gICAgICAgICAqL1xuICAgICAgICBpZiAoY29tcHV0ZV9mbHVzaGJpdHMoZ2ZwLCBuZXcgVG90YWxCeXRlcygpKSAhPSBnZmMuUmVzdlNpemUpIHtcbiAgICAgICAgICAgIFN5c3RlbS5lcnIucHJpbnRsbihcIkludGVybmFsIGJ1ZmZlciBpbmNvbnNpc3RlbmN5LiBmbHVzaGJpdHMgPD4gUmVzdlNpemVcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvKlxuICAgICAgICAgKiBjb21wYXJlIG1haW5fZGF0YV9iZWdpbiBmb3IgdGhlIG5leHQgZnJhbWUgd2l0aCB3aGF0IHdlIHRoaW5rIHRoZVxuICAgICAgICAgKiByZXN2c2l6ZSBpczpcbiAgICAgICAgICovXG4gICAgICAgIGlmICgobDNfc2lkZS5tYWluX2RhdGFfYmVnaW4gKiA4KSAhPSBnZmMuUmVzdlNpemUpIHtcbiAgICAgICAgICAgIFN5c3RlbS5lcnIucHJpbnRmKFwiYml0IHJlc2Vydm9pciBlcnJvcjogXFxuXCJcbiAgICAgICAgICAgICAgICArIFwibDNfc2lkZS5tYWluX2RhdGFfYmVnaW46ICVkIFxcblwiXG4gICAgICAgICAgICAgICAgKyBcIlJlc3ZvaXIgc2l6ZTogICAgICAgICAgICAgJWQgXFxuXCJcbiAgICAgICAgICAgICAgICArIFwicmVzdiBkcmFpbiAocG9zdCkgICAgICAgICAlZCBcXG5cIlxuICAgICAgICAgICAgICAgICsgXCJyZXN2IGRyYWluIChwcmUpICAgICAgICAgICVkIFxcblwiXG4gICAgICAgICAgICAgICAgKyBcImhlYWRlciBhbmQgc2lkZWluZm86ICAgICAgJWQgXFxuXCJcbiAgICAgICAgICAgICAgICArIFwiZGF0YSBiaXRzOiAgICAgICAgICAgICAgICAlZCBcXG5cIlxuICAgICAgICAgICAgICAgICsgXCJ0b3RhbCBiaXRzOiAgICAgICAgICAgICAgICVkIChyZW1haW5kZXI6ICVkKSBcXG5cIlxuICAgICAgICAgICAgICAgICsgXCJiaXRzcGVyZnJhbWU6ICAgICAgICAgICAgICVkIFxcblwiLFxuICAgICAgICAgICAgICAgIDggKiBsM19zaWRlLm1haW5fZGF0YV9iZWdpbiwgZ2ZjLlJlc3ZTaXplLFxuICAgICAgICAgICAgICAgIGwzX3NpZGUucmVzdkRyYWluX3Bvc3QsIGwzX3NpZGUucmVzdkRyYWluX3ByZSxcbiAgICAgICAgICAgICAgICA4ICogZ2ZjLnNpZGVpbmZvX2xlbiwgYml0cyAtIGwzX3NpZGUucmVzdkRyYWluX3Bvc3QgLSA4XG4gICAgICAgICAgICAgICAgKiBnZmMuc2lkZWluZm9fbGVuLCBiaXRzLCBiaXRzICUgOCwgYml0c1BlckZyYW1lKTtcblxuICAgICAgICAgICAgU3lzdGVtLmVyci5wcmludGxuKFwiVGhpcyBpcyBhIGZhdGFsIGVycm9yLiAgSXQgaGFzIHNldmVyYWwgcG9zc2libGUgY2F1c2VzOlwiKTtcbiAgICAgICAgICAgIFN5c3RlbS5lcnIucHJpbnRsbihcIjkwJSUgIExBTUUgY29tcGlsZWQgd2l0aCBidWdneSB2ZXJzaW9uIG9mIGdjYyB1c2luZyBhZHZhbmNlZCBvcHRpbWl6YXRpb25zXCIpO1xuICAgICAgICAgICAgU3lzdGVtLmVyci5wcmludGxuKFwiIDklJSAgWW91ciBzeXN0ZW0gaXMgb3ZlcmNsb2NrZWRcIik7XG4gICAgICAgICAgICBTeXN0ZW0uZXJyLnByaW50bG4oXCIgMSUlICBidWcgaW4gTEFNRSBlbmNvZGluZyBsaWJyYXJ5XCIpO1xuXG4gICAgICAgICAgICBnZmMuUmVzdlNpemUgPSBsM19zaWRlLm1haW5fZGF0YV9iZWdpbiAqIDg7XG4gICAgICAgIH1cbiAgICAgICAgLy87XG4gICAgICAgIGFzc2VydCh0b3RiaXQgJSA4ID09IDApO1xuXG4gICAgICAgIGlmICh0b3RiaXQgPiAxMDAwMDAwMDAwKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogdG8gYXZvaWQgdG90Yml0IG92ZXJmbG93LCAoYXQgOGggZW5jb2RpbmcgYXQgMTI4a2JzKSBsZXRzIHJlc2V0XG4gICAgICAgICAgICAgKiBiaXQgY291bnRlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBMYW1lSW50ZXJuYWxGbGFncy5NQVhfSEVBREVSX0JVRjsgKytpKVxuICAgICAgICAgICAgICAgIGdmYy5oZWFkZXJbaV0ud3JpdGVfdGltaW5nIC09IHRvdGJpdDtcbiAgICAgICAgICAgIHRvdGJpdCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogPFBSRT5cbiAgICAgKiBjb3B5IGRhdGEgb3V0IG9mIHRoZSBpbnRlcm5hbCBNUDMgYml0IGJ1ZmZlciBpbnRvIGEgdXNlciBzdXBwbGllZFxuICAgICAqICAgICAgIHVuc2lnbmVkIGNoYXIgYnVmZmVyLlxuICAgICAqXG4gICAgICogICAgICAgbXAzZGF0YT0wICAgICAgaW5kaWNhdGVzIGRhdGEgaW4gYnVmZmVyIGlzIGFuIGlkM3RhZ3MgYW5kIFZCUiB0YWdzXG4gICAgICogICAgICAgbXAzZGF0YT0xICAgICAgZGF0YSBpcyByZWFsIG1wMyBmcmFtZSBkYXRhLlxuICAgICAqIDwvUFJFPlxuICAgICAqL1xuICAgIHRoaXMuY29weV9idWZmZXIgPSBmdW5jdGlvbiAoZ2ZjLCBidWZmZXIsIGJ1ZmZlclBvcywgc2l6ZSwgbXAzZGF0YSkge1xuICAgICAgICB2YXIgbWluaW11bSA9IGJ1ZkJ5dGVJZHggKyAxO1xuICAgICAgICBpZiAobWluaW11bSA8PSAwKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGlmIChzaXplICE9IDAgJiYgbWluaW11bSA+IHNpemUpIHtcbiAgICAgICAgICAgIC8qIGJ1ZmZlciBpcyB0b28gc21hbGwgKi9cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KGJ1ZiwgMCwgYnVmZmVyLCBidWZmZXJQb3MsIG1pbmltdW0pO1xuICAgICAgICBidWZCeXRlSWR4ID0gLTE7XG4gICAgICAgIGJ1ZkJpdElkeCA9IDA7XG5cbiAgICAgICAgaWYgKG1wM2RhdGEgIT0gMCkge1xuICAgICAgICAgICAgdmFyIGNyYyA9IG5ld19pbnQoMSk7XG4gICAgICAgICAgICBjcmNbMF0gPSBnZmMubk11c2ljQ1JDO1xuICAgICAgICAgICAgdmJyLnVwZGF0ZU11c2ljQ1JDKGNyYywgYnVmZmVyLCBidWZmZXJQb3MsIG1pbmltdW0pO1xuICAgICAgICAgICAgZ2ZjLm5NdXNpY0NSQyA9IGNyY1swXTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBzdW0gbnVtYmVyIG9mIGJ5dGVzIGJlbG9uZ2luZyB0byB0aGUgbXAzIHN0cmVhbSB0aGlzIGluZm8gd2lsbCBiZVxuICAgICAgICAgICAgICogd3JpdHRlbiBpbnRvIHRoZSBYaW5nL0xBTUUgaGVhZGVyIGZvciBzZWVraW5nXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChtaW5pbXVtID4gMCkge1xuICAgICAgICAgICAgICAgIGdmYy5WQlJfc2Vla190YWJsZS5uQnl0ZXNXcml0dGVuICs9IG1pbmltdW07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChnZmMuZGVjb2RlX29uX3RoZV9mbHkpIHsgLyogZGVjb2RlIHRoZSBmcmFtZSAqL1xuICAgICAgICAgICAgICAgIHZhciBwY21fYnVmID0gbmV3X2Zsb2F0X24oWzIsIDExNTJdKTtcbiAgICAgICAgICAgICAgICB2YXIgbXAzX2luID0gbWluaW11bTtcbiAgICAgICAgICAgICAgICB2YXIgc2FtcGxlc19vdXQgPSAtMTtcbiAgICAgICAgICAgICAgICB2YXIgaTtcblxuICAgICAgICAgICAgICAgIC8qIHJlLXN5bnRoZXNpcyB0byBwY20uIFJlcGVhdCB1bnRpbCB3ZSBnZXQgYSBzYW1wbGVzX291dD0wICovXG4gICAgICAgICAgICAgICAgd2hpbGUgKHNhbXBsZXNfb3V0ICE9IDApIHtcblxuICAgICAgICAgICAgICAgICAgICBzYW1wbGVzX291dCA9IG1wZy5oaXBfZGVjb2RlMV91bmNsaXBwZWQoZ2ZjLmhpcCwgYnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyUG9zLCBtcDNfaW4sIHBjbV9idWZbMF0sIHBjbV9idWZbMV0pO1xuICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgKiBzYW1wbGVzX291dCA9IDA6IG5lZWQgbW9yZSBkYXRhIHRvIGRlY29kZSBzYW1wbGVzX291dCA9XG4gICAgICAgICAgICAgICAgICAgICAqIC0xOiBlcnJvci4gTGV0cyBhc3N1bWUgMCBwY20gb3V0cHV0IHNhbXBsZXNfb3V0ID0gbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgICAqIG9mIHNhbXBsZXMgb3V0cHV0XG4gICAgICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAqIHNldCB0aGUgbGVuZ2h0IG9mIHRoZSBtcDMgaW5wdXQgYnVmZmVyIHRvIHplcm8sIHNvIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgICogaW4gdGhlIG5leHQgaXRlcmF0aW9uIG9mIHRoZSBsb29wIHdlIHdpbGwgYmUgcXVlcnlpbmdcbiAgICAgICAgICAgICAgICAgICAgICogbXBnbGliIGFib3V0IGJ1ZmZlcmVkIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIG1wM19pbiA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNhbXBsZXNfb3V0ID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogZXJyb3IgZGVjb2RpbmcuIE5vdCBmYXRhbCwgYnV0IG1pZ2h0IHNjcmV3IHVwIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogUmVwbGF5R2FpbiB0YWcuIFdoYXQgc2hvdWxkIHdlIGRvPyBJZ25vcmUgZm9yIG5vd1xuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVzX291dCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNhbXBsZXNfb3V0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogcHJvY2VzcyB0aGUgUENNIGRhdGEgKi9cblxuICAgICAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHRoaXMgc2hvdWxkIG5vdCBiZSBwb3NzaWJsZSwgYW5kIGluZGljYXRlcyB3ZSBoYXZlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBvdmVyZmxvd24gdGhlIHBjbV9idWYgYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydChzYW1wbGVzX291dCA8PSAxMTUyKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdmYy5maW5kUGVha1NhbXBsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzYW1wbGVzX291dDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwY21fYnVmWzBdW2ldID4gZ2ZjLlBlYWtTYW1wbGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZmMuUGVha1NhbXBsZSA9IHBjbV9idWZbMF1baV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKC1wY21fYnVmWzBdW2ldID4gZ2ZjLlBlYWtTYW1wbGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZmMuUGVha1NhbXBsZSA9IC1wY21fYnVmWzBdW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2ZjLmNoYW5uZWxzX291dCA+IDEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzYW1wbGVzX291dDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGNtX2J1ZlsxXVtpXSA+IGdmYy5QZWFrU2FtcGxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdmYy5QZWFrU2FtcGxlID0gcGNtX2J1ZlsxXVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKC1wY21fYnVmWzFdW2ldID4gZ2ZjLlBlYWtTYW1wbGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2ZjLlBlYWtTYW1wbGUgPSAtcGNtX2J1ZlsxXVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2ZjLmZpbmRSZXBsYXlHYWluKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnYS5BbmFseXplU2FtcGxlcyhnZmMucmdkYXRhLCBwY21fYnVmWzBdLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGNtX2J1ZlsxXSwgMCwgc2FtcGxlc19vdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZmMuY2hhbm5lbHNfb3V0KSA9PSBHYWluQW5hbHlzaXMuR0FJTl9BTkFMWVNJU19FUlJPUilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC02O1xuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLyogaWYgKHNhbXBsZXNfb3V0PjApICovXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIHdoaWxlIChzYW1wbGVzX291dCE9MCkgKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGlmIChnZmMuZGVjb2RlX29uX3RoZV9mbHkpICovXG5cbiAgICAgICAgfVxuICAgICAgICAvKiBpZiAobXAzZGF0YSkgKi9cbiAgICAgICAgcmV0dXJuIG1pbmltdW07XG4gICAgfTtcblxuICAgIHRoaXMuaW5pdF9iaXRfc3RyZWFtX3cgPSBmdW5jdGlvbiAoZ2ZjKSB7XG4gICAgICAgIGJ1ZiA9IG5ld19ieXRlKExhbWUuTEFNRV9NQVhNUDNCVUZGRVIpO1xuXG4gICAgICAgIGdmYy5oX3B0ciA9IGdmYy53X3B0ciA9IDA7XG4gICAgICAgIGdmYy5oZWFkZXJbZ2ZjLmhfcHRyXS53cml0ZV90aW1pbmcgPSAwO1xuICAgICAgICBidWZCeXRlSWR4ID0gLTE7XG4gICAgICAgIGJ1ZkJpdElkeCA9IDA7XG4gICAgICAgIHRvdGJpdCA9IDA7XG4gICAgfTtcblxuICAgIC8vIEZyb20gbWFjaGluZS5oXG5cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJpdFN0cmVhbTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lamejs/src/js/BitStream.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lamejs/src/js/CBRNewIterationLoop.js":
/*!***********************************************************!*\
  !*** ./node_modules/lamejs/src/js/CBRNewIterationLoop.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var common = __webpack_require__(/*! ./common.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/common.js\");\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\nvar MeanBits = __webpack_require__(/*! ./MeanBits.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/MeanBits.js\");\nvar Encoder = __webpack_require__(/*! ./Encoder.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/Encoder.js\");\nvar L3Side = __webpack_require__(/*! ./L3Side.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/L3Side.js\");\nvar LameInternalFlags = __webpack_require__(/*! ./LameInternalFlags.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/LameInternalFlags.js\");\n\nfunction CBRNewIterationLoop(_quantize)  {\n    var quantize = _quantize;\n    this.quantize = quantize;\n\tthis.iteration_loop = function(gfp, pe, ms_ener_ratio, ratio) {\n\t\tvar gfc = gfp.internal_flags;\n        var l3_xmin = new_float(L3Side.SFBMAX);\n\t\tvar xrpow = new_float(576);\n\t\tvar targ_bits = new_int(2);\n\t\tvar mean_bits = 0, max_bits;\n\t\tvar l3_side = gfc.l3_side;\n\n\t\tvar mb = new MeanBits(mean_bits);\n\t\tthis.quantize.rv.ResvFrameBegin(gfp, mb);\n\t\tmean_bits = mb.bits;\n\n\t\t/* quantize! */\n\t\tfor (var gr = 0; gr < gfc.mode_gr; gr++) {\n\n\t\t\t/*\n\t\t\t * calculate needed bits\n\t\t\t */\n\t\t\tmax_bits = this.quantize.qupvt.on_pe(gfp, pe, targ_bits, mean_bits,\n\t\t\t\t\tgr, gr);\n\n\t\t\tif (gfc.mode_ext == Encoder.MPG_MD_MS_LR) {\n\t\t\t\tthis.quantize.ms_convert(gfc.l3_side, gr);\n\t\t\t\tthis.quantize.qupvt.reduce_side(targ_bits, ms_ener_ratio[gr],\n\t\t\t\t\t\tmean_bits, max_bits);\n\t\t\t}\n\n\t\t\tfor (var ch = 0; ch < gfc.channels_out; ch++) {\n\t\t\t\tvar adjust, masking_lower_db;\n\t\t\t\tvar cod_info = l3_side.tt[gr][ch];\n\n\t\t\t\tif (cod_info.block_type != Encoder.SHORT_TYPE) {\n\t\t\t\t\t// NORM, START or STOP type\n\t\t\t\t\tadjust = 0;\n\t\t\t\t\tmasking_lower_db = gfc.PSY.mask_adjust - adjust;\n\t\t\t\t} else {\n\t\t\t\t\tadjust = 0;\n\t\t\t\t\tmasking_lower_db = gfc.PSY.mask_adjust_short - adjust;\n\t\t\t\t}\n\t\t\t\tgfc.masking_lower =  Math.pow(10.0,\n\t\t\t\t\t\tmasking_lower_db * 0.1);\n\n\t\t\t\t/*\n\t\t\t\t * init_outer_loop sets up cod_info, scalefac and xrpow\n\t\t\t\t */\n\t\t\t\tthis.quantize.init_outer_loop(gfc, cod_info);\n\t\t\t\tif (this.quantize.init_xrpow(gfc, cod_info, xrpow)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * xr contains energy we will have to encode calculate the\n\t\t\t\t\t * masking abilities find some good quantization in\n\t\t\t\t\t * outer_loop\n\t\t\t\t\t */\n\t\t\t\t\tthis.quantize.qupvt.calc_xmin(gfp, ratio[gr][ch], cod_info,\n\t\t\t\t\t\t\tl3_xmin);\n\t\t\t\t\tthis.quantize.outer_loop(gfp, cod_info, l3_xmin, xrpow, ch,\n\t\t\t\t\t\t\ttarg_bits[ch]);\n\t\t\t\t}\n\n\t\t\t\tthis.quantize.iteration_finish_one(gfc, gr, ch);\n\t\t\t\tassert (cod_info.part2_3_length <= LameInternalFlags.MAX_BITS_PER_CHANNEL);\n\t\t\t\tassert (cod_info.part2_3_length <= targ_bits[ch]);\n\t\t\t} /* for ch */\n\t\t} /* for gr */\n\n\t\tthis.quantize.rv.ResvFrameEnd(gfc, mean_bits);\n\t}\n}\nmodule.exports = CBRNewIterationLoop;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL0NCUk5ld0l0ZXJhdGlvbkxvb3AuanMiLCJtYXBwaW5ncyI6IkFBQUEsYUFBYSxtQkFBTyxDQUFDLCtFQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLG1GQUFlO0FBQ3RDLGNBQWMsbUJBQU8sQ0FBQyxpRkFBYztBQUNwQyxhQUFhLG1CQUFPLENBQUMsK0VBQWE7QUFDbEMsd0JBQXdCLG1CQUFPLENBQUMscUdBQXdCOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsa0JBQWtCOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL0NCUk5ld0l0ZXJhdGlvbkxvb3AuanM/NTgyMiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24uanMnKTtcbnZhciBTeXN0ZW0gPSBjb21tb24uU3lzdGVtO1xudmFyIFZick1vZGUgPSBjb21tb24uVmJyTW9kZTtcbnZhciBGbG9hdCA9IGNvbW1vbi5GbG9hdDtcbnZhciBTaG9ydEJsb2NrID0gY29tbW9uLlNob3J0QmxvY2s7XG52YXIgVXRpbCA9IGNvbW1vbi5VdGlsO1xudmFyIEFycmF5cyA9IGNvbW1vbi5BcnJheXM7XG52YXIgbmV3X2FycmF5X24gPSBjb21tb24ubmV3X2FycmF5X247XG52YXIgbmV3X2J5dGUgPSBjb21tb24ubmV3X2J5dGU7XG52YXIgbmV3X2RvdWJsZSA9IGNvbW1vbi5uZXdfZG91YmxlO1xudmFyIG5ld19mbG9hdCA9IGNvbW1vbi5uZXdfZmxvYXQ7XG52YXIgbmV3X2Zsb2F0X24gPSBjb21tb24ubmV3X2Zsb2F0X247XG52YXIgbmV3X2ludCA9IGNvbW1vbi5uZXdfaW50O1xudmFyIG5ld19pbnRfbiA9IGNvbW1vbi5uZXdfaW50X247XG52YXIgYXNzZXJ0ID0gY29tbW9uLmFzc2VydDtcblxudmFyIE1lYW5CaXRzID0gcmVxdWlyZSgnLi9NZWFuQml0cy5qcycpO1xudmFyIEVuY29kZXIgPSByZXF1aXJlKCcuL0VuY29kZXIuanMnKTtcbnZhciBMM1NpZGUgPSByZXF1aXJlKCcuL0wzU2lkZS5qcycpO1xudmFyIExhbWVJbnRlcm5hbEZsYWdzID0gcmVxdWlyZSgnLi9MYW1lSW50ZXJuYWxGbGFncy5qcycpO1xuXG5mdW5jdGlvbiBDQlJOZXdJdGVyYXRpb25Mb29wKF9xdWFudGl6ZSkgIHtcbiAgICB2YXIgcXVhbnRpemUgPSBfcXVhbnRpemU7XG4gICAgdGhpcy5xdWFudGl6ZSA9IHF1YW50aXplO1xuXHR0aGlzLml0ZXJhdGlvbl9sb29wID0gZnVuY3Rpb24oZ2ZwLCBwZSwgbXNfZW5lcl9yYXRpbywgcmF0aW8pIHtcblx0XHR2YXIgZ2ZjID0gZ2ZwLmludGVybmFsX2ZsYWdzO1xuICAgICAgICB2YXIgbDNfeG1pbiA9IG5ld19mbG9hdChMM1NpZGUuU0ZCTUFYKTtcblx0XHR2YXIgeHJwb3cgPSBuZXdfZmxvYXQoNTc2KTtcblx0XHR2YXIgdGFyZ19iaXRzID0gbmV3X2ludCgyKTtcblx0XHR2YXIgbWVhbl9iaXRzID0gMCwgbWF4X2JpdHM7XG5cdFx0dmFyIGwzX3NpZGUgPSBnZmMubDNfc2lkZTtcblxuXHRcdHZhciBtYiA9IG5ldyBNZWFuQml0cyhtZWFuX2JpdHMpO1xuXHRcdHRoaXMucXVhbnRpemUucnYuUmVzdkZyYW1lQmVnaW4oZ2ZwLCBtYik7XG5cdFx0bWVhbl9iaXRzID0gbWIuYml0cztcblxuXHRcdC8qIHF1YW50aXplISAqL1xuXHRcdGZvciAodmFyIGdyID0gMDsgZ3IgPCBnZmMubW9kZV9ncjsgZ3IrKykge1xuXG5cdFx0XHQvKlxuXHRcdFx0ICogY2FsY3VsYXRlIG5lZWRlZCBiaXRzXG5cdFx0XHQgKi9cblx0XHRcdG1heF9iaXRzID0gdGhpcy5xdWFudGl6ZS5xdXB2dC5vbl9wZShnZnAsIHBlLCB0YXJnX2JpdHMsIG1lYW5fYml0cyxcblx0XHRcdFx0XHRnciwgZ3IpO1xuXG5cdFx0XHRpZiAoZ2ZjLm1vZGVfZXh0ID09IEVuY29kZXIuTVBHX01EX01TX0xSKSB7XG5cdFx0XHRcdHRoaXMucXVhbnRpemUubXNfY29udmVydChnZmMubDNfc2lkZSwgZ3IpO1xuXHRcdFx0XHR0aGlzLnF1YW50aXplLnF1cHZ0LnJlZHVjZV9zaWRlKHRhcmdfYml0cywgbXNfZW5lcl9yYXRpb1tncl0sXG5cdFx0XHRcdFx0XHRtZWFuX2JpdHMsIG1heF9iaXRzKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICh2YXIgY2ggPSAwOyBjaCA8IGdmYy5jaGFubmVsc19vdXQ7IGNoKyspIHtcblx0XHRcdFx0dmFyIGFkanVzdCwgbWFza2luZ19sb3dlcl9kYjtcblx0XHRcdFx0dmFyIGNvZF9pbmZvID0gbDNfc2lkZS50dFtncl1bY2hdO1xuXG5cdFx0XHRcdGlmIChjb2RfaW5mby5ibG9ja190eXBlICE9IEVuY29kZXIuU0hPUlRfVFlQRSkge1xuXHRcdFx0XHRcdC8vIE5PUk0sIFNUQVJUIG9yIFNUT1AgdHlwZVxuXHRcdFx0XHRcdGFkanVzdCA9IDA7XG5cdFx0XHRcdFx0bWFza2luZ19sb3dlcl9kYiA9IGdmYy5QU1kubWFza19hZGp1c3QgLSBhZGp1c3Q7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YWRqdXN0ID0gMDtcblx0XHRcdFx0XHRtYXNraW5nX2xvd2VyX2RiID0gZ2ZjLlBTWS5tYXNrX2FkanVzdF9zaG9ydCAtIGFkanVzdDtcblx0XHRcdFx0fVxuXHRcdFx0XHRnZmMubWFza2luZ19sb3dlciA9ICBNYXRoLnBvdygxMC4wLFxuXHRcdFx0XHRcdFx0bWFza2luZ19sb3dlcl9kYiAqIDAuMSk7XG5cblx0XHRcdFx0Lypcblx0XHRcdFx0ICogaW5pdF9vdXRlcl9sb29wIHNldHMgdXAgY29kX2luZm8sIHNjYWxlZmFjIGFuZCB4cnBvd1xuXHRcdFx0XHQgKi9cblx0XHRcdFx0dGhpcy5xdWFudGl6ZS5pbml0X291dGVyX2xvb3AoZ2ZjLCBjb2RfaW5mbyk7XG5cdFx0XHRcdGlmICh0aGlzLnF1YW50aXplLmluaXRfeHJwb3coZ2ZjLCBjb2RfaW5mbywgeHJwb3cpKSB7XG5cdFx0XHRcdFx0Lypcblx0XHRcdFx0XHQgKiB4ciBjb250YWlucyBlbmVyZ3kgd2Ugd2lsbCBoYXZlIHRvIGVuY29kZSBjYWxjdWxhdGUgdGhlXG5cdFx0XHRcdFx0ICogbWFza2luZyBhYmlsaXRpZXMgZmluZCBzb21lIGdvb2QgcXVhbnRpemF0aW9uIGluXG5cdFx0XHRcdFx0ICogb3V0ZXJfbG9vcFxuXHRcdFx0XHRcdCAqL1xuXHRcdFx0XHRcdHRoaXMucXVhbnRpemUucXVwdnQuY2FsY194bWluKGdmcCwgcmF0aW9bZ3JdW2NoXSwgY29kX2luZm8sXG5cdFx0XHRcdFx0XHRcdGwzX3htaW4pO1xuXHRcdFx0XHRcdHRoaXMucXVhbnRpemUub3V0ZXJfbG9vcChnZnAsIGNvZF9pbmZvLCBsM194bWluLCB4cnBvdywgY2gsXG5cdFx0XHRcdFx0XHRcdHRhcmdfYml0c1tjaF0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5xdWFudGl6ZS5pdGVyYXRpb25fZmluaXNoX29uZShnZmMsIGdyLCBjaCk7XG5cdFx0XHRcdGFzc2VydCAoY29kX2luZm8ucGFydDJfM19sZW5ndGggPD0gTGFtZUludGVybmFsRmxhZ3MuTUFYX0JJVFNfUEVSX0NIQU5ORUwpO1xuXHRcdFx0XHRhc3NlcnQgKGNvZF9pbmZvLnBhcnQyXzNfbGVuZ3RoIDw9IHRhcmdfYml0c1tjaF0pO1xuXHRcdFx0fSAvKiBmb3IgY2ggKi9cblx0XHR9IC8qIGZvciBnciAqL1xuXG5cdFx0dGhpcy5xdWFudGl6ZS5ydi5SZXN2RnJhbWVFbmQoZ2ZjLCBtZWFuX2JpdHMpO1xuXHR9XG59XG5tb2R1bGUuZXhwb3J0cyA9IENCUk5ld0l0ZXJhdGlvbkxvb3A7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lamejs/src/js/CBRNewIterationLoop.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lamejs/src/js/CalcNoiseData.js":
/*!*****************************************************!*\
  !*** ./node_modules/lamejs/src/js/CalcNoiseData.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var common = __webpack_require__(/*! ./common.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/common.js\");\nvar new_float = common.new_float;\nvar new_int = common.new_int;\nvar assert = common.assert;\n\nfunction CalcNoiseData() {\n    this.global_gain = 0;\n    this.sfb_count1 = 0;\n    this.step = new_int(39);\n    this.noise = new_float(39);\n    this.noise_log = new_float(39);\n}\n\nmodule.exports = CalcNoiseData;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL0NhbGNOb2lzZURhdGEuanMiLCJtYXBwaW5ncyI6IkFBQUEsYUFBYSxtQkFBTyxDQUFDLCtFQUFhO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbGFtZWpzL3NyYy9qcy9DYWxjTm9pc2VEYXRhLmpzPzdkZDIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uLmpzJyk7XG52YXIgbmV3X2Zsb2F0ID0gY29tbW9uLm5ld19mbG9hdDtcbnZhciBuZXdfaW50ID0gY29tbW9uLm5ld19pbnQ7XG52YXIgYXNzZXJ0ID0gY29tbW9uLmFzc2VydDtcblxuZnVuY3Rpb24gQ2FsY05vaXNlRGF0YSgpIHtcbiAgICB0aGlzLmdsb2JhbF9nYWluID0gMDtcbiAgICB0aGlzLnNmYl9jb3VudDEgPSAwO1xuICAgIHRoaXMuc3RlcCA9IG5ld19pbnQoMzkpO1xuICAgIHRoaXMubm9pc2UgPSBuZXdfZmxvYXQoMzkpO1xuICAgIHRoaXMubm9pc2VfbG9nID0gbmV3X2Zsb2F0KDM5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDYWxjTm9pc2VEYXRhO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lamejs/src/js/CalcNoiseData.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lamejs/src/js/CalcNoiseResult.js":
/*!*******************************************************!*\
  !*** ./node_modules/lamejs/src/js/CalcNoiseResult.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("//package mp3;\n\nfunction CalcNoiseResult() {\n    /**\n     * sum of quantization noise > masking\n     */\n    this.over_noise = 0.;\n    /**\n     * sum of all quantization noise\n     */\n    this.tot_noise = 0.;\n    /**\n     * max quantization noise\n     */\n    this.max_noise = 0.;\n    /**\n     * number of quantization noise > masking\n     */\n    this.over_count = 0;\n    /**\n     * SSD-like cost of distorted bands\n     */\n    this.over_SSD = 0;\n    this.bits = 0;\n}\n\nmodule.exports = CalcNoiseResult;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL0NhbGNOb2lzZVJlc3VsdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL0NhbGNOb2lzZVJlc3VsdC5qcz80NTVhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vcGFja2FnZSBtcDM7XG5cbmZ1bmN0aW9uIENhbGNOb2lzZVJlc3VsdCgpIHtcbiAgICAvKipcbiAgICAgKiBzdW0gb2YgcXVhbnRpemF0aW9uIG5vaXNlID4gbWFza2luZ1xuICAgICAqL1xuICAgIHRoaXMub3Zlcl9ub2lzZSA9IDAuO1xuICAgIC8qKlxuICAgICAqIHN1bSBvZiBhbGwgcXVhbnRpemF0aW9uIG5vaXNlXG4gICAgICovXG4gICAgdGhpcy50b3Rfbm9pc2UgPSAwLjtcbiAgICAvKipcbiAgICAgKiBtYXggcXVhbnRpemF0aW9uIG5vaXNlXG4gICAgICovXG4gICAgdGhpcy5tYXhfbm9pc2UgPSAwLjtcbiAgICAvKipcbiAgICAgKiBudW1iZXIgb2YgcXVhbnRpemF0aW9uIG5vaXNlID4gbWFza2luZ1xuICAgICAqL1xuICAgIHRoaXMub3Zlcl9jb3VudCA9IDA7XG4gICAgLyoqXG4gICAgICogU1NELWxpa2UgY29zdCBvZiBkaXN0b3J0ZWQgYmFuZHNcbiAgICAgKi9cbiAgICB0aGlzLm92ZXJfU1NEID0gMDtcbiAgICB0aGlzLmJpdHMgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENhbGNOb2lzZVJlc3VsdDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lamejs/src/js/CalcNoiseResult.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lamejs/src/js/Encoder.js":
/*!***********************************************!*\
  !*** ./node_modules/lamejs/src/js/Encoder.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var common = __webpack_require__(/*! ./common.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/common.js\");\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\n/**\n * ENCDELAY The encoder delay.\n *\n * Minimum allowed is MDCTDELAY (see below)\n *\n * The first 96 samples will be attenuated, so using a value less than 96\n * will result in corrupt data for the first 96-ENCDELAY samples.\n *\n * suggested: 576 set to 1160 to sync with FhG.\n */\nEncoder.ENCDELAY = 576;\n/**\n * make sure there is at least one complete frame after the last frame\n * containing real data\n *\n * Using a value of 288 would be sufficient for a a very sophisticated\n * decoder that can decode granule-by-granule instead of frame by frame. But\n * lets not assume this, and assume the decoder will not decode frame N\n * unless it also has data for frame N+1\n */\nEncoder.POSTDELAY = 1152;\n\n/**\n * delay of the MDCT used in mdct.c original ISO routines had a delay of\n * 528! Takehiro's routines:\n */\nEncoder.MDCTDELAY = 48;\nEncoder.FFTOFFSET = (224 + Encoder.MDCTDELAY);\n\n/**\n * Most decoders, including the one we use, have a delay of 528 samples.\n */\nEncoder.DECDELAY = 528;\n\n/**\n * number of subbands\n */\nEncoder.SBLIMIT = 32;\n\n/**\n * parition bands bands\n */\nEncoder.CBANDS = 64;\n\n/**\n * number of critical bands/scale factor bands where masking is computed\n */\nEncoder.SBPSY_l = 21;\nEncoder.SBPSY_s = 12;\n\n/**\n * total number of scalefactor bands encoded\n */\nEncoder.SBMAX_l = 22;\nEncoder.SBMAX_s = 13;\nEncoder.PSFB21 = 6;\nEncoder.PSFB12 = 6;\n\n/**\n * FFT sizes\n */\nEncoder.BLKSIZE = 1024;\nEncoder.HBLKSIZE = (Encoder.BLKSIZE / 2 + 1);\nEncoder.BLKSIZE_s = 256;\nEncoder.HBLKSIZE_s = (Encoder.BLKSIZE_s / 2 + 1);\n\nEncoder.NORM_TYPE = 0;\nEncoder.START_TYPE = 1;\nEncoder.SHORT_TYPE = 2;\nEncoder.STOP_TYPE = 3;\n\n/**\n * <PRE>\n * Mode Extention:\n * When we are in stereo mode, there are 4 possible methods to store these\n * two channels. The stereo modes -m? are using a subset of them.\n *\n *  -ms: MPG_MD_LR_LR\n *  -mj: MPG_MD_LR_LR and MPG_MD_MS_LR\n *  -mf: MPG_MD_MS_LR\n *  -mi: all\n * </PRE>\n */\nEncoder.MPG_MD_LR_LR = 0;\nEncoder.MPG_MD_LR_I = 1;\nEncoder.MPG_MD_MS_LR = 2;\nEncoder.MPG_MD_MS_I = 3;\n\nEncoder.fircoef = [-0.0207887 * 5, -0.0378413 * 5,\n    -0.0432472 * 5, -0.031183 * 5, 7.79609e-18 * 5, 0.0467745 * 5,\n    0.10091 * 5, 0.151365 * 5, 0.187098 * 5];\n\nfunction Encoder() {\n    var NewMDCT = __webpack_require__(/*! ./NewMDCT.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/NewMDCT.js\");\n    var III_psy_ratio = __webpack_require__(/*! ./III_psy_ratio.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/III_psy_ratio.js\");\n    var MPEGMode = __webpack_require__(/*! ./MPEGMode.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/MPEGMode.js\");\n\n    var FFTOFFSET = Encoder.FFTOFFSET;\n    var MPG_MD_MS_LR = Encoder.MPG_MD_MS_LR;\n    //BitStream bs;\n    //PsyModel psy;\n    //VBRTag vbr;\n    //QuantizePVT qupvt;\n    var bs = null;\n    this.psy = null;\n    var psy = null;\n    var vbr = null;\n    var qupvt = null;\n\n    //public final void setModules(BitStream bs, PsyModel psy, QuantizePVT qupvt,\n    //    VBRTag vbr) {\n    this.setModules = function (_bs, _psy, _qupvt, _vbr) {\n        bs = _bs;\n        this.psy = _psy;\n        psy = _psy;\n        vbr = _vbr;\n        qupvt = _qupvt;\n    };\n\n    var newMDCT = new NewMDCT();\n\n    /***********************************************************************\n     *\n     * encoder and decoder delays\n     *\n     ***********************************************************************/\n\n    /**\n     * <PRE>\n     * layer III enc->dec delay:  1056 (1057?)   (observed)\n     * layer  II enc->dec delay:   480  (481?)   (observed)\n     *\n     * polyphase 256-16             (dec or enc)        = 240\n     * mdct      256+32  (9*32)     (dec or enc)        = 288\n     * total:    512+16\n     *\n     * My guess is that delay of polyphase filterbank is actualy 240.5\n     * (there are technical reasons for this, see postings in mp3encoder).\n     * So total Encode+Decode delay = ENCDELAY + 528 + 1\n     * </PRE>\n     */\n\n\n    /**\n     * auto-adjust of ATH, useful for low volume Gabriel Bouvigne 3 feb 2001\n     *\n     * modifies some values in gfp.internal_flags.ATH (gfc.ATH)\n     */\n//private void adjust_ATH(final LameInternalFlags gfc) {\n    function adjust_ATH(gfc) {\n        var gr2_max, max_pow;\n\n        if (gfc.ATH.useAdjust == 0) {\n            gfc.ATH.adjust = 1.0;\n            /* no adjustment */\n            return;\n        }\n\n        /* jd - 2001 mar 12, 27, jun 30 */\n        /* loudness based on equal loudness curve; */\n        /* use granule with maximum combined loudness */\n        max_pow = gfc.loudness_sq[0][0];\n        gr2_max = gfc.loudness_sq[1][0];\n        if (gfc.channels_out == 2) {\n            max_pow += gfc.loudness_sq[0][1];\n            gr2_max += gfc.loudness_sq[1][1];\n        } else {\n            max_pow += max_pow;\n            gr2_max += gr2_max;\n        }\n        if (gfc.mode_gr == 2) {\n            max_pow = Math.max(max_pow, gr2_max);\n        }\n        max_pow *= 0.5;\n        /* max_pow approaches 1.0 for full band noise */\n\n        /* jd - 2001 mar 31, jun 30 */\n        /* user tuning of ATH adjustment region */\n        max_pow *= gfc.ATH.aaSensitivityP;\n\n        /*\n         * adjust ATH depending on range of maximum value\n         */\n\n        /* jd - 2001 feb27, mar12,20, jun30, jul22 */\n        /* continuous curves based on approximation */\n        /* to GB's original values. */\n        /* For an increase in approximate loudness, */\n        /* set ATH adjust to adjust_limit immediately */\n        /* after a delay of one frame. */\n        /* For a loudness decrease, reduce ATH adjust */\n        /* towards adjust_limit gradually. */\n        /* max_pow is a loudness squared or a power. */\n        if (max_pow > 0.03125) { /* ((1 - 0.000625)/ 31.98) from curve below */\n            if (gfc.ATH.adjust >= 1.0) {\n                gfc.ATH.adjust = 1.0;\n            } else {\n                /* preceding frame has lower ATH adjust; */\n                /* ascend only to the preceding adjust_limit */\n                /* in case there is leading low volume */\n                if (gfc.ATH.adjust < gfc.ATH.adjustLimit) {\n                    gfc.ATH.adjust = gfc.ATH.adjustLimit;\n                }\n            }\n            gfc.ATH.adjustLimit = 1.0;\n        } else { /* adjustment curve */\n            /* about 32 dB maximum adjust (0.000625) */\n            var adj_lim_new = 31.98 * max_pow + 0.000625;\n            if (gfc.ATH.adjust >= adj_lim_new) { /* descend gradually */\n                gfc.ATH.adjust *= adj_lim_new * 0.075 + 0.925;\n                if (gfc.ATH.adjust < adj_lim_new) { /* stop descent */\n                    gfc.ATH.adjust = adj_lim_new;\n                }\n            } else { /* ascend */\n                if (gfc.ATH.adjustLimit >= adj_lim_new) {\n                    gfc.ATH.adjust = adj_lim_new;\n                } else {\n                    /* preceding frame has lower ATH adjust; */\n                    /* ascend only to the preceding adjust_limit */\n                    if (gfc.ATH.adjust < gfc.ATH.adjustLimit) {\n                        gfc.ATH.adjust = gfc.ATH.adjustLimit;\n                    }\n                }\n            }\n            gfc.ATH.adjustLimit = adj_lim_new;\n        }\n    }\n\n    /**\n     * <PRE>\n     *  some simple statistics\n     *\n     *  bitrate index 0: free bitrate . not allowed in VBR mode\n     *  : bitrates, kbps depending on MPEG version\n     *  bitrate index 15: forbidden\n     *\n     *  mode_ext:\n     *  0:  LR\n     *  1:  LR-i\n     *  2:  MS\n     *  3:  MS-i\n     * </PRE>\n     */\n    function updateStats(gfc) {\n        var gr, ch;\n        assert(0 <= gfc.bitrate_index && gfc.bitrate_index < 16);\n        assert(0 <= gfc.mode_ext && gfc.mode_ext < 4);\n\n        /* count bitrate indices */\n        gfc.bitrate_stereoMode_Hist[gfc.bitrate_index][4]++;\n        gfc.bitrate_stereoMode_Hist[15][4]++;\n\n        /* count 'em for every mode extension in case of 2 channel encoding */\n        if (gfc.channels_out == 2) {\n            gfc.bitrate_stereoMode_Hist[gfc.bitrate_index][gfc.mode_ext]++;\n            gfc.bitrate_stereoMode_Hist[15][gfc.mode_ext]++;\n        }\n        for (gr = 0; gr < gfc.mode_gr; ++gr) {\n            for (ch = 0; ch < gfc.channels_out; ++ch) {\n                var bt = gfc.l3_side.tt[gr][ch].block_type | 0;\n                if (gfc.l3_side.tt[gr][ch].mixed_block_flag != 0)\n                    bt = 4;\n                gfc.bitrate_blockType_Hist[gfc.bitrate_index][bt]++;\n                gfc.bitrate_blockType_Hist[gfc.bitrate_index][5]++;\n                gfc.bitrate_blockType_Hist[15][bt]++;\n                gfc.bitrate_blockType_Hist[15][5]++;\n            }\n        }\n    }\n\n    function lame_encode_frame_init(gfp, inbuf) {\n        var gfc = gfp.internal_flags;\n\n        var ch, gr;\n\n        if (gfc.lame_encode_frame_init == 0) {\n            /* prime the MDCT/polyphase filterbank with a short block */\n            var i, j;\n            var primebuff0 = new_float(286 + 1152 + 576);\n            var primebuff1 = new_float(286 + 1152 + 576);\n            gfc.lame_encode_frame_init = 1;\n            for (i = 0, j = 0; i < 286 + 576 * (1 + gfc.mode_gr); ++i) {\n                if (i < 576 * gfc.mode_gr) {\n                    primebuff0[i] = 0;\n                    if (gfc.channels_out == 2)\n                        primebuff1[i] = 0;\n                } else {\n                    primebuff0[i] = inbuf[0][j];\n                    if (gfc.channels_out == 2)\n                        primebuff1[i] = inbuf[1][j];\n                    ++j;\n                }\n            }\n            /* polyphase filtering / mdct */\n            for (gr = 0; gr < gfc.mode_gr; gr++) {\n                for (ch = 0; ch < gfc.channels_out; ch++) {\n                    gfc.l3_side.tt[gr][ch].block_type = Encoder.SHORT_TYPE;\n                }\n            }\n            newMDCT.mdct_sub48(gfc, primebuff0, primebuff1);\n\n            /* check FFT will not use a negative starting offset */\n            assert(576 >= Encoder.FFTOFFSET);\n            /* check if we have enough data for FFT */\n            assert(gfc.mf_size >= (Encoder.BLKSIZE + gfp.framesize - Encoder.FFTOFFSET));\n            /* check if we have enough data for polyphase filterbank */\n            assert(gfc.mf_size >= (512 + gfp.framesize - 32));\n        }\n\n    }\n\n    /**\n     * <PRE>\n     * encodeframe()           Layer 3\n     *\n     * encode a single frame\n     *\n     *\n     *    lame_encode_frame()\n     *\n     *\n     *                           gr 0            gr 1\n     *    inbuf:           |--------------|--------------|--------------|\n     *\n     *\n     *    Polyphase (18 windows, each shifted 32)\n     *    gr 0:\n     *    window1          <----512---.\n     *    window18                 <----512---.\n     *\n     *    gr 1:\n     *    window1                         <----512---.\n     *    window18                                <----512---.\n     *\n     *\n     *\n     *    MDCT output:  |--------------|--------------|--------------|\n     *\n     *    FFT's                    <---------1024---------.\n     *                                             <---------1024-------.\n     *\n     *\n     *\n     *        inbuf = buffer of PCM data size=MP3 framesize\n     *        encoder acts on inbuf[ch][0], but output is delayed by MDCTDELAY\n     *        so the MDCT coefficints are from inbuf[ch][-MDCTDELAY]\n     *\n     *        psy-model FFT has a 1 granule delay, so we feed it data for the\n     *        next granule.\n     *        FFT is centered over granule:  224+576+224\n     *        So FFT starts at:   576-224-MDCTDELAY\n     *\n     *        MPEG2:  FFT ends at:  BLKSIZE+576-224-MDCTDELAY      (1328)\n     *        MPEG1:  FFT ends at:  BLKSIZE+2*576-224-MDCTDELAY    (1904)\n     *\n     *        MPEG2:  polyphase first window:  [0..511]\n     *                          18th window:   [544..1055]          (1056)\n     *        MPEG1:            36th window:   [1120..1631]         (1632)\n     *                data needed:  512+framesize-32\n     *\n     *        A close look newmdct.c shows that the polyphase filterbank\n     *        only uses data from [0..510] for each window.  Perhaps because the window\n     *        used by the filterbank is zero for the last point, so Takehiro's\n     *        code doesn't bother to compute with it.\n     *\n     *        FFT starts at 576-224-MDCTDELAY (304)  = 576-FFTOFFSET\n     *\n     * </PRE>\n     */\n\n\n    this.lame_encode_mp3_frame = function (gfp, inbuf_l, inbuf_r, mp3buf, mp3bufPos, mp3buf_size) {\n        var mp3count;\n        var masking_LR = new_array_n([2, 2]);\n        /*\n         * LR masking &\n         * energy\n         */\n        masking_LR[0][0] = new III_psy_ratio();\n        masking_LR[0][1] = new III_psy_ratio();\n        masking_LR[1][0] = new III_psy_ratio();\n        masking_LR[1][1] = new III_psy_ratio();\n        var masking_MS = new_array_n([2, 2]);\n        /* MS masking & energy */\n        masking_MS[0][0] = new III_psy_ratio();\n        masking_MS[0][1] = new III_psy_ratio();\n        masking_MS[1][0] = new III_psy_ratio();\n        masking_MS[1][1] = new III_psy_ratio();\n        //III_psy_ratio masking[][];\n        var masking;\n        /* pointer to selected maskings */\n        var inbuf = [null, null];\n        var gfc = gfp.internal_flags;\n\n        var tot_ener = new_float_n([2, 4]);\n        var ms_ener_ratio = [.5, .5];\n        var pe = [[0., 0.], [0., 0.]];\n        var pe_MS = [[0., 0.], [0., 0.]];\n\n//float[][] pe_use;\n        var pe_use;\n\n        var ch, gr;\n\n        inbuf[0] = inbuf_l;\n        inbuf[1] = inbuf_r;\n\n        if (gfc.lame_encode_frame_init == 0) {\n            /* first run? */\n            lame_encode_frame_init(gfp, inbuf);\n\n        }\n\n        /********************** padding *****************************/\n        /**\n         * <PRE>\n         * padding method as described in\n         * \"MPEG-Layer3 / Bitstream Syntax and Decoding\"\n         * by Martin Sieler, Ralph Sperschneider\n         *\n         * note: there is no padding for the very first frame\n         *\n         * Robert Hegemann 2000-06-22\n         * </PRE>\n         */\n        gfc.padding = 0;\n        if ((gfc.slot_lag -= gfc.frac_SpF) < 0) {\n            gfc.slot_lag += gfp.out_samplerate;\n            gfc.padding = 1;\n        }\n\n        /****************************************\n         * Stage 1: psychoacoustic model *\n         ****************************************/\n\n        if (gfc.psymodel != 0) {\n            /*\n             * psychoacoustic model psy model has a 1 granule (576) delay that\n             * we must compensate for (mt 6/99).\n             */\n            var ret;\n            var bufp = [null, null];\n            /* address of beginning of left & right granule */\n            var bufpPos = 0;\n            /* address of beginning of left & right granule */\n            var blocktype = new_int(2);\n\n            for (gr = 0; gr < gfc.mode_gr; gr++) {\n\n                for (ch = 0; ch < gfc.channels_out; ch++) {\n                    bufp[ch] = inbuf[ch];\n                    bufpPos = 576 + gr * 576 - Encoder.FFTOFFSET;\n                }\n                if (gfp.VBR == VbrMode.vbr_mtrh || gfp.VBR == VbrMode.vbr_mt) {\n                    ret = psy.L3psycho_anal_vbr(gfp, bufp, bufpPos, gr,\n                        masking_LR, masking_MS, pe[gr], pe_MS[gr],\n                        tot_ener[gr], blocktype);\n                } else {\n                    ret = psy.L3psycho_anal_ns(gfp, bufp, bufpPos, gr,\n                        masking_LR, masking_MS, pe[gr], pe_MS[gr],\n                        tot_ener[gr], blocktype);\n                }\n                if (ret != 0)\n                    return -4;\n\n                if (gfp.mode == MPEGMode.JOINT_STEREO) {\n                    ms_ener_ratio[gr] = tot_ener[gr][2] + tot_ener[gr][3];\n                    if (ms_ener_ratio[gr] > 0)\n                        ms_ener_ratio[gr] = tot_ener[gr][3] / ms_ener_ratio[gr];\n                }\n\n                /* block type flags */\n                for (ch = 0; ch < gfc.channels_out; ch++) {\n                    var cod_info = gfc.l3_side.tt[gr][ch];\n                    cod_info.block_type = blocktype[ch];\n                    cod_info.mixed_block_flag = 0;\n                }\n            }\n        } else {\n            /* no psy model */\n            for (gr = 0; gr < gfc.mode_gr; gr++)\n                for (ch = 0; ch < gfc.channels_out; ch++) {\n                    gfc.l3_side.tt[gr][ch].block_type = Encoder.NORM_TYPE;\n                    gfc.l3_side.tt[gr][ch].mixed_block_flag = 0;\n                    pe_MS[gr][ch] = pe[gr][ch] = 700;\n                }\n        }\n\n        /* auto-adjust of ATH, useful for low volume */\n        adjust_ATH(gfc);\n\n        /****************************************\n         * Stage 2: MDCT *\n         ****************************************/\n\n        /* polyphase filtering / mdct */\n        newMDCT.mdct_sub48(gfc, inbuf[0], inbuf[1]);\n\n        /****************************************\n         * Stage 3: MS/LR decision *\n         ****************************************/\n\n        /* Here will be selected MS or LR coding of the 2 stereo channels */\n        gfc.mode_ext = Encoder.MPG_MD_LR_LR;\n\n        if (gfp.force_ms) {\n            gfc.mode_ext = Encoder.MPG_MD_MS_LR;\n        } else if (gfp.mode == MPEGMode.JOINT_STEREO) {\n            /*\n             * ms_ratio = is scaled, for historical reasons, to look like a\n             * ratio of side_channel / total. 0 = signal is 100% mono .5 = L & R\n             * uncorrelated\n             */\n\n            /**\n             * <PRE>\n             * [0] and [1] are the results for the two granules in MPEG-1,\n             * in MPEG-2 it's only a faked averaging of the same value\n             * _prev is the value of the last granule of the previous frame\n             * _next is the value of the first granule of the next frame\n             * </PRE>\n             */\n\n            var sum_pe_MS = 0.;\n            var sum_pe_LR = 0.;\n            for (gr = 0; gr < gfc.mode_gr; gr++) {\n                for (ch = 0; ch < gfc.channels_out; ch++) {\n                    sum_pe_MS += pe_MS[gr][ch];\n                    sum_pe_LR += pe[gr][ch];\n                }\n            }\n\n            /* based on PE: M/S coding would not use much more bits than L/R */\n            if (sum_pe_MS <= 1.00 * sum_pe_LR) {\n\n                var gi0 = gfc.l3_side.tt[0];\n                var gi1 = gfc.l3_side.tt[gfc.mode_gr - 1];\n\n                if (gi0[0].block_type == gi0[1].block_type\n                    && gi1[0].block_type == gi1[1].block_type) {\n\n                    gfc.mode_ext = Encoder.MPG_MD_MS_LR;\n                }\n            }\n        }\n\n        /* bit and noise allocation */\n        if (gfc.mode_ext == MPG_MD_MS_LR) {\n            masking = masking_MS;\n            /* use MS masking */\n            pe_use = pe_MS;\n        } else {\n            masking = masking_LR;\n            /* use LR masking */\n            pe_use = pe;\n        }\n\n        /* copy data for MP3 frame analyzer */\n        if (gfp.analysis && gfc.pinfo != null) {\n            for (gr = 0; gr < gfc.mode_gr; gr++) {\n                for (ch = 0; ch < gfc.channels_out; ch++) {\n                    gfc.pinfo.ms_ratio[gr] = gfc.ms_ratio[gr];\n                    gfc.pinfo.ms_ener_ratio[gr] = ms_ener_ratio[gr];\n                    gfc.pinfo.blocktype[gr][ch] = gfc.l3_side.tt[gr][ch].block_type;\n                    gfc.pinfo.pe[gr][ch] = pe_use[gr][ch];\n                    System.arraycopy(gfc.l3_side.tt[gr][ch].xr, 0,\n                        gfc.pinfo.xr[gr][ch], 0, 576);\n                    /*\n                     * in psymodel, LR and MS data was stored in pinfo. switch\n                     * to MS data:\n                     */\n                    if (gfc.mode_ext == MPG_MD_MS_LR) {\n                        gfc.pinfo.ers[gr][ch] = gfc.pinfo.ers[gr][ch + 2];\n                        System.arraycopy(gfc.pinfo.energy[gr][ch + 2], 0,\n                            gfc.pinfo.energy[gr][ch], 0,\n                            gfc.pinfo.energy[gr][ch].length);\n                    }\n                }\n            }\n        }\n\n        /****************************************\n         * Stage 4: quantization loop *\n         ****************************************/\n\n        if (gfp.VBR == VbrMode.vbr_off || gfp.VBR == VbrMode.vbr_abr) {\n\n            var i;\n            var f;\n\n            for (i = 0; i < 18; i++)\n                gfc.nsPsy.pefirbuf[i] = gfc.nsPsy.pefirbuf[i + 1];\n\n            f = 0.0;\n            for (gr = 0; gr < gfc.mode_gr; gr++)\n                for (ch = 0; ch < gfc.channels_out; ch++)\n                    f += pe_use[gr][ch];\n            gfc.nsPsy.pefirbuf[18] = f;\n\n            f = gfc.nsPsy.pefirbuf[9];\n            for (i = 0; i < 9; i++)\n                f += (gfc.nsPsy.pefirbuf[i] + gfc.nsPsy.pefirbuf[18 - i])\n                    * Encoder.fircoef[i];\n\n            f = (670 * 5 * gfc.mode_gr * gfc.channels_out) / f;\n            for (gr = 0; gr < gfc.mode_gr; gr++) {\n                for (ch = 0; ch < gfc.channels_out; ch++) {\n                    pe_use[gr][ch] *= f;\n                }\n            }\n        }\n        gfc.iteration_loop.iteration_loop(gfp, pe_use, ms_ener_ratio, masking);\n\n        /****************************************\n         * Stage 5: bitstream formatting *\n         ****************************************/\n\n        /* write the frame to the bitstream */\n        bs.format_bitstream(gfp);\n\n        /* copy mp3 bit buffer into array */\n        mp3count = bs.copy_buffer(gfc, mp3buf, mp3bufPos, mp3buf_size, 1);\n\n        if (gfp.bWriteVbrTag)\n            vbr.addVbrFrame(gfp);\n\n        if (gfp.analysis && gfc.pinfo != null) {\n            for (ch = 0; ch < gfc.channels_out; ch++) {\n                var j;\n                for (j = 0; j < FFTOFFSET; j++)\n                    gfc.pinfo.pcmdata[ch][j] = gfc.pinfo.pcmdata[ch][j\n                    + gfp.framesize];\n                for (j = FFTOFFSET; j < 1600; j++) {\n                    gfc.pinfo.pcmdata[ch][j] = inbuf[ch][j - FFTOFFSET];\n                }\n            }\n            qupvt.set_frame_pinfo(gfp, masking);\n        }\n\n        updateStats(gfc);\n\n        return mp3count;\n    }\n}\n\n\nmodule.exports = Encoder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL0VuY29kZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEsYUFBYSxtQkFBTyxDQUFDLCtFQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLGlGQUFjO0FBQ3hDLHdCQUF3QixtQkFBTyxDQUFDLDZGQUFvQjtBQUNwRCxtQkFBbUIsbUJBQU8sQ0FBQyxtRkFBZTs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLGNBQWM7QUFDZCx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkMseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQ0FBbUM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDLDZCQUE2Qix1QkFBdUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsa0JBQWtCOztBQUUzQyw2QkFBNkIsdUJBQXVCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLHVCQUF1QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EseUJBQXlCLGtCQUFrQjtBQUMzQyw2QkFBNkIsdUJBQXVCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLGtCQUFrQjtBQUMzQyw2QkFBNkIsdUJBQXVCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QixrQkFBa0I7QUFDM0MsNkJBQTZCLHVCQUF1QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0IsUUFBUTtBQUNoQzs7QUFFQTtBQUNBLHlCQUF5QixrQkFBa0I7QUFDM0MsNkJBQTZCLHVCQUF1QjtBQUNwRDtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixrQkFBa0I7QUFDM0MsNkJBQTZCLHVCQUF1QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL0VuY29kZXIuanM/NDBlYiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24uanMnKTtcbnZhciBTeXN0ZW0gPSBjb21tb24uU3lzdGVtO1xudmFyIFZick1vZGUgPSBjb21tb24uVmJyTW9kZTtcbnZhciBGbG9hdCA9IGNvbW1vbi5GbG9hdDtcbnZhciBTaG9ydEJsb2NrID0gY29tbW9uLlNob3J0QmxvY2s7XG52YXIgVXRpbCA9IGNvbW1vbi5VdGlsO1xudmFyIEFycmF5cyA9IGNvbW1vbi5BcnJheXM7XG52YXIgbmV3X2FycmF5X24gPSBjb21tb24ubmV3X2FycmF5X247XG52YXIgbmV3X2J5dGUgPSBjb21tb24ubmV3X2J5dGU7XG52YXIgbmV3X2RvdWJsZSA9IGNvbW1vbi5uZXdfZG91YmxlO1xudmFyIG5ld19mbG9hdCA9IGNvbW1vbi5uZXdfZmxvYXQ7XG52YXIgbmV3X2Zsb2F0X24gPSBjb21tb24ubmV3X2Zsb2F0X247XG52YXIgbmV3X2ludCA9IGNvbW1vbi5uZXdfaW50O1xudmFyIG5ld19pbnRfbiA9IGNvbW1vbi5uZXdfaW50X247XG52YXIgYXNzZXJ0ID0gY29tbW9uLmFzc2VydDtcblxuLyoqXG4gKiBFTkNERUxBWSBUaGUgZW5jb2RlciBkZWxheS5cbiAqXG4gKiBNaW5pbXVtIGFsbG93ZWQgaXMgTURDVERFTEFZIChzZWUgYmVsb3cpXG4gKlxuICogVGhlIGZpcnN0IDk2IHNhbXBsZXMgd2lsbCBiZSBhdHRlbnVhdGVkLCBzbyB1c2luZyBhIHZhbHVlIGxlc3MgdGhhbiA5NlxuICogd2lsbCByZXN1bHQgaW4gY29ycnVwdCBkYXRhIGZvciB0aGUgZmlyc3QgOTYtRU5DREVMQVkgc2FtcGxlcy5cbiAqXG4gKiBzdWdnZXN0ZWQ6IDU3NiBzZXQgdG8gMTE2MCB0byBzeW5jIHdpdGggRmhHLlxuICovXG5FbmNvZGVyLkVOQ0RFTEFZID0gNTc2O1xuLyoqXG4gKiBtYWtlIHN1cmUgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGNvbXBsZXRlIGZyYW1lIGFmdGVyIHRoZSBsYXN0IGZyYW1lXG4gKiBjb250YWluaW5nIHJlYWwgZGF0YVxuICpcbiAqIFVzaW5nIGEgdmFsdWUgb2YgMjg4IHdvdWxkIGJlIHN1ZmZpY2llbnQgZm9yIGEgYSB2ZXJ5IHNvcGhpc3RpY2F0ZWRcbiAqIGRlY29kZXIgdGhhdCBjYW4gZGVjb2RlIGdyYW51bGUtYnktZ3JhbnVsZSBpbnN0ZWFkIG9mIGZyYW1lIGJ5IGZyYW1lLiBCdXRcbiAqIGxldHMgbm90IGFzc3VtZSB0aGlzLCBhbmQgYXNzdW1lIHRoZSBkZWNvZGVyIHdpbGwgbm90IGRlY29kZSBmcmFtZSBOXG4gKiB1bmxlc3MgaXQgYWxzbyBoYXMgZGF0YSBmb3IgZnJhbWUgTisxXG4gKi9cbkVuY29kZXIuUE9TVERFTEFZID0gMTE1MjtcblxuLyoqXG4gKiBkZWxheSBvZiB0aGUgTURDVCB1c2VkIGluIG1kY3QuYyBvcmlnaW5hbCBJU08gcm91dGluZXMgaGFkIGEgZGVsYXkgb2ZcbiAqIDUyOCEgVGFrZWhpcm8ncyByb3V0aW5lczpcbiAqL1xuRW5jb2Rlci5NRENUREVMQVkgPSA0ODtcbkVuY29kZXIuRkZUT0ZGU0VUID0gKDIyNCArIEVuY29kZXIuTURDVERFTEFZKTtcblxuLyoqXG4gKiBNb3N0IGRlY29kZXJzLCBpbmNsdWRpbmcgdGhlIG9uZSB3ZSB1c2UsIGhhdmUgYSBkZWxheSBvZiA1Mjggc2FtcGxlcy5cbiAqL1xuRW5jb2Rlci5ERUNERUxBWSA9IDUyODtcblxuLyoqXG4gKiBudW1iZXIgb2Ygc3ViYmFuZHNcbiAqL1xuRW5jb2Rlci5TQkxJTUlUID0gMzI7XG5cbi8qKlxuICogcGFyaXRpb24gYmFuZHMgYmFuZHNcbiAqL1xuRW5jb2Rlci5DQkFORFMgPSA2NDtcblxuLyoqXG4gKiBudW1iZXIgb2YgY3JpdGljYWwgYmFuZHMvc2NhbGUgZmFjdG9yIGJhbmRzIHdoZXJlIG1hc2tpbmcgaXMgY29tcHV0ZWRcbiAqL1xuRW5jb2Rlci5TQlBTWV9sID0gMjE7XG5FbmNvZGVyLlNCUFNZX3MgPSAxMjtcblxuLyoqXG4gKiB0b3RhbCBudW1iZXIgb2Ygc2NhbGVmYWN0b3IgYmFuZHMgZW5jb2RlZFxuICovXG5FbmNvZGVyLlNCTUFYX2wgPSAyMjtcbkVuY29kZXIuU0JNQVhfcyA9IDEzO1xuRW5jb2Rlci5QU0ZCMjEgPSA2O1xuRW5jb2Rlci5QU0ZCMTIgPSA2O1xuXG4vKipcbiAqIEZGVCBzaXplc1xuICovXG5FbmNvZGVyLkJMS1NJWkUgPSAxMDI0O1xuRW5jb2Rlci5IQkxLU0laRSA9IChFbmNvZGVyLkJMS1NJWkUgLyAyICsgMSk7XG5FbmNvZGVyLkJMS1NJWkVfcyA9IDI1NjtcbkVuY29kZXIuSEJMS1NJWkVfcyA9IChFbmNvZGVyLkJMS1NJWkVfcyAvIDIgKyAxKTtcblxuRW5jb2Rlci5OT1JNX1RZUEUgPSAwO1xuRW5jb2Rlci5TVEFSVF9UWVBFID0gMTtcbkVuY29kZXIuU0hPUlRfVFlQRSA9IDI7XG5FbmNvZGVyLlNUT1BfVFlQRSA9IDM7XG5cbi8qKlxuICogPFBSRT5cbiAqIE1vZGUgRXh0ZW50aW9uOlxuICogV2hlbiB3ZSBhcmUgaW4gc3RlcmVvIG1vZGUsIHRoZXJlIGFyZSA0IHBvc3NpYmxlIG1ldGhvZHMgdG8gc3RvcmUgdGhlc2VcbiAqIHR3byBjaGFubmVscy4gVGhlIHN0ZXJlbyBtb2RlcyAtbT8gYXJlIHVzaW5nIGEgc3Vic2V0IG9mIHRoZW0uXG4gKlxuICogIC1tczogTVBHX01EX0xSX0xSXG4gKiAgLW1qOiBNUEdfTURfTFJfTFIgYW5kIE1QR19NRF9NU19MUlxuICogIC1tZjogTVBHX01EX01TX0xSXG4gKiAgLW1pOiBhbGxcbiAqIDwvUFJFPlxuICovXG5FbmNvZGVyLk1QR19NRF9MUl9MUiA9IDA7XG5FbmNvZGVyLk1QR19NRF9MUl9JID0gMTtcbkVuY29kZXIuTVBHX01EX01TX0xSID0gMjtcbkVuY29kZXIuTVBHX01EX01TX0kgPSAzO1xuXG5FbmNvZGVyLmZpcmNvZWYgPSBbLTAuMDIwNzg4NyAqIDUsIC0wLjAzNzg0MTMgKiA1LFxuICAgIC0wLjA0MzI0NzIgKiA1LCAtMC4wMzExODMgKiA1LCA3Ljc5NjA5ZS0xOCAqIDUsIDAuMDQ2Nzc0NSAqIDUsXG4gICAgMC4xMDA5MSAqIDUsIDAuMTUxMzY1ICogNSwgMC4xODcwOTggKiA1XTtcblxuZnVuY3Rpb24gRW5jb2RlcigpIHtcbiAgICB2YXIgTmV3TURDVCA9IHJlcXVpcmUoJy4vTmV3TURDVC5qcycpO1xuICAgIHZhciBJSUlfcHN5X3JhdGlvID0gcmVxdWlyZSgnLi9JSUlfcHN5X3JhdGlvLmpzJyk7XG4gICAgdmFyIE1QRUdNb2RlID0gcmVxdWlyZSgnLi9NUEVHTW9kZS5qcycpO1xuXG4gICAgdmFyIEZGVE9GRlNFVCA9IEVuY29kZXIuRkZUT0ZGU0VUO1xuICAgIHZhciBNUEdfTURfTVNfTFIgPSBFbmNvZGVyLk1QR19NRF9NU19MUjtcbiAgICAvL0JpdFN0cmVhbSBicztcbiAgICAvL1BzeU1vZGVsIHBzeTtcbiAgICAvL1ZCUlRhZyB2YnI7XG4gICAgLy9RdWFudGl6ZVBWVCBxdXB2dDtcbiAgICB2YXIgYnMgPSBudWxsO1xuICAgIHRoaXMucHN5ID0gbnVsbDtcbiAgICB2YXIgcHN5ID0gbnVsbDtcbiAgICB2YXIgdmJyID0gbnVsbDtcbiAgICB2YXIgcXVwdnQgPSBudWxsO1xuXG4gICAgLy9wdWJsaWMgZmluYWwgdm9pZCBzZXRNb2R1bGVzKEJpdFN0cmVhbSBicywgUHN5TW9kZWwgcHN5LCBRdWFudGl6ZVBWVCBxdXB2dCxcbiAgICAvLyAgICBWQlJUYWcgdmJyKSB7XG4gICAgdGhpcy5zZXRNb2R1bGVzID0gZnVuY3Rpb24gKF9icywgX3BzeSwgX3F1cHZ0LCBfdmJyKSB7XG4gICAgICAgIGJzID0gX2JzO1xuICAgICAgICB0aGlzLnBzeSA9IF9wc3k7XG4gICAgICAgIHBzeSA9IF9wc3k7XG4gICAgICAgIHZiciA9IF92YnI7XG4gICAgICAgIHF1cHZ0ID0gX3F1cHZ0O1xuICAgIH07XG5cbiAgICB2YXIgbmV3TURDVCA9IG5ldyBOZXdNRENUKCk7XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgKlxuICAgICAqIGVuY29kZXIgYW5kIGRlY29kZXIgZGVsYXlzXG4gICAgICpcbiAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAvKipcbiAgICAgKiA8UFJFPlxuICAgICAqIGxheWVyIElJSSBlbmMtPmRlYyBkZWxheTogIDEwNTYgKDEwNTc/KSAgIChvYnNlcnZlZClcbiAgICAgKiBsYXllciAgSUkgZW5jLT5kZWMgZGVsYXk6ICAgNDgwICAoNDgxPykgICAob2JzZXJ2ZWQpXG4gICAgICpcbiAgICAgKiBwb2x5cGhhc2UgMjU2LTE2ICAgICAgICAgICAgIChkZWMgb3IgZW5jKSAgICAgICAgPSAyNDBcbiAgICAgKiBtZGN0ICAgICAgMjU2KzMyICAoOSozMikgICAgIChkZWMgb3IgZW5jKSAgICAgICAgPSAyODhcbiAgICAgKiB0b3RhbDogICAgNTEyKzE2XG4gICAgICpcbiAgICAgKiBNeSBndWVzcyBpcyB0aGF0IGRlbGF5IG9mIHBvbHlwaGFzZSBmaWx0ZXJiYW5rIGlzIGFjdHVhbHkgMjQwLjVcbiAgICAgKiAodGhlcmUgYXJlIHRlY2huaWNhbCByZWFzb25zIGZvciB0aGlzLCBzZWUgcG9zdGluZ3MgaW4gbXAzZW5jb2RlcikuXG4gICAgICogU28gdG90YWwgRW5jb2RlK0RlY29kZSBkZWxheSA9IEVOQ0RFTEFZICsgNTI4ICsgMVxuICAgICAqIDwvUFJFPlxuICAgICAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBhdXRvLWFkanVzdCBvZiBBVEgsIHVzZWZ1bCBmb3IgbG93IHZvbHVtZSBHYWJyaWVsIEJvdXZpZ25lIDMgZmViIDIwMDFcbiAgICAgKlxuICAgICAqIG1vZGlmaWVzIHNvbWUgdmFsdWVzIGluIGdmcC5pbnRlcm5hbF9mbGFncy5BVEggKGdmYy5BVEgpXG4gICAgICovXG4vL3ByaXZhdGUgdm9pZCBhZGp1c3RfQVRIKGZpbmFsIExhbWVJbnRlcm5hbEZsYWdzIGdmYykge1xuICAgIGZ1bmN0aW9uIGFkanVzdF9BVEgoZ2ZjKSB7XG4gICAgICAgIHZhciBncjJfbWF4LCBtYXhfcG93O1xuXG4gICAgICAgIGlmIChnZmMuQVRILnVzZUFkanVzdCA9PSAwKSB7XG4gICAgICAgICAgICBnZmMuQVRILmFkanVzdCA9IDEuMDtcbiAgICAgICAgICAgIC8qIG5vIGFkanVzdG1lbnQgKi9cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGpkIC0gMjAwMSBtYXIgMTIsIDI3LCBqdW4gMzAgKi9cbiAgICAgICAgLyogbG91ZG5lc3MgYmFzZWQgb24gZXF1YWwgbG91ZG5lc3MgY3VydmU7ICovXG4gICAgICAgIC8qIHVzZSBncmFudWxlIHdpdGggbWF4aW11bSBjb21iaW5lZCBsb3VkbmVzcyAqL1xuICAgICAgICBtYXhfcG93ID0gZ2ZjLmxvdWRuZXNzX3NxWzBdWzBdO1xuICAgICAgICBncjJfbWF4ID0gZ2ZjLmxvdWRuZXNzX3NxWzFdWzBdO1xuICAgICAgICBpZiAoZ2ZjLmNoYW5uZWxzX291dCA9PSAyKSB7XG4gICAgICAgICAgICBtYXhfcG93ICs9IGdmYy5sb3VkbmVzc19zcVswXVsxXTtcbiAgICAgICAgICAgIGdyMl9tYXggKz0gZ2ZjLmxvdWRuZXNzX3NxWzFdWzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWF4X3BvdyArPSBtYXhfcG93O1xuICAgICAgICAgICAgZ3IyX21heCArPSBncjJfbWF4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZmMubW9kZV9nciA9PSAyKSB7XG4gICAgICAgICAgICBtYXhfcG93ID0gTWF0aC5tYXgobWF4X3BvdywgZ3IyX21heCk7XG4gICAgICAgIH1cbiAgICAgICAgbWF4X3BvdyAqPSAwLjU7XG4gICAgICAgIC8qIG1heF9wb3cgYXBwcm9hY2hlcyAxLjAgZm9yIGZ1bGwgYmFuZCBub2lzZSAqL1xuXG4gICAgICAgIC8qIGpkIC0gMjAwMSBtYXIgMzEsIGp1biAzMCAqL1xuICAgICAgICAvKiB1c2VyIHR1bmluZyBvZiBBVEggYWRqdXN0bWVudCByZWdpb24gKi9cbiAgICAgICAgbWF4X3BvdyAqPSBnZmMuQVRILmFhU2Vuc2l0aXZpdHlQO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIGFkanVzdCBBVEggZGVwZW5kaW5nIG9uIHJhbmdlIG9mIG1heGltdW0gdmFsdWVcbiAgICAgICAgICovXG5cbiAgICAgICAgLyogamQgLSAyMDAxIGZlYjI3LCBtYXIxMiwyMCwganVuMzAsIGp1bDIyICovXG4gICAgICAgIC8qIGNvbnRpbnVvdXMgY3VydmVzIGJhc2VkIG9uIGFwcHJveGltYXRpb24gKi9cbiAgICAgICAgLyogdG8gR0IncyBvcmlnaW5hbCB2YWx1ZXMuICovXG4gICAgICAgIC8qIEZvciBhbiBpbmNyZWFzZSBpbiBhcHByb3hpbWF0ZSBsb3VkbmVzcywgKi9cbiAgICAgICAgLyogc2V0IEFUSCBhZGp1c3QgdG8gYWRqdXN0X2xpbWl0IGltbWVkaWF0ZWx5ICovXG4gICAgICAgIC8qIGFmdGVyIGEgZGVsYXkgb2Ygb25lIGZyYW1lLiAqL1xuICAgICAgICAvKiBGb3IgYSBsb3VkbmVzcyBkZWNyZWFzZSwgcmVkdWNlIEFUSCBhZGp1c3QgKi9cbiAgICAgICAgLyogdG93YXJkcyBhZGp1c3RfbGltaXQgZ3JhZHVhbGx5LiAqL1xuICAgICAgICAvKiBtYXhfcG93IGlzIGEgbG91ZG5lc3Mgc3F1YXJlZCBvciBhIHBvd2VyLiAqL1xuICAgICAgICBpZiAobWF4X3BvdyA+IDAuMDMxMjUpIHsgLyogKCgxIC0gMC4wMDA2MjUpLyAzMS45OCkgZnJvbSBjdXJ2ZSBiZWxvdyAqL1xuICAgICAgICAgICAgaWYgKGdmYy5BVEguYWRqdXN0ID49IDEuMCkge1xuICAgICAgICAgICAgICAgIGdmYy5BVEguYWRqdXN0ID0gMS4wO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKiBwcmVjZWRpbmcgZnJhbWUgaGFzIGxvd2VyIEFUSCBhZGp1c3Q7ICovXG4gICAgICAgICAgICAgICAgLyogYXNjZW5kIG9ubHkgdG8gdGhlIHByZWNlZGluZyBhZGp1c3RfbGltaXQgKi9cbiAgICAgICAgICAgICAgICAvKiBpbiBjYXNlIHRoZXJlIGlzIGxlYWRpbmcgbG93IHZvbHVtZSAqL1xuICAgICAgICAgICAgICAgIGlmIChnZmMuQVRILmFkanVzdCA8IGdmYy5BVEguYWRqdXN0TGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2ZjLkFUSC5hZGp1c3QgPSBnZmMuQVRILmFkanVzdExpbWl0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdmYy5BVEguYWRqdXN0TGltaXQgPSAxLjA7XG4gICAgICAgIH0gZWxzZSB7IC8qIGFkanVzdG1lbnQgY3VydmUgKi9cbiAgICAgICAgICAgIC8qIGFib3V0IDMyIGRCIG1heGltdW0gYWRqdXN0ICgwLjAwMDYyNSkgKi9cbiAgICAgICAgICAgIHZhciBhZGpfbGltX25ldyA9IDMxLjk4ICogbWF4X3BvdyArIDAuMDAwNjI1O1xuICAgICAgICAgICAgaWYgKGdmYy5BVEguYWRqdXN0ID49IGFkal9saW1fbmV3KSB7IC8qIGRlc2NlbmQgZ3JhZHVhbGx5ICovXG4gICAgICAgICAgICAgICAgZ2ZjLkFUSC5hZGp1c3QgKj0gYWRqX2xpbV9uZXcgKiAwLjA3NSArIDAuOTI1O1xuICAgICAgICAgICAgICAgIGlmIChnZmMuQVRILmFkanVzdCA8IGFkal9saW1fbmV3KSB7IC8qIHN0b3AgZGVzY2VudCAqL1xuICAgICAgICAgICAgICAgICAgICBnZmMuQVRILmFkanVzdCA9IGFkal9saW1fbmV3O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7IC8qIGFzY2VuZCAqL1xuICAgICAgICAgICAgICAgIGlmIChnZmMuQVRILmFkanVzdExpbWl0ID49IGFkal9saW1fbmV3KSB7XG4gICAgICAgICAgICAgICAgICAgIGdmYy5BVEguYWRqdXN0ID0gYWRqX2xpbV9uZXc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLyogcHJlY2VkaW5nIGZyYW1lIGhhcyBsb3dlciBBVEggYWRqdXN0OyAqL1xuICAgICAgICAgICAgICAgICAgICAvKiBhc2NlbmQgb25seSB0byB0aGUgcHJlY2VkaW5nIGFkanVzdF9saW1pdCAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2ZjLkFUSC5hZGp1c3QgPCBnZmMuQVRILmFkanVzdExpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZmMuQVRILmFkanVzdCA9IGdmYy5BVEguYWRqdXN0TGltaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZmMuQVRILmFkanVzdExpbWl0ID0gYWRqX2xpbV9uZXc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiA8UFJFPlxuICAgICAqICBzb21lIHNpbXBsZSBzdGF0aXN0aWNzXG4gICAgICpcbiAgICAgKiAgYml0cmF0ZSBpbmRleCAwOiBmcmVlIGJpdHJhdGUgLiBub3QgYWxsb3dlZCBpbiBWQlIgbW9kZVxuICAgICAqICA6IGJpdHJhdGVzLCBrYnBzIGRlcGVuZGluZyBvbiBNUEVHIHZlcnNpb25cbiAgICAgKiAgYml0cmF0ZSBpbmRleCAxNTogZm9yYmlkZGVuXG4gICAgICpcbiAgICAgKiAgbW9kZV9leHQ6XG4gICAgICogIDA6ICBMUlxuICAgICAqICAxOiAgTFItaVxuICAgICAqICAyOiAgTVNcbiAgICAgKiAgMzogIE1TLWlcbiAgICAgKiA8L1BSRT5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVTdGF0cyhnZmMpIHtcbiAgICAgICAgdmFyIGdyLCBjaDtcbiAgICAgICAgYXNzZXJ0KDAgPD0gZ2ZjLmJpdHJhdGVfaW5kZXggJiYgZ2ZjLmJpdHJhdGVfaW5kZXggPCAxNik7XG4gICAgICAgIGFzc2VydCgwIDw9IGdmYy5tb2RlX2V4dCAmJiBnZmMubW9kZV9leHQgPCA0KTtcblxuICAgICAgICAvKiBjb3VudCBiaXRyYXRlIGluZGljZXMgKi9cbiAgICAgICAgZ2ZjLmJpdHJhdGVfc3RlcmVvTW9kZV9IaXN0W2dmYy5iaXRyYXRlX2luZGV4XVs0XSsrO1xuICAgICAgICBnZmMuYml0cmF0ZV9zdGVyZW9Nb2RlX0hpc3RbMTVdWzRdKys7XG5cbiAgICAgICAgLyogY291bnQgJ2VtIGZvciBldmVyeSBtb2RlIGV4dGVuc2lvbiBpbiBjYXNlIG9mIDIgY2hhbm5lbCBlbmNvZGluZyAqL1xuICAgICAgICBpZiAoZ2ZjLmNoYW5uZWxzX291dCA9PSAyKSB7XG4gICAgICAgICAgICBnZmMuYml0cmF0ZV9zdGVyZW9Nb2RlX0hpc3RbZ2ZjLmJpdHJhdGVfaW5kZXhdW2dmYy5tb2RlX2V4dF0rKztcbiAgICAgICAgICAgIGdmYy5iaXRyYXRlX3N0ZXJlb01vZGVfSGlzdFsxNV1bZ2ZjLm1vZGVfZXh0XSsrO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoZ3IgPSAwOyBnciA8IGdmYy5tb2RlX2dyOyArK2dyKSB7XG4gICAgICAgICAgICBmb3IgKGNoID0gMDsgY2ggPCBnZmMuY2hhbm5lbHNfb3V0OyArK2NoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ0ID0gZ2ZjLmwzX3NpZGUudHRbZ3JdW2NoXS5ibG9ja190eXBlIHwgMDtcbiAgICAgICAgICAgICAgICBpZiAoZ2ZjLmwzX3NpZGUudHRbZ3JdW2NoXS5taXhlZF9ibG9ja19mbGFnICE9IDApXG4gICAgICAgICAgICAgICAgICAgIGJ0ID0gNDtcbiAgICAgICAgICAgICAgICBnZmMuYml0cmF0ZV9ibG9ja1R5cGVfSGlzdFtnZmMuYml0cmF0ZV9pbmRleF1bYnRdKys7XG4gICAgICAgICAgICAgICAgZ2ZjLmJpdHJhdGVfYmxvY2tUeXBlX0hpc3RbZ2ZjLmJpdHJhdGVfaW5kZXhdWzVdKys7XG4gICAgICAgICAgICAgICAgZ2ZjLmJpdHJhdGVfYmxvY2tUeXBlX0hpc3RbMTVdW2J0XSsrO1xuICAgICAgICAgICAgICAgIGdmYy5iaXRyYXRlX2Jsb2NrVHlwZV9IaXN0WzE1XVs1XSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGFtZV9lbmNvZGVfZnJhbWVfaW5pdChnZnAsIGluYnVmKSB7XG4gICAgICAgIHZhciBnZmMgPSBnZnAuaW50ZXJuYWxfZmxhZ3M7XG5cbiAgICAgICAgdmFyIGNoLCBncjtcblxuICAgICAgICBpZiAoZ2ZjLmxhbWVfZW5jb2RlX2ZyYW1lX2luaXQgPT0gMCkge1xuICAgICAgICAgICAgLyogcHJpbWUgdGhlIE1EQ1QvcG9seXBoYXNlIGZpbHRlcmJhbmsgd2l0aCBhIHNob3J0IGJsb2NrICovXG4gICAgICAgICAgICB2YXIgaSwgajtcbiAgICAgICAgICAgIHZhciBwcmltZWJ1ZmYwID0gbmV3X2Zsb2F0KDI4NiArIDExNTIgKyA1NzYpO1xuICAgICAgICAgICAgdmFyIHByaW1lYnVmZjEgPSBuZXdfZmxvYXQoMjg2ICsgMTE1MiArIDU3Nik7XG4gICAgICAgICAgICBnZmMubGFtZV9lbmNvZGVfZnJhbWVfaW5pdCA9IDE7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IDI4NiArIDU3NiAqICgxICsgZ2ZjLm1vZGVfZ3IpOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA8IDU3NiAqIGdmYy5tb2RlX2dyKSB7XG4gICAgICAgICAgICAgICAgICAgIHByaW1lYnVmZjBbaV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2ZjLmNoYW5uZWxzX291dCA9PSAyKVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWVidWZmMVtpXSA9IDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpbWVidWZmMFtpXSA9IGluYnVmWzBdW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2ZjLmNoYW5uZWxzX291dCA9PSAyKVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWVidWZmMVtpXSA9IGluYnVmWzFdW2pdO1xuICAgICAgICAgICAgICAgICAgICArK2o7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogcG9seXBoYXNlIGZpbHRlcmluZyAvIG1kY3QgKi9cbiAgICAgICAgICAgIGZvciAoZ3IgPSAwOyBnciA8IGdmYy5tb2RlX2dyOyBncisrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjaCA9IDA7IGNoIDwgZ2ZjLmNoYW5uZWxzX291dDsgY2grKykge1xuICAgICAgICAgICAgICAgICAgICBnZmMubDNfc2lkZS50dFtncl1bY2hdLmJsb2NrX3R5cGUgPSBFbmNvZGVyLlNIT1JUX1RZUEU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3TURDVC5tZGN0X3N1YjQ4KGdmYywgcHJpbWVidWZmMCwgcHJpbWVidWZmMSk7XG5cbiAgICAgICAgICAgIC8qIGNoZWNrIEZGVCB3aWxsIG5vdCB1c2UgYSBuZWdhdGl2ZSBzdGFydGluZyBvZmZzZXQgKi9cbiAgICAgICAgICAgIGFzc2VydCg1NzYgPj0gRW5jb2Rlci5GRlRPRkZTRVQpO1xuICAgICAgICAgICAgLyogY2hlY2sgaWYgd2UgaGF2ZSBlbm91Z2ggZGF0YSBmb3IgRkZUICovXG4gICAgICAgICAgICBhc3NlcnQoZ2ZjLm1mX3NpemUgPj0gKEVuY29kZXIuQkxLU0laRSArIGdmcC5mcmFtZXNpemUgLSBFbmNvZGVyLkZGVE9GRlNFVCkpO1xuICAgICAgICAgICAgLyogY2hlY2sgaWYgd2UgaGF2ZSBlbm91Z2ggZGF0YSBmb3IgcG9seXBoYXNlIGZpbHRlcmJhbmsgKi9cbiAgICAgICAgICAgIGFzc2VydChnZmMubWZfc2l6ZSA+PSAoNTEyICsgZ2ZwLmZyYW1lc2l6ZSAtIDMyKSk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIDxQUkU+XG4gICAgICogZW5jb2RlZnJhbWUoKSAgICAgICAgICAgTGF5ZXIgM1xuICAgICAqXG4gICAgICogZW5jb2RlIGEgc2luZ2xlIGZyYW1lXG4gICAgICpcbiAgICAgKlxuICAgICAqICAgIGxhbWVfZW5jb2RlX2ZyYW1lKClcbiAgICAgKlxuICAgICAqXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBnciAwICAgICAgICAgICAgZ3IgMVxuICAgICAqICAgIGluYnVmOiAgICAgICAgICAgfC0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tfFxuICAgICAqXG4gICAgICpcbiAgICAgKiAgICBQb2x5cGhhc2UgKDE4IHdpbmRvd3MsIGVhY2ggc2hpZnRlZCAzMilcbiAgICAgKiAgICBnciAwOlxuICAgICAqICAgIHdpbmRvdzEgICAgICAgICAgPC0tLS01MTItLS0uXG4gICAgICogICAgd2luZG93MTggICAgICAgICAgICAgICAgIDwtLS0tNTEyLS0tLlxuICAgICAqXG4gICAgICogICAgZ3IgMTpcbiAgICAgKiAgICB3aW5kb3cxICAgICAgICAgICAgICAgICAgICAgICAgIDwtLS0tNTEyLS0tLlxuICAgICAqICAgIHdpbmRvdzE4ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8LS0tLTUxMi0tLS5cbiAgICAgKlxuICAgICAqXG4gICAgICpcbiAgICAgKiAgICBNRENUIG91dHB1dDogIHwtLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLXxcbiAgICAgKlxuICAgICAqICAgIEZGVCdzICAgICAgICAgICAgICAgICAgICA8LS0tLS0tLS0tMTAyNC0tLS0tLS0tLS5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwtLS0tLS0tLS0xMDI0LS0tLS0tLS5cbiAgICAgKlxuICAgICAqXG4gICAgICpcbiAgICAgKiAgICAgICAgaW5idWYgPSBidWZmZXIgb2YgUENNIGRhdGEgc2l6ZT1NUDMgZnJhbWVzaXplXG4gICAgICogICAgICAgIGVuY29kZXIgYWN0cyBvbiBpbmJ1ZltjaF1bMF0sIGJ1dCBvdXRwdXQgaXMgZGVsYXllZCBieSBNRENUREVMQVlcbiAgICAgKiAgICAgICAgc28gdGhlIE1EQ1QgY29lZmZpY2ludHMgYXJlIGZyb20gaW5idWZbY2hdWy1NRENUREVMQVldXG4gICAgICpcbiAgICAgKiAgICAgICAgcHN5LW1vZGVsIEZGVCBoYXMgYSAxIGdyYW51bGUgZGVsYXksIHNvIHdlIGZlZWQgaXQgZGF0YSBmb3IgdGhlXG4gICAgICogICAgICAgIG5leHQgZ3JhbnVsZS5cbiAgICAgKiAgICAgICAgRkZUIGlzIGNlbnRlcmVkIG92ZXIgZ3JhbnVsZTogIDIyNCs1NzYrMjI0XG4gICAgICogICAgICAgIFNvIEZGVCBzdGFydHMgYXQ6ICAgNTc2LTIyNC1NRENUREVMQVlcbiAgICAgKlxuICAgICAqICAgICAgICBNUEVHMjogIEZGVCBlbmRzIGF0OiAgQkxLU0laRSs1NzYtMjI0LU1EQ1RERUxBWSAgICAgICgxMzI4KVxuICAgICAqICAgICAgICBNUEVHMTogIEZGVCBlbmRzIGF0OiAgQkxLU0laRSsyKjU3Ni0yMjQtTURDVERFTEFZICAgICgxOTA0KVxuICAgICAqXG4gICAgICogICAgICAgIE1QRUcyOiAgcG9seXBoYXNlIGZpcnN0IHdpbmRvdzogIFswLi41MTFdXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIDE4dGggd2luZG93OiAgIFs1NDQuLjEwNTVdICAgICAgICAgICgxMDU2KVxuICAgICAqICAgICAgICBNUEVHMTogICAgICAgICAgICAzNnRoIHdpbmRvdzogICBbMTEyMC4uMTYzMV0gICAgICAgICAoMTYzMilcbiAgICAgKiAgICAgICAgICAgICAgICBkYXRhIG5lZWRlZDogIDUxMitmcmFtZXNpemUtMzJcbiAgICAgKlxuICAgICAqICAgICAgICBBIGNsb3NlIGxvb2sgbmV3bWRjdC5jIHNob3dzIHRoYXQgdGhlIHBvbHlwaGFzZSBmaWx0ZXJiYW5rXG4gICAgICogICAgICAgIG9ubHkgdXNlcyBkYXRhIGZyb20gWzAuLjUxMF0gZm9yIGVhY2ggd2luZG93LiAgUGVyaGFwcyBiZWNhdXNlIHRoZSB3aW5kb3dcbiAgICAgKiAgICAgICAgdXNlZCBieSB0aGUgZmlsdGVyYmFuayBpcyB6ZXJvIGZvciB0aGUgbGFzdCBwb2ludCwgc28gVGFrZWhpcm8nc1xuICAgICAqICAgICAgICBjb2RlIGRvZXNuJ3QgYm90aGVyIHRvIGNvbXB1dGUgd2l0aCBpdC5cbiAgICAgKlxuICAgICAqICAgICAgICBGRlQgc3RhcnRzIGF0IDU3Ni0yMjQtTURDVERFTEFZICgzMDQpICA9IDU3Ni1GRlRPRkZTRVRcbiAgICAgKlxuICAgICAqIDwvUFJFPlxuICAgICAqL1xuXG5cbiAgICB0aGlzLmxhbWVfZW5jb2RlX21wM19mcmFtZSA9IGZ1bmN0aW9uIChnZnAsIGluYnVmX2wsIGluYnVmX3IsIG1wM2J1ZiwgbXAzYnVmUG9zLCBtcDNidWZfc2l6ZSkge1xuICAgICAgICB2YXIgbXAzY291bnQ7XG4gICAgICAgIHZhciBtYXNraW5nX0xSID0gbmV3X2FycmF5X24oWzIsIDJdKTtcbiAgICAgICAgLypcbiAgICAgICAgICogTFIgbWFza2luZyAmXG4gICAgICAgICAqIGVuZXJneVxuICAgICAgICAgKi9cbiAgICAgICAgbWFza2luZ19MUlswXVswXSA9IG5ldyBJSUlfcHN5X3JhdGlvKCk7XG4gICAgICAgIG1hc2tpbmdfTFJbMF1bMV0gPSBuZXcgSUlJX3BzeV9yYXRpbygpO1xuICAgICAgICBtYXNraW5nX0xSWzFdWzBdID0gbmV3IElJSV9wc3lfcmF0aW8oKTtcbiAgICAgICAgbWFza2luZ19MUlsxXVsxXSA9IG5ldyBJSUlfcHN5X3JhdGlvKCk7XG4gICAgICAgIHZhciBtYXNraW5nX01TID0gbmV3X2FycmF5X24oWzIsIDJdKTtcbiAgICAgICAgLyogTVMgbWFza2luZyAmIGVuZXJneSAqL1xuICAgICAgICBtYXNraW5nX01TWzBdWzBdID0gbmV3IElJSV9wc3lfcmF0aW8oKTtcbiAgICAgICAgbWFza2luZ19NU1swXVsxXSA9IG5ldyBJSUlfcHN5X3JhdGlvKCk7XG4gICAgICAgIG1hc2tpbmdfTVNbMV1bMF0gPSBuZXcgSUlJX3BzeV9yYXRpbygpO1xuICAgICAgICBtYXNraW5nX01TWzFdWzFdID0gbmV3IElJSV9wc3lfcmF0aW8oKTtcbiAgICAgICAgLy9JSUlfcHN5X3JhdGlvIG1hc2tpbmdbXVtdO1xuICAgICAgICB2YXIgbWFza2luZztcbiAgICAgICAgLyogcG9pbnRlciB0byBzZWxlY3RlZCBtYXNraW5ncyAqL1xuICAgICAgICB2YXIgaW5idWYgPSBbbnVsbCwgbnVsbF07XG4gICAgICAgIHZhciBnZmMgPSBnZnAuaW50ZXJuYWxfZmxhZ3M7XG5cbiAgICAgICAgdmFyIHRvdF9lbmVyID0gbmV3X2Zsb2F0X24oWzIsIDRdKTtcbiAgICAgICAgdmFyIG1zX2VuZXJfcmF0aW8gPSBbLjUsIC41XTtcbiAgICAgICAgdmFyIHBlID0gW1swLiwgMC5dLCBbMC4sIDAuXV07XG4gICAgICAgIHZhciBwZV9NUyA9IFtbMC4sIDAuXSwgWzAuLCAwLl1dO1xuXG4vL2Zsb2F0W11bXSBwZV91c2U7XG4gICAgICAgIHZhciBwZV91c2U7XG5cbiAgICAgICAgdmFyIGNoLCBncjtcblxuICAgICAgICBpbmJ1ZlswXSA9IGluYnVmX2w7XG4gICAgICAgIGluYnVmWzFdID0gaW5idWZfcjtcblxuICAgICAgICBpZiAoZ2ZjLmxhbWVfZW5jb2RlX2ZyYW1lX2luaXQgPT0gMCkge1xuICAgICAgICAgICAgLyogZmlyc3QgcnVuPyAqL1xuICAgICAgICAgICAgbGFtZV9lbmNvZGVfZnJhbWVfaW5pdChnZnAsIGluYnVmKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKiogcGFkZGluZyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxQUkU+XG4gICAgICAgICAqIHBhZGRpbmcgbWV0aG9kIGFzIGRlc2NyaWJlZCBpblxuICAgICAgICAgKiBcIk1QRUctTGF5ZXIzIC8gQml0c3RyZWFtIFN5bnRheCBhbmQgRGVjb2RpbmdcIlxuICAgICAgICAgKiBieSBNYXJ0aW4gU2llbGVyLCBSYWxwaCBTcGVyc2NobmVpZGVyXG4gICAgICAgICAqXG4gICAgICAgICAqIG5vdGU6IHRoZXJlIGlzIG5vIHBhZGRpbmcgZm9yIHRoZSB2ZXJ5IGZpcnN0IGZyYW1lXG4gICAgICAgICAqXG4gICAgICAgICAqIFJvYmVydCBIZWdlbWFubiAyMDAwLTA2LTIyXG4gICAgICAgICAqIDwvUFJFPlxuICAgICAgICAgKi9cbiAgICAgICAgZ2ZjLnBhZGRpbmcgPSAwO1xuICAgICAgICBpZiAoKGdmYy5zbG90X2xhZyAtPSBnZmMuZnJhY19TcEYpIDwgMCkge1xuICAgICAgICAgICAgZ2ZjLnNsb3RfbGFnICs9IGdmcC5vdXRfc2FtcGxlcmF0ZTtcbiAgICAgICAgICAgIGdmYy5wYWRkaW5nID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICAqIFN0YWdlIDE6IHBzeWNob2Fjb3VzdGljIG1vZGVsICpcbiAgICAgICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgaWYgKGdmYy5wc3ltb2RlbCAhPSAwKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogcHN5Y2hvYWNvdXN0aWMgbW9kZWwgcHN5IG1vZGVsIGhhcyBhIDEgZ3JhbnVsZSAoNTc2KSBkZWxheSB0aGF0XG4gICAgICAgICAgICAgKiB3ZSBtdXN0IGNvbXBlbnNhdGUgZm9yIChtdCA2Lzk5KS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIHJldDtcbiAgICAgICAgICAgIHZhciBidWZwID0gW251bGwsIG51bGxdO1xuICAgICAgICAgICAgLyogYWRkcmVzcyBvZiBiZWdpbm5pbmcgb2YgbGVmdCAmIHJpZ2h0IGdyYW51bGUgKi9cbiAgICAgICAgICAgIHZhciBidWZwUG9zID0gMDtcbiAgICAgICAgICAgIC8qIGFkZHJlc3Mgb2YgYmVnaW5uaW5nIG9mIGxlZnQgJiByaWdodCBncmFudWxlICovXG4gICAgICAgICAgICB2YXIgYmxvY2t0eXBlID0gbmV3X2ludCgyKTtcblxuICAgICAgICAgICAgZm9yIChnciA9IDA7IGdyIDwgZ2ZjLm1vZGVfZ3I7IGdyKyspIHtcblxuICAgICAgICAgICAgICAgIGZvciAoY2ggPSAwOyBjaCA8IGdmYy5jaGFubmVsc19vdXQ7IGNoKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmcFtjaF0gPSBpbmJ1ZltjaF07XG4gICAgICAgICAgICAgICAgICAgIGJ1ZnBQb3MgPSA1NzYgKyBnciAqIDU3NiAtIEVuY29kZXIuRkZUT0ZGU0VUO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZ2ZwLlZCUiA9PSBWYnJNb2RlLnZicl9tdHJoIHx8IGdmcC5WQlIgPT0gVmJyTW9kZS52YnJfbXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gcHN5LkwzcHN5Y2hvX2FuYWxfdmJyKGdmcCwgYnVmcCwgYnVmcFBvcywgZ3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNraW5nX0xSLCBtYXNraW5nX01TLCBwZVtncl0sIHBlX01TW2dyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdF9lbmVyW2dyXSwgYmxvY2t0eXBlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXQgPSBwc3kuTDNwc3ljaG9fYW5hbF9ucyhnZnAsIGJ1ZnAsIGJ1ZnBQb3MsIGdyLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFza2luZ19MUiwgbWFza2luZ19NUywgcGVbZ3JdLCBwZV9NU1tncl0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RfZW5lcltncl0sIGJsb2NrdHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXQgIT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC00O1xuXG4gICAgICAgICAgICAgICAgaWYgKGdmcC5tb2RlID09IE1QRUdNb2RlLkpPSU5UX1NURVJFTykge1xuICAgICAgICAgICAgICAgICAgICBtc19lbmVyX3JhdGlvW2dyXSA9IHRvdF9lbmVyW2dyXVsyXSArIHRvdF9lbmVyW2dyXVszXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1zX2VuZXJfcmF0aW9bZ3JdID4gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zX2VuZXJfcmF0aW9bZ3JdID0gdG90X2VuZXJbZ3JdWzNdIC8gbXNfZW5lcl9yYXRpb1tncl07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLyogYmxvY2sgdHlwZSBmbGFncyAqL1xuICAgICAgICAgICAgICAgIGZvciAoY2ggPSAwOyBjaCA8IGdmYy5jaGFubmVsc19vdXQ7IGNoKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvZF9pbmZvID0gZ2ZjLmwzX3NpZGUudHRbZ3JdW2NoXTtcbiAgICAgICAgICAgICAgICAgICAgY29kX2luZm8uYmxvY2tfdHlwZSA9IGJsb2NrdHlwZVtjaF07XG4gICAgICAgICAgICAgICAgICAgIGNvZF9pbmZvLm1peGVkX2Jsb2NrX2ZsYWcgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8qIG5vIHBzeSBtb2RlbCAqL1xuICAgICAgICAgICAgZm9yIChnciA9IDA7IGdyIDwgZ2ZjLm1vZGVfZ3I7IGdyKyspXG4gICAgICAgICAgICAgICAgZm9yIChjaCA9IDA7IGNoIDwgZ2ZjLmNoYW5uZWxzX291dDsgY2grKykge1xuICAgICAgICAgICAgICAgICAgICBnZmMubDNfc2lkZS50dFtncl1bY2hdLmJsb2NrX3R5cGUgPSBFbmNvZGVyLk5PUk1fVFlQRTtcbiAgICAgICAgICAgICAgICAgICAgZ2ZjLmwzX3NpZGUudHRbZ3JdW2NoXS5taXhlZF9ibG9ja19mbGFnID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcGVfTVNbZ3JdW2NoXSA9IHBlW2dyXVtjaF0gPSA3MDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyogYXV0by1hZGp1c3Qgb2YgQVRILCB1c2VmdWwgZm9yIGxvdyB2b2x1bWUgKi9cbiAgICAgICAgYWRqdXN0X0FUSChnZmMpO1xuXG4gICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICAqIFN0YWdlIDI6IE1EQ1QgKlxuICAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiBwb2x5cGhhc2UgZmlsdGVyaW5nIC8gbWRjdCAqL1xuICAgICAgICBuZXdNRENULm1kY3Rfc3ViNDgoZ2ZjLCBpbmJ1ZlswXSwgaW5idWZbMV0pO1xuXG4gICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICAqIFN0YWdlIDM6IE1TL0xSIGRlY2lzaW9uICpcbiAgICAgICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyogSGVyZSB3aWxsIGJlIHNlbGVjdGVkIE1TIG9yIExSIGNvZGluZyBvZiB0aGUgMiBzdGVyZW8gY2hhbm5lbHMgKi9cbiAgICAgICAgZ2ZjLm1vZGVfZXh0ID0gRW5jb2Rlci5NUEdfTURfTFJfTFI7XG5cbiAgICAgICAgaWYgKGdmcC5mb3JjZV9tcykge1xuICAgICAgICAgICAgZ2ZjLm1vZGVfZXh0ID0gRW5jb2Rlci5NUEdfTURfTVNfTFI7XG4gICAgICAgIH0gZWxzZSBpZiAoZ2ZwLm1vZGUgPT0gTVBFR01vZGUuSk9JTlRfU1RFUkVPKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogbXNfcmF0aW8gPSBpcyBzY2FsZWQsIGZvciBoaXN0b3JpY2FsIHJlYXNvbnMsIHRvIGxvb2sgbGlrZSBhXG4gICAgICAgICAgICAgKiByYXRpbyBvZiBzaWRlX2NoYW5uZWwgLyB0b3RhbC4gMCA9IHNpZ25hbCBpcyAxMDAlIG1vbm8gLjUgPSBMICYgUlxuICAgICAgICAgICAgICogdW5jb3JyZWxhdGVkXG4gICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiA8UFJFPlxuICAgICAgICAgICAgICogWzBdIGFuZCBbMV0gYXJlIHRoZSByZXN1bHRzIGZvciB0aGUgdHdvIGdyYW51bGVzIGluIE1QRUctMSxcbiAgICAgICAgICAgICAqIGluIE1QRUctMiBpdCdzIG9ubHkgYSBmYWtlZCBhdmVyYWdpbmcgb2YgdGhlIHNhbWUgdmFsdWVcbiAgICAgICAgICAgICAqIF9wcmV2IGlzIHRoZSB2YWx1ZSBvZiB0aGUgbGFzdCBncmFudWxlIG9mIHRoZSBwcmV2aW91cyBmcmFtZVxuICAgICAgICAgICAgICogX25leHQgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBncmFudWxlIG9mIHRoZSBuZXh0IGZyYW1lXG4gICAgICAgICAgICAgKiA8L1BSRT5cbiAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB2YXIgc3VtX3BlX01TID0gMC47XG4gICAgICAgICAgICB2YXIgc3VtX3BlX0xSID0gMC47XG4gICAgICAgICAgICBmb3IgKGdyID0gMDsgZ3IgPCBnZmMubW9kZV9ncjsgZ3IrKykge1xuICAgICAgICAgICAgICAgIGZvciAoY2ggPSAwOyBjaCA8IGdmYy5jaGFubmVsc19vdXQ7IGNoKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtX3BlX01TICs9IHBlX01TW2dyXVtjaF07XG4gICAgICAgICAgICAgICAgICAgIHN1bV9wZV9MUiArPSBwZVtncl1bY2hdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyogYmFzZWQgb24gUEU6IE0vUyBjb2Rpbmcgd291bGQgbm90IHVzZSBtdWNoIG1vcmUgYml0cyB0aGFuIEwvUiAqL1xuICAgICAgICAgICAgaWYgKHN1bV9wZV9NUyA8PSAxLjAwICogc3VtX3BlX0xSKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgZ2kwID0gZ2ZjLmwzX3NpZGUudHRbMF07XG4gICAgICAgICAgICAgICAgdmFyIGdpMSA9IGdmYy5sM19zaWRlLnR0W2dmYy5tb2RlX2dyIC0gMV07XG5cbiAgICAgICAgICAgICAgICBpZiAoZ2kwWzBdLmJsb2NrX3R5cGUgPT0gZ2kwWzFdLmJsb2NrX3R5cGVcbiAgICAgICAgICAgICAgICAgICAgJiYgZ2kxWzBdLmJsb2NrX3R5cGUgPT0gZ2kxWzFdLmJsb2NrX3R5cGUpIHtcblxuICAgICAgICAgICAgICAgICAgICBnZmMubW9kZV9leHQgPSBFbmNvZGVyLk1QR19NRF9NU19MUjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiBiaXQgYW5kIG5vaXNlIGFsbG9jYXRpb24gKi9cbiAgICAgICAgaWYgKGdmYy5tb2RlX2V4dCA9PSBNUEdfTURfTVNfTFIpIHtcbiAgICAgICAgICAgIG1hc2tpbmcgPSBtYXNraW5nX01TO1xuICAgICAgICAgICAgLyogdXNlIE1TIG1hc2tpbmcgKi9cbiAgICAgICAgICAgIHBlX3VzZSA9IHBlX01TO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFza2luZyA9IG1hc2tpbmdfTFI7XG4gICAgICAgICAgICAvKiB1c2UgTFIgbWFza2luZyAqL1xuICAgICAgICAgICAgcGVfdXNlID0gcGU7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBjb3B5IGRhdGEgZm9yIE1QMyBmcmFtZSBhbmFseXplciAqL1xuICAgICAgICBpZiAoZ2ZwLmFuYWx5c2lzICYmIGdmYy5waW5mbyAhPSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGdyID0gMDsgZ3IgPCBnZmMubW9kZV9ncjsgZ3IrKykge1xuICAgICAgICAgICAgICAgIGZvciAoY2ggPSAwOyBjaCA8IGdmYy5jaGFubmVsc19vdXQ7IGNoKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZ2ZjLnBpbmZvLm1zX3JhdGlvW2dyXSA9IGdmYy5tc19yYXRpb1tncl07XG4gICAgICAgICAgICAgICAgICAgIGdmYy5waW5mby5tc19lbmVyX3JhdGlvW2dyXSA9IG1zX2VuZXJfcmF0aW9bZ3JdO1xuICAgICAgICAgICAgICAgICAgICBnZmMucGluZm8uYmxvY2t0eXBlW2dyXVtjaF0gPSBnZmMubDNfc2lkZS50dFtncl1bY2hdLmJsb2NrX3R5cGU7XG4gICAgICAgICAgICAgICAgICAgIGdmYy5waW5mby5wZVtncl1bY2hdID0gcGVfdXNlW2dyXVtjaF07XG4gICAgICAgICAgICAgICAgICAgIFN5c3RlbS5hcnJheWNvcHkoZ2ZjLmwzX3NpZGUudHRbZ3JdW2NoXS54ciwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdmYy5waW5mby54cltncl1bY2hdLCAwLCA1NzYpO1xuICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgKiBpbiBwc3ltb2RlbCwgTFIgYW5kIE1TIGRhdGEgd2FzIHN0b3JlZCBpbiBwaW5mby4gc3dpdGNoXG4gICAgICAgICAgICAgICAgICAgICAqIHRvIE1TIGRhdGE6XG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2ZjLm1vZGVfZXh0ID09IE1QR19NRF9NU19MUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2ZjLnBpbmZvLmVyc1tncl1bY2hdID0gZ2ZjLnBpbmZvLmVyc1tncl1bY2ggKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFN5c3RlbS5hcnJheWNvcHkoZ2ZjLnBpbmZvLmVuZXJneVtncl1bY2ggKyAyXSwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZmMucGluZm8uZW5lcmd5W2dyXVtjaF0sIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2ZjLnBpbmZvLmVuZXJneVtncl1bY2hdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAgKiBTdGFnZSA0OiBxdWFudGl6YXRpb24gbG9vcCAqXG4gICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIGlmIChnZnAuVkJSID09IFZick1vZGUudmJyX29mZiB8fCBnZnAuVkJSID09IFZick1vZGUudmJyX2Ficikge1xuXG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIHZhciBmO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTg7IGkrKylcbiAgICAgICAgICAgICAgICBnZmMubnNQc3kucGVmaXJidWZbaV0gPSBnZmMubnNQc3kucGVmaXJidWZbaSArIDFdO1xuXG4gICAgICAgICAgICBmID0gMC4wO1xuICAgICAgICAgICAgZm9yIChnciA9IDA7IGdyIDwgZ2ZjLm1vZGVfZ3I7IGdyKyspXG4gICAgICAgICAgICAgICAgZm9yIChjaCA9IDA7IGNoIDwgZ2ZjLmNoYW5uZWxzX291dDsgY2grKylcbiAgICAgICAgICAgICAgICAgICAgZiArPSBwZV91c2VbZ3JdW2NoXTtcbiAgICAgICAgICAgIGdmYy5uc1BzeS5wZWZpcmJ1ZlsxOF0gPSBmO1xuXG4gICAgICAgICAgICBmID0gZ2ZjLm5zUHN5LnBlZmlyYnVmWzldO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDk7IGkrKylcbiAgICAgICAgICAgICAgICBmICs9IChnZmMubnNQc3kucGVmaXJidWZbaV0gKyBnZmMubnNQc3kucGVmaXJidWZbMTggLSBpXSlcbiAgICAgICAgICAgICAgICAgICAgKiBFbmNvZGVyLmZpcmNvZWZbaV07XG5cbiAgICAgICAgICAgIGYgPSAoNjcwICogNSAqIGdmYy5tb2RlX2dyICogZ2ZjLmNoYW5uZWxzX291dCkgLyBmO1xuICAgICAgICAgICAgZm9yIChnciA9IDA7IGdyIDwgZ2ZjLm1vZGVfZ3I7IGdyKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNoID0gMDsgY2ggPCBnZmMuY2hhbm5lbHNfb3V0OyBjaCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlX3VzZVtncl1bY2hdICo9IGY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdmYy5pdGVyYXRpb25fbG9vcC5pdGVyYXRpb25fbG9vcChnZnAsIHBlX3VzZSwgbXNfZW5lcl9yYXRpbywgbWFza2luZyk7XG5cbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgICogU3RhZ2UgNTogYml0c3RyZWFtIGZvcm1hdHRpbmcgKlxuICAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiB3cml0ZSB0aGUgZnJhbWUgdG8gdGhlIGJpdHN0cmVhbSAqL1xuICAgICAgICBicy5mb3JtYXRfYml0c3RyZWFtKGdmcCk7XG5cbiAgICAgICAgLyogY29weSBtcDMgYml0IGJ1ZmZlciBpbnRvIGFycmF5ICovXG4gICAgICAgIG1wM2NvdW50ID0gYnMuY29weV9idWZmZXIoZ2ZjLCBtcDNidWYsIG1wM2J1ZlBvcywgbXAzYnVmX3NpemUsIDEpO1xuXG4gICAgICAgIGlmIChnZnAuYldyaXRlVmJyVGFnKVxuICAgICAgICAgICAgdmJyLmFkZFZickZyYW1lKGdmcCk7XG5cbiAgICAgICAgaWYgKGdmcC5hbmFseXNpcyAmJiBnZmMucGluZm8gIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChjaCA9IDA7IGNoIDwgZ2ZjLmNoYW5uZWxzX291dDsgY2grKykge1xuICAgICAgICAgICAgICAgIHZhciBqO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBGRlRPRkZTRVQ7IGorKylcbiAgICAgICAgICAgICAgICAgICAgZ2ZjLnBpbmZvLnBjbWRhdGFbY2hdW2pdID0gZ2ZjLnBpbmZvLnBjbWRhdGFbY2hdW2pcbiAgICAgICAgICAgICAgICAgICAgKyBnZnAuZnJhbWVzaXplXTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSBGRlRPRkZTRVQ7IGogPCAxNjAwOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZ2ZjLnBpbmZvLnBjbWRhdGFbY2hdW2pdID0gaW5idWZbY2hdW2ogLSBGRlRPRkZTRVRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHF1cHZ0LnNldF9mcmFtZV9waW5mbyhnZnAsIG1hc2tpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlU3RhdHMoZ2ZjKTtcblxuICAgICAgICByZXR1cm4gbXAzY291bnQ7XG4gICAgfVxufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gRW5jb2RlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lamejs/src/js/Encoder.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lamejs/src/js/FFT.js":
/*!*******************************************!*\
  !*** ./node_modules/lamejs/src/js/FFT.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var common = __webpack_require__(/*! ./common.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/common.js\");\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\nvar Encoder = __webpack_require__(/*! ./Encoder.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/Encoder.js\");\n\nfunction FFT() {\n\n    var window = new_float(Encoder.BLKSIZE);\n    var window_s = new_float(Encoder.BLKSIZE_s / 2);\n\n    var costab = [\n        9.238795325112867e-01, 3.826834323650898e-01,\n        9.951847266721969e-01, 9.801714032956060e-02,\n        9.996988186962042e-01, 2.454122852291229e-02,\n        9.999811752826011e-01, 6.135884649154475e-03\n    ];\n\n    function fht(fz, fzPos, n) {\n        var tri = 0;\n        var k4;\n        var fi;\n        var gi;\n\n        n <<= 1;\n        /* to get BLKSIZE, because of 3DNow! ASM routine */\n        var fn = fzPos + n;\n        k4 = 4;\n        do {\n            var s1, c1;\n            var i, k1, k2, k3, kx;\n            kx = k4 >> 1;\n            k1 = k4;\n            k2 = k4 << 1;\n            k3 = k2 + k1;\n            k4 = k2 << 1;\n            fi = fzPos;\n            gi = fi + kx;\n            do {\n                var f0, f1, f2, f3;\n                f1 = fz[fi + 0] - fz[fi + k1];\n                f0 = fz[fi + 0] + fz[fi + k1];\n                f3 = fz[fi + k2] - fz[fi + k3];\n                f2 = fz[fi + k2] + fz[fi + k3];\n                fz[fi + k2] = f0 - f2;\n                fz[fi + 0] = f0 + f2;\n                fz[fi + k3] = f1 - f3;\n                fz[fi + k1] = f1 + f3;\n                f1 = fz[gi + 0] - fz[gi + k1];\n                f0 = fz[gi + 0] + fz[gi + k1];\n                f3 = (Util.SQRT2 * fz[gi + k3]);\n                f2 = (Util.SQRT2 * fz[gi + k2]);\n                fz[gi + k2] = f0 - f2;\n                fz[gi + 0] = f0 + f2;\n                fz[gi + k3] = f1 - f3;\n                fz[gi + k1] = f1 + f3;\n                gi += k4;\n                fi += k4;\n            } while (fi < fn);\n            c1 = costab[tri + 0];\n            s1 = costab[tri + 1];\n            for (i = 1; i < kx; i++) {\n                var c2, s2;\n                c2 = 1 - (2 * s1) * s1;\n                s2 = (2 * s1) * c1;\n                fi = fzPos + i;\n                gi = fzPos + k1 - i;\n                do {\n                    var a, b, g0, f0, f1, g1, f2, g2, f3, g3;\n                    b = s2 * fz[fi + k1] - c2 * fz[gi + k1];\n                    a = c2 * fz[fi + k1] + s2 * fz[gi + k1];\n                    f1 = fz[fi + 0] - a;\n                    f0 = fz[fi + 0] + a;\n                    g1 = fz[gi + 0] - b;\n                    g0 = fz[gi + 0] + b;\n                    b = s2 * fz[fi + k3] - c2 * fz[gi + k3];\n                    a = c2 * fz[fi + k3] + s2 * fz[gi + k3];\n                    f3 = fz[fi + k2] - a;\n                    f2 = fz[fi + k2] + a;\n                    g3 = fz[gi + k2] - b;\n                    g2 = fz[gi + k2] + b;\n                    b = s1 * f2 - c1 * g3;\n                    a = c1 * f2 + s1 * g3;\n                    fz[fi + k2] = f0 - a;\n                    fz[fi + 0] = f0 + a;\n                    fz[gi + k3] = g1 - b;\n                    fz[gi + k1] = g1 + b;\n                    b = c1 * g2 - s1 * f3;\n                    a = s1 * g2 + c1 * f3;\n                    fz[gi + k2] = g0 - a;\n                    fz[gi + 0] = g0 + a;\n                    fz[fi + k3] = f1 - b;\n                    fz[fi + k1] = f1 + b;\n                    gi += k4;\n                    fi += k4;\n                } while (fi < fn);\n                c2 = c1;\n                c1 = c2 * costab[tri + 0] - s1 * costab[tri + 1];\n                s1 = c2 * costab[tri + 1] + s1 * costab[tri + 0];\n            }\n            tri += 2;\n        } while (k4 < n);\n    }\n\n    var rv_tbl = [0x00, 0x80, 0x40,\n        0xc0, 0x20, 0xa0, 0x60, 0xe0, 0x10,\n        0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70,\n        0xf0, 0x08, 0x88, 0x48, 0xc8, 0x28,\n        0xa8, 0x68, 0xe8, 0x18, 0x98, 0x58,\n        0xd8, 0x38, 0xb8, 0x78, 0xf8, 0x04,\n        0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64,\n        0xe4, 0x14, 0x94, 0x54, 0xd4, 0x34,\n        0xb4, 0x74, 0xf4, 0x0c, 0x8c, 0x4c,\n        0xcc, 0x2c, 0xac, 0x6c, 0xec, 0x1c,\n        0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c,\n        0xfc, 0x02, 0x82, 0x42, 0xc2, 0x22,\n        0xa2, 0x62, 0xe2, 0x12, 0x92, 0x52,\n        0xd2, 0x32, 0xb2, 0x72, 0xf2, 0x0a,\n        0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a,\n        0xea, 0x1a, 0x9a, 0x5a, 0xda, 0x3a,\n        0xba, 0x7a, 0xfa, 0x06, 0x86, 0x46,\n        0xc6, 0x26, 0xa6, 0x66, 0xe6, 0x16,\n        0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76,\n        0xf6, 0x0e, 0x8e, 0x4e, 0xce, 0x2e,\n        0xae, 0x6e, 0xee, 0x1e, 0x9e, 0x5e,\n        0xde, 0x3e, 0xbe, 0x7e, 0xfe];\n\n    this.fft_short = function (gfc, x_real, chn, buffer, bufPos) {\n        for (var b = 0; b < 3; b++) {\n            var x = Encoder.BLKSIZE_s / 2;\n            var k = 0xffff & ((576 / 3) * (b + 1));\n            var j = Encoder.BLKSIZE_s / 8 - 1;\n            do {\n                var f0, f1, f2, f3, w;\n                var i = rv_tbl[j << 2] & 0xff;\n\n                f0 = window_s[i] * buffer[chn][bufPos + i + k];\n                w = window_s[0x7f - i] * buffer[chn][bufPos + i + k + 0x80];\n                f1 = f0 - w;\n                f0 = f0 + w;\n                f2 = window_s[i + 0x40] * buffer[chn][bufPos + i + k + 0x40];\n                w = window_s[0x3f - i] * buffer[chn][bufPos + i + k + 0xc0];\n                f3 = f2 - w;\n                f2 = f2 + w;\n\n                x -= 4;\n                x_real[b][x + 0] = f0 + f2;\n                x_real[b][x + 2] = f0 - f2;\n                x_real[b][x + 1] = f1 + f3;\n                x_real[b][x + 3] = f1 - f3;\n\n                f0 = window_s[i + 0x01] * buffer[chn][bufPos + i + k + 0x01];\n                w = window_s[0x7e - i] * buffer[chn][bufPos + i + k + 0x81];\n                f1 = f0 - w;\n                f0 = f0 + w;\n                f2 = window_s[i + 0x41] * buffer[chn][bufPos + i + k + 0x41];\n                w = window_s[0x3e - i] * buffer[chn][bufPos + i + k + 0xc1];\n                f3 = f2 - w;\n                f2 = f2 + w;\n\n                x_real[b][x + Encoder.BLKSIZE_s / 2 + 0] = f0 + f2;\n                x_real[b][x + Encoder.BLKSIZE_s / 2 + 2] = f0 - f2;\n                x_real[b][x + Encoder.BLKSIZE_s / 2 + 1] = f1 + f3;\n                x_real[b][x + Encoder.BLKSIZE_s / 2 + 3] = f1 - f3;\n            } while (--j >= 0);\n\n            fht(x_real[b], x, Encoder.BLKSIZE_s / 2);\n            /* BLKSIZE_s/2 because of 3DNow! ASM routine */\n            /* BLKSIZE/2 because of 3DNow! ASM routine */\n        }\n    }\n\n    this.fft_long = function (gfc, y, chn, buffer, bufPos) {\n        var jj = Encoder.BLKSIZE / 8 - 1;\n        var x = Encoder.BLKSIZE / 2;\n\n        do {\n            var f0, f1, f2, f3, w;\n            var i = rv_tbl[jj] & 0xff;\n            f0 = window[i] * buffer[chn][bufPos + i];\n            w = window[i + 0x200] * buffer[chn][bufPos + i + 0x200];\n            f1 = f0 - w;\n            f0 = f0 + w;\n            f2 = window[i + 0x100] * buffer[chn][bufPos + i + 0x100];\n            w = window[i + 0x300] * buffer[chn][bufPos + i + 0x300];\n            f3 = f2 - w;\n            f2 = f2 + w;\n\n            x -= 4;\n            y[x + 0] = f0 + f2;\n            y[x + 2] = f0 - f2;\n            y[x + 1] = f1 + f3;\n            y[x + 3] = f1 - f3;\n\n            f0 = window[i + 0x001] * buffer[chn][bufPos + i + 0x001];\n            w = window[i + 0x201] * buffer[chn][bufPos + i + 0x201];\n            f1 = f0 - w;\n            f0 = f0 + w;\n            f2 = window[i + 0x101] * buffer[chn][bufPos + i + 0x101];\n            w = window[i + 0x301] * buffer[chn][bufPos + i + 0x301];\n            f3 = f2 - w;\n            f2 = f2 + w;\n\n            y[x + Encoder.BLKSIZE / 2 + 0] = f0 + f2;\n            y[x + Encoder.BLKSIZE / 2 + 2] = f0 - f2;\n            y[x + Encoder.BLKSIZE / 2 + 1] = f1 + f3;\n            y[x + Encoder.BLKSIZE / 2 + 3] = f1 - f3;\n        } while (--jj >= 0);\n\n        fht(y, x, Encoder.BLKSIZE / 2);\n        /* BLKSIZE/2 because of 3DNow! ASM routine */\n    }\n\n    this.init_fft = function (gfc) {\n        /* The type of window used here will make no real difference, but */\n        /*\n         * in the interest of merging nspsytune stuff - switch to blackman\n         * window\n         */\n        for (var i = 0; i < Encoder.BLKSIZE; i++)\n            /* blackman window */\n            window[i] = (0.42 - 0.5 * Math.cos(2 * Math.PI * (i + .5)\n                / Encoder.BLKSIZE) + 0.08 * Math.cos(4 * Math.PI * (i + .5)\n                / Encoder.BLKSIZE));\n\n        for (var i = 0; i < Encoder.BLKSIZE_s / 2; i++)\n            window_s[i] = (0.5 * (1.0 - Math.cos(2.0 * Math.PI\n                * (i + 0.5) / Encoder.BLKSIZE_s)));\n\n    }\n\n}\n\nmodule.exports = FFT;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL0ZGVC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsK0VBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLG1CQUFPLENBQUMsaUZBQWM7O0FBRXBDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLDJCQUEyQjtBQUNuRDtBQUNBOztBQUVBOztBQUVBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL0ZGVC5qcz8yODQyIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbi5qcycpO1xudmFyIFN5c3RlbSA9IGNvbW1vbi5TeXN0ZW07XG52YXIgVmJyTW9kZSA9IGNvbW1vbi5WYnJNb2RlO1xudmFyIEZsb2F0ID0gY29tbW9uLkZsb2F0O1xudmFyIFNob3J0QmxvY2sgPSBjb21tb24uU2hvcnRCbG9jaztcbnZhciBVdGlsID0gY29tbW9uLlV0aWw7XG52YXIgQXJyYXlzID0gY29tbW9uLkFycmF5cztcbnZhciBuZXdfYXJyYXlfbiA9IGNvbW1vbi5uZXdfYXJyYXlfbjtcbnZhciBuZXdfYnl0ZSA9IGNvbW1vbi5uZXdfYnl0ZTtcbnZhciBuZXdfZG91YmxlID0gY29tbW9uLm5ld19kb3VibGU7XG52YXIgbmV3X2Zsb2F0ID0gY29tbW9uLm5ld19mbG9hdDtcbnZhciBuZXdfZmxvYXRfbiA9IGNvbW1vbi5uZXdfZmxvYXRfbjtcbnZhciBuZXdfaW50ID0gY29tbW9uLm5ld19pbnQ7XG52YXIgbmV3X2ludF9uID0gY29tbW9uLm5ld19pbnRfbjtcbnZhciBhc3NlcnQgPSBjb21tb24uYXNzZXJ0O1xuXG52YXIgRW5jb2RlciA9IHJlcXVpcmUoJy4vRW5jb2Rlci5qcycpO1xuXG5mdW5jdGlvbiBGRlQoKSB7XG5cbiAgICB2YXIgd2luZG93ID0gbmV3X2Zsb2F0KEVuY29kZXIuQkxLU0laRSk7XG4gICAgdmFyIHdpbmRvd19zID0gbmV3X2Zsb2F0KEVuY29kZXIuQkxLU0laRV9zIC8gMik7XG5cbiAgICB2YXIgY29zdGFiID0gW1xuICAgICAgICA5LjIzODc5NTMyNTExMjg2N2UtMDEsIDMuODI2ODM0MzIzNjUwODk4ZS0wMSxcbiAgICAgICAgOS45NTE4NDcyNjY3MjE5NjllLTAxLCA5LjgwMTcxNDAzMjk1NjA2MGUtMDIsXG4gICAgICAgIDkuOTk2OTg4MTg2OTYyMDQyZS0wMSwgMi40NTQxMjI4NTIyOTEyMjllLTAyLFxuICAgICAgICA5Ljk5OTgxMTc1MjgyNjAxMWUtMDEsIDYuMTM1ODg0NjQ5MTU0NDc1ZS0wM1xuICAgIF07XG5cbiAgICBmdW5jdGlvbiBmaHQoZnosIGZ6UG9zLCBuKSB7XG4gICAgICAgIHZhciB0cmkgPSAwO1xuICAgICAgICB2YXIgazQ7XG4gICAgICAgIHZhciBmaTtcbiAgICAgICAgdmFyIGdpO1xuXG4gICAgICAgIG4gPDw9IDE7XG4gICAgICAgIC8qIHRvIGdldCBCTEtTSVpFLCBiZWNhdXNlIG9mIDNETm93ISBBU00gcm91dGluZSAqL1xuICAgICAgICB2YXIgZm4gPSBmelBvcyArIG47XG4gICAgICAgIGs0ID0gNDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdmFyIHMxLCBjMTtcbiAgICAgICAgICAgIHZhciBpLCBrMSwgazIsIGszLCBreDtcbiAgICAgICAgICAgIGt4ID0gazQgPj4gMTtcbiAgICAgICAgICAgIGsxID0gazQ7XG4gICAgICAgICAgICBrMiA9IGs0IDw8IDE7XG4gICAgICAgICAgICBrMyA9IGsyICsgazE7XG4gICAgICAgICAgICBrNCA9IGsyIDw8IDE7XG4gICAgICAgICAgICBmaSA9IGZ6UG9zO1xuICAgICAgICAgICAgZ2kgPSBmaSArIGt4O1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHZhciBmMCwgZjEsIGYyLCBmMztcbiAgICAgICAgICAgICAgICBmMSA9IGZ6W2ZpICsgMF0gLSBmeltmaSArIGsxXTtcbiAgICAgICAgICAgICAgICBmMCA9IGZ6W2ZpICsgMF0gKyBmeltmaSArIGsxXTtcbiAgICAgICAgICAgICAgICBmMyA9IGZ6W2ZpICsgazJdIC0gZnpbZmkgKyBrM107XG4gICAgICAgICAgICAgICAgZjIgPSBmeltmaSArIGsyXSArIGZ6W2ZpICsgazNdO1xuICAgICAgICAgICAgICAgIGZ6W2ZpICsgazJdID0gZjAgLSBmMjtcbiAgICAgICAgICAgICAgICBmeltmaSArIDBdID0gZjAgKyBmMjtcbiAgICAgICAgICAgICAgICBmeltmaSArIGszXSA9IGYxIC0gZjM7XG4gICAgICAgICAgICAgICAgZnpbZmkgKyBrMV0gPSBmMSArIGYzO1xuICAgICAgICAgICAgICAgIGYxID0gZnpbZ2kgKyAwXSAtIGZ6W2dpICsgazFdO1xuICAgICAgICAgICAgICAgIGYwID0gZnpbZ2kgKyAwXSArIGZ6W2dpICsgazFdO1xuICAgICAgICAgICAgICAgIGYzID0gKFV0aWwuU1FSVDIgKiBmeltnaSArIGszXSk7XG4gICAgICAgICAgICAgICAgZjIgPSAoVXRpbC5TUVJUMiAqIGZ6W2dpICsgazJdKTtcbiAgICAgICAgICAgICAgICBmeltnaSArIGsyXSA9IGYwIC0gZjI7XG4gICAgICAgICAgICAgICAgZnpbZ2kgKyAwXSA9IGYwICsgZjI7XG4gICAgICAgICAgICAgICAgZnpbZ2kgKyBrM10gPSBmMSAtIGYzO1xuICAgICAgICAgICAgICAgIGZ6W2dpICsgazFdID0gZjEgKyBmMztcbiAgICAgICAgICAgICAgICBnaSArPSBrNDtcbiAgICAgICAgICAgICAgICBmaSArPSBrNDtcbiAgICAgICAgICAgIH0gd2hpbGUgKGZpIDwgZm4pO1xuICAgICAgICAgICAgYzEgPSBjb3N0YWJbdHJpICsgMF07XG4gICAgICAgICAgICBzMSA9IGNvc3RhYlt0cmkgKyAxXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBreDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGMyLCBzMjtcbiAgICAgICAgICAgICAgICBjMiA9IDEgLSAoMiAqIHMxKSAqIHMxO1xuICAgICAgICAgICAgICAgIHMyID0gKDIgKiBzMSkgKiBjMTtcbiAgICAgICAgICAgICAgICBmaSA9IGZ6UG9zICsgaTtcbiAgICAgICAgICAgICAgICBnaSA9IGZ6UG9zICsgazEgLSBpO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEsIGIsIGcwLCBmMCwgZjEsIGcxLCBmMiwgZzIsIGYzLCBnMztcbiAgICAgICAgICAgICAgICAgICAgYiA9IHMyICogZnpbZmkgKyBrMV0gLSBjMiAqIGZ6W2dpICsgazFdO1xuICAgICAgICAgICAgICAgICAgICBhID0gYzIgKiBmeltmaSArIGsxXSArIHMyICogZnpbZ2kgKyBrMV07XG4gICAgICAgICAgICAgICAgICAgIGYxID0gZnpbZmkgKyAwXSAtIGE7XG4gICAgICAgICAgICAgICAgICAgIGYwID0gZnpbZmkgKyAwXSArIGE7XG4gICAgICAgICAgICAgICAgICAgIGcxID0gZnpbZ2kgKyAwXSAtIGI7XG4gICAgICAgICAgICAgICAgICAgIGcwID0gZnpbZ2kgKyAwXSArIGI7XG4gICAgICAgICAgICAgICAgICAgIGIgPSBzMiAqIGZ6W2ZpICsgazNdIC0gYzIgKiBmeltnaSArIGszXTtcbiAgICAgICAgICAgICAgICAgICAgYSA9IGMyICogZnpbZmkgKyBrM10gKyBzMiAqIGZ6W2dpICsgazNdO1xuICAgICAgICAgICAgICAgICAgICBmMyA9IGZ6W2ZpICsgazJdIC0gYTtcbiAgICAgICAgICAgICAgICAgICAgZjIgPSBmeltmaSArIGsyXSArIGE7XG4gICAgICAgICAgICAgICAgICAgIGczID0gZnpbZ2kgKyBrMl0gLSBiO1xuICAgICAgICAgICAgICAgICAgICBnMiA9IGZ6W2dpICsgazJdICsgYjtcbiAgICAgICAgICAgICAgICAgICAgYiA9IHMxICogZjIgLSBjMSAqIGczO1xuICAgICAgICAgICAgICAgICAgICBhID0gYzEgKiBmMiArIHMxICogZzM7XG4gICAgICAgICAgICAgICAgICAgIGZ6W2ZpICsgazJdID0gZjAgLSBhO1xuICAgICAgICAgICAgICAgICAgICBmeltmaSArIDBdID0gZjAgKyBhO1xuICAgICAgICAgICAgICAgICAgICBmeltnaSArIGszXSA9IGcxIC0gYjtcbiAgICAgICAgICAgICAgICAgICAgZnpbZ2kgKyBrMV0gPSBnMSArIGI7XG4gICAgICAgICAgICAgICAgICAgIGIgPSBjMSAqIGcyIC0gczEgKiBmMztcbiAgICAgICAgICAgICAgICAgICAgYSA9IHMxICogZzIgKyBjMSAqIGYzO1xuICAgICAgICAgICAgICAgICAgICBmeltnaSArIGsyXSA9IGcwIC0gYTtcbiAgICAgICAgICAgICAgICAgICAgZnpbZ2kgKyAwXSA9IGcwICsgYTtcbiAgICAgICAgICAgICAgICAgICAgZnpbZmkgKyBrM10gPSBmMSAtIGI7XG4gICAgICAgICAgICAgICAgICAgIGZ6W2ZpICsgazFdID0gZjEgKyBiO1xuICAgICAgICAgICAgICAgICAgICBnaSArPSBrNDtcbiAgICAgICAgICAgICAgICAgICAgZmkgKz0gazQ7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoZmkgPCBmbik7XG4gICAgICAgICAgICAgICAgYzIgPSBjMTtcbiAgICAgICAgICAgICAgICBjMSA9IGMyICogY29zdGFiW3RyaSArIDBdIC0gczEgKiBjb3N0YWJbdHJpICsgMV07XG4gICAgICAgICAgICAgICAgczEgPSBjMiAqIGNvc3RhYlt0cmkgKyAxXSArIHMxICogY29zdGFiW3RyaSArIDBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJpICs9IDI7XG4gICAgICAgIH0gd2hpbGUgKGs0IDwgbik7XG4gICAgfVxuXG4gICAgdmFyIHJ2X3RibCA9IFsweDAwLCAweDgwLCAweDQwLFxuICAgICAgICAweGMwLCAweDIwLCAweGEwLCAweDYwLCAweGUwLCAweDEwLFxuICAgICAgICAweDkwLCAweDUwLCAweGQwLCAweDMwLCAweGIwLCAweDcwLFxuICAgICAgICAweGYwLCAweDA4LCAweDg4LCAweDQ4LCAweGM4LCAweDI4LFxuICAgICAgICAweGE4LCAweDY4LCAweGU4LCAweDE4LCAweDk4LCAweDU4LFxuICAgICAgICAweGQ4LCAweDM4LCAweGI4LCAweDc4LCAweGY4LCAweDA0LFxuICAgICAgICAweDg0LCAweDQ0LCAweGM0LCAweDI0LCAweGE0LCAweDY0LFxuICAgICAgICAweGU0LCAweDE0LCAweDk0LCAweDU0LCAweGQ0LCAweDM0LFxuICAgICAgICAweGI0LCAweDc0LCAweGY0LCAweDBjLCAweDhjLCAweDRjLFxuICAgICAgICAweGNjLCAweDJjLCAweGFjLCAweDZjLCAweGVjLCAweDFjLFxuICAgICAgICAweDljLCAweDVjLCAweGRjLCAweDNjLCAweGJjLCAweDdjLFxuICAgICAgICAweGZjLCAweDAyLCAweDgyLCAweDQyLCAweGMyLCAweDIyLFxuICAgICAgICAweGEyLCAweDYyLCAweGUyLCAweDEyLCAweDkyLCAweDUyLFxuICAgICAgICAweGQyLCAweDMyLCAweGIyLCAweDcyLCAweGYyLCAweDBhLFxuICAgICAgICAweDhhLCAweDRhLCAweGNhLCAweDJhLCAweGFhLCAweDZhLFxuICAgICAgICAweGVhLCAweDFhLCAweDlhLCAweDVhLCAweGRhLCAweDNhLFxuICAgICAgICAweGJhLCAweDdhLCAweGZhLCAweDA2LCAweDg2LCAweDQ2LFxuICAgICAgICAweGM2LCAweDI2LCAweGE2LCAweDY2LCAweGU2LCAweDE2LFxuICAgICAgICAweDk2LCAweDU2LCAweGQ2LCAweDM2LCAweGI2LCAweDc2LFxuICAgICAgICAweGY2LCAweDBlLCAweDhlLCAweDRlLCAweGNlLCAweDJlLFxuICAgICAgICAweGFlLCAweDZlLCAweGVlLCAweDFlLCAweDllLCAweDVlLFxuICAgICAgICAweGRlLCAweDNlLCAweGJlLCAweDdlLCAweGZlXTtcblxuICAgIHRoaXMuZmZ0X3Nob3J0ID0gZnVuY3Rpb24gKGdmYywgeF9yZWFsLCBjaG4sIGJ1ZmZlciwgYnVmUG9zKSB7XG4gICAgICAgIGZvciAodmFyIGIgPSAwOyBiIDwgMzsgYisrKSB7XG4gICAgICAgICAgICB2YXIgeCA9IEVuY29kZXIuQkxLU0laRV9zIC8gMjtcbiAgICAgICAgICAgIHZhciBrID0gMHhmZmZmICYgKCg1NzYgLyAzKSAqIChiICsgMSkpO1xuICAgICAgICAgICAgdmFyIGogPSBFbmNvZGVyLkJMS1NJWkVfcyAvIDggLSAxO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHZhciBmMCwgZjEsIGYyLCBmMywgdztcbiAgICAgICAgICAgICAgICB2YXIgaSA9IHJ2X3RibFtqIDw8IDJdICYgMHhmZjtcblxuICAgICAgICAgICAgICAgIGYwID0gd2luZG93X3NbaV0gKiBidWZmZXJbY2huXVtidWZQb3MgKyBpICsga107XG4gICAgICAgICAgICAgICAgdyA9IHdpbmRvd19zWzB4N2YgLSBpXSAqIGJ1ZmZlcltjaG5dW2J1ZlBvcyArIGkgKyBrICsgMHg4MF07XG4gICAgICAgICAgICAgICAgZjEgPSBmMCAtIHc7XG4gICAgICAgICAgICAgICAgZjAgPSBmMCArIHc7XG4gICAgICAgICAgICAgICAgZjIgPSB3aW5kb3dfc1tpICsgMHg0MF0gKiBidWZmZXJbY2huXVtidWZQb3MgKyBpICsgayArIDB4NDBdO1xuICAgICAgICAgICAgICAgIHcgPSB3aW5kb3dfc1sweDNmIC0gaV0gKiBidWZmZXJbY2huXVtidWZQb3MgKyBpICsgayArIDB4YzBdO1xuICAgICAgICAgICAgICAgIGYzID0gZjIgLSB3O1xuICAgICAgICAgICAgICAgIGYyID0gZjIgKyB3O1xuXG4gICAgICAgICAgICAgICAgeCAtPSA0O1xuICAgICAgICAgICAgICAgIHhfcmVhbFtiXVt4ICsgMF0gPSBmMCArIGYyO1xuICAgICAgICAgICAgICAgIHhfcmVhbFtiXVt4ICsgMl0gPSBmMCAtIGYyO1xuICAgICAgICAgICAgICAgIHhfcmVhbFtiXVt4ICsgMV0gPSBmMSArIGYzO1xuICAgICAgICAgICAgICAgIHhfcmVhbFtiXVt4ICsgM10gPSBmMSAtIGYzO1xuXG4gICAgICAgICAgICAgICAgZjAgPSB3aW5kb3dfc1tpICsgMHgwMV0gKiBidWZmZXJbY2huXVtidWZQb3MgKyBpICsgayArIDB4MDFdO1xuICAgICAgICAgICAgICAgIHcgPSB3aW5kb3dfc1sweDdlIC0gaV0gKiBidWZmZXJbY2huXVtidWZQb3MgKyBpICsgayArIDB4ODFdO1xuICAgICAgICAgICAgICAgIGYxID0gZjAgLSB3O1xuICAgICAgICAgICAgICAgIGYwID0gZjAgKyB3O1xuICAgICAgICAgICAgICAgIGYyID0gd2luZG93X3NbaSArIDB4NDFdICogYnVmZmVyW2Nobl1bYnVmUG9zICsgaSArIGsgKyAweDQxXTtcbiAgICAgICAgICAgICAgICB3ID0gd2luZG93X3NbMHgzZSAtIGldICogYnVmZmVyW2Nobl1bYnVmUG9zICsgaSArIGsgKyAweGMxXTtcbiAgICAgICAgICAgICAgICBmMyA9IGYyIC0gdztcbiAgICAgICAgICAgICAgICBmMiA9IGYyICsgdztcblxuICAgICAgICAgICAgICAgIHhfcmVhbFtiXVt4ICsgRW5jb2Rlci5CTEtTSVpFX3MgLyAyICsgMF0gPSBmMCArIGYyO1xuICAgICAgICAgICAgICAgIHhfcmVhbFtiXVt4ICsgRW5jb2Rlci5CTEtTSVpFX3MgLyAyICsgMl0gPSBmMCAtIGYyO1xuICAgICAgICAgICAgICAgIHhfcmVhbFtiXVt4ICsgRW5jb2Rlci5CTEtTSVpFX3MgLyAyICsgMV0gPSBmMSArIGYzO1xuICAgICAgICAgICAgICAgIHhfcmVhbFtiXVt4ICsgRW5jb2Rlci5CTEtTSVpFX3MgLyAyICsgM10gPSBmMSAtIGYzO1xuICAgICAgICAgICAgfSB3aGlsZSAoLS1qID49IDApO1xuXG4gICAgICAgICAgICBmaHQoeF9yZWFsW2JdLCB4LCBFbmNvZGVyLkJMS1NJWkVfcyAvIDIpO1xuICAgICAgICAgICAgLyogQkxLU0laRV9zLzIgYmVjYXVzZSBvZiAzRE5vdyEgQVNNIHJvdXRpbmUgKi9cbiAgICAgICAgICAgIC8qIEJMS1NJWkUvMiBiZWNhdXNlIG9mIDNETm93ISBBU00gcm91dGluZSAqL1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5mZnRfbG9uZyA9IGZ1bmN0aW9uIChnZmMsIHksIGNobiwgYnVmZmVyLCBidWZQb3MpIHtcbiAgICAgICAgdmFyIGpqID0gRW5jb2Rlci5CTEtTSVpFIC8gOCAtIDE7XG4gICAgICAgIHZhciB4ID0gRW5jb2Rlci5CTEtTSVpFIC8gMjtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgICB2YXIgZjAsIGYxLCBmMiwgZjMsIHc7XG4gICAgICAgICAgICB2YXIgaSA9IHJ2X3RibFtqal0gJiAweGZmO1xuICAgICAgICAgICAgZjAgPSB3aW5kb3dbaV0gKiBidWZmZXJbY2huXVtidWZQb3MgKyBpXTtcbiAgICAgICAgICAgIHcgPSB3aW5kb3dbaSArIDB4MjAwXSAqIGJ1ZmZlcltjaG5dW2J1ZlBvcyArIGkgKyAweDIwMF07XG4gICAgICAgICAgICBmMSA9IGYwIC0gdztcbiAgICAgICAgICAgIGYwID0gZjAgKyB3O1xuICAgICAgICAgICAgZjIgPSB3aW5kb3dbaSArIDB4MTAwXSAqIGJ1ZmZlcltjaG5dW2J1ZlBvcyArIGkgKyAweDEwMF07XG4gICAgICAgICAgICB3ID0gd2luZG93W2kgKyAweDMwMF0gKiBidWZmZXJbY2huXVtidWZQb3MgKyBpICsgMHgzMDBdO1xuICAgICAgICAgICAgZjMgPSBmMiAtIHc7XG4gICAgICAgICAgICBmMiA9IGYyICsgdztcblxuICAgICAgICAgICAgeCAtPSA0O1xuICAgICAgICAgICAgeVt4ICsgMF0gPSBmMCArIGYyO1xuICAgICAgICAgICAgeVt4ICsgMl0gPSBmMCAtIGYyO1xuICAgICAgICAgICAgeVt4ICsgMV0gPSBmMSArIGYzO1xuICAgICAgICAgICAgeVt4ICsgM10gPSBmMSAtIGYzO1xuXG4gICAgICAgICAgICBmMCA9IHdpbmRvd1tpICsgMHgwMDFdICogYnVmZmVyW2Nobl1bYnVmUG9zICsgaSArIDB4MDAxXTtcbiAgICAgICAgICAgIHcgPSB3aW5kb3dbaSArIDB4MjAxXSAqIGJ1ZmZlcltjaG5dW2J1ZlBvcyArIGkgKyAweDIwMV07XG4gICAgICAgICAgICBmMSA9IGYwIC0gdztcbiAgICAgICAgICAgIGYwID0gZjAgKyB3O1xuICAgICAgICAgICAgZjIgPSB3aW5kb3dbaSArIDB4MTAxXSAqIGJ1ZmZlcltjaG5dW2J1ZlBvcyArIGkgKyAweDEwMV07XG4gICAgICAgICAgICB3ID0gd2luZG93W2kgKyAweDMwMV0gKiBidWZmZXJbY2huXVtidWZQb3MgKyBpICsgMHgzMDFdO1xuICAgICAgICAgICAgZjMgPSBmMiAtIHc7XG4gICAgICAgICAgICBmMiA9IGYyICsgdztcblxuICAgICAgICAgICAgeVt4ICsgRW5jb2Rlci5CTEtTSVpFIC8gMiArIDBdID0gZjAgKyBmMjtcbiAgICAgICAgICAgIHlbeCArIEVuY29kZXIuQkxLU0laRSAvIDIgKyAyXSA9IGYwIC0gZjI7XG4gICAgICAgICAgICB5W3ggKyBFbmNvZGVyLkJMS1NJWkUgLyAyICsgMV0gPSBmMSArIGYzO1xuICAgICAgICAgICAgeVt4ICsgRW5jb2Rlci5CTEtTSVpFIC8gMiArIDNdID0gZjEgLSBmMztcbiAgICAgICAgfSB3aGlsZSAoLS1qaiA+PSAwKTtcblxuICAgICAgICBmaHQoeSwgeCwgRW5jb2Rlci5CTEtTSVpFIC8gMik7XG4gICAgICAgIC8qIEJMS1NJWkUvMiBiZWNhdXNlIG9mIDNETm93ISBBU00gcm91dGluZSAqL1xuICAgIH1cblxuICAgIHRoaXMuaW5pdF9mZnQgPSBmdW5jdGlvbiAoZ2ZjKSB7XG4gICAgICAgIC8qIFRoZSB0eXBlIG9mIHdpbmRvdyB1c2VkIGhlcmUgd2lsbCBtYWtlIG5vIHJlYWwgZGlmZmVyZW5jZSwgYnV0ICovXG4gICAgICAgIC8qXG4gICAgICAgICAqIGluIHRoZSBpbnRlcmVzdCBvZiBtZXJnaW5nIG5zcHN5dHVuZSBzdHVmZiAtIHN3aXRjaCB0byBibGFja21hblxuICAgICAgICAgKiB3aW5kb3dcbiAgICAgICAgICovXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgRW5jb2Rlci5CTEtTSVpFOyBpKyspXG4gICAgICAgICAgICAvKiBibGFja21hbiB3aW5kb3cgKi9cbiAgICAgICAgICAgIHdpbmRvd1tpXSA9ICgwLjQyIC0gMC41ICogTWF0aC5jb3MoMiAqIE1hdGguUEkgKiAoaSArIC41KVxuICAgICAgICAgICAgICAgIC8gRW5jb2Rlci5CTEtTSVpFKSArIDAuMDggKiBNYXRoLmNvcyg0ICogTWF0aC5QSSAqIChpICsgLjUpXG4gICAgICAgICAgICAgICAgLyBFbmNvZGVyLkJMS1NJWkUpKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEVuY29kZXIuQkxLU0laRV9zIC8gMjsgaSsrKVxuICAgICAgICAgICAgd2luZG93X3NbaV0gPSAoMC41ICogKDEuMCAtIE1hdGguY29zKDIuMCAqIE1hdGguUElcbiAgICAgICAgICAgICAgICAqIChpICsgMC41KSAvIEVuY29kZXIuQkxLU0laRV9zKSkpO1xuXG4gICAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gRkZUO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lamejs/src/js/FFT.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lamejs/src/js/GainAnalysis.js":
/*!****************************************************!*\
  !*** ./node_modules/lamejs/src/js/GainAnalysis.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/*\n *  ReplayGainAnalysis - analyzes input samples and give the recommended dB change\n *  Copyright (C) 2001 David Robinson and Glen Sawyer\n *  Improvements and optimizations added by Frank Klemm, and by Marcel Muller \n *\n *  This library is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Lesser General Public\n *  License as published by the Free Software Foundation; either\n *  version 2.1 of the License, or (at your option) any later version.\n *\n *  This library is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n *  concept and filter values by David Robinson (David@Robinson.org)\n *    -- blame him if you think the idea is flawed\n *  original coding by Glen Sawyer (mp3gain@hotmail.com)\n *    -- blame him if you think this runs too slowly, or the coding is otherwise flawed\n *\n *  lots of code improvements by Frank Klemm ( http://www.uni-jena.de/~pfk/mpp/ )\n *    -- credit him for all the _good_ programming ;)\n *\n *\n *  For an explanation of the concepts and the basic algorithms involved, go to:\n *    http://www.replaygain.org/\n */\n\n/*\n *  Here's the deal. Call\n *\n *    InitGainAnalysis ( long samplefreq );\n *\n *  to initialize everything. Call\n *\n *    AnalyzeSamples ( var Float_t*  left_samples,\n *                     var Float_t*  right_samples,\n *                     size_t          num_samples,\n *                     int             num_channels );\n *\n *  as many times as you want, with as many or as few samples as you want.\n *  If mono, pass the sample buffer in through left_samples, leave\n *  right_samples NULL, and make sure num_channels = 1.\n *\n *    GetTitleGain()\n *\n *  will return the recommended dB level change for all samples analyzed\n *  SINCE THE LAST TIME you called GetTitleGain() OR InitGainAnalysis().\n *\n *    GetAlbumGain()\n *\n *  will return the recommended dB level change for all samples analyzed\n *  since InitGainAnalysis() was called and finalized with GetTitleGain().\n *\n *  Pseudo-code to process an album:\n *\n *    Float_t       l_samples [4096];\n *    Float_t       r_samples [4096];\n *    size_t        num_samples;\n *    unsigned int  num_songs;\n *    unsigned int  i;\n *\n *    InitGainAnalysis ( 44100 );\n *    for ( i = 1; i <= num_songs; i++ ) {\n *        while ( ( num_samples = getSongSamples ( song[i], left_samples, right_samples ) ) > 0 )\n *            AnalyzeSamples ( left_samples, right_samples, num_samples, 2 );\n *        fprintf (\"Recommended dB change for song %2d: %+6.2 dB\\n\", i, GetTitleGain() );\n *    }\n *    fprintf (\"Recommended dB change for whole album: %+6.2 dB\\n\", GetAlbumGain() );\n */\n\n/*\n *  So here's the main source of potential code confusion:\n *\n *  The filters applied to the incoming samples are IIR filters,\n *  meaning they rely on up to <filter order> number of previous samples\n *  AND up to <filter order> number of previous filtered samples.\n *\n *  I set up the AnalyzeSamples routine to minimize memory usage and interface\n *  complexity. The speed isn't compromised too much (I don't think), but the\n *  internal complexity is higher than it should be for such a relatively\n *  simple routine.\n *\n *  Optimization/clarity suggestions are welcome.\n */\nvar common = __webpack_require__(/*! ./common.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/common.js\");\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\n/**\n * Table entries per dB\n */\nGainAnalysis.STEPS_per_dB = 100.;\n/**\n * Table entries for 0...MAX_dB (normal max. values are 70...80 dB)\n */\nGainAnalysis.MAX_dB = 120.;\nGainAnalysis.GAIN_NOT_ENOUGH_SAMPLES = -24601;\nGainAnalysis.GAIN_ANALYSIS_ERROR = 0;\nGainAnalysis.GAIN_ANALYSIS_OK = 1;\nGainAnalysis.INIT_GAIN_ANALYSIS_ERROR = 0;\nGainAnalysis.INIT_GAIN_ANALYSIS_OK = 1;\n\nGainAnalysis.YULE_ORDER = 10;\nGainAnalysis.MAX_ORDER = GainAnalysis.YULE_ORDER;\n\nGainAnalysis.MAX_SAMP_FREQ = 48000;\nGainAnalysis.RMS_WINDOW_TIME_NUMERATOR = 1;\nGainAnalysis.RMS_WINDOW_TIME_DENOMINATOR = 20;\nGainAnalysis.MAX_SAMPLES_PER_WINDOW = ((GainAnalysis.MAX_SAMP_FREQ * GainAnalysis.RMS_WINDOW_TIME_NUMERATOR) / GainAnalysis.RMS_WINDOW_TIME_DENOMINATOR + 1);\n\nfunction GainAnalysis() {\n    /**\n     * calibration value for 89dB\n     */\n    var PINK_REF = 64.82;\n\n    var YULE_ORDER = GainAnalysis.YULE_ORDER;\n    /**\n     * percentile which is louder than the proposed level\n     */\n    var RMS_PERCENTILE = 0.95;\n    /**\n     * maximum allowed sample frequency [Hz]\n     */\n    var MAX_SAMP_FREQ = GainAnalysis.MAX_SAMP_FREQ;\n    var RMS_WINDOW_TIME_NUMERATOR = GainAnalysis.RMS_WINDOW_TIME_NUMERATOR;\n    /**\n     * numerator / denominator = time slice size [s]\n     */\n    var RMS_WINDOW_TIME_DENOMINATOR = GainAnalysis.RMS_WINDOW_TIME_DENOMINATOR;\n    /**\n     * max. Samples per Time slice\n     */\n    var MAX_SAMPLES_PER_WINDOW = GainAnalysis.MAX_SAMPLES_PER_WINDOW;\n\n\n    var ABYule = [\n        [0.03857599435200, -3.84664617118067, -0.02160367184185,\n            7.81501653005538, -0.00123395316851, -11.34170355132042,\n            -0.00009291677959, 13.05504219327545, -0.01655260341619,\n            -12.28759895145294, 0.02161526843274, 9.48293806319790,\n            -0.02074045215285, -5.87257861775999, 0.00594298065125,\n            2.75465861874613, 0.00306428023191, -0.86984376593551,\n            0.00012025322027, 0.13919314567432, 0.00288463683916],\n        [0.05418656406430, -3.47845948550071, -0.02911007808948,\n            6.36317777566148, -0.00848709379851, -8.54751527471874,\n            -0.00851165645469, 9.47693607801280, -0.00834990904936,\n            -8.81498681370155, 0.02245293253339, 6.85401540936998,\n            -0.02596338512915, -4.39470996079559, 0.01624864962975,\n            2.19611684890774, -0.00240879051584, -0.75104302451432,\n            0.00674613682247, 0.13149317958808, -0.00187763777362],\n        [0.15457299681924, -2.37898834973084, -0.09331049056315,\n            2.84868151156327, -0.06247880153653, -2.64577170229825,\n            0.02163541888798, 2.23697657451713, -0.05588393329856,\n            -1.67148153367602, 0.04781476674921, 1.00595954808547,\n            0.00222312597743, -0.45953458054983, 0.03174092540049,\n            0.16378164858596, -0.01390589421898, -0.05032077717131,\n            0.00651420667831, 0.02347897407020, -0.00881362733839],\n        [0.30296907319327, -1.61273165137247, -0.22613988682123,\n            1.07977492259970, -0.08587323730772, -0.25656257754070,\n            0.03282930172664, -0.16276719120440, -0.00915702933434,\n            -0.22638893773906, -0.02364141202522, 0.39120800788284,\n            -0.00584456039913, -0.22138138954925, 0.06276101321749,\n            0.04500235387352, -0.00000828086748, 0.02005851806501,\n            0.00205861885564, 0.00302439095741, -0.02950134983287],\n        [0.33642304856132, -1.49858979367799, -0.25572241425570,\n            0.87350271418188, -0.11828570177555, 0.12205022308084,\n            0.11921148675203, -0.80774944671438, -0.07834489609479,\n            0.47854794562326, -0.00469977914380, -0.12453458140019,\n            -0.00589500224440, -0.04067510197014, 0.05724228140351,\n            0.08333755284107, 0.00832043980773, -0.04237348025746,\n            -0.01635381384540, 0.02977207319925, -0.01760176568150],\n        [0.44915256608450, -0.62820619233671, -0.14351757464547,\n            0.29661783706366, -0.22784394429749, -0.37256372942400,\n            -0.01419140100551, 0.00213767857124, 0.04078262797139,\n            -0.42029820170918, -0.12398163381748, 0.22199650564824,\n            0.04097565135648, 0.00613424350682, 0.10478503600251,\n            0.06747620744683, -0.01863887810927, 0.05784820375801,\n            -0.03193428438915, 0.03222754072173, 0.00541907748707],\n        [0.56619470757641, -1.04800335126349, -0.75464456939302,\n            0.29156311971249, 0.16242137742230, -0.26806001042947,\n            0.16744243493672, 0.00819999645858, -0.18901604199609,\n            0.45054734505008, 0.30931782841830, -0.33032403314006,\n            -0.27562961986224, 0.06739368333110, 0.00647310677246,\n            -0.04784254229033, 0.08647503780351, 0.01639907836189,\n            -0.03788984554840, 0.01807364323573, -0.00588215443421],\n        [0.58100494960553, -0.51035327095184, -0.53174909058578,\n            -0.31863563325245, -0.14289799034253, -0.20256413484477,\n            0.17520704835522, 0.14728154134330, 0.02377945217615,\n            0.38952639978999, 0.15558449135573, -0.23313271880868,\n            -0.25344790059353, -0.05246019024463, 0.01628462406333,\n            -0.02505961724053, 0.06920467763959, 0.02442357316099,\n            -0.03721611395801, 0.01818801111503, -0.00749618797172],\n        [0.53648789255105, -0.25049871956020, -0.42163034350696,\n            -0.43193942311114, -0.00275953611929, -0.03424681017675,\n            0.04267842219415, -0.04678328784242, -0.10214864179676,\n            0.26408300200955, 0.14590772289388, 0.15113130533216,\n            -0.02459864859345, -0.17556493366449, -0.11202315195388,\n            -0.18823009262115, -0.04060034127000, 0.05477720428674,\n            0.04788665548180, 0.04704409688120, -0.02217936801134]];\n\n    var ABButter = [\n        [0.98621192462708, -1.97223372919527, -1.97242384925416,\n            0.97261396931306, 0.98621192462708],\n        [0.98500175787242, -1.96977855582618, -1.97000351574484,\n            0.97022847566350, 0.98500175787242],\n        [0.97938932735214, -1.95835380975398, -1.95877865470428,\n            0.95920349965459, 0.97938932735214],\n        [0.97531843204928, -1.95002759149878, -1.95063686409857,\n            0.95124613669835, 0.97531843204928],\n        [0.97316523498161, -1.94561023566527, -1.94633046996323,\n            0.94705070426118, 0.97316523498161],\n        [0.96454515552826, -1.92783286977036, -1.92909031105652,\n            0.93034775234268, 0.96454515552826],\n        [0.96009142950541, -1.91858953033784, -1.92018285901082,\n            0.92177618768381, 0.96009142950541],\n        [0.95856916599601, -1.91542108074780, -1.91713833199203,\n            0.91885558323625, 0.95856916599601],\n        [0.94597685600279, -1.88903307939452, -1.89195371200558,\n            0.89487434461664, 0.94597685600279]];\n\n\n    /**\n     * When calling this procedure, make sure that ip[-order] and op[-order]\n     * point to real data\n     */\n    //private void filterYule(final float[] input, int inputPos, float[] output,\n    //int outputPos, int nSamples, final float[] kernel) {\n    function filterYule(input, inputPos, output, outputPos, nSamples, kernel) {\n\n        while ((nSamples--) != 0) {\n            /* 1e-10 is a hack to avoid slowdown because of denormals */\n            output[outputPos] = 1e-10 + input[inputPos + 0] * kernel[0]\n                - output[outputPos - 1] * kernel[1] + input[inputPos - 1]\n                * kernel[2] - output[outputPos - 2] * kernel[3]\n                + input[inputPos - 2] * kernel[4] - output[outputPos - 3]\n                * kernel[5] + input[inputPos - 3] * kernel[6]\n                - output[outputPos - 4] * kernel[7] + input[inputPos - 4]\n                * kernel[8] - output[outputPos - 5] * kernel[9]\n                + input[inputPos - 5] * kernel[10] - output[outputPos - 6]\n                * kernel[11] + input[inputPos - 6] * kernel[12]\n                - output[outputPos - 7] * kernel[13] + input[inputPos - 7]\n                * kernel[14] - output[outputPos - 8] * kernel[15]\n                + input[inputPos - 8] * kernel[16] - output[outputPos - 9]\n                * kernel[17] + input[inputPos - 9] * kernel[18]\n                - output[outputPos - 10] * kernel[19]\n                + input[inputPos - 10] * kernel[20];\n            ++outputPos;\n            ++inputPos;\n        }\n    }\n\n//private void filterButter(final float[] input, int inputPos,\n//    float[] output, int outputPos, int nSamples, final float[] kernel) {\n    function filterButter(input, inputPos, output, outputPos, nSamples, kernel) {\n\n        while ((nSamples--) != 0) {\n            output[outputPos] = input[inputPos + 0] * kernel[0]\n                - output[outputPos - 1] * kernel[1] + input[inputPos - 1]\n                * kernel[2] - output[outputPos - 2] * kernel[3]\n                + input[inputPos - 2] * kernel[4];\n            ++outputPos;\n            ++inputPos;\n        }\n    }\n\n    /**\n     * @return INIT_GAIN_ANALYSIS_OK if successful, INIT_GAIN_ANALYSIS_ERROR if\n     *         not\n     */\n    function ResetSampleFrequency(rgData, samplefreq) {\n        /* zero out initial values */\n        for (var i = 0; i < MAX_ORDER; i++)\n            rgData.linprebuf[i] = rgData.lstepbuf[i] = rgData.loutbuf[i] = rgData.rinprebuf[i] = rgData.rstepbuf[i] = rgData.routbuf[i] = 0.;\n\n        switch (0 | (samplefreq)) {\n            case 48000:\n                rgData.reqindex = 0;\n                break;\n            case 44100:\n                rgData.reqindex = 1;\n                break;\n            case 32000:\n                rgData.reqindex = 2;\n                break;\n            case 24000:\n                rgData.reqindex = 3;\n                break;\n            case 22050:\n                rgData.reqindex = 4;\n                break;\n            case 16000:\n                rgData.reqindex = 5;\n                break;\n            case 12000:\n                rgData.reqindex = 6;\n                break;\n            case 11025:\n                rgData.reqindex = 7;\n                break;\n            case 8000:\n                rgData.reqindex = 8;\n                break;\n            default:\n                return INIT_GAIN_ANALYSIS_ERROR;\n        }\n\n        rgData.sampleWindow = 0 | ((samplefreq * RMS_WINDOW_TIME_NUMERATOR\n            + RMS_WINDOW_TIME_DENOMINATOR - 1) / RMS_WINDOW_TIME_DENOMINATOR);\n\n        rgData.lsum = 0.;\n        rgData.rsum = 0.;\n        rgData.totsamp = 0;\n\n        Arrays.ill(rgData.A, 0);\n\n        return INIT_GAIN_ANALYSIS_OK;\n    }\n\n    this.InitGainAnalysis = function (rgData, samplefreq) {\n        if (ResetSampleFrequency(rgData, samplefreq) != INIT_GAIN_ANALYSIS_OK) {\n            return INIT_GAIN_ANALYSIS_ERROR;\n        }\n\n        rgData.linpre = MAX_ORDER;\n        rgData.rinpre = MAX_ORDER;\n        rgData.lstep = MAX_ORDER;\n        rgData.rstep = MAX_ORDER;\n        rgData.lout = MAX_ORDER;\n        rgData.rout = MAX_ORDER;\n\n        Arrays.fill(rgData.B, 0);\n\n        return INIT_GAIN_ANALYSIS_OK;\n    };\n\n    /**\n     * square\n     */\n    function fsqr(d) {\n        return d * d;\n    }\n\n    this.AnalyzeSamples = function (rgData, left_samples, left_samplesPos, right_samples, right_samplesPos, num_samples,\n                                    num_channels) {\n        var curleft;\n        var curleftBase;\n        var curright;\n        var currightBase;\n        var batchsamples;\n        var cursamples;\n        var cursamplepos;\n\n        if (num_samples == 0)\n            return GAIN_ANALYSIS_OK;\n\n        cursamplepos = 0;\n        batchsamples = num_samples;\n\n        switch (num_channels) {\n            case 1:\n                right_samples = left_samples;\n                right_samplesPos = left_samplesPos;\n                break;\n            case 2:\n                break;\n            default:\n                return GAIN_ANALYSIS_ERROR;\n        }\n\n        if (num_samples < MAX_ORDER) {\n            System.arraycopy(left_samples, left_samplesPos, rgData.linprebuf,\n                MAX_ORDER, num_samples);\n            System.arraycopy(right_samples, right_samplesPos, rgData.rinprebuf,\n                MAX_ORDER, num_samples);\n        } else {\n            System.arraycopy(left_samples, left_samplesPos, rgData.linprebuf,\n                MAX_ORDER, MAX_ORDER);\n            System.arraycopy(right_samples, right_samplesPos, rgData.rinprebuf,\n                MAX_ORDER, MAX_ORDER);\n        }\n\n        while (batchsamples > 0) {\n            cursamples = batchsamples > rgData.sampleWindow - rgData.totsamp ? rgData.sampleWindow\n            - rgData.totsamp\n                : batchsamples;\n            if (cursamplepos < MAX_ORDER) {\n                curleft = rgData.linpre + cursamplepos;\n                curleftBase = rgData.linprebuf;\n                curright = rgData.rinpre + cursamplepos;\n                currightBase = rgData.rinprebuf;\n                if (cursamples > MAX_ORDER - cursamplepos)\n                    cursamples = MAX_ORDER - cursamplepos;\n            } else {\n                curleft = left_samplesPos + cursamplepos;\n                curleftBase = left_samples;\n                curright = right_samplesPos + cursamplepos;\n                currightBase = right_samples;\n            }\n\n            filterYule(curleftBase, curleft, rgData.lstepbuf, rgData.lstep\n                + rgData.totsamp, cursamples, ABYule[rgData.reqindex]);\n            filterYule(currightBase, curright, rgData.rstepbuf, rgData.rstep\n                + rgData.totsamp, cursamples, ABYule[rgData.reqindex]);\n\n            filterButter(rgData.lstepbuf, rgData.lstep + rgData.totsamp,\n                rgData.loutbuf, rgData.lout + rgData.totsamp, cursamples,\n                ABButter[rgData.reqindex]);\n            filterButter(rgData.rstepbuf, rgData.rstep + rgData.totsamp,\n                rgData.routbuf, rgData.rout + rgData.totsamp, cursamples,\n                ABButter[rgData.reqindex]);\n\n            curleft = rgData.lout + rgData.totsamp;\n            /* Get the squared values */\n            curleftBase = rgData.loutbuf;\n            curright = rgData.rout + rgData.totsamp;\n            currightBase = rgData.routbuf;\n\n            var i = cursamples % 8;\n            while ((i--) != 0) {\n                rgData.lsum += fsqr(curleftBase[curleft++]);\n                rgData.rsum += fsqr(currightBase[curright++]);\n            }\n            i = cursamples / 8;\n            while ((i--) != 0) {\n                rgData.lsum += fsqr(curleftBase[curleft + 0])\n                    + fsqr(curleftBase[curleft + 1])\n                    + fsqr(curleftBase[curleft + 2])\n                    + fsqr(curleftBase[curleft + 3])\n                    + fsqr(curleftBase[curleft + 4])\n                    + fsqr(curleftBase[curleft + 5])\n                    + fsqr(curleftBase[curleft + 6])\n                    + fsqr(curleftBase[curleft + 7]);\n                curleft += 8;\n                rgData.rsum += fsqr(currightBase[curright + 0])\n                    + fsqr(currightBase[curright + 1])\n                    + fsqr(currightBase[curright + 2])\n                    + fsqr(currightBase[curright + 3])\n                    + fsqr(currightBase[curright + 4])\n                    + fsqr(currightBase[curright + 5])\n                    + fsqr(currightBase[curright + 6])\n                    + fsqr(currightBase[curright + 7]);\n                curright += 8;\n            }\n\n            batchsamples -= cursamples;\n            cursamplepos += cursamples;\n            rgData.totsamp += cursamples;\n            if (rgData.totsamp == rgData.sampleWindow) {\n                /* Get the Root Mean Square (RMS) for this set of samples */\n                var val = GainAnalysis.STEPS_per_dB\n                    * 10.\n                    * Math.log10((rgData.lsum + rgData.rsum)\n                        / rgData.totsamp * 0.5 + 1.e-37);\n                var ival = (val <= 0) ? 0 : 0 | val;\n                if (ival >= rgData.A.length)\n                    ival = rgData.A.length - 1;\n                rgData.A[ival]++;\n                rgData.lsum = rgData.rsum = 0.;\n\n                System.arraycopy(rgData.loutbuf, rgData.totsamp,\n                    rgData.loutbuf, 0, MAX_ORDER);\n                System.arraycopy(rgData.routbuf, rgData.totsamp,\n                    rgData.routbuf, 0, MAX_ORDER);\n                System.arraycopy(rgData.lstepbuf, rgData.totsamp,\n                    rgData.lstepbuf, 0, MAX_ORDER);\n                System.arraycopy(rgData.rstepbuf, rgData.totsamp,\n                    rgData.rstepbuf, 0, MAX_ORDER);\n                rgData.totsamp = 0;\n            }\n            if (rgData.totsamp > rgData.sampleWindow) {\n                /*\n                 * somehow I really screwed up: Error in programming! Contact\n                 * author about totsamp > sampleWindow\n                 */\n                return GAIN_ANALYSIS_ERROR;\n            }\n        }\n        if (num_samples < MAX_ORDER) {\n            System.arraycopy(rgData.linprebuf, num_samples, rgData.linprebuf,\n                0, MAX_ORDER - num_samples);\n            System.arraycopy(rgData.rinprebuf, num_samples, rgData.rinprebuf,\n                0, MAX_ORDER - num_samples);\n            System.arraycopy(left_samples, left_samplesPos, rgData.linprebuf,\n                MAX_ORDER - num_samples, num_samples);\n            System.arraycopy(right_samples, right_samplesPos, rgData.rinprebuf,\n                MAX_ORDER - num_samples, num_samples);\n        } else {\n            System.arraycopy(left_samples, left_samplesPos + num_samples\n                - MAX_ORDER, rgData.linprebuf, 0, MAX_ORDER);\n            System.arraycopy(right_samples, right_samplesPos + num_samples\n                - MAX_ORDER, rgData.rinprebuf, 0, MAX_ORDER);\n        }\n\n        return GAIN_ANALYSIS_OK;\n    };\n\n    function analyzeResult(Array, len) {\n        var i;\n\n        var elems = 0;\n        for (i = 0; i < len; i++)\n            elems += Array[i];\n        if (elems == 0)\n            return GAIN_NOT_ENOUGH_SAMPLES;\n\n        var upper = 0 | Math.ceil(elems * (1. - RMS_PERCENTILE));\n        for (i = len; i-- > 0;) {\n            if ((upper -= Array[i]) <= 0)\n                break;\n        }\n\n        //return (float) ((float) PINK_REF - (float) i / (float) STEPS_per_dB);\n        return (PINK_REF - i / GainAnalysis.STEPS_per_dB);\n    }\n\n    this.GetTitleGain = function (rgData) {\n        var retval = analyzeResult(rgData.A, rgData.A.length);\n\n        for (var i = 0; i < rgData.A.length; i++) {\n            rgData.B[i] += rgData.A[i];\n            rgData.A[i] = 0;\n        }\n\n        for (var i = 0; i < MAX_ORDER; i++)\n            rgData.linprebuf[i] = rgData.lstepbuf[i] = rgData.loutbuf[i] = rgData.rinprebuf[i] = rgData.rstepbuf[i] = rgData.routbuf[i] = 0.;\n\n        rgData.totsamp = 0;\n        rgData.lsum = rgData.rsum = 0.;\n        return retval;\n    }\n\n}\n\nmodule.exports = GainAnalysis;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL0dhaW5BbmFseXNpcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsK0VBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLGVBQWU7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xhbWVqcy9zcmMvanMvR2FpbkFuYWx5c2lzLmpzP2QxZTAiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqICBSZXBsYXlHYWluQW5hbHlzaXMgLSBhbmFseXplcyBpbnB1dCBzYW1wbGVzIGFuZCBnaXZlIHRoZSByZWNvbW1lbmRlZCBkQiBjaGFuZ2VcbiAqICBDb3B5cmlnaHQgKEMpIDIwMDEgRGF2aWQgUm9iaW5zb24gYW5kIEdsZW4gU2F3eWVyXG4gKiAgSW1wcm92ZW1lbnRzIGFuZCBvcHRpbWl6YXRpb25zIGFkZGVkIGJ5IEZyYW5rIEtsZW1tLCBhbmQgYnkgTWFyY2VsIE11bGxlciBcbiAqXG4gKiAgVGhpcyBsaWJyYXJ5IGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICogIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcbiAqICBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uOyBlaXRoZXJcbiAqICB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiAqXG4gKiAgVGhpcyBsaWJyYXJ5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gKiAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAqICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlIEdOVVxuICogIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcbiAqICBMaWNlbnNlIGFsb25nIHdpdGggdGhpcyBsaWJyYXJ5OyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4gKiAgRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlLCBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgIDAyMTExLTEzMDcgIFVTQVxuICpcbiAqICBjb25jZXB0IGFuZCBmaWx0ZXIgdmFsdWVzIGJ5IERhdmlkIFJvYmluc29uIChEYXZpZEBSb2JpbnNvbi5vcmcpXG4gKiAgICAtLSBibGFtZSBoaW0gaWYgeW91IHRoaW5rIHRoZSBpZGVhIGlzIGZsYXdlZFxuICogIG9yaWdpbmFsIGNvZGluZyBieSBHbGVuIFNhd3llciAobXAzZ2FpbkBob3RtYWlsLmNvbSlcbiAqICAgIC0tIGJsYW1lIGhpbSBpZiB5b3UgdGhpbmsgdGhpcyBydW5zIHRvbyBzbG93bHksIG9yIHRoZSBjb2RpbmcgaXMgb3RoZXJ3aXNlIGZsYXdlZFxuICpcbiAqICBsb3RzIG9mIGNvZGUgaW1wcm92ZW1lbnRzIGJ5IEZyYW5rIEtsZW1tICggaHR0cDovL3d3dy51bmktamVuYS5kZS9+cGZrL21wcC8gKVxuICogICAgLS0gY3JlZGl0IGhpbSBmb3IgYWxsIHRoZSBfZ29vZF8gcHJvZ3JhbW1pbmcgOylcbiAqXG4gKlxuICogIEZvciBhbiBleHBsYW5hdGlvbiBvZiB0aGUgY29uY2VwdHMgYW5kIHRoZSBiYXNpYyBhbGdvcml0aG1zIGludm9sdmVkLCBnbyB0bzpcbiAqICAgIGh0dHA6Ly93d3cucmVwbGF5Z2Fpbi5vcmcvXG4gKi9cblxuLypcbiAqICBIZXJlJ3MgdGhlIGRlYWwuIENhbGxcbiAqXG4gKiAgICBJbml0R2FpbkFuYWx5c2lzICggbG9uZyBzYW1wbGVmcmVxICk7XG4gKlxuICogIHRvIGluaXRpYWxpemUgZXZlcnl0aGluZy4gQ2FsbFxuICpcbiAqICAgIEFuYWx5emVTYW1wbGVzICggdmFyIEZsb2F0X3QqICBsZWZ0X3NhbXBsZXMsXG4gKiAgICAgICAgICAgICAgICAgICAgIHZhciBGbG9hdF90KiAgcmlnaHRfc2FtcGxlcyxcbiAqICAgICAgICAgICAgICAgICAgICAgc2l6ZV90ICAgICAgICAgIG51bV9zYW1wbGVzLFxuICogICAgICAgICAgICAgICAgICAgICBpbnQgICAgICAgICAgICAgbnVtX2NoYW5uZWxzICk7XG4gKlxuICogIGFzIG1hbnkgdGltZXMgYXMgeW91IHdhbnQsIHdpdGggYXMgbWFueSBvciBhcyBmZXcgc2FtcGxlcyBhcyB5b3Ugd2FudC5cbiAqICBJZiBtb25vLCBwYXNzIHRoZSBzYW1wbGUgYnVmZmVyIGluIHRocm91Z2ggbGVmdF9zYW1wbGVzLCBsZWF2ZVxuICogIHJpZ2h0X3NhbXBsZXMgTlVMTCwgYW5kIG1ha2Ugc3VyZSBudW1fY2hhbm5lbHMgPSAxLlxuICpcbiAqICAgIEdldFRpdGxlR2FpbigpXG4gKlxuICogIHdpbGwgcmV0dXJuIHRoZSByZWNvbW1lbmRlZCBkQiBsZXZlbCBjaGFuZ2UgZm9yIGFsbCBzYW1wbGVzIGFuYWx5emVkXG4gKiAgU0lOQ0UgVEhFIExBU1QgVElNRSB5b3UgY2FsbGVkIEdldFRpdGxlR2FpbigpIE9SIEluaXRHYWluQW5hbHlzaXMoKS5cbiAqXG4gKiAgICBHZXRBbGJ1bUdhaW4oKVxuICpcbiAqICB3aWxsIHJldHVybiB0aGUgcmVjb21tZW5kZWQgZEIgbGV2ZWwgY2hhbmdlIGZvciBhbGwgc2FtcGxlcyBhbmFseXplZFxuICogIHNpbmNlIEluaXRHYWluQW5hbHlzaXMoKSB3YXMgY2FsbGVkIGFuZCBmaW5hbGl6ZWQgd2l0aCBHZXRUaXRsZUdhaW4oKS5cbiAqXG4gKiAgUHNldWRvLWNvZGUgdG8gcHJvY2VzcyBhbiBhbGJ1bTpcbiAqXG4gKiAgICBGbG9hdF90ICAgICAgIGxfc2FtcGxlcyBbNDA5Nl07XG4gKiAgICBGbG9hdF90ICAgICAgIHJfc2FtcGxlcyBbNDA5Nl07XG4gKiAgICBzaXplX3QgICAgICAgIG51bV9zYW1wbGVzO1xuICogICAgdW5zaWduZWQgaW50ICBudW1fc29uZ3M7XG4gKiAgICB1bnNpZ25lZCBpbnQgIGk7XG4gKlxuICogICAgSW5pdEdhaW5BbmFseXNpcyAoIDQ0MTAwICk7XG4gKiAgICBmb3IgKCBpID0gMTsgaSA8PSBudW1fc29uZ3M7IGkrKyApIHtcbiAqICAgICAgICB3aGlsZSAoICggbnVtX3NhbXBsZXMgPSBnZXRTb25nU2FtcGxlcyAoIHNvbmdbaV0sIGxlZnRfc2FtcGxlcywgcmlnaHRfc2FtcGxlcyApICkgPiAwIClcbiAqICAgICAgICAgICAgQW5hbHl6ZVNhbXBsZXMgKCBsZWZ0X3NhbXBsZXMsIHJpZ2h0X3NhbXBsZXMsIG51bV9zYW1wbGVzLCAyICk7XG4gKiAgICAgICAgZnByaW50ZiAoXCJSZWNvbW1lbmRlZCBkQiBjaGFuZ2UgZm9yIHNvbmcgJTJkOiAlKzYuMiBkQlxcblwiLCBpLCBHZXRUaXRsZUdhaW4oKSApO1xuICogICAgfVxuICogICAgZnByaW50ZiAoXCJSZWNvbW1lbmRlZCBkQiBjaGFuZ2UgZm9yIHdob2xlIGFsYnVtOiAlKzYuMiBkQlxcblwiLCBHZXRBbGJ1bUdhaW4oKSApO1xuICovXG5cbi8qXG4gKiAgU28gaGVyZSdzIHRoZSBtYWluIHNvdXJjZSBvZiBwb3RlbnRpYWwgY29kZSBjb25mdXNpb246XG4gKlxuICogIFRoZSBmaWx0ZXJzIGFwcGxpZWQgdG8gdGhlIGluY29taW5nIHNhbXBsZXMgYXJlIElJUiBmaWx0ZXJzLFxuICogIG1lYW5pbmcgdGhleSByZWx5IG9uIHVwIHRvIDxmaWx0ZXIgb3JkZXI+IG51bWJlciBvZiBwcmV2aW91cyBzYW1wbGVzXG4gKiAgQU5EIHVwIHRvIDxmaWx0ZXIgb3JkZXI+IG51bWJlciBvZiBwcmV2aW91cyBmaWx0ZXJlZCBzYW1wbGVzLlxuICpcbiAqICBJIHNldCB1cCB0aGUgQW5hbHl6ZVNhbXBsZXMgcm91dGluZSB0byBtaW5pbWl6ZSBtZW1vcnkgdXNhZ2UgYW5kIGludGVyZmFjZVxuICogIGNvbXBsZXhpdHkuIFRoZSBzcGVlZCBpc24ndCBjb21wcm9taXNlZCB0b28gbXVjaCAoSSBkb24ndCB0aGluayksIGJ1dCB0aGVcbiAqICBpbnRlcm5hbCBjb21wbGV4aXR5IGlzIGhpZ2hlciB0aGFuIGl0IHNob3VsZCBiZSBmb3Igc3VjaCBhIHJlbGF0aXZlbHlcbiAqICBzaW1wbGUgcm91dGluZS5cbiAqXG4gKiAgT3B0aW1pemF0aW9uL2NsYXJpdHkgc3VnZ2VzdGlvbnMgYXJlIHdlbGNvbWUuXG4gKi9cbnZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbi5qcycpO1xudmFyIFN5c3RlbSA9IGNvbW1vbi5TeXN0ZW07XG52YXIgVmJyTW9kZSA9IGNvbW1vbi5WYnJNb2RlO1xudmFyIEZsb2F0ID0gY29tbW9uLkZsb2F0O1xudmFyIFNob3J0QmxvY2sgPSBjb21tb24uU2hvcnRCbG9jaztcbnZhciBVdGlsID0gY29tbW9uLlV0aWw7XG52YXIgQXJyYXlzID0gY29tbW9uLkFycmF5cztcbnZhciBuZXdfYXJyYXlfbiA9IGNvbW1vbi5uZXdfYXJyYXlfbjtcbnZhciBuZXdfYnl0ZSA9IGNvbW1vbi5uZXdfYnl0ZTtcbnZhciBuZXdfZG91YmxlID0gY29tbW9uLm5ld19kb3VibGU7XG52YXIgbmV3X2Zsb2F0ID0gY29tbW9uLm5ld19mbG9hdDtcbnZhciBuZXdfZmxvYXRfbiA9IGNvbW1vbi5uZXdfZmxvYXRfbjtcbnZhciBuZXdfaW50ID0gY29tbW9uLm5ld19pbnQ7XG52YXIgbmV3X2ludF9uID0gY29tbW9uLm5ld19pbnRfbjtcbnZhciBhc3NlcnQgPSBjb21tb24uYXNzZXJ0O1xuXG4vKipcbiAqIFRhYmxlIGVudHJpZXMgcGVyIGRCXG4gKi9cbkdhaW5BbmFseXNpcy5TVEVQU19wZXJfZEIgPSAxMDAuO1xuLyoqXG4gKiBUYWJsZSBlbnRyaWVzIGZvciAwLi4uTUFYX2RCIChub3JtYWwgbWF4LiB2YWx1ZXMgYXJlIDcwLi4uODAgZEIpXG4gKi9cbkdhaW5BbmFseXNpcy5NQVhfZEIgPSAxMjAuO1xuR2FpbkFuYWx5c2lzLkdBSU5fTk9UX0VOT1VHSF9TQU1QTEVTID0gLTI0NjAxO1xuR2FpbkFuYWx5c2lzLkdBSU5fQU5BTFlTSVNfRVJST1IgPSAwO1xuR2FpbkFuYWx5c2lzLkdBSU5fQU5BTFlTSVNfT0sgPSAxO1xuR2FpbkFuYWx5c2lzLklOSVRfR0FJTl9BTkFMWVNJU19FUlJPUiA9IDA7XG5HYWluQW5hbHlzaXMuSU5JVF9HQUlOX0FOQUxZU0lTX09LID0gMTtcblxuR2FpbkFuYWx5c2lzLllVTEVfT1JERVIgPSAxMDtcbkdhaW5BbmFseXNpcy5NQVhfT1JERVIgPSBHYWluQW5hbHlzaXMuWVVMRV9PUkRFUjtcblxuR2FpbkFuYWx5c2lzLk1BWF9TQU1QX0ZSRVEgPSA0ODAwMDtcbkdhaW5BbmFseXNpcy5STVNfV0lORE9XX1RJTUVfTlVNRVJBVE9SID0gMTtcbkdhaW5BbmFseXNpcy5STVNfV0lORE9XX1RJTUVfREVOT01JTkFUT1IgPSAyMDtcbkdhaW5BbmFseXNpcy5NQVhfU0FNUExFU19QRVJfV0lORE9XID0gKChHYWluQW5hbHlzaXMuTUFYX1NBTVBfRlJFUSAqIEdhaW5BbmFseXNpcy5STVNfV0lORE9XX1RJTUVfTlVNRVJBVE9SKSAvIEdhaW5BbmFseXNpcy5STVNfV0lORE9XX1RJTUVfREVOT01JTkFUT1IgKyAxKTtcblxuZnVuY3Rpb24gR2FpbkFuYWx5c2lzKCkge1xuICAgIC8qKlxuICAgICAqIGNhbGlicmF0aW9uIHZhbHVlIGZvciA4OWRCXG4gICAgICovXG4gICAgdmFyIFBJTktfUkVGID0gNjQuODI7XG5cbiAgICB2YXIgWVVMRV9PUkRFUiA9IEdhaW5BbmFseXNpcy5ZVUxFX09SREVSO1xuICAgIC8qKlxuICAgICAqIHBlcmNlbnRpbGUgd2hpY2ggaXMgbG91ZGVyIHRoYW4gdGhlIHByb3Bvc2VkIGxldmVsXG4gICAgICovXG4gICAgdmFyIFJNU19QRVJDRU5USUxFID0gMC45NTtcbiAgICAvKipcbiAgICAgKiBtYXhpbXVtIGFsbG93ZWQgc2FtcGxlIGZyZXF1ZW5jeSBbSHpdXG4gICAgICovXG4gICAgdmFyIE1BWF9TQU1QX0ZSRVEgPSBHYWluQW5hbHlzaXMuTUFYX1NBTVBfRlJFUTtcbiAgICB2YXIgUk1TX1dJTkRPV19USU1FX05VTUVSQVRPUiA9IEdhaW5BbmFseXNpcy5STVNfV0lORE9XX1RJTUVfTlVNRVJBVE9SO1xuICAgIC8qKlxuICAgICAqIG51bWVyYXRvciAvIGRlbm9taW5hdG9yID0gdGltZSBzbGljZSBzaXplIFtzXVxuICAgICAqL1xuICAgIHZhciBSTVNfV0lORE9XX1RJTUVfREVOT01JTkFUT1IgPSBHYWluQW5hbHlzaXMuUk1TX1dJTkRPV19USU1FX0RFTk9NSU5BVE9SO1xuICAgIC8qKlxuICAgICAqIG1heC4gU2FtcGxlcyBwZXIgVGltZSBzbGljZVxuICAgICAqL1xuICAgIHZhciBNQVhfU0FNUExFU19QRVJfV0lORE9XID0gR2FpbkFuYWx5c2lzLk1BWF9TQU1QTEVTX1BFUl9XSU5ET1c7XG5cblxuICAgIHZhciBBQll1bGUgPSBbXG4gICAgICAgIFswLjAzODU3NTk5NDM1MjAwLCAtMy44NDY2NDYxNzExODA2NywgLTAuMDIxNjAzNjcxODQxODUsXG4gICAgICAgICAgICA3LjgxNTAxNjUzMDA1NTM4LCAtMC4wMDEyMzM5NTMxNjg1MSwgLTExLjM0MTcwMzU1MTMyMDQyLFxuICAgICAgICAgICAgLTAuMDAwMDkyOTE2Nzc5NTksIDEzLjA1NTA0MjE5MzI3NTQ1LCAtMC4wMTY1NTI2MDM0MTYxOSxcbiAgICAgICAgICAgIC0xMi4yODc1OTg5NTE0NTI5NCwgMC4wMjE2MTUyNjg0MzI3NCwgOS40ODI5MzgwNjMxOTc5MCxcbiAgICAgICAgICAgIC0wLjAyMDc0MDQ1MjE1Mjg1LCAtNS44NzI1Nzg2MTc3NTk5OSwgMC4wMDU5NDI5ODA2NTEyNSxcbiAgICAgICAgICAgIDIuNzU0NjU4NjE4NzQ2MTMsIDAuMDAzMDY0MjgwMjMxOTEsIC0wLjg2OTg0Mzc2NTkzNTUxLFxuICAgICAgICAgICAgMC4wMDAxMjAyNTMyMjAyNywgMC4xMzkxOTMxNDU2NzQzMiwgMC4wMDI4ODQ2MzY4MzkxNl0sXG4gICAgICAgIFswLjA1NDE4NjU2NDA2NDMwLCAtMy40Nzg0NTk0ODU1MDA3MSwgLTAuMDI5MTEwMDc4MDg5NDgsXG4gICAgICAgICAgICA2LjM2MzE3Nzc3NTY2MTQ4LCAtMC4wMDg0ODcwOTM3OTg1MSwgLTguNTQ3NTE1Mjc0NzE4NzQsXG4gICAgICAgICAgICAtMC4wMDg1MTE2NTY0NTQ2OSwgOS40NzY5MzYwNzgwMTI4MCwgLTAuMDA4MzQ5OTA5MDQ5MzYsXG4gICAgICAgICAgICAtOC44MTQ5ODY4MTM3MDE1NSwgMC4wMjI0NTI5MzI1MzMzOSwgNi44NTQwMTU0MDkzNjk5OCxcbiAgICAgICAgICAgIC0wLjAyNTk2MzM4NTEyOTE1LCAtNC4zOTQ3MDk5NjA3OTU1OSwgMC4wMTYyNDg2NDk2Mjk3NSxcbiAgICAgICAgICAgIDIuMTk2MTE2ODQ4OTA3NzQsIC0wLjAwMjQwODc5MDUxNTg0LCAtMC43NTEwNDMwMjQ1MTQzMixcbiAgICAgICAgICAgIDAuMDA2NzQ2MTM2ODIyNDcsIDAuMTMxNDkzMTc5NTg4MDgsIC0wLjAwMTg3NzYzNzc3MzYyXSxcbiAgICAgICAgWzAuMTU0NTcyOTk2ODE5MjQsIC0yLjM3ODk4ODM0OTczMDg0LCAtMC4wOTMzMTA0OTA1NjMxNSxcbiAgICAgICAgICAgIDIuODQ4NjgxNTExNTYzMjcsIC0wLjA2MjQ3ODgwMTUzNjUzLCAtMi42NDU3NzE3MDIyOTgyNSxcbiAgICAgICAgICAgIDAuMDIxNjM1NDE4ODg3OTgsIDIuMjM2OTc2NTc0NTE3MTMsIC0wLjA1NTg4MzkzMzI5ODU2LFxuICAgICAgICAgICAgLTEuNjcxNDgxNTMzNjc2MDIsIDAuMDQ3ODE0NzY2NzQ5MjEsIDEuMDA1OTU5NTQ4MDg1NDcsXG4gICAgICAgICAgICAwLjAwMjIyMzEyNTk3NzQzLCAtMC40NTk1MzQ1ODA1NDk4MywgMC4wMzE3NDA5MjU0MDA0OSxcbiAgICAgICAgICAgIDAuMTYzNzgxNjQ4NTg1OTYsIC0wLjAxMzkwNTg5NDIxODk4LCAtMC4wNTAzMjA3NzcxNzEzMSxcbiAgICAgICAgICAgIDAuMDA2NTE0MjA2Njc4MzEsIDAuMDIzNDc4OTc0MDcwMjAsIC0wLjAwODgxMzYyNzMzODM5XSxcbiAgICAgICAgWzAuMzAyOTY5MDczMTkzMjcsIC0xLjYxMjczMTY1MTM3MjQ3LCAtMC4yMjYxMzk4ODY4MjEyMyxcbiAgICAgICAgICAgIDEuMDc5Nzc0OTIyNTk5NzAsIC0wLjA4NTg3MzIzNzMwNzcyLCAtMC4yNTY1NjI1Nzc1NDA3MCxcbiAgICAgICAgICAgIDAuMDMyODI5MzAxNzI2NjQsIC0wLjE2Mjc2NzE5MTIwNDQwLCAtMC4wMDkxNTcwMjkzMzQzNCxcbiAgICAgICAgICAgIC0wLjIyNjM4ODkzNzczOTA2LCAtMC4wMjM2NDE0MTIwMjUyMiwgMC4zOTEyMDgwMDc4ODI4NCxcbiAgICAgICAgICAgIC0wLjAwNTg0NDU2MDM5OTEzLCAtMC4yMjEzODEzODk1NDkyNSwgMC4wNjI3NjEwMTMyMTc0OSxcbiAgICAgICAgICAgIDAuMDQ1MDAyMzUzODczNTIsIC0wLjAwMDAwODI4MDg2NzQ4LCAwLjAyMDA1ODUxODA2NTAxLFxuICAgICAgICAgICAgMC4wMDIwNTg2MTg4NTU2NCwgMC4wMDMwMjQzOTA5NTc0MSwgLTAuMDI5NTAxMzQ5ODMyODddLFxuICAgICAgICBbMC4zMzY0MjMwNDg1NjEzMiwgLTEuNDk4NTg5NzkzNjc3OTksIC0wLjI1NTcyMjQxNDI1NTcwLFxuICAgICAgICAgICAgMC44NzM1MDI3MTQxODE4OCwgLTAuMTE4Mjg1NzAxNzc1NTUsIDAuMTIyMDUwMjIzMDgwODQsXG4gICAgICAgICAgICAwLjExOTIxMTQ4Njc1MjAzLCAtMC44MDc3NDk0NDY3MTQzOCwgLTAuMDc4MzQ0ODk2MDk0NzksXG4gICAgICAgICAgICAwLjQ3ODU0Nzk0NTYyMzI2LCAtMC4wMDQ2OTk3NzkxNDM4MCwgLTAuMTI0NTM0NTgxNDAwMTksXG4gICAgICAgICAgICAtMC4wMDU4OTUwMDIyNDQ0MCwgLTAuMDQwNjc1MTAxOTcwMTQsIDAuMDU3MjQyMjgxNDAzNTEsXG4gICAgICAgICAgICAwLjA4MzMzNzU1Mjg0MTA3LCAwLjAwODMyMDQzOTgwNzczLCAtMC4wNDIzNzM0ODAyNTc0NixcbiAgICAgICAgICAgIC0wLjAxNjM1MzgxMzg0NTQwLCAwLjAyOTc3MjA3MzE5OTI1LCAtMC4wMTc2MDE3NjU2ODE1MF0sXG4gICAgICAgIFswLjQ0OTE1MjU2NjA4NDUwLCAtMC42MjgyMDYxOTIzMzY3MSwgLTAuMTQzNTE3NTc0NjQ1NDcsXG4gICAgICAgICAgICAwLjI5NjYxNzgzNzA2MzY2LCAtMC4yMjc4NDM5NDQyOTc0OSwgLTAuMzcyNTYzNzI5NDI0MDAsXG4gICAgICAgICAgICAtMC4wMTQxOTE0MDEwMDU1MSwgMC4wMDIxMzc2Nzg1NzEyNCwgMC4wNDA3ODI2Mjc5NzEzOSxcbiAgICAgICAgICAgIC0wLjQyMDI5ODIwMTcwOTE4LCAtMC4xMjM5ODE2MzM4MTc0OCwgMC4yMjE5OTY1MDU2NDgyNCxcbiAgICAgICAgICAgIDAuMDQwOTc1NjUxMzU2NDgsIDAuMDA2MTM0MjQzNTA2ODIsIDAuMTA0Nzg1MDM2MDAyNTEsXG4gICAgICAgICAgICAwLjA2NzQ3NjIwNzQ0NjgzLCAtMC4wMTg2Mzg4NzgxMDkyNywgMC4wNTc4NDgyMDM3NTgwMSxcbiAgICAgICAgICAgIC0wLjAzMTkzNDI4NDM4OTE1LCAwLjAzMjIyNzU0MDcyMTczLCAwLjAwNTQxOTA3NzQ4NzA3XSxcbiAgICAgICAgWzAuNTY2MTk0NzA3NTc2NDEsIC0xLjA0ODAwMzM1MTI2MzQ5LCAtMC43NTQ2NDQ1NjkzOTMwMixcbiAgICAgICAgICAgIDAuMjkxNTYzMTE5NzEyNDksIDAuMTYyNDIxMzc3NDIyMzAsIC0wLjI2ODA2MDAxMDQyOTQ3LFxuICAgICAgICAgICAgMC4xNjc0NDI0MzQ5MzY3MiwgMC4wMDgxOTk5OTY0NTg1OCwgLTAuMTg5MDE2MDQxOTk2MDksXG4gICAgICAgICAgICAwLjQ1MDU0NzM0NTA1MDA4LCAwLjMwOTMxNzgyODQxODMwLCAtMC4zMzAzMjQwMzMxNDAwNixcbiAgICAgICAgICAgIC0wLjI3NTYyOTYxOTg2MjI0LCAwLjA2NzM5MzY4MzMzMTEwLCAwLjAwNjQ3MzEwNjc3MjQ2LFxuICAgICAgICAgICAgLTAuMDQ3ODQyNTQyMjkwMzMsIDAuMDg2NDc1MDM3ODAzNTEsIDAuMDE2Mzk5MDc4MzYxODksXG4gICAgICAgICAgICAtMC4wMzc4ODk4NDU1NDg0MCwgMC4wMTgwNzM2NDMyMzU3MywgLTAuMDA1ODgyMTU0NDM0MjFdLFxuICAgICAgICBbMC41ODEwMDQ5NDk2MDU1MywgLTAuNTEwMzUzMjcwOTUxODQsIC0wLjUzMTc0OTA5MDU4NTc4LFxuICAgICAgICAgICAgLTAuMzE4NjM1NjMzMjUyNDUsIC0wLjE0Mjg5Nzk5MDM0MjUzLCAtMC4yMDI1NjQxMzQ4NDQ3NyxcbiAgICAgICAgICAgIDAuMTc1MjA3MDQ4MzU1MjIsIDAuMTQ3MjgxNTQxMzQzMzAsIDAuMDIzNzc5NDUyMTc2MTUsXG4gICAgICAgICAgICAwLjM4OTUyNjM5OTc4OTk5LCAwLjE1NTU4NDQ5MTM1NTczLCAtMC4yMzMxMzI3MTg4MDg2OCxcbiAgICAgICAgICAgIC0wLjI1MzQ0NzkwMDU5MzUzLCAtMC4wNTI0NjAxOTAyNDQ2MywgMC4wMTYyODQ2MjQwNjMzMyxcbiAgICAgICAgICAgIC0wLjAyNTA1OTYxNzI0MDUzLCAwLjA2OTIwNDY3NzYzOTU5LCAwLjAyNDQyMzU3MzE2MDk5LFxuICAgICAgICAgICAgLTAuMDM3MjE2MTEzOTU4MDEsIDAuMDE4MTg4MDExMTE1MDMsIC0wLjAwNzQ5NjE4Nzk3MTcyXSxcbiAgICAgICAgWzAuNTM2NDg3ODkyNTUxMDUsIC0wLjI1MDQ5ODcxOTU2MDIwLCAtMC40MjE2MzAzNDM1MDY5NixcbiAgICAgICAgICAgIC0wLjQzMTkzOTQyMzExMTE0LCAtMC4wMDI3NTk1MzYxMTkyOSwgLTAuMDM0MjQ2ODEwMTc2NzUsXG4gICAgICAgICAgICAwLjA0MjY3ODQyMjE5NDE1LCAtMC4wNDY3ODMyODc4NDI0MiwgLTAuMTAyMTQ4NjQxNzk2NzYsXG4gICAgICAgICAgICAwLjI2NDA4MzAwMjAwOTU1LCAwLjE0NTkwNzcyMjg5Mzg4LCAwLjE1MTEzMTMwNTMzMjE2LFxuICAgICAgICAgICAgLTAuMDI0NTk4NjQ4NTkzNDUsIC0wLjE3NTU2NDkzMzY2NDQ5LCAtMC4xMTIwMjMxNTE5NTM4OCxcbiAgICAgICAgICAgIC0wLjE4ODIzMDA5MjYyMTE1LCAtMC4wNDA2MDAzNDEyNzAwMCwgMC4wNTQ3NzcyMDQyODY3NCxcbiAgICAgICAgICAgIDAuMDQ3ODg2NjU1NDgxODAsIDAuMDQ3MDQ0MDk2ODgxMjAsIC0wLjAyMjE3OTM2ODAxMTM0XV07XG5cbiAgICB2YXIgQUJCdXR0ZXIgPSBbXG4gICAgICAgIFswLjk4NjIxMTkyNDYyNzA4LCAtMS45NzIyMzM3MjkxOTUyNywgLTEuOTcyNDIzODQ5MjU0MTYsXG4gICAgICAgICAgICAwLjk3MjYxMzk2OTMxMzA2LCAwLjk4NjIxMTkyNDYyNzA4XSxcbiAgICAgICAgWzAuOTg1MDAxNzU3ODcyNDIsIC0xLjk2OTc3ODU1NTgyNjE4LCAtMS45NzAwMDM1MTU3NDQ4NCxcbiAgICAgICAgICAgIDAuOTcwMjI4NDc1NjYzNTAsIDAuOTg1MDAxNzU3ODcyNDJdLFxuICAgICAgICBbMC45NzkzODkzMjczNTIxNCwgLTEuOTU4MzUzODA5NzUzOTgsIC0xLjk1ODc3ODY1NDcwNDI4LFxuICAgICAgICAgICAgMC45NTkyMDM0OTk2NTQ1OSwgMC45NzkzODkzMjczNTIxNF0sXG4gICAgICAgIFswLjk3NTMxODQzMjA0OTI4LCAtMS45NTAwMjc1OTE0OTg3OCwgLTEuOTUwNjM2ODY0MDk4NTcsXG4gICAgICAgICAgICAwLjk1MTI0NjEzNjY5ODM1LCAwLjk3NTMxODQzMjA0OTI4XSxcbiAgICAgICAgWzAuOTczMTY1MjM0OTgxNjEsIC0xLjk0NTYxMDIzNTY2NTI3LCAtMS45NDYzMzA0Njk5NjMyMyxcbiAgICAgICAgICAgIDAuOTQ3MDUwNzA0MjYxMTgsIDAuOTczMTY1MjM0OTgxNjFdLFxuICAgICAgICBbMC45NjQ1NDUxNTU1MjgyNiwgLTEuOTI3ODMyODY5NzcwMzYsIC0xLjkyOTA5MDMxMTA1NjUyLFxuICAgICAgICAgICAgMC45MzAzNDc3NTIzNDI2OCwgMC45NjQ1NDUxNTU1MjgyNl0sXG4gICAgICAgIFswLjk2MDA5MTQyOTUwNTQxLCAtMS45MTg1ODk1MzAzMzc4NCwgLTEuOTIwMTgyODU5MDEwODIsXG4gICAgICAgICAgICAwLjkyMTc3NjE4NzY4MzgxLCAwLjk2MDA5MTQyOTUwNTQxXSxcbiAgICAgICAgWzAuOTU4NTY5MTY1OTk2MDEsIC0xLjkxNTQyMTA4MDc0NzgwLCAtMS45MTcxMzgzMzE5OTIwMyxcbiAgICAgICAgICAgIDAuOTE4ODU1NTgzMjM2MjUsIDAuOTU4NTY5MTY1OTk2MDFdLFxuICAgICAgICBbMC45NDU5NzY4NTYwMDI3OSwgLTEuODg5MDMzMDc5Mzk0NTIsIC0xLjg5MTk1MzcxMjAwNTU4LFxuICAgICAgICAgICAgMC44OTQ4NzQzNDQ2MTY2NCwgMC45NDU5NzY4NTYwMDI3OV1dO1xuXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGNhbGxpbmcgdGhpcyBwcm9jZWR1cmUsIG1ha2Ugc3VyZSB0aGF0IGlwWy1vcmRlcl0gYW5kIG9wWy1vcmRlcl1cbiAgICAgKiBwb2ludCB0byByZWFsIGRhdGFcbiAgICAgKi9cbiAgICAvL3ByaXZhdGUgdm9pZCBmaWx0ZXJZdWxlKGZpbmFsIGZsb2F0W10gaW5wdXQsIGludCBpbnB1dFBvcywgZmxvYXRbXSBvdXRwdXQsXG4gICAgLy9pbnQgb3V0cHV0UG9zLCBpbnQgblNhbXBsZXMsIGZpbmFsIGZsb2F0W10ga2VybmVsKSB7XG4gICAgZnVuY3Rpb24gZmlsdGVyWXVsZShpbnB1dCwgaW5wdXRQb3MsIG91dHB1dCwgb3V0cHV0UG9zLCBuU2FtcGxlcywga2VybmVsKSB7XG5cbiAgICAgICAgd2hpbGUgKChuU2FtcGxlcy0tKSAhPSAwKSB7XG4gICAgICAgICAgICAvKiAxZS0xMCBpcyBhIGhhY2sgdG8gYXZvaWQgc2xvd2Rvd24gYmVjYXVzZSBvZiBkZW5vcm1hbHMgKi9cbiAgICAgICAgICAgIG91dHB1dFtvdXRwdXRQb3NdID0gMWUtMTAgKyBpbnB1dFtpbnB1dFBvcyArIDBdICoga2VybmVsWzBdXG4gICAgICAgICAgICAgICAgLSBvdXRwdXRbb3V0cHV0UG9zIC0gMV0gKiBrZXJuZWxbMV0gKyBpbnB1dFtpbnB1dFBvcyAtIDFdXG4gICAgICAgICAgICAgICAgKiBrZXJuZWxbMl0gLSBvdXRwdXRbb3V0cHV0UG9zIC0gMl0gKiBrZXJuZWxbM11cbiAgICAgICAgICAgICAgICArIGlucHV0W2lucHV0UG9zIC0gMl0gKiBrZXJuZWxbNF0gLSBvdXRwdXRbb3V0cHV0UG9zIC0gM11cbiAgICAgICAgICAgICAgICAqIGtlcm5lbFs1XSArIGlucHV0W2lucHV0UG9zIC0gM10gKiBrZXJuZWxbNl1cbiAgICAgICAgICAgICAgICAtIG91dHB1dFtvdXRwdXRQb3MgLSA0XSAqIGtlcm5lbFs3XSArIGlucHV0W2lucHV0UG9zIC0gNF1cbiAgICAgICAgICAgICAgICAqIGtlcm5lbFs4XSAtIG91dHB1dFtvdXRwdXRQb3MgLSA1XSAqIGtlcm5lbFs5XVxuICAgICAgICAgICAgICAgICsgaW5wdXRbaW5wdXRQb3MgLSA1XSAqIGtlcm5lbFsxMF0gLSBvdXRwdXRbb3V0cHV0UG9zIC0gNl1cbiAgICAgICAgICAgICAgICAqIGtlcm5lbFsxMV0gKyBpbnB1dFtpbnB1dFBvcyAtIDZdICoga2VybmVsWzEyXVxuICAgICAgICAgICAgICAgIC0gb3V0cHV0W291dHB1dFBvcyAtIDddICoga2VybmVsWzEzXSArIGlucHV0W2lucHV0UG9zIC0gN11cbiAgICAgICAgICAgICAgICAqIGtlcm5lbFsxNF0gLSBvdXRwdXRbb3V0cHV0UG9zIC0gOF0gKiBrZXJuZWxbMTVdXG4gICAgICAgICAgICAgICAgKyBpbnB1dFtpbnB1dFBvcyAtIDhdICoga2VybmVsWzE2XSAtIG91dHB1dFtvdXRwdXRQb3MgLSA5XVxuICAgICAgICAgICAgICAgICoga2VybmVsWzE3XSArIGlucHV0W2lucHV0UG9zIC0gOV0gKiBrZXJuZWxbMThdXG4gICAgICAgICAgICAgICAgLSBvdXRwdXRbb3V0cHV0UG9zIC0gMTBdICoga2VybmVsWzE5XVxuICAgICAgICAgICAgICAgICsgaW5wdXRbaW5wdXRQb3MgLSAxMF0gKiBrZXJuZWxbMjBdO1xuICAgICAgICAgICAgKytvdXRwdXRQb3M7XG4gICAgICAgICAgICArK2lucHV0UG9zO1xuICAgICAgICB9XG4gICAgfVxuXG4vL3ByaXZhdGUgdm9pZCBmaWx0ZXJCdXR0ZXIoZmluYWwgZmxvYXRbXSBpbnB1dCwgaW50IGlucHV0UG9zLFxuLy8gICAgZmxvYXRbXSBvdXRwdXQsIGludCBvdXRwdXRQb3MsIGludCBuU2FtcGxlcywgZmluYWwgZmxvYXRbXSBrZXJuZWwpIHtcbiAgICBmdW5jdGlvbiBmaWx0ZXJCdXR0ZXIoaW5wdXQsIGlucHV0UG9zLCBvdXRwdXQsIG91dHB1dFBvcywgblNhbXBsZXMsIGtlcm5lbCkge1xuXG4gICAgICAgIHdoaWxlICgoblNhbXBsZXMtLSkgIT0gMCkge1xuICAgICAgICAgICAgb3V0cHV0W291dHB1dFBvc10gPSBpbnB1dFtpbnB1dFBvcyArIDBdICoga2VybmVsWzBdXG4gICAgICAgICAgICAgICAgLSBvdXRwdXRbb3V0cHV0UG9zIC0gMV0gKiBrZXJuZWxbMV0gKyBpbnB1dFtpbnB1dFBvcyAtIDFdXG4gICAgICAgICAgICAgICAgKiBrZXJuZWxbMl0gLSBvdXRwdXRbb3V0cHV0UG9zIC0gMl0gKiBrZXJuZWxbM11cbiAgICAgICAgICAgICAgICArIGlucHV0W2lucHV0UG9zIC0gMl0gKiBrZXJuZWxbNF07XG4gICAgICAgICAgICArK291dHB1dFBvcztcbiAgICAgICAgICAgICsraW5wdXRQb3M7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIElOSVRfR0FJTl9BTkFMWVNJU19PSyBpZiBzdWNjZXNzZnVsLCBJTklUX0dBSU5fQU5BTFlTSVNfRVJST1IgaWZcbiAgICAgKiAgICAgICAgIG5vdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlc2V0U2FtcGxlRnJlcXVlbmN5KHJnRGF0YSwgc2FtcGxlZnJlcSkge1xuICAgICAgICAvKiB6ZXJvIG91dCBpbml0aWFsIHZhbHVlcyAqL1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE1BWF9PUkRFUjsgaSsrKVxuICAgICAgICAgICAgcmdEYXRhLmxpbnByZWJ1ZltpXSA9IHJnRGF0YS5sc3RlcGJ1ZltpXSA9IHJnRGF0YS5sb3V0YnVmW2ldID0gcmdEYXRhLnJpbnByZWJ1ZltpXSA9IHJnRGF0YS5yc3RlcGJ1ZltpXSA9IHJnRGF0YS5yb3V0YnVmW2ldID0gMC47XG5cbiAgICAgICAgc3dpdGNoICgwIHwgKHNhbXBsZWZyZXEpKSB7XG4gICAgICAgICAgICBjYXNlIDQ4MDAwOlxuICAgICAgICAgICAgICAgIHJnRGF0YS5yZXFpbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ0MTAwOlxuICAgICAgICAgICAgICAgIHJnRGF0YS5yZXFpbmRleCA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDMyMDAwOlxuICAgICAgICAgICAgICAgIHJnRGF0YS5yZXFpbmRleCA9IDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI0MDAwOlxuICAgICAgICAgICAgICAgIHJnRGF0YS5yZXFpbmRleCA9IDM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDIyMDUwOlxuICAgICAgICAgICAgICAgIHJnRGF0YS5yZXFpbmRleCA9IDQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE2MDAwOlxuICAgICAgICAgICAgICAgIHJnRGF0YS5yZXFpbmRleCA9IDU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEyMDAwOlxuICAgICAgICAgICAgICAgIHJnRGF0YS5yZXFpbmRleCA9IDY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDExMDI1OlxuICAgICAgICAgICAgICAgIHJnRGF0YS5yZXFpbmRleCA9IDc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDgwMDA6XG4gICAgICAgICAgICAgICAgcmdEYXRhLnJlcWluZGV4ID0gODtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIElOSVRfR0FJTl9BTkFMWVNJU19FUlJPUjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJnRGF0YS5zYW1wbGVXaW5kb3cgPSAwIHwgKChzYW1wbGVmcmVxICogUk1TX1dJTkRPV19USU1FX05VTUVSQVRPUlxuICAgICAgICAgICAgKyBSTVNfV0lORE9XX1RJTUVfREVOT01JTkFUT1IgLSAxKSAvIFJNU19XSU5ET1dfVElNRV9ERU5PTUlOQVRPUik7XG5cbiAgICAgICAgcmdEYXRhLmxzdW0gPSAwLjtcbiAgICAgICAgcmdEYXRhLnJzdW0gPSAwLjtcbiAgICAgICAgcmdEYXRhLnRvdHNhbXAgPSAwO1xuXG4gICAgICAgIEFycmF5cy5pbGwocmdEYXRhLkEsIDApO1xuXG4gICAgICAgIHJldHVybiBJTklUX0dBSU5fQU5BTFlTSVNfT0s7XG4gICAgfVxuXG4gICAgdGhpcy5Jbml0R2FpbkFuYWx5c2lzID0gZnVuY3Rpb24gKHJnRGF0YSwgc2FtcGxlZnJlcSkge1xuICAgICAgICBpZiAoUmVzZXRTYW1wbGVGcmVxdWVuY3kocmdEYXRhLCBzYW1wbGVmcmVxKSAhPSBJTklUX0dBSU5fQU5BTFlTSVNfT0spIHtcbiAgICAgICAgICAgIHJldHVybiBJTklUX0dBSU5fQU5BTFlTSVNfRVJST1I7XG4gICAgICAgIH1cblxuICAgICAgICByZ0RhdGEubGlucHJlID0gTUFYX09SREVSO1xuICAgICAgICByZ0RhdGEucmlucHJlID0gTUFYX09SREVSO1xuICAgICAgICByZ0RhdGEubHN0ZXAgPSBNQVhfT1JERVI7XG4gICAgICAgIHJnRGF0YS5yc3RlcCA9IE1BWF9PUkRFUjtcbiAgICAgICAgcmdEYXRhLmxvdXQgPSBNQVhfT1JERVI7XG4gICAgICAgIHJnRGF0YS5yb3V0ID0gTUFYX09SREVSO1xuXG4gICAgICAgIEFycmF5cy5maWxsKHJnRGF0YS5CLCAwKTtcblxuICAgICAgICByZXR1cm4gSU5JVF9HQUlOX0FOQUxZU0lTX09LO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzcXVhcmVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmc3FyKGQpIHtcbiAgICAgICAgcmV0dXJuIGQgKiBkO1xuICAgIH1cblxuICAgIHRoaXMuQW5hbHl6ZVNhbXBsZXMgPSBmdW5jdGlvbiAocmdEYXRhLCBsZWZ0X3NhbXBsZXMsIGxlZnRfc2FtcGxlc1BvcywgcmlnaHRfc2FtcGxlcywgcmlnaHRfc2FtcGxlc1BvcywgbnVtX3NhbXBsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1fY2hhbm5lbHMpIHtcbiAgICAgICAgdmFyIGN1cmxlZnQ7XG4gICAgICAgIHZhciBjdXJsZWZ0QmFzZTtcbiAgICAgICAgdmFyIGN1cnJpZ2h0O1xuICAgICAgICB2YXIgY3VycmlnaHRCYXNlO1xuICAgICAgICB2YXIgYmF0Y2hzYW1wbGVzO1xuICAgICAgICB2YXIgY3Vyc2FtcGxlcztcbiAgICAgICAgdmFyIGN1cnNhbXBsZXBvcztcblxuICAgICAgICBpZiAobnVtX3NhbXBsZXMgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBHQUlOX0FOQUxZU0lTX09LO1xuXG4gICAgICAgIGN1cnNhbXBsZXBvcyA9IDA7XG4gICAgICAgIGJhdGNoc2FtcGxlcyA9IG51bV9zYW1wbGVzO1xuXG4gICAgICAgIHN3aXRjaCAobnVtX2NoYW5uZWxzKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmlnaHRfc2FtcGxlcyA9IGxlZnRfc2FtcGxlcztcbiAgICAgICAgICAgICAgICByaWdodF9zYW1wbGVzUG9zID0gbGVmdF9zYW1wbGVzUG9zO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gR0FJTl9BTkFMWVNJU19FUlJPUjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChudW1fc2FtcGxlcyA8IE1BWF9PUkRFUikge1xuICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weShsZWZ0X3NhbXBsZXMsIGxlZnRfc2FtcGxlc1BvcywgcmdEYXRhLmxpbnByZWJ1ZixcbiAgICAgICAgICAgICAgICBNQVhfT1JERVIsIG51bV9zYW1wbGVzKTtcbiAgICAgICAgICAgIFN5c3RlbS5hcnJheWNvcHkocmlnaHRfc2FtcGxlcywgcmlnaHRfc2FtcGxlc1BvcywgcmdEYXRhLnJpbnByZWJ1ZixcbiAgICAgICAgICAgICAgICBNQVhfT1JERVIsIG51bV9zYW1wbGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFN5c3RlbS5hcnJheWNvcHkobGVmdF9zYW1wbGVzLCBsZWZ0X3NhbXBsZXNQb3MsIHJnRGF0YS5saW5wcmVidWYsXG4gICAgICAgICAgICAgICAgTUFYX09SREVSLCBNQVhfT1JERVIpO1xuICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weShyaWdodF9zYW1wbGVzLCByaWdodF9zYW1wbGVzUG9zLCByZ0RhdGEucmlucHJlYnVmLFxuICAgICAgICAgICAgICAgIE1BWF9PUkRFUiwgTUFYX09SREVSKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChiYXRjaHNhbXBsZXMgPiAwKSB7XG4gICAgICAgICAgICBjdXJzYW1wbGVzID0gYmF0Y2hzYW1wbGVzID4gcmdEYXRhLnNhbXBsZVdpbmRvdyAtIHJnRGF0YS50b3RzYW1wID8gcmdEYXRhLnNhbXBsZVdpbmRvd1xuICAgICAgICAgICAgLSByZ0RhdGEudG90c2FtcFxuICAgICAgICAgICAgICAgIDogYmF0Y2hzYW1wbGVzO1xuICAgICAgICAgICAgaWYgKGN1cnNhbXBsZXBvcyA8IE1BWF9PUkRFUikge1xuICAgICAgICAgICAgICAgIGN1cmxlZnQgPSByZ0RhdGEubGlucHJlICsgY3Vyc2FtcGxlcG9zO1xuICAgICAgICAgICAgICAgIGN1cmxlZnRCYXNlID0gcmdEYXRhLmxpbnByZWJ1ZjtcbiAgICAgICAgICAgICAgICBjdXJyaWdodCA9IHJnRGF0YS5yaW5wcmUgKyBjdXJzYW1wbGVwb3M7XG4gICAgICAgICAgICAgICAgY3VycmlnaHRCYXNlID0gcmdEYXRhLnJpbnByZWJ1ZjtcbiAgICAgICAgICAgICAgICBpZiAoY3Vyc2FtcGxlcyA+IE1BWF9PUkRFUiAtIGN1cnNhbXBsZXBvcylcbiAgICAgICAgICAgICAgICAgICAgY3Vyc2FtcGxlcyA9IE1BWF9PUkRFUiAtIGN1cnNhbXBsZXBvcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VybGVmdCA9IGxlZnRfc2FtcGxlc1BvcyArIGN1cnNhbXBsZXBvcztcbiAgICAgICAgICAgICAgICBjdXJsZWZ0QmFzZSA9IGxlZnRfc2FtcGxlcztcbiAgICAgICAgICAgICAgICBjdXJyaWdodCA9IHJpZ2h0X3NhbXBsZXNQb3MgKyBjdXJzYW1wbGVwb3M7XG4gICAgICAgICAgICAgICAgY3VycmlnaHRCYXNlID0gcmlnaHRfc2FtcGxlcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmlsdGVyWXVsZShjdXJsZWZ0QmFzZSwgY3VybGVmdCwgcmdEYXRhLmxzdGVwYnVmLCByZ0RhdGEubHN0ZXBcbiAgICAgICAgICAgICAgICArIHJnRGF0YS50b3RzYW1wLCBjdXJzYW1wbGVzLCBBQll1bGVbcmdEYXRhLnJlcWluZGV4XSk7XG4gICAgICAgICAgICBmaWx0ZXJZdWxlKGN1cnJpZ2h0QmFzZSwgY3VycmlnaHQsIHJnRGF0YS5yc3RlcGJ1ZiwgcmdEYXRhLnJzdGVwXG4gICAgICAgICAgICAgICAgKyByZ0RhdGEudG90c2FtcCwgY3Vyc2FtcGxlcywgQUJZdWxlW3JnRGF0YS5yZXFpbmRleF0pO1xuXG4gICAgICAgICAgICBmaWx0ZXJCdXR0ZXIocmdEYXRhLmxzdGVwYnVmLCByZ0RhdGEubHN0ZXAgKyByZ0RhdGEudG90c2FtcCxcbiAgICAgICAgICAgICAgICByZ0RhdGEubG91dGJ1ZiwgcmdEYXRhLmxvdXQgKyByZ0RhdGEudG90c2FtcCwgY3Vyc2FtcGxlcyxcbiAgICAgICAgICAgICAgICBBQkJ1dHRlcltyZ0RhdGEucmVxaW5kZXhdKTtcbiAgICAgICAgICAgIGZpbHRlckJ1dHRlcihyZ0RhdGEucnN0ZXBidWYsIHJnRGF0YS5yc3RlcCArIHJnRGF0YS50b3RzYW1wLFxuICAgICAgICAgICAgICAgIHJnRGF0YS5yb3V0YnVmLCByZ0RhdGEucm91dCArIHJnRGF0YS50b3RzYW1wLCBjdXJzYW1wbGVzLFxuICAgICAgICAgICAgICAgIEFCQnV0dGVyW3JnRGF0YS5yZXFpbmRleF0pO1xuXG4gICAgICAgICAgICBjdXJsZWZ0ID0gcmdEYXRhLmxvdXQgKyByZ0RhdGEudG90c2FtcDtcbiAgICAgICAgICAgIC8qIEdldCB0aGUgc3F1YXJlZCB2YWx1ZXMgKi9cbiAgICAgICAgICAgIGN1cmxlZnRCYXNlID0gcmdEYXRhLmxvdXRidWY7XG4gICAgICAgICAgICBjdXJyaWdodCA9IHJnRGF0YS5yb3V0ICsgcmdEYXRhLnRvdHNhbXA7XG4gICAgICAgICAgICBjdXJyaWdodEJhc2UgPSByZ0RhdGEucm91dGJ1ZjtcblxuICAgICAgICAgICAgdmFyIGkgPSBjdXJzYW1wbGVzICUgODtcbiAgICAgICAgICAgIHdoaWxlICgoaS0tKSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgcmdEYXRhLmxzdW0gKz0gZnNxcihjdXJsZWZ0QmFzZVtjdXJsZWZ0KytdKTtcbiAgICAgICAgICAgICAgICByZ0RhdGEucnN1bSArPSBmc3FyKGN1cnJpZ2h0QmFzZVtjdXJyaWdodCsrXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpID0gY3Vyc2FtcGxlcyAvIDg7XG4gICAgICAgICAgICB3aGlsZSAoKGktLSkgIT0gMCkge1xuICAgICAgICAgICAgICAgIHJnRGF0YS5sc3VtICs9IGZzcXIoY3VybGVmdEJhc2VbY3VybGVmdCArIDBdKVxuICAgICAgICAgICAgICAgICAgICArIGZzcXIoY3VybGVmdEJhc2VbY3VybGVmdCArIDFdKVxuICAgICAgICAgICAgICAgICAgICArIGZzcXIoY3VybGVmdEJhc2VbY3VybGVmdCArIDJdKVxuICAgICAgICAgICAgICAgICAgICArIGZzcXIoY3VybGVmdEJhc2VbY3VybGVmdCArIDNdKVxuICAgICAgICAgICAgICAgICAgICArIGZzcXIoY3VybGVmdEJhc2VbY3VybGVmdCArIDRdKVxuICAgICAgICAgICAgICAgICAgICArIGZzcXIoY3VybGVmdEJhc2VbY3VybGVmdCArIDVdKVxuICAgICAgICAgICAgICAgICAgICArIGZzcXIoY3VybGVmdEJhc2VbY3VybGVmdCArIDZdKVxuICAgICAgICAgICAgICAgICAgICArIGZzcXIoY3VybGVmdEJhc2VbY3VybGVmdCArIDddKTtcbiAgICAgICAgICAgICAgICBjdXJsZWZ0ICs9IDg7XG4gICAgICAgICAgICAgICAgcmdEYXRhLnJzdW0gKz0gZnNxcihjdXJyaWdodEJhc2VbY3VycmlnaHQgKyAwXSlcbiAgICAgICAgICAgICAgICAgICAgKyBmc3FyKGN1cnJpZ2h0QmFzZVtjdXJyaWdodCArIDFdKVxuICAgICAgICAgICAgICAgICAgICArIGZzcXIoY3VycmlnaHRCYXNlW2N1cnJpZ2h0ICsgMl0pXG4gICAgICAgICAgICAgICAgICAgICsgZnNxcihjdXJyaWdodEJhc2VbY3VycmlnaHQgKyAzXSlcbiAgICAgICAgICAgICAgICAgICAgKyBmc3FyKGN1cnJpZ2h0QmFzZVtjdXJyaWdodCArIDRdKVxuICAgICAgICAgICAgICAgICAgICArIGZzcXIoY3VycmlnaHRCYXNlW2N1cnJpZ2h0ICsgNV0pXG4gICAgICAgICAgICAgICAgICAgICsgZnNxcihjdXJyaWdodEJhc2VbY3VycmlnaHQgKyA2XSlcbiAgICAgICAgICAgICAgICAgICAgKyBmc3FyKGN1cnJpZ2h0QmFzZVtjdXJyaWdodCArIDddKTtcbiAgICAgICAgICAgICAgICBjdXJyaWdodCArPSA4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBiYXRjaHNhbXBsZXMgLT0gY3Vyc2FtcGxlcztcbiAgICAgICAgICAgIGN1cnNhbXBsZXBvcyArPSBjdXJzYW1wbGVzO1xuICAgICAgICAgICAgcmdEYXRhLnRvdHNhbXAgKz0gY3Vyc2FtcGxlcztcbiAgICAgICAgICAgIGlmIChyZ0RhdGEudG90c2FtcCA9PSByZ0RhdGEuc2FtcGxlV2luZG93KSB7XG4gICAgICAgICAgICAgICAgLyogR2V0IHRoZSBSb290IE1lYW4gU3F1YXJlIChSTVMpIGZvciB0aGlzIHNldCBvZiBzYW1wbGVzICovXG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IEdhaW5BbmFseXNpcy5TVEVQU19wZXJfZEJcbiAgICAgICAgICAgICAgICAgICAgKiAxMC5cbiAgICAgICAgICAgICAgICAgICAgKiBNYXRoLmxvZzEwKChyZ0RhdGEubHN1bSArIHJnRGF0YS5yc3VtKVxuICAgICAgICAgICAgICAgICAgICAgICAgLyByZ0RhdGEudG90c2FtcCAqIDAuNSArIDEuZS0zNyk7XG4gICAgICAgICAgICAgICAgdmFyIGl2YWwgPSAodmFsIDw9IDApID8gMCA6IDAgfCB2YWw7XG4gICAgICAgICAgICAgICAgaWYgKGl2YWwgPj0gcmdEYXRhLkEubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBpdmFsID0gcmdEYXRhLkEubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICByZ0RhdGEuQVtpdmFsXSsrO1xuICAgICAgICAgICAgICAgIHJnRGF0YS5sc3VtID0gcmdEYXRhLnJzdW0gPSAwLjtcblxuICAgICAgICAgICAgICAgIFN5c3RlbS5hcnJheWNvcHkocmdEYXRhLmxvdXRidWYsIHJnRGF0YS50b3RzYW1wLFxuICAgICAgICAgICAgICAgICAgICByZ0RhdGEubG91dGJ1ZiwgMCwgTUFYX09SREVSKTtcbiAgICAgICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KHJnRGF0YS5yb3V0YnVmLCByZ0RhdGEudG90c2FtcCxcbiAgICAgICAgICAgICAgICAgICAgcmdEYXRhLnJvdXRidWYsIDAsIE1BWF9PUkRFUik7XG4gICAgICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weShyZ0RhdGEubHN0ZXBidWYsIHJnRGF0YS50b3RzYW1wLFxuICAgICAgICAgICAgICAgICAgICByZ0RhdGEubHN0ZXBidWYsIDAsIE1BWF9PUkRFUik7XG4gICAgICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weShyZ0RhdGEucnN0ZXBidWYsIHJnRGF0YS50b3RzYW1wLFxuICAgICAgICAgICAgICAgICAgICByZ0RhdGEucnN0ZXBidWYsIDAsIE1BWF9PUkRFUik7XG4gICAgICAgICAgICAgICAgcmdEYXRhLnRvdHNhbXAgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJnRGF0YS50b3RzYW1wID4gcmdEYXRhLnNhbXBsZVdpbmRvdykge1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogc29tZWhvdyBJIHJlYWxseSBzY3Jld2VkIHVwOiBFcnJvciBpbiBwcm9ncmFtbWluZyEgQ29udGFjdFxuICAgICAgICAgICAgICAgICAqIGF1dGhvciBhYm91dCB0b3RzYW1wID4gc2FtcGxlV2luZG93XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgcmV0dXJuIEdBSU5fQU5BTFlTSVNfRVJST1I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bV9zYW1wbGVzIDwgTUFYX09SREVSKSB7XG4gICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KHJnRGF0YS5saW5wcmVidWYsIG51bV9zYW1wbGVzLCByZ0RhdGEubGlucHJlYnVmLFxuICAgICAgICAgICAgICAgIDAsIE1BWF9PUkRFUiAtIG51bV9zYW1wbGVzKTtcbiAgICAgICAgICAgIFN5c3RlbS5hcnJheWNvcHkocmdEYXRhLnJpbnByZWJ1ZiwgbnVtX3NhbXBsZXMsIHJnRGF0YS5yaW5wcmVidWYsXG4gICAgICAgICAgICAgICAgMCwgTUFYX09SREVSIC0gbnVtX3NhbXBsZXMpO1xuICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weShsZWZ0X3NhbXBsZXMsIGxlZnRfc2FtcGxlc1BvcywgcmdEYXRhLmxpbnByZWJ1ZixcbiAgICAgICAgICAgICAgICBNQVhfT1JERVIgLSBudW1fc2FtcGxlcywgbnVtX3NhbXBsZXMpO1xuICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weShyaWdodF9zYW1wbGVzLCByaWdodF9zYW1wbGVzUG9zLCByZ0RhdGEucmlucHJlYnVmLFxuICAgICAgICAgICAgICAgIE1BWF9PUkRFUiAtIG51bV9zYW1wbGVzLCBudW1fc2FtcGxlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KGxlZnRfc2FtcGxlcywgbGVmdF9zYW1wbGVzUG9zICsgbnVtX3NhbXBsZXNcbiAgICAgICAgICAgICAgICAtIE1BWF9PUkRFUiwgcmdEYXRhLmxpbnByZWJ1ZiwgMCwgTUFYX09SREVSKTtcbiAgICAgICAgICAgIFN5c3RlbS5hcnJheWNvcHkocmlnaHRfc2FtcGxlcywgcmlnaHRfc2FtcGxlc1BvcyArIG51bV9zYW1wbGVzXG4gICAgICAgICAgICAgICAgLSBNQVhfT1JERVIsIHJnRGF0YS5yaW5wcmVidWYsIDAsIE1BWF9PUkRFUik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gR0FJTl9BTkFMWVNJU19PSztcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gYW5hbHl6ZVJlc3VsdChBcnJheSwgbGVuKSB7XG4gICAgICAgIHZhciBpO1xuXG4gICAgICAgIHZhciBlbGVtcyA9IDA7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICAgIGVsZW1zICs9IEFycmF5W2ldO1xuICAgICAgICBpZiAoZWxlbXMgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBHQUlOX05PVF9FTk9VR0hfU0FNUExFUztcblxuICAgICAgICB2YXIgdXBwZXIgPSAwIHwgTWF0aC5jZWlsKGVsZW1zICogKDEuIC0gUk1TX1BFUkNFTlRJTEUpKTtcbiAgICAgICAgZm9yIChpID0gbGVuOyBpLS0gPiAwOykge1xuICAgICAgICAgICAgaWYgKCh1cHBlciAtPSBBcnJheVtpXSkgPD0gMClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vcmV0dXJuIChmbG9hdCkgKChmbG9hdCkgUElOS19SRUYgLSAoZmxvYXQpIGkgLyAoZmxvYXQpIFNURVBTX3Blcl9kQik7XG4gICAgICAgIHJldHVybiAoUElOS19SRUYgLSBpIC8gR2FpbkFuYWx5c2lzLlNURVBTX3Blcl9kQik7XG4gICAgfVxuXG4gICAgdGhpcy5HZXRUaXRsZUdhaW4gPSBmdW5jdGlvbiAocmdEYXRhKSB7XG4gICAgICAgIHZhciByZXR2YWwgPSBhbmFseXplUmVzdWx0KHJnRGF0YS5BLCByZ0RhdGEuQS5sZW5ndGgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmdEYXRhLkEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJnRGF0YS5CW2ldICs9IHJnRGF0YS5BW2ldO1xuICAgICAgICAgICAgcmdEYXRhLkFbaV0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBNQVhfT1JERVI7IGkrKylcbiAgICAgICAgICAgIHJnRGF0YS5saW5wcmVidWZbaV0gPSByZ0RhdGEubHN0ZXBidWZbaV0gPSByZ0RhdGEubG91dGJ1ZltpXSA9IHJnRGF0YS5yaW5wcmVidWZbaV0gPSByZ0RhdGEucnN0ZXBidWZbaV0gPSByZ0RhdGEucm91dGJ1ZltpXSA9IDAuO1xuXG4gICAgICAgIHJnRGF0YS50b3RzYW1wID0gMDtcbiAgICAgICAgcmdEYXRhLmxzdW0gPSByZ0RhdGEucnN1bSA9IDAuO1xuICAgICAgICByZXR1cm4gcmV0dmFsO1xuICAgIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdhaW5BbmFseXNpcztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lamejs/src/js/GainAnalysis.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lamejs/src/js/GrInfo.js":
/*!**********************************************!*\
  !*** ./node_modules/lamejs/src/js/GrInfo.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("//package mp3;\nvar common = __webpack_require__(/*! ./common.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/common.js\");\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\nvar L3Side = __webpack_require__(/*! ./L3Side.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/L3Side.js\");\n\nfunction GrInfo() {\n    //float xr[] = new float[576];\n    this.xr = new_float(576);\n    //int l3_enc[] = new int[576];\n    this.l3_enc = new_int(576);\n    //int scalefac[] = new int[L3Side.SFBMAX];\n    this.scalefac = new_int(L3Side.SFBMAX);\n    this.xrpow_max = 0.;\n\n    this.part2_3_length = 0;\n    this.big_values = 0;\n    this.count1 = 0;\n    this.global_gain = 0;\n    this.scalefac_compress = 0;\n    this.block_type = 0;\n    this.mixed_block_flag = 0;\n    this.table_select = new_int(3);\n    this.subblock_gain = new_int(3 + 1);\n    this.region0_count = 0;\n    this.region1_count = 0;\n    this.preflag = 0;\n    this.scalefac_scale = 0;\n    this.count1table_select = 0;\n\n    this.part2_length = 0;\n    this.sfb_lmax = 0;\n    this.sfb_smin = 0;\n    this.psy_lmax = 0;\n    this.sfbmax = 0;\n    this.psymax = 0;\n    this.sfbdivide = 0;\n    this.width = new_int(L3Side.SFBMAX);\n    this.window = new_int(L3Side.SFBMAX);\n    this.count1bits = 0;\n    /**\n     * added for LSF\n     */\n    this.sfb_partition_table = null;\n    this.slen = new_int(4);\n\n    this.max_nonzero_coeff = 0;\n\n    var self = this;\n    function clone_int(array) {\n        return new Int32Array(array);\n    }\n    function clone_float(array) {\n        return new Float32Array(array);\n    }\n    this.assign = function (other) {\n        self.xr = clone_float(other.xr); //.slice(0); //clone();\n        self.l3_enc = clone_int(other.l3_enc); //.slice(0); //clone();\n        self.scalefac = clone_int(other.scalefac);//.slice(0); //clone();\n        self.xrpow_max = other.xrpow_max;\n\n        self.part2_3_length = other.part2_3_length;\n        self.big_values = other.big_values;\n        self.count1 = other.count1;\n        self.global_gain = other.global_gain;\n        self.scalefac_compress = other.scalefac_compress;\n        self.block_type = other.block_type;\n        self.mixed_block_flag = other.mixed_block_flag;\n        self.table_select = clone_int(other.table_select);//.slice(0); //clone();\n        self.subblock_gain = clone_int(other.subblock_gain); //.slice(0); //.clone();\n        self.region0_count = other.region0_count;\n        self.region1_count = other.region1_count;\n        self.preflag = other.preflag;\n        self.scalefac_scale = other.scalefac_scale;\n        self.count1table_select = other.count1table_select;\n\n        self.part2_length = other.part2_length;\n        self.sfb_lmax = other.sfb_lmax;\n        self.sfb_smin = other.sfb_smin;\n        self.psy_lmax = other.psy_lmax;\n        self.sfbmax = other.sfbmax;\n        self.psymax = other.psymax;\n        self.sfbdivide = other.sfbdivide;\n        self.width = clone_int(other.width); //.slice(0); //.clone();\n        self.window = clone_int(other.window); //.slice(0); //.clone();\n        self.count1bits = other.count1bits;\n\n        self.sfb_partition_table = other.sfb_partition_table.slice(0); //.clone();\n        self.slen = clone_int(other.slen); //.slice(0); //.clone();\n        self.max_nonzero_coeff = other.max_nonzero_coeff;\n    }\n}\n\nmodule.exports = GrInfo;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL0dySW5mby5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQywrRUFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQywrRUFBYTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGFBQWE7QUFDdEQsK0NBQStDLGFBQWE7QUFDNUQsa0RBQWtELGFBQWE7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsYUFBYTtBQUN2RSw2REFBNkQsYUFBYTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGFBQWE7QUFDMUQsK0NBQStDLGFBQWE7QUFDNUQ7O0FBRUEsdUVBQXVFO0FBQ3ZFLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbGFtZWpzL3NyYy9qcy9HckluZm8uanM/ZWFmYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvL3BhY2thZ2UgbXAzO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uLmpzJyk7XG52YXIgU3lzdGVtID0gY29tbW9uLlN5c3RlbTtcbnZhciBWYnJNb2RlID0gY29tbW9uLlZick1vZGU7XG52YXIgRmxvYXQgPSBjb21tb24uRmxvYXQ7XG52YXIgU2hvcnRCbG9jayA9IGNvbW1vbi5TaG9ydEJsb2NrO1xudmFyIFV0aWwgPSBjb21tb24uVXRpbDtcbnZhciBBcnJheXMgPSBjb21tb24uQXJyYXlzO1xudmFyIG5ld19hcnJheV9uID0gY29tbW9uLm5ld19hcnJheV9uO1xudmFyIG5ld19ieXRlID0gY29tbW9uLm5ld19ieXRlO1xudmFyIG5ld19kb3VibGUgPSBjb21tb24ubmV3X2RvdWJsZTtcbnZhciBuZXdfZmxvYXQgPSBjb21tb24ubmV3X2Zsb2F0O1xudmFyIG5ld19mbG9hdF9uID0gY29tbW9uLm5ld19mbG9hdF9uO1xudmFyIG5ld19pbnQgPSBjb21tb24ubmV3X2ludDtcbnZhciBuZXdfaW50X24gPSBjb21tb24ubmV3X2ludF9uO1xudmFyIGFzc2VydCA9IGNvbW1vbi5hc3NlcnQ7XG5cbnZhciBMM1NpZGUgPSByZXF1aXJlKCcuL0wzU2lkZS5qcycpO1xuXG5mdW5jdGlvbiBHckluZm8oKSB7XG4gICAgLy9mbG9hdCB4cltdID0gbmV3IGZsb2F0WzU3Nl07XG4gICAgdGhpcy54ciA9IG5ld19mbG9hdCg1NzYpO1xuICAgIC8vaW50IGwzX2VuY1tdID0gbmV3IGludFs1NzZdO1xuICAgIHRoaXMubDNfZW5jID0gbmV3X2ludCg1NzYpO1xuICAgIC8vaW50IHNjYWxlZmFjW10gPSBuZXcgaW50W0wzU2lkZS5TRkJNQVhdO1xuICAgIHRoaXMuc2NhbGVmYWMgPSBuZXdfaW50KEwzU2lkZS5TRkJNQVgpO1xuICAgIHRoaXMueHJwb3dfbWF4ID0gMC47XG5cbiAgICB0aGlzLnBhcnQyXzNfbGVuZ3RoID0gMDtcbiAgICB0aGlzLmJpZ192YWx1ZXMgPSAwO1xuICAgIHRoaXMuY291bnQxID0gMDtcbiAgICB0aGlzLmdsb2JhbF9nYWluID0gMDtcbiAgICB0aGlzLnNjYWxlZmFjX2NvbXByZXNzID0gMDtcbiAgICB0aGlzLmJsb2NrX3R5cGUgPSAwO1xuICAgIHRoaXMubWl4ZWRfYmxvY2tfZmxhZyA9IDA7XG4gICAgdGhpcy50YWJsZV9zZWxlY3QgPSBuZXdfaW50KDMpO1xuICAgIHRoaXMuc3ViYmxvY2tfZ2FpbiA9IG5ld19pbnQoMyArIDEpO1xuICAgIHRoaXMucmVnaW9uMF9jb3VudCA9IDA7XG4gICAgdGhpcy5yZWdpb24xX2NvdW50ID0gMDtcbiAgICB0aGlzLnByZWZsYWcgPSAwO1xuICAgIHRoaXMuc2NhbGVmYWNfc2NhbGUgPSAwO1xuICAgIHRoaXMuY291bnQxdGFibGVfc2VsZWN0ID0gMDtcblxuICAgIHRoaXMucGFydDJfbGVuZ3RoID0gMDtcbiAgICB0aGlzLnNmYl9sbWF4ID0gMDtcbiAgICB0aGlzLnNmYl9zbWluID0gMDtcbiAgICB0aGlzLnBzeV9sbWF4ID0gMDtcbiAgICB0aGlzLnNmYm1heCA9IDA7XG4gICAgdGhpcy5wc3ltYXggPSAwO1xuICAgIHRoaXMuc2ZiZGl2aWRlID0gMDtcbiAgICB0aGlzLndpZHRoID0gbmV3X2ludChMM1NpZGUuU0ZCTUFYKTtcbiAgICB0aGlzLndpbmRvdyA9IG5ld19pbnQoTDNTaWRlLlNGQk1BWCk7XG4gICAgdGhpcy5jb3VudDFiaXRzID0gMDtcbiAgICAvKipcbiAgICAgKiBhZGRlZCBmb3IgTFNGXG4gICAgICovXG4gICAgdGhpcy5zZmJfcGFydGl0aW9uX3RhYmxlID0gbnVsbDtcbiAgICB0aGlzLnNsZW4gPSBuZXdfaW50KDQpO1xuXG4gICAgdGhpcy5tYXhfbm9uemVyb19jb2VmZiA9IDA7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgZnVuY3Rpb24gY2xvbmVfaW50KGFycmF5KSB7XG4gICAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheShhcnJheSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsb25lX2Zsb2F0KGFycmF5KSB7XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KGFycmF5KTtcbiAgICB9XG4gICAgdGhpcy5hc3NpZ24gPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgc2VsZi54ciA9IGNsb25lX2Zsb2F0KG90aGVyLnhyKTsgLy8uc2xpY2UoMCk7IC8vY2xvbmUoKTtcbiAgICAgICAgc2VsZi5sM19lbmMgPSBjbG9uZV9pbnQob3RoZXIubDNfZW5jKTsgLy8uc2xpY2UoMCk7IC8vY2xvbmUoKTtcbiAgICAgICAgc2VsZi5zY2FsZWZhYyA9IGNsb25lX2ludChvdGhlci5zY2FsZWZhYyk7Ly8uc2xpY2UoMCk7IC8vY2xvbmUoKTtcbiAgICAgICAgc2VsZi54cnBvd19tYXggPSBvdGhlci54cnBvd19tYXg7XG5cbiAgICAgICAgc2VsZi5wYXJ0Ml8zX2xlbmd0aCA9IG90aGVyLnBhcnQyXzNfbGVuZ3RoO1xuICAgICAgICBzZWxmLmJpZ192YWx1ZXMgPSBvdGhlci5iaWdfdmFsdWVzO1xuICAgICAgICBzZWxmLmNvdW50MSA9IG90aGVyLmNvdW50MTtcbiAgICAgICAgc2VsZi5nbG9iYWxfZ2FpbiA9IG90aGVyLmdsb2JhbF9nYWluO1xuICAgICAgICBzZWxmLnNjYWxlZmFjX2NvbXByZXNzID0gb3RoZXIuc2NhbGVmYWNfY29tcHJlc3M7XG4gICAgICAgIHNlbGYuYmxvY2tfdHlwZSA9IG90aGVyLmJsb2NrX3R5cGU7XG4gICAgICAgIHNlbGYubWl4ZWRfYmxvY2tfZmxhZyA9IG90aGVyLm1peGVkX2Jsb2NrX2ZsYWc7XG4gICAgICAgIHNlbGYudGFibGVfc2VsZWN0ID0gY2xvbmVfaW50KG90aGVyLnRhYmxlX3NlbGVjdCk7Ly8uc2xpY2UoMCk7IC8vY2xvbmUoKTtcbiAgICAgICAgc2VsZi5zdWJibG9ja19nYWluID0gY2xvbmVfaW50KG90aGVyLnN1YmJsb2NrX2dhaW4pOyAvLy5zbGljZSgwKTsgLy8uY2xvbmUoKTtcbiAgICAgICAgc2VsZi5yZWdpb24wX2NvdW50ID0gb3RoZXIucmVnaW9uMF9jb3VudDtcbiAgICAgICAgc2VsZi5yZWdpb24xX2NvdW50ID0gb3RoZXIucmVnaW9uMV9jb3VudDtcbiAgICAgICAgc2VsZi5wcmVmbGFnID0gb3RoZXIucHJlZmxhZztcbiAgICAgICAgc2VsZi5zY2FsZWZhY19zY2FsZSA9IG90aGVyLnNjYWxlZmFjX3NjYWxlO1xuICAgICAgICBzZWxmLmNvdW50MXRhYmxlX3NlbGVjdCA9IG90aGVyLmNvdW50MXRhYmxlX3NlbGVjdDtcblxuICAgICAgICBzZWxmLnBhcnQyX2xlbmd0aCA9IG90aGVyLnBhcnQyX2xlbmd0aDtcbiAgICAgICAgc2VsZi5zZmJfbG1heCA9IG90aGVyLnNmYl9sbWF4O1xuICAgICAgICBzZWxmLnNmYl9zbWluID0gb3RoZXIuc2ZiX3NtaW47XG4gICAgICAgIHNlbGYucHN5X2xtYXggPSBvdGhlci5wc3lfbG1heDtcbiAgICAgICAgc2VsZi5zZmJtYXggPSBvdGhlci5zZmJtYXg7XG4gICAgICAgIHNlbGYucHN5bWF4ID0gb3RoZXIucHN5bWF4O1xuICAgICAgICBzZWxmLnNmYmRpdmlkZSA9IG90aGVyLnNmYmRpdmlkZTtcbiAgICAgICAgc2VsZi53aWR0aCA9IGNsb25lX2ludChvdGhlci53aWR0aCk7IC8vLnNsaWNlKDApOyAvLy5jbG9uZSgpO1xuICAgICAgICBzZWxmLndpbmRvdyA9IGNsb25lX2ludChvdGhlci53aW5kb3cpOyAvLy5zbGljZSgwKTsgLy8uY2xvbmUoKTtcbiAgICAgICAgc2VsZi5jb3VudDFiaXRzID0gb3RoZXIuY291bnQxYml0cztcblxuICAgICAgICBzZWxmLnNmYl9wYXJ0aXRpb25fdGFibGUgPSBvdGhlci5zZmJfcGFydGl0aW9uX3RhYmxlLnNsaWNlKDApOyAvLy5jbG9uZSgpO1xuICAgICAgICBzZWxmLnNsZW4gPSBjbG9uZV9pbnQob3RoZXIuc2xlbik7IC8vLnNsaWNlKDApOyAvLy5jbG9uZSgpO1xuICAgICAgICBzZWxmLm1heF9ub256ZXJvX2NvZWZmID0gb3RoZXIubWF4X25vbnplcm9fY29lZmY7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdySW5mbztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lamejs/src/js/GrInfo.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lamejs/src/js/IIISideInfo.js":
/*!***************************************************!*\
  !*** ./node_modules/lamejs/src/js/IIISideInfo.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var common = __webpack_require__(/*! ./common.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/common.js\");\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\nvar GrInfo = __webpack_require__(/*! ./GrInfo.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/GrInfo.js\");\n\nfunction IIISideInfo() {\n    this.tt = [[null, null], [null, null]];\n    this.main_data_begin = 0;\n    this.private_bits = 0;\n    this.resvDrain_pre = 0;\n    this.resvDrain_post = 0;\n    this.scfsi = [new_int(4), new_int(4)];\n\n    for (var gr = 0; gr < 2; gr++) {\n        for (var ch = 0; ch < 2; ch++) {\n            this.tt[gr][ch] = new GrInfo();\n        }\n    }\n}\n\nmodule.exports = IIISideInfo;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL0lJSVNpZGVJbmZvLmpzIiwibWFwcGluZ3MiOiJBQUFBLGFBQWEsbUJBQU8sQ0FBQywrRUFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQywrRUFBYTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFFBQVE7QUFDN0IseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xhbWVqcy9zcmMvanMvSUlJU2lkZUluZm8uanM/NzNmNiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24uanMnKTtcbnZhciBTeXN0ZW0gPSBjb21tb24uU3lzdGVtO1xudmFyIFZick1vZGUgPSBjb21tb24uVmJyTW9kZTtcbnZhciBGbG9hdCA9IGNvbW1vbi5GbG9hdDtcbnZhciBTaG9ydEJsb2NrID0gY29tbW9uLlNob3J0QmxvY2s7XG52YXIgVXRpbCA9IGNvbW1vbi5VdGlsO1xudmFyIEFycmF5cyA9IGNvbW1vbi5BcnJheXM7XG52YXIgbmV3X2FycmF5X24gPSBjb21tb24ubmV3X2FycmF5X247XG52YXIgbmV3X2J5dGUgPSBjb21tb24ubmV3X2J5dGU7XG52YXIgbmV3X2RvdWJsZSA9IGNvbW1vbi5uZXdfZG91YmxlO1xudmFyIG5ld19mbG9hdCA9IGNvbW1vbi5uZXdfZmxvYXQ7XG52YXIgbmV3X2Zsb2F0X24gPSBjb21tb24ubmV3X2Zsb2F0X247XG52YXIgbmV3X2ludCA9IGNvbW1vbi5uZXdfaW50O1xudmFyIG5ld19pbnRfbiA9IGNvbW1vbi5uZXdfaW50X247XG52YXIgYXNzZXJ0ID0gY29tbW9uLmFzc2VydDtcblxudmFyIEdySW5mbyA9IHJlcXVpcmUoJy4vR3JJbmZvLmpzJyk7XG5cbmZ1bmN0aW9uIElJSVNpZGVJbmZvKCkge1xuICAgIHRoaXMudHQgPSBbW251bGwsIG51bGxdLCBbbnVsbCwgbnVsbF1dO1xuICAgIHRoaXMubWFpbl9kYXRhX2JlZ2luID0gMDtcbiAgICB0aGlzLnByaXZhdGVfYml0cyA9IDA7XG4gICAgdGhpcy5yZXN2RHJhaW5fcHJlID0gMDtcbiAgICB0aGlzLnJlc3ZEcmFpbl9wb3N0ID0gMDtcbiAgICB0aGlzLnNjZnNpID0gW25ld19pbnQoNCksIG5ld19pbnQoNCldO1xuXG4gICAgZm9yICh2YXIgZ3IgPSAwOyBnciA8IDI7IGdyKyspIHtcbiAgICAgICAgZm9yICh2YXIgY2ggPSAwOyBjaCA8IDI7IGNoKyspIHtcbiAgICAgICAgICAgIHRoaXMudHRbZ3JdW2NoXSA9IG5ldyBHckluZm8oKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBJSUlTaWRlSW5mbztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lamejs/src/js/IIISideInfo.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lamejs/src/js/III_psy_ratio.js":
/*!*****************************************************!*\
  !*** ./node_modules/lamejs/src/js/III_psy_ratio.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("//package mp3;\n\nvar III_psy_xmin = __webpack_require__(/*! ./III_psy_xmin.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/III_psy_xmin.js\");\n\nfunction III_psy_ratio() {\n\tthis.thm = new III_psy_xmin();\n\tthis.en = new III_psy_xmin();\n}\n\nmodule.exports = III_psy_ratio;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL0lJSV9wc3lfcmF0aW8uanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsbUJBQW1CLG1CQUFPLENBQUMsMkZBQW1COztBQUU5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbGFtZWpzL3NyYy9qcy9JSUlfcHN5X3JhdGlvLmpzPzViMjAiXSwic291cmNlc0NvbnRlbnQiOlsiLy9wYWNrYWdlIG1wMztcblxudmFyIElJSV9wc3lfeG1pbiA9IHJlcXVpcmUoJy4vSUlJX3BzeV94bWluLmpzJyk7XG5cbmZ1bmN0aW9uIElJSV9wc3lfcmF0aW8oKSB7XG5cdHRoaXMudGhtID0gbmV3IElJSV9wc3lfeG1pbigpO1xuXHR0aGlzLmVuID0gbmV3IElJSV9wc3lfeG1pbigpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IElJSV9wc3lfcmF0aW87XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lamejs/src/js/III_psy_ratio.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lamejs/src/js/III_psy_xmin.js":
/*!****************************************************!*\
  !*** ./node_modules/lamejs/src/js/III_psy_xmin.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var Encoder = __webpack_require__(/*! ./Encoder.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/Encoder.js\");\nvar common = __webpack_require__(/*! ./common.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/common.js\");\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\nfunction III_psy_xmin() {\n    this.l = new_float(Encoder.SBMAX_l);\n    this.s = new_float_n([Encoder.SBMAX_s, 3]);\n\n    var self = this;\n    this.assign = function (iii_psy_xmin) {\n        System.arraycopy(iii_psy_xmin.l, 0, self.l, 0, Encoder.SBMAX_l);\n        for (var i = 0; i < Encoder.SBMAX_s; i++) {\n            for (var j = 0; j < 3; j++) {\n                self.s[i][j] = iii_psy_xmin.s[i][j];\n            }\n        }\n    }\n}\n\nmodule.exports = III_psy_xmin;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL0lJSV9wc3lfeG1pbi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxjQUFjLG1CQUFPLENBQUMsaUZBQWM7QUFDcEMsYUFBYSxtQkFBTyxDQUFDLCtFQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0MsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbGFtZWpzL3NyYy9qcy9JSUlfcHN5X3htaW4uanM/YjhjYyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgRW5jb2RlciA9IHJlcXVpcmUoJy4vRW5jb2Rlci5qcycpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uLmpzJyk7XG52YXIgU3lzdGVtID0gY29tbW9uLlN5c3RlbTtcbnZhciBWYnJNb2RlID0gY29tbW9uLlZick1vZGU7XG52YXIgRmxvYXQgPSBjb21tb24uRmxvYXQ7XG52YXIgU2hvcnRCbG9jayA9IGNvbW1vbi5TaG9ydEJsb2NrO1xudmFyIFV0aWwgPSBjb21tb24uVXRpbDtcbnZhciBBcnJheXMgPSBjb21tb24uQXJyYXlzO1xudmFyIG5ld19hcnJheV9uID0gY29tbW9uLm5ld19hcnJheV9uO1xudmFyIG5ld19ieXRlID0gY29tbW9uLm5ld19ieXRlO1xudmFyIG5ld19kb3VibGUgPSBjb21tb24ubmV3X2RvdWJsZTtcbnZhciBuZXdfZmxvYXQgPSBjb21tb24ubmV3X2Zsb2F0O1xudmFyIG5ld19mbG9hdF9uID0gY29tbW9uLm5ld19mbG9hdF9uO1xudmFyIG5ld19pbnQgPSBjb21tb24ubmV3X2ludDtcbnZhciBuZXdfaW50X24gPSBjb21tb24ubmV3X2ludF9uO1xudmFyIGFzc2VydCA9IGNvbW1vbi5hc3NlcnQ7XG5cbmZ1bmN0aW9uIElJSV9wc3lfeG1pbigpIHtcbiAgICB0aGlzLmwgPSBuZXdfZmxvYXQoRW5jb2Rlci5TQk1BWF9sKTtcbiAgICB0aGlzLnMgPSBuZXdfZmxvYXRfbihbRW5jb2Rlci5TQk1BWF9zLCAzXSk7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5hc3NpZ24gPSBmdW5jdGlvbiAoaWlpX3BzeV94bWluKSB7XG4gICAgICAgIFN5c3RlbS5hcnJheWNvcHkoaWlpX3BzeV94bWluLmwsIDAsIHNlbGYubCwgMCwgRW5jb2Rlci5TQk1BWF9sKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBFbmNvZGVyLlNCTUFYX3M7IGkrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAzOyBqKyspIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNbaV1bal0gPSBpaWlfcHN5X3htaW4uc1tpXVtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBJSUlfcHN5X3htaW47XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lamejs/src/js/III_psy_xmin.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lamejs/src/js/L3Side.js":
/*!**********************************************!*\
  !*** ./node_modules/lamejs/src/js/L3Side.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var Encoder = __webpack_require__(/*! ./Encoder.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/Encoder.js\");\n\nvar L3Side = {};\n\n\n\t/**\n\t * max scalefactor band, max(SBMAX_l, SBMAX_s*3, (SBMAX_s-3)*3+8)\n\t */\nL3Side.SFBMAX = (Encoder.SBMAX_s * 3);\n\nmodule.exports = L3Side;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL0wzU2lkZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxjQUFjLG1CQUFPLENBQUMsaUZBQWM7O0FBRXBDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbGFtZWpzL3NyYy9qcy9MM1NpZGUuanM/ZmEwMSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgRW5jb2RlciA9IHJlcXVpcmUoJy4vRW5jb2Rlci5qcycpO1xuXG52YXIgTDNTaWRlID0ge307XG5cblxuXHQvKipcblx0ICogbWF4IHNjYWxlZmFjdG9yIGJhbmQsIG1heChTQk1BWF9sLCBTQk1BWF9zKjMsIChTQk1BWF9zLTMpKjMrOClcblx0ICovXG5MM1NpZGUuU0ZCTUFYID0gKEVuY29kZXIuU0JNQVhfcyAqIDMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEwzU2lkZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lamejs/src/js/L3Side.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lamejs/src/js/Lame.js":
/*!********************************************!*\
  !*** ./node_modules/lamejs/src/js/Lame.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var common = __webpack_require__(/*! ./common.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/common.js\");\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar new_short_n = common.new_short_n;\nvar assert = common.assert;\n\nvar PsyModel = __webpack_require__(/*! ./PsyModel.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/PsyModel.js\");\nvar LameGlobalFlags = __webpack_require__(/*! ./LameGlobalFlags.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/LameGlobalFlags.js\");\nvar LameInternalFlags = __webpack_require__(/*! ./LameInternalFlags.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/LameInternalFlags.js\");\nvar ATH = __webpack_require__(/*! ./ATH.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/ATH.js\");\nvar ReplayGain = __webpack_require__(/*! ./ReplayGain.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/ReplayGain.js\");\nvar CBRNewIterationLoop = __webpack_require__(/*! ./CBRNewIterationLoop.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/CBRNewIterationLoop.js\");\nvar BitStream = __webpack_require__(/*! ./BitStream.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/BitStream.js\");\nvar Tables = __webpack_require__(/*! ./Tables.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/Tables.js\");\nvar Encoder = __webpack_require__(/*! ./Encoder.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/Encoder.js\");\n\nfunction Lame() {\n    var MPEGMode = __webpack_require__(/*! ./MPEGMode.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/MPEGMode.js\");\n    var self = this;\n    var LAME_MAXALBUMART = (128 * 1024);\n\n    Lame.V9 = 410;\n    Lame.V8 = 420;\n    Lame.V7 = 430;\n    Lame.V6 = 440;\n    Lame.V5 = 450;\n    Lame.V4 = 460;\n    Lame.V3 = 470;\n    Lame.V2 = 480;\n    Lame.V1 = 490;\n    Lame.V0 = 500;\n\n    /* still there for compatibility */\n\n    Lame.R3MIX = 1000;\n    Lame.STANDARD = 1001;\n    Lame.EXTREME = 1002;\n    Lame.INSANE = 1003;\n    Lame.STANDARD_FAST = 1004;\n    Lame.EXTREME_FAST = 1005;\n    Lame.MEDIUM = 1006;\n    Lame.MEDIUM_FAST = 1007;\n\n    /**\n     * maximum size of mp3buffer needed if you encode at most 1152 samples for\n     * each call to lame_encode_buffer. see lame_encode_buffer() below\n     * (LAME_MAXMP3BUFFER is now obsolete)\n     */\n    var LAME_MAXMP3BUFFER = (16384 + LAME_MAXALBUMART);\n    Lame.LAME_MAXMP3BUFFER = LAME_MAXMP3BUFFER;\n\n    var ga;\n    var bs;\n    var p;\n    var qupvt;\n    var qu;\n    var psy = new PsyModel();\n    var vbr;\n    var ver;\n    var id3;\n    var mpglib;\n    this.enc = new Encoder();\n\n    this.setModules = function (_ga, _bs, _p, _qupvt, _qu, _vbr, _ver, _id3, _mpglib) {\n        ga = _ga;\n        bs = _bs;\n        p = _p;\n        qupvt = _qupvt;\n        qu = _qu;\n        vbr = _vbr;\n        ver = _ver;\n        id3 = _id3;\n        mpglib = _mpglib;\n        this.enc.setModules(bs, psy, qupvt, vbr);\n    }\n\n    /**\n     * PSY Model related stuff\n     */\n    function PSY() {\n        /**\n         * The dbQ stuff.\n         */\n        this.mask_adjust = 0.;\n        /**\n         * The dbQ stuff.\n         */\n        this.mask_adjust_short = 0.;\n        /* at transition from one scalefactor band to next */\n        /**\n         * Band weight long scalefactor bands.\n         */\n        this.bo_l_weight = new_float(Encoder.SBMAX_l);\n        /**\n         * Band weight short scalefactor bands.\n         */\n        this.bo_s_weight = new_float(Encoder.SBMAX_s);\n    }\n\n    function LowPassHighPass() {\n        this.lowerlimit = 0.;\n    }\n\n    function BandPass(bitrate, lPass) {\n        this.lowpass = lPass;\n    }\n\n    var LAME_ID = 0xFFF88E3B;\n\n    function lame_init_old(gfp) {\n        var gfc;\n\n        gfp.class_id = LAME_ID;\n\n        gfc = gfp.internal_flags = new LameInternalFlags();\n\n        /* Global flags. set defaults here for non-zero values */\n        /* see lame.h for description */\n        /*\n         * set integer values to -1 to mean that LAME will compute the best\n         * value, UNLESS the calling program as set it (and the value is no\n         * longer -1)\n         */\n\n        gfp.mode = MPEGMode.NOT_SET;\n        gfp.original = 1;\n        gfp.in_samplerate = 44100;\n        gfp.num_channels = 2;\n        gfp.num_samples = -1;\n\n        gfp.bWriteVbrTag = true;\n        gfp.quality = -1;\n        gfp.short_blocks = null;\n        gfc.subblock_gain = -1;\n\n        gfp.lowpassfreq = 0;\n        gfp.highpassfreq = 0;\n        gfp.lowpasswidth = -1;\n        gfp.highpasswidth = -1;\n\n        gfp.VBR = VbrMode.vbr_off;\n        gfp.VBR_q = 4;\n        gfp.ATHcurve = -1;\n        gfp.VBR_mean_bitrate_kbps = 128;\n        gfp.VBR_min_bitrate_kbps = 0;\n        gfp.VBR_max_bitrate_kbps = 0;\n        gfp.VBR_hard_min = 0;\n        gfc.VBR_min_bitrate = 1;\n        /* not 0 ????? */\n        gfc.VBR_max_bitrate = 13;\n        /* not 14 ????? */\n\n        gfp.quant_comp = -1;\n        gfp.quant_comp_short = -1;\n\n        gfp.msfix = -1;\n\n        gfc.resample_ratio = 1;\n\n        gfc.OldValue[0] = 180;\n        gfc.OldValue[1] = 180;\n        gfc.CurrentStep[0] = 4;\n        gfc.CurrentStep[1] = 4;\n        gfc.masking_lower = 1;\n        gfc.nsPsy.attackthre = -1;\n        gfc.nsPsy.attackthre_s = -1;\n\n        gfp.scale = -1;\n\n        gfp.athaa_type = -1;\n        gfp.ATHtype = -1;\n        /* default = -1 = set in lame_init_params */\n        gfp.athaa_loudapprox = -1;\n        /* 1 = flat loudness approx. (total energy) */\n        /* 2 = equal loudness curve */\n        gfp.athaa_sensitivity = 0.0;\n        /* no offset */\n        gfp.useTemporal = null;\n        gfp.interChRatio = -1;\n\n        /*\n         * The reason for int mf_samples_to_encode = ENCDELAY + POSTDELAY;\n         * ENCDELAY = internal encoder delay. And then we have to add\n         * POSTDELAY=288 because of the 50% MDCT overlap. A 576 MDCT granule\n         * decodes to 1152 samples. To synthesize the 576 samples centered under\n         * this granule we need the previous granule for the first 288 samples\n         * (no problem), and the next granule for the next 288 samples (not\n         * possible if this is last granule). So we need to pad with 288 samples\n         * to make sure we can encode the 576 samples we are interested in.\n         */\n        gfc.mf_samples_to_encode = Encoder.ENCDELAY + Encoder.POSTDELAY;\n        gfp.encoder_padding = 0;\n        gfc.mf_size = Encoder.ENCDELAY - Encoder.MDCTDELAY;\n        /*\n         * we pad input with this many 0's\n         */\n\n        gfp.findReplayGain = false;\n        gfp.decode_on_the_fly = false;\n\n        gfc.decode_on_the_fly = false;\n        gfc.findReplayGain = false;\n        gfc.findPeakSample = false;\n\n        gfc.RadioGain = 0;\n        gfc.AudiophileGain = 0;\n        gfc.noclipGainChange = 0;\n        gfc.noclipScale = -1.0;\n\n        gfp.preset = 0;\n\n        gfp.write_id3tag_automatic = true;\n        return 0;\n    }\n\n    this.lame_init = function () {\n        var gfp = new LameGlobalFlags();\n\n        var ret = lame_init_old(gfp);\n        if (ret != 0) {\n            return null;\n        }\n\n        gfp.lame_allocated_gfp = 1;\n        return gfp;\n    }\n\n    function filter_coef(x) {\n        if (x > 1.0)\n            return 0.0;\n        if (x <= 0.0)\n            return 1.0;\n\n        return Math.cos(Math.PI / 2 * x);\n    }\n\n    this.nearestBitrateFullIndex = function (bitrate) {\n        /* borrowed from DM abr presets */\n\n        var full_bitrate_table = [8, 16, 24, 32, 40, 48, 56, 64, 80,\n            96, 112, 128, 160, 192, 224, 256, 320];\n\n        var lower_range = 0, lower_range_kbps = 0, upper_range = 0, upper_range_kbps = 0;\n\n        /* We assume specified bitrate will be 320kbps */\n        upper_range_kbps = full_bitrate_table[16];\n        upper_range = 16;\n        lower_range_kbps = full_bitrate_table[16];\n        lower_range = 16;\n\n        /*\n         * Determine which significant bitrates the value specified falls\n         * between, if loop ends without breaking then we were correct above\n         * that the value was 320\n         */\n        for (var b = 0; b < 16; b++) {\n            if ((Math.max(bitrate, full_bitrate_table[b + 1])) != bitrate) {\n                upper_range_kbps = full_bitrate_table[b + 1];\n                upper_range = b + 1;\n                lower_range_kbps = full_bitrate_table[b];\n                lower_range = (b);\n                break;\n                /* We found upper range */\n            }\n        }\n\n        /* Determine which range the value specified is closer to */\n        if ((upper_range_kbps - bitrate) > (bitrate - lower_range_kbps)) {\n            return lower_range;\n        }\n        return upper_range;\n    }\n\n    function optimum_samplefreq(lowpassfreq, input_samplefreq) {\n        /*\n         * Rules:\n         *\n         * - if possible, sfb21 should NOT be used\n         */\n        var suggested_samplefreq = 44100;\n\n        if (input_samplefreq >= 48000)\n            suggested_samplefreq = 48000;\n        else if (input_samplefreq >= 44100)\n            suggested_samplefreq = 44100;\n        else if (input_samplefreq >= 32000)\n            suggested_samplefreq = 32000;\n        else if (input_samplefreq >= 24000)\n            suggested_samplefreq = 24000;\n        else if (input_samplefreq >= 22050)\n            suggested_samplefreq = 22050;\n        else if (input_samplefreq >= 16000)\n            suggested_samplefreq = 16000;\n        else if (input_samplefreq >= 12000)\n            suggested_samplefreq = 12000;\n        else if (input_samplefreq >= 11025)\n            suggested_samplefreq = 11025;\n        else if (input_samplefreq >= 8000)\n            suggested_samplefreq = 8000;\n\n        if (lowpassfreq == -1)\n            return suggested_samplefreq;\n\n        if (lowpassfreq <= 15960)\n            suggested_samplefreq = 44100;\n        if (lowpassfreq <= 15250)\n            suggested_samplefreq = 32000;\n        if (lowpassfreq <= 11220)\n            suggested_samplefreq = 24000;\n        if (lowpassfreq <= 9970)\n            suggested_samplefreq = 22050;\n        if (lowpassfreq <= 7230)\n            suggested_samplefreq = 16000;\n        if (lowpassfreq <= 5420)\n            suggested_samplefreq = 12000;\n        if (lowpassfreq <= 4510)\n            suggested_samplefreq = 11025;\n        if (lowpassfreq <= 3970)\n            suggested_samplefreq = 8000;\n\n        if (input_samplefreq < suggested_samplefreq) {\n            /*\n             * choose a valid MPEG sample frequency above the input sample\n             * frequency to avoid SFB21/12 bitrate bloat rh 061115\n             */\n            if (input_samplefreq > 44100) {\n                return 48000;\n            }\n            if (input_samplefreq > 32000) {\n                return 44100;\n            }\n            if (input_samplefreq > 24000) {\n                return 32000;\n            }\n            if (input_samplefreq > 22050) {\n                return 24000;\n            }\n            if (input_samplefreq > 16000) {\n                return 22050;\n            }\n            if (input_samplefreq > 12000) {\n                return 16000;\n            }\n            if (input_samplefreq > 11025) {\n                return 12000;\n            }\n            if (input_samplefreq > 8000) {\n                return 11025;\n            }\n            return 8000;\n        }\n        return suggested_samplefreq;\n    }\n\n    /**\n     * convert samp freq in Hz to index\n     */\n    function SmpFrqIndex(sample_freq, gpf) {\n        switch (sample_freq) {\n            case 44100:\n                gpf.version = 1;\n                return 0;\n            case 48000:\n                gpf.version = 1;\n                return 1;\n            case 32000:\n                gpf.version = 1;\n                return 2;\n            case 22050:\n                gpf.version = 0;\n                return 0;\n            case 24000:\n                gpf.version = 0;\n                return 1;\n            case 16000:\n                gpf.version = 0;\n                return 2;\n            case 11025:\n                gpf.version = 0;\n                return 0;\n            case 12000:\n                gpf.version = 0;\n                return 1;\n            case 8000:\n                gpf.version = 0;\n                return 2;\n            default:\n                gpf.version = 0;\n                return -1;\n        }\n    }\n\n    /**\n     * @param bRate\n     *            legal rates from 8 to 320\n     */\n    function FindNearestBitrate(bRate, version, samplerate) {\n        /* MPEG-1 or MPEG-2 LSF */\n        if (samplerate < 16000)\n            version = 2;\n\n        var bitrate = Tables.bitrate_table[version][1];\n\n        for (var i = 2; i <= 14; i++) {\n            if (Tables.bitrate_table[version][i] > 0) {\n                if (Math.abs(Tables.bitrate_table[version][i] - bRate) < Math\n                        .abs(bitrate - bRate))\n                    bitrate = Tables.bitrate_table[version][i];\n            }\n        }\n        return bitrate;\n    }\n\n    /**\n     * @param bRate\n     *            legal rates from 32 to 448 kbps\n     * @param version\n     *            MPEG-1 or MPEG-2/2.5 LSF\n     */\n    function BitrateIndex(bRate, version, samplerate) {\n        /* convert bitrate in kbps to index */\n        if (samplerate < 16000)\n            version = 2;\n        for (var i = 0; i <= 14; i++) {\n            if (Tables.bitrate_table[version][i] > 0) {\n                if (Tables.bitrate_table[version][i] == bRate) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    function optimum_bandwidth(lh, bitrate) {\n        /**\n         * <PRE>\n         *  Input:\n         *      bitrate     total bitrate in kbps\n         *\n         *   Output:\n         *      lowerlimit: best lowpass frequency limit for input filter in Hz\n         *      upperlimit: best highpass frequency limit for input filter in Hz\n         * </PRE>\n         */\n        var freq_map = [new BandPass(8, 2000),\n            new BandPass(16, 3700), new BandPass(24, 3900),\n            new BandPass(32, 5500), new BandPass(40, 7000),\n            new BandPass(48, 7500), new BandPass(56, 10000),\n            new BandPass(64, 11000), new BandPass(80, 13500),\n            new BandPass(96, 15100), new BandPass(112, 15600),\n            new BandPass(128, 17000), new BandPass(160, 17500),\n            new BandPass(192, 18600), new BandPass(224, 19400),\n            new BandPass(256, 19700), new BandPass(320, 20500)];\n\n        var table_index = self.nearestBitrateFullIndex(bitrate);\n        lh.lowerlimit = freq_map[table_index].lowpass;\n    }\n\n    function lame_init_params_ppflt(gfp) {\n        var gfc = gfp.internal_flags;\n        /***************************************************************/\n        /* compute info needed for polyphase filter (filter type==0, default) */\n        /***************************************************************/\n\n        var lowpass_band = 32;\n        var highpass_band = -1;\n\n        if (gfc.lowpass1 > 0) {\n            var minband = 999;\n            for (var band = 0; band <= 31; band++) {\n                var freq = (band / 31.0);\n                /* this band and above will be zeroed: */\n                if (freq >= gfc.lowpass2) {\n                    lowpass_band = Math.min(lowpass_band, band);\n                }\n                if (gfc.lowpass1 < freq && freq < gfc.lowpass2) {\n                    minband = Math.min(minband, band);\n                }\n            }\n\n            /*\n             * compute the *actual* transition band implemented by the polyphase\n             * filter\n             */\n            if (minband == 999) {\n                gfc.lowpass1 = (lowpass_band - .75) / 31.0;\n            } else {\n                gfc.lowpass1 = (minband - .75) / 31.0;\n            }\n            gfc.lowpass2 = lowpass_band / 31.0;\n        }\n\n        /*\n         * make sure highpass filter is within 90% of what the effective\n         * highpass frequency will be\n         */\n        if (gfc.highpass2 > 0) {\n            if (gfc.highpass2 < .9 * (.75 / 31.0)) {\n                gfc.highpass1 = 0;\n                gfc.highpass2 = 0;\n                System.err.println(\"Warning: highpass filter disabled.  \"\n                    + \"highpass frequency too small\\n\");\n            }\n        }\n\n        if (gfc.highpass2 > 0) {\n            var maxband = -1;\n            for (var band = 0; band <= 31; band++) {\n                var freq = band / 31.0;\n                /* this band and below will be zereod */\n                if (freq <= gfc.highpass1) {\n                    highpass_band = Math.max(highpass_band, band);\n                }\n                if (gfc.highpass1 < freq && freq < gfc.highpass2) {\n                    maxband = Math.max(maxband, band);\n                }\n            }\n            /*\n             * compute the *actual* transition band implemented by the polyphase\n             * filter\n             */\n            gfc.highpass1 = highpass_band / 31.0;\n            if (maxband == -1) {\n                gfc.highpass2 = (highpass_band + .75) / 31.0;\n            } else {\n                gfc.highpass2 = (maxband + .75) / 31.0;\n            }\n        }\n\n        for (var band = 0; band < 32; band++) {\n            var fc1, fc2;\n            var freq = band / 31.0;\n            if (gfc.highpass2 > gfc.highpass1) {\n                fc1 = filter_coef((gfc.highpass2 - freq)\n                    / (gfc.highpass2 - gfc.highpass1 + 1e-20));\n            } else {\n                fc1 = 1.0;\n            }\n            if (gfc.lowpass2 > gfc.lowpass1) {\n                fc2 = filter_coef((freq - gfc.lowpass1)\n                    / (gfc.lowpass2 - gfc.lowpass1 + 1e-20));\n            } else {\n                fc2 = 1.0;\n            }\n            gfc.amp_filter[band] = (fc1 * fc2);\n        }\n    }\n\n    function lame_init_qval(gfp) {\n        var gfc = gfp.internal_flags;\n\n        switch (gfp.quality) {\n            default:\n            case 9: /* no psymodel, no noise shaping */\n                gfc.psymodel = 0;\n                gfc.noise_shaping = 0;\n                gfc.noise_shaping_amp = 0;\n                gfc.noise_shaping_stop = 0;\n                gfc.use_best_huffman = 0;\n                gfc.full_outer_loop = 0;\n                break;\n\n            case 8:\n                gfp.quality = 7;\n            //$FALL-THROUGH$\n            case 7:\n                /*\n                 * use psymodel (for short block and m/s switching), but no noise\n                 * shapping\n                 */\n                gfc.psymodel = 1;\n                gfc.noise_shaping = 0;\n                gfc.noise_shaping_amp = 0;\n                gfc.noise_shaping_stop = 0;\n                gfc.use_best_huffman = 0;\n                gfc.full_outer_loop = 0;\n                break;\n\n            case 6:\n                gfc.psymodel = 1;\n                if (gfc.noise_shaping == 0)\n                    gfc.noise_shaping = 1;\n                gfc.noise_shaping_amp = 0;\n                gfc.noise_shaping_stop = 0;\n                if (gfc.subblock_gain == -1)\n                    gfc.subblock_gain = 1;\n                gfc.use_best_huffman = 0;\n                gfc.full_outer_loop = 0;\n                break;\n\n            case 5:\n                gfc.psymodel = 1;\n                if (gfc.noise_shaping == 0)\n                    gfc.noise_shaping = 1;\n                gfc.noise_shaping_amp = 0;\n                gfc.noise_shaping_stop = 0;\n                if (gfc.subblock_gain == -1)\n                    gfc.subblock_gain = 1;\n                gfc.use_best_huffman = 0;\n                gfc.full_outer_loop = 0;\n                break;\n\n            case 4:\n                gfc.psymodel = 1;\n                if (gfc.noise_shaping == 0)\n                    gfc.noise_shaping = 1;\n                gfc.noise_shaping_amp = 0;\n                gfc.noise_shaping_stop = 0;\n                if (gfc.subblock_gain == -1)\n                    gfc.subblock_gain = 1;\n                gfc.use_best_huffman = 1;\n                gfc.full_outer_loop = 0;\n                break;\n\n            case 3:\n                gfc.psymodel = 1;\n                if (gfc.noise_shaping == 0)\n                    gfc.noise_shaping = 1;\n                gfc.noise_shaping_amp = 1;\n                gfc.noise_shaping_stop = 1;\n                if (gfc.subblock_gain == -1)\n                    gfc.subblock_gain = 1;\n                gfc.use_best_huffman = 1;\n                gfc.full_outer_loop = 0;\n                break;\n\n            case 2:\n                gfc.psymodel = 1;\n                if (gfc.noise_shaping == 0)\n                    gfc.noise_shaping = 1;\n                if (gfc.substep_shaping == 0)\n                    gfc.substep_shaping = 2;\n                gfc.noise_shaping_amp = 1;\n                gfc.noise_shaping_stop = 1;\n                if (gfc.subblock_gain == -1)\n                    gfc.subblock_gain = 1;\n                gfc.use_best_huffman = 1;\n                /* inner loop */\n                gfc.full_outer_loop = 0;\n                break;\n\n            case 1:\n                gfc.psymodel = 1;\n                if (gfc.noise_shaping == 0)\n                    gfc.noise_shaping = 1;\n                if (gfc.substep_shaping == 0)\n                    gfc.substep_shaping = 2;\n                gfc.noise_shaping_amp = 2;\n                gfc.noise_shaping_stop = 1;\n                if (gfc.subblock_gain == -1)\n                    gfc.subblock_gain = 1;\n                gfc.use_best_huffman = 1;\n                gfc.full_outer_loop = 0;\n                break;\n\n            case 0:\n                gfc.psymodel = 1;\n                if (gfc.noise_shaping == 0)\n                    gfc.noise_shaping = 1;\n                if (gfc.substep_shaping == 0)\n                    gfc.substep_shaping = 2;\n                gfc.noise_shaping_amp = 2;\n                gfc.noise_shaping_stop = 1;\n                if (gfc.subblock_gain == -1)\n                    gfc.subblock_gain = 1;\n                gfc.use_best_huffman = 1;\n                /*\n                 * type 2 disabled because of it slowness, in favor of full outer\n                 * loop search\n                 */\n                gfc.full_outer_loop = 0;\n                /*\n                 * full outer loop search disabled because of audible distortions it\n                 * may generate rh 060629\n                 */\n                break;\n        }\n\n    }\n\n    function lame_init_bitstream(gfp) {\n        var gfc = gfp.internal_flags;\n        gfp.frameNum = 0;\n\n        if (gfp.write_id3tag_automatic) {\n            id3.id3tag_write_v2(gfp);\n        }\n        /* initialize histogram data optionally used by frontend */\n\n        gfc.bitrate_stereoMode_Hist = new_int_n([16, 4 + 1]);\n        gfc.bitrate_blockType_Hist = new_int_n([16, 4 + 1 + 1]);\n\n        gfc.PeakSample = 0.0;\n\n        /* Write initial VBR Header to bitstream and init VBR data */\n        if (gfp.bWriteVbrTag)\n            vbr.InitVbrTag(gfp);\n    }\n\n    /********************************************************************\n     * initialize internal params based on data in gf (globalflags struct filled\n     * in by calling program)\n     *\n     * OUTLINE:\n     *\n     * We first have some complex code to determine bitrate, output samplerate\n     * and mode. It is complicated by the fact that we allow the user to set\n     * some or all of these parameters, and need to determine best possible\n     * values for the rest of them:\n     *\n     * 1. set some CPU related flags 2. check if we are mono.mono, stereo.mono\n     * or stereo.stereo 3. compute bitrate and output samplerate: user may have\n     * set compression ratio user may have set a bitrate user may have set a\n     * output samplerate 4. set some options which depend on output samplerate\n     * 5. compute the actual compression ratio 6. set mode based on compression\n     * ratio\n     *\n     * The remaining code is much simpler - it just sets options based on the\n     * mode & compression ratio:\n     *\n     * set allow_diff_short based on mode select lowpass filter based on\n     * compression ratio & mode set the bitrate index, and min/max bitrates for\n     * VBR modes disable VBR tag if it is not appropriate initialize the\n     * bitstream initialize scalefac_band data set sideinfo_len (based on\n     * channels, CRC, out_samplerate) write an id3v2 tag into the bitstream\n     * write VBR tag into the bitstream set mpeg1/2 flag estimate the number of\n     * frames (based on a lot of data)\n     *\n     * now we set more flags: nspsytune: see code VBR modes see code CBR/ABR see\n     * code\n     *\n     * Finally, we set the algorithm flags based on the gfp.quality value\n     * lame_init_qval(gfp);\n     *\n     ********************************************************************/\n    this.lame_init_params = function (gfp) {\n        var gfc = gfp.internal_flags;\n\n        gfc.Class_ID = 0;\n        if (gfc.ATH == null)\n            gfc.ATH = new ATH();\n        if (gfc.PSY == null)\n            gfc.PSY = new PSY();\n        if (gfc.rgdata == null)\n            gfc.rgdata = new ReplayGain();\n\n        gfc.channels_in = gfp.num_channels;\n        if (gfc.channels_in == 1)\n            gfp.mode = MPEGMode.MONO;\n        gfc.channels_out = (gfp.mode == MPEGMode.MONO) ? 1 : 2;\n        gfc.mode_ext = Encoder.MPG_MD_MS_LR;\n        if (gfp.mode == MPEGMode.MONO)\n            gfp.force_ms = false;\n        /*\n         * don't allow forced mid/side stereo for mono output\n         */\n\n        if (gfp.VBR == VbrMode.vbr_off && gfp.VBR_mean_bitrate_kbps != 128\n            && gfp.brate == 0)\n            gfp.brate = gfp.VBR_mean_bitrate_kbps;\n\n        if (gfp.VBR == VbrMode.vbr_off || gfp.VBR == VbrMode.vbr_mtrh\n            || gfp.VBR == VbrMode.vbr_mt) {\n            /* these modes can handle free format condition */\n        } else {\n            gfp.free_format = false;\n            /* mode can't be mixed with free format */\n        }\n\n        if (gfp.VBR == VbrMode.vbr_off && gfp.brate == 0) {\n            /* no bitrate or compression ratio specified, use 11.025 */\n            if (BitStream.EQ(gfp.compression_ratio, 0))\n                gfp.compression_ratio = 11.025;\n            /*\n             * rate to compress a CD down to exactly 128000 bps\n             */\n        }\n\n        /* find bitrate if user specify a compression ratio */\n        if (gfp.VBR == VbrMode.vbr_off && gfp.compression_ratio > 0) {\n\n            if (gfp.out_samplerate == 0)\n                gfp.out_samplerate = map2MP3Frequency((int)(0.97 * gfp.in_samplerate));\n            /*\n             * round up with a margin of 3 %\n             */\n\n            /*\n             * choose a bitrate for the output samplerate which achieves\n             * specified compression ratio\n             */\n            gfp.brate = 0 | (gfp.out_samplerate * 16 * gfc.channels_out / (1.e3 * gfp.compression_ratio));\n\n            /* we need the version for the bitrate table look up */\n            gfc.samplerate_index = SmpFrqIndex(gfp.out_samplerate, gfp);\n\n            if (!gfp.free_format) /*\n             * for non Free Format find the nearest allowed\n             * bitrate\n             */\n                gfp.brate = FindNearestBitrate(gfp.brate, gfp.version,\n                    gfp.out_samplerate);\n        }\n\n        if (gfp.out_samplerate != 0) {\n            if (gfp.out_samplerate < 16000) {\n                gfp.VBR_mean_bitrate_kbps = Math.max(gfp.VBR_mean_bitrate_kbps,\n                    8);\n                gfp.VBR_mean_bitrate_kbps = Math.min(gfp.VBR_mean_bitrate_kbps,\n                    64);\n            } else if (gfp.out_samplerate < 32000) {\n                gfp.VBR_mean_bitrate_kbps = Math.max(gfp.VBR_mean_bitrate_kbps,\n                    8);\n                gfp.VBR_mean_bitrate_kbps = Math.min(gfp.VBR_mean_bitrate_kbps,\n                    160);\n            } else {\n                gfp.VBR_mean_bitrate_kbps = Math.max(gfp.VBR_mean_bitrate_kbps,\n                    32);\n                gfp.VBR_mean_bitrate_kbps = Math.min(gfp.VBR_mean_bitrate_kbps,\n                    320);\n            }\n        }\n\n        /****************************************************************/\n        /* if a filter has not been enabled, see if we should add one: */\n        /****************************************************************/\n        if (gfp.lowpassfreq == 0) {\n            var lowpass = 16000.;\n\n            switch (gfp.VBR) {\n                case VbrMode.vbr_off:\n                {\n                    var lh = new LowPassHighPass();\n                    optimum_bandwidth(lh, gfp.brate);\n                    lowpass = lh.lowerlimit;\n                    break;\n                }\n                case VbrMode.vbr_abr:\n                {\n                    var lh = new LowPassHighPass();\n                    optimum_bandwidth(lh, gfp.VBR_mean_bitrate_kbps);\n                    lowpass = lh.lowerlimit;\n                    break;\n                }\n                case VbrMode.vbr_rh:\n                {\n                    var x = [19500, 19000, 18600, 18000, 17500, 16000,\n                        15600, 14900, 12500, 10000, 3950];\n                    if (0 <= gfp.VBR_q && gfp.VBR_q <= 9) {\n                        var a = x[gfp.VBR_q], b = x[gfp.VBR_q + 1], m = gfp.VBR_q_frac;\n                        lowpass = linear_int(a, b, m);\n                    } else {\n                        lowpass = 19500;\n                    }\n                    break;\n                }\n                default:\n                {\n                    var x = [19500, 19000, 18500, 18000, 17500, 16500,\n                        15500, 14500, 12500, 9500, 3950];\n                    if (0 <= gfp.VBR_q && gfp.VBR_q <= 9) {\n                        var a = x[gfp.VBR_q], b = x[gfp.VBR_q + 1], m = gfp.VBR_q_frac;\n                        lowpass = linear_int(a, b, m);\n                    } else {\n                        lowpass = 19500;\n                    }\n                }\n            }\n            if (gfp.mode == MPEGMode.MONO\n                && (gfp.VBR == VbrMode.vbr_off || gfp.VBR == VbrMode.vbr_abr))\n                lowpass *= 1.5;\n\n            gfp.lowpassfreq = lowpass | 0;\n        }\n\n        if (gfp.out_samplerate == 0) {\n            if (2 * gfp.lowpassfreq > gfp.in_samplerate) {\n                gfp.lowpassfreq = gfp.in_samplerate / 2;\n            }\n            gfp.out_samplerate = optimum_samplefreq(gfp.lowpassfreq | 0,\n                gfp.in_samplerate);\n        }\n\n        gfp.lowpassfreq = Math.min(20500, gfp.lowpassfreq);\n        gfp.lowpassfreq = Math.min(gfp.out_samplerate / 2, gfp.lowpassfreq);\n\n        if (gfp.VBR == VbrMode.vbr_off) {\n            gfp.compression_ratio = gfp.out_samplerate * 16 * gfc.channels_out\n                / (1.e3 * gfp.brate);\n        }\n        if (gfp.VBR == VbrMode.vbr_abr) {\n            gfp.compression_ratio = gfp.out_samplerate * 16 * gfc.channels_out\n                / (1.e3 * gfp.VBR_mean_bitrate_kbps);\n        }\n\n        /*\n         * do not compute ReplayGain values and do not find the peak sample if\n         * we can't store them\n         */\n        if (!gfp.bWriteVbrTag) {\n            gfp.findReplayGain = false;\n            gfp.decode_on_the_fly = false;\n            gfc.findPeakSample = false;\n        }\n        gfc.findReplayGain = gfp.findReplayGain;\n        gfc.decode_on_the_fly = gfp.decode_on_the_fly;\n\n        if (gfc.decode_on_the_fly)\n            gfc.findPeakSample = true;\n\n        if (gfc.findReplayGain) {\n            if (ga.InitGainAnalysis(gfc.rgdata, gfp.out_samplerate) == GainAnalysis.INIT_GAIN_ANALYSIS_ERROR) {\n                gfp.internal_flags = null;\n                return -6;\n            }\n        }\n\n        if (gfc.decode_on_the_fly && !gfp.decode_only) {\n            if (gfc.hip != null) {\n                mpglib.hip_decode_exit(gfc.hip);\n            }\n            gfc.hip = mpglib.hip_decode_init();\n        }\n\n        gfc.mode_gr = gfp.out_samplerate <= 24000 ? 1 : 2;\n        /*\n         * Number of granules per frame\n         */\n        gfp.framesize = 576 * gfc.mode_gr;\n        gfp.encoder_delay = Encoder.ENCDELAY;\n\n        gfc.resample_ratio = gfp.in_samplerate / gfp.out_samplerate;\n\n        /**\n         * <PRE>\n         *  sample freq       bitrate     compression ratio\n         *     [kHz]      [kbps/channel]   for 16 bit input\n         *     44.1            56               12.6\n         *     44.1            64               11.025\n         *     44.1            80                8.82\n         *     22.05           24               14.7\n         *     22.05           32               11.025\n         *     22.05           40                8.82\n         *     16              16               16.0\n         *     16              24               10.667\n         * </PRE>\n         */\n        /**\n         * <PRE>\n         *  For VBR, take a guess at the compression_ratio.\n         *  For example:\n         *\n         *    VBR_q    compression     like\n         *     -        4.4         320 kbps/44 kHz\n         *   0...1      5.5         256 kbps/44 kHz\n         *     2        7.3         192 kbps/44 kHz\n         *     4        8.8         160 kbps/44 kHz\n         *     6       11           128 kbps/44 kHz\n         *     9       14.7          96 kbps\n         *\n         *  for lower bitrates, downsample with --resample\n         * </PRE>\n         */\n        switch (gfp.VBR) {\n            case VbrMode.vbr_mt:\n            case VbrMode.vbr_rh:\n            case VbrMode.vbr_mtrh:\n            {\n                /* numbers are a bit strange, but they determine the lowpass value */\n                var cmp = [5.7, 6.5, 7.3, 8.2, 10, 11.9, 13, 14,\n                    15, 16.5];\n                gfp.compression_ratio = cmp[gfp.VBR_q];\n            }\n                break;\n            case VbrMode.vbr_abr:\n                gfp.compression_ratio = gfp.out_samplerate * 16 * gfc.channels_out\n                    / (1.e3 * gfp.VBR_mean_bitrate_kbps);\n                break;\n            default:\n                gfp.compression_ratio = gfp.out_samplerate * 16 * gfc.channels_out\n                    / (1.e3 * gfp.brate);\n                break;\n        }\n\n        /*\n         * mode = -1 (not set by user) or mode = MONO (because of only 1 input\n         * channel). If mode has not been set, then select J-STEREO\n         */\n        if (gfp.mode == MPEGMode.NOT_SET) {\n            gfp.mode = MPEGMode.JOINT_STEREO;\n        }\n\n        /* apply user driven high pass filter */\n        if (gfp.highpassfreq > 0) {\n            gfc.highpass1 = 2. * gfp.highpassfreq;\n\n            if (gfp.highpasswidth >= 0)\n                gfc.highpass2 = 2. * (gfp.highpassfreq + gfp.highpasswidth);\n            else\n            /* 0% above on default */\n                gfc.highpass2 = (1 + 0.00) * 2. * gfp.highpassfreq;\n\n            gfc.highpass1 /= gfp.out_samplerate;\n            gfc.highpass2 /= gfp.out_samplerate;\n        } else {\n            gfc.highpass1 = 0;\n            gfc.highpass2 = 0;\n        }\n        /* apply user driven low pass filter */\n        if (gfp.lowpassfreq > 0) {\n            gfc.lowpass2 = 2. * gfp.lowpassfreq;\n            if (gfp.lowpasswidth >= 0) {\n                gfc.lowpass1 = 2. * (gfp.lowpassfreq - gfp.lowpasswidth);\n                if (gfc.lowpass1 < 0) /* has to be >= 0 */\n                    gfc.lowpass1 = 0;\n            } else { /* 0% below on default */\n                gfc.lowpass1 = (1 - 0.00) * 2. * gfp.lowpassfreq;\n            }\n            gfc.lowpass1 /= gfp.out_samplerate;\n            gfc.lowpass2 /= gfp.out_samplerate;\n        } else {\n            gfc.lowpass1 = 0;\n            gfc.lowpass2 = 0;\n        }\n\n        /**********************************************************************/\n        /* compute info needed for polyphase filter (filter type==0, default) */\n        /**********************************************************************/\n        lame_init_params_ppflt(gfp);\n        /*******************************************************\n         * samplerate and bitrate index\n         *******************************************************/\n        gfc.samplerate_index = SmpFrqIndex(gfp.out_samplerate, gfp);\n        if (gfc.samplerate_index < 0) {\n            gfp.internal_flags = null;\n            return -1;\n        }\n\n        if (gfp.VBR == VbrMode.vbr_off) {\n            if (gfp.free_format) {\n                gfc.bitrate_index = 0;\n            } else {\n                gfp.brate = FindNearestBitrate(gfp.brate, gfp.version,\n                    gfp.out_samplerate);\n                gfc.bitrate_index = BitrateIndex(gfp.brate, gfp.version,\n                    gfp.out_samplerate);\n                if (gfc.bitrate_index <= 0) {\n                    gfp.internal_flags = null;\n                    return -1;\n                }\n            }\n        } else {\n            gfc.bitrate_index = 1;\n        }\n\n        /* for CBR, we will write an \"info\" tag. */\n\n        if (gfp.analysis)\n            gfp.bWriteVbrTag = false;\n\n        /* some file options not allowed if output is: not specified or stdout */\n        if (gfc.pinfo != null)\n            gfp.bWriteVbrTag = false;\n        /* disable Xing VBR tag */\n\n        bs.init_bit_stream_w(gfc);\n\n        var j = gfc.samplerate_index + (3 * gfp.version) + 6\n            * (gfp.out_samplerate < 16000 ? 1 : 0);\n        for (var i = 0; i < Encoder.SBMAX_l + 1; i++)\n            gfc.scalefac_band.l[i] = qupvt.sfBandIndex[j].l[i];\n\n        for (var i = 0; i < Encoder.PSFB21 + 1; i++) {\n            var size = (gfc.scalefac_band.l[22] - gfc.scalefac_band.l[21])\n                / Encoder.PSFB21;\n            var start = gfc.scalefac_band.l[21] + i * size;\n            gfc.scalefac_band.psfb21[i] = start;\n        }\n        gfc.scalefac_band.psfb21[Encoder.PSFB21] = 576;\n\n        for (var i = 0; i < Encoder.SBMAX_s + 1; i++)\n            gfc.scalefac_band.s[i] = qupvt.sfBandIndex[j].s[i];\n\n        for (var i = 0; i < Encoder.PSFB12 + 1; i++) {\n            var size = (gfc.scalefac_band.s[13] - gfc.scalefac_band.s[12])\n                / Encoder.PSFB12;\n            var start = gfc.scalefac_band.s[12] + i * size;\n            gfc.scalefac_band.psfb12[i] = start;\n        }\n        gfc.scalefac_band.psfb12[Encoder.PSFB12] = 192;\n        /* determine the mean bitrate for main data */\n        if (gfp.version == 1) /* MPEG 1 */\n            gfc.sideinfo_len = (gfc.channels_out == 1) ? 4 + 17 : 4 + 32;\n        else\n        /* MPEG 2 */\n            gfc.sideinfo_len = (gfc.channels_out == 1) ? 4 + 9 : 4 + 17;\n\n        if (gfp.error_protection)\n            gfc.sideinfo_len += 2;\n\n        lame_init_bitstream(gfp);\n\n        gfc.Class_ID = LAME_ID;\n\n        {\n            var k;\n\n            for (k = 0; k < 19; k++)\n                gfc.nsPsy.pefirbuf[k] = 700 * gfc.mode_gr * gfc.channels_out;\n\n            if (gfp.ATHtype == -1)\n                gfp.ATHtype = 4;\n        }\n        assert(gfp.VBR_q <= 9);\n        assert(gfp.VBR_q >= 0);\n\n        switch (gfp.VBR) {\n\n            case VbrMode.vbr_mt:\n                gfp.VBR = VbrMode.vbr_mtrh;\n            //$FALL-THROUGH$\n            case VbrMode.vbr_mtrh:\n            {\n                if (gfp.useTemporal == null) {\n                    gfp.useTemporal = false;\n                    /* off by default for this VBR mode */\n                }\n\n                p.apply_preset(gfp, 500 - (gfp.VBR_q * 10), 0);\n                /**\n                 * <PRE>\n                 *   The newer VBR code supports only a limited\n                 *     subset of quality levels:\n                 *     9-5=5 are the same, uses x^3/4 quantization\n                 *   4-0=0 are the same  5 plus best huffman divide code\n                 * </PRE>\n                 */\n                if (gfp.quality < 0)\n                    gfp.quality = LAME_DEFAULT_QUALITY;\n                if (gfp.quality < 5)\n                    gfp.quality = 0;\n                if (gfp.quality > 5)\n                    gfp.quality = 5;\n\n                gfc.PSY.mask_adjust = gfp.maskingadjust;\n                gfc.PSY.mask_adjust_short = gfp.maskingadjust_short;\n\n                /*\n                 * sfb21 extra only with MPEG-1 at higher sampling rates\n                 */\n                if (gfp.experimentalY)\n                    gfc.sfb21_extra = false;\n                else\n                    gfc.sfb21_extra = (gfp.out_samplerate > 44000);\n\n                gfc.iteration_loop = new VBRNewIterationLoop(qu);\n                break;\n\n            }\n            case VbrMode.vbr_rh:\n            {\n\n                p.apply_preset(gfp, 500 - (gfp.VBR_q * 10), 0);\n\n                gfc.PSY.mask_adjust = gfp.maskingadjust;\n                gfc.PSY.mask_adjust_short = gfp.maskingadjust_short;\n\n                /*\n                 * sfb21 extra only with MPEG-1 at higher sampling rates\n                 */\n                if (gfp.experimentalY)\n                    gfc.sfb21_extra = false;\n                else\n                    gfc.sfb21_extra = (gfp.out_samplerate > 44000);\n\n                /*\n                 * VBR needs at least the output of GPSYCHO, so we have to garantee\n                 * that by setting a minimum quality level, actually level 6 does\n                 * it. down to level 6\n                 */\n                if (gfp.quality > 6)\n                    gfp.quality = 6;\n\n                if (gfp.quality < 0)\n                    gfp.quality = LAME_DEFAULT_QUALITY;\n\n                gfc.iteration_loop = new VBROldIterationLoop(qu);\n                break;\n            }\n\n            default: /* cbr/abr */\n            {\n                var vbrmode;\n\n                /*\n                 * no sfb21 extra with CBR code\n                 */\n                gfc.sfb21_extra = false;\n\n                if (gfp.quality < 0)\n                    gfp.quality = LAME_DEFAULT_QUALITY;\n\n                vbrmode = gfp.VBR;\n                if (vbrmode == VbrMode.vbr_off)\n                    gfp.VBR_mean_bitrate_kbps = gfp.brate;\n                /* second, set parameters depending on bitrate */\n                p.apply_preset(gfp, gfp.VBR_mean_bitrate_kbps, 0);\n                gfp.VBR = vbrmode;\n\n                gfc.PSY.mask_adjust = gfp.maskingadjust;\n                gfc.PSY.mask_adjust_short = gfp.maskingadjust_short;\n\n                if (vbrmode == VbrMode.vbr_off) {\n                    gfc.iteration_loop = new CBRNewIterationLoop(qu);\n                } else {\n                    gfc.iteration_loop = new ABRIterationLoop(qu);\n                }\n                break;\n            }\n        }\n        assert(gfp.scale >= 0);\n        /* initialize default values common for all modes */\n\n        if (gfp.VBR != VbrMode.vbr_off) { /* choose a min/max bitrate for VBR */\n            /* if the user didn't specify VBR_max_bitrate: */\n            gfc.VBR_min_bitrate = 1;\n            /*\n             * default: allow 8 kbps (MPEG-2) or 32 kbps (MPEG-1)\n             */\n            gfc.VBR_max_bitrate = 14;\n            /*\n             * default: allow 160 kbps (MPEG-2) or 320 kbps (MPEG-1)\n             */\n            if (gfp.out_samplerate < 16000)\n                gfc.VBR_max_bitrate = 8;\n            /* default: allow 64 kbps (MPEG-2.5) */\n            if (gfp.VBR_min_bitrate_kbps != 0) {\n                gfp.VBR_min_bitrate_kbps = FindNearestBitrate(\n                    gfp.VBR_min_bitrate_kbps, gfp.version,\n                    gfp.out_samplerate);\n                gfc.VBR_min_bitrate = BitrateIndex(gfp.VBR_min_bitrate_kbps,\n                    gfp.version, gfp.out_samplerate);\n                if (gfc.VBR_min_bitrate < 0)\n                    return -1;\n            }\n            if (gfp.VBR_max_bitrate_kbps != 0) {\n                gfp.VBR_max_bitrate_kbps = FindNearestBitrate(\n                    gfp.VBR_max_bitrate_kbps, gfp.version,\n                    gfp.out_samplerate);\n                gfc.VBR_max_bitrate = BitrateIndex(gfp.VBR_max_bitrate_kbps,\n                    gfp.version, gfp.out_samplerate);\n                if (gfc.VBR_max_bitrate < 0)\n                    return -1;\n            }\n            gfp.VBR_min_bitrate_kbps = Tables.bitrate_table[gfp.version][gfc.VBR_min_bitrate];\n            gfp.VBR_max_bitrate_kbps = Tables.bitrate_table[gfp.version][gfc.VBR_max_bitrate];\n            gfp.VBR_mean_bitrate_kbps = Math.min(\n                Tables.bitrate_table[gfp.version][gfc.VBR_max_bitrate],\n                gfp.VBR_mean_bitrate_kbps);\n            gfp.VBR_mean_bitrate_kbps = Math.max(\n                Tables.bitrate_table[gfp.version][gfc.VBR_min_bitrate],\n                gfp.VBR_mean_bitrate_kbps);\n        }\n\n        /* just another daily changing developer switch */\n        if (gfp.tune) {\n            gfc.PSY.mask_adjust += gfp.tune_value_a;\n            gfc.PSY.mask_adjust_short += gfp.tune_value_a;\n        }\n\n        /* initialize internal qval settings */\n        lame_init_qval(gfp);\n        assert(gfp.scale >= 0);\n        /*\n         * automatic ATH adjustment on\n         */\n        if (gfp.athaa_type < 0)\n            gfc.ATH.useAdjust = 3;\n        else\n            gfc.ATH.useAdjust = gfp.athaa_type;\n\n        /* initialize internal adaptive ATH settings -jd */\n        gfc.ATH.aaSensitivityP = Math.pow(10.0, gfp.athaa_sensitivity\n            / -10.0);\n\n        if (gfp.short_blocks == null) {\n            gfp.short_blocks = ShortBlock.short_block_allowed;\n        }\n\n        /*\n         * Note Jan/2003: Many hardware decoders cannot handle short blocks in\n         * regular stereo mode unless they are coupled (same type in both\n         * channels) it is a rare event (1 frame per min. or so) that LAME would\n         * use uncoupled short blocks, so lets turn them off until we decide how\n         * to handle this. No other encoders allow uncoupled short blocks, even\n         * though it is in the standard.\n         */\n        /*\n         * rh 20040217: coupling makes no sense for mono and dual-mono streams\n         */\n        if (gfp.short_blocks == ShortBlock.short_block_allowed\n            && (gfp.mode == MPEGMode.JOINT_STEREO || gfp.mode == MPEGMode.STEREO)) {\n            gfp.short_blocks = ShortBlock.short_block_coupled;\n        }\n\n        if (gfp.quant_comp < 0)\n            gfp.quant_comp = 1;\n        if (gfp.quant_comp_short < 0)\n            gfp.quant_comp_short = 0;\n\n        if (gfp.msfix < 0)\n            gfp.msfix = 0;\n\n        /* select psychoacoustic model */\n        gfp.exp_nspsytune = gfp.exp_nspsytune | 1;\n\n        if (gfp.internal_flags.nsPsy.attackthre < 0)\n            gfp.internal_flags.nsPsy.attackthre = PsyModel.NSATTACKTHRE;\n        if (gfp.internal_flags.nsPsy.attackthre_s < 0)\n            gfp.internal_flags.nsPsy.attackthre_s = PsyModel.NSATTACKTHRE_S;\n\n        assert(gfp.scale >= 0);\n\n        if (gfp.scale < 0)\n            gfp.scale = 1;\n\n        if (gfp.ATHtype < 0)\n            gfp.ATHtype = 4;\n\n        if (gfp.ATHcurve < 0)\n            gfp.ATHcurve = 4;\n\n        if (gfp.athaa_loudapprox < 0)\n            gfp.athaa_loudapprox = 2;\n\n        if (gfp.interChRatio < 0)\n            gfp.interChRatio = 0;\n\n        if (gfp.useTemporal == null)\n            gfp.useTemporal = true;\n        /* on by default */\n\n        /*\n         * padding method as described in\n         * \"MPEG-Layer3 / Bitstream Syntax and Decoding\" by Martin Sieler, Ralph\n         * Sperschneider\n         *\n         * note: there is no padding for the very first frame\n         *\n         * Robert Hegemann 2000-06-22\n         */\n        gfc.slot_lag = gfc.frac_SpF = 0;\n        if (gfp.VBR == VbrMode.vbr_off)\n            gfc.slot_lag = gfc.frac_SpF = (((gfp.version + 1) * 72000 * gfp.brate) % gfp.out_samplerate) | 0;\n\n        qupvt.iteration_init(gfp);\n        psy.psymodel_init(gfp);\n        assert(gfp.scale >= 0);\n        return 0;\n    }\n\n    function update_inbuffer_size(gfc, nsamples) {\n        if (gfc.in_buffer_0 == null || gfc.in_buffer_nsamples < nsamples) {\n            gfc.in_buffer_0 = new_float(nsamples);\n            gfc.in_buffer_1 = new_float(nsamples);\n            gfc.in_buffer_nsamples = nsamples;\n        }\n    }\n\n    this.lame_encode_flush = function (gfp, mp3buffer, mp3bufferPos, mp3buffer_size) {\n        var gfc = gfp.internal_flags;\n        var buffer = new_short_n([2, 1152]);\n        var imp3 = 0, mp3count, mp3buffer_size_remaining;\n\n        /*\n         * we always add POSTDELAY=288 padding to make sure granule with real\n         * data can be complety decoded (because of 50% overlap with next\n         * granule\n         */\n        var end_padding;\n        var frames_left;\n        var samples_to_encode = gfc.mf_samples_to_encode - Encoder.POSTDELAY;\n        var mf_needed = calcNeeded(gfp);\n\n        /* Was flush already called? */\n        if (gfc.mf_samples_to_encode < 1) {\n            return 0;\n        }\n        mp3count = 0;\n\n        if (gfp.in_samplerate != gfp.out_samplerate) {\n            /*\n             * delay due to resampling; needs to be fixed, if resampling code\n             * gets changed\n             */\n            samples_to_encode += 16. * gfp.out_samplerate / gfp.in_samplerate;\n        }\n        end_padding = gfp.framesize - (samples_to_encode % gfp.framesize);\n        if (end_padding < 576)\n            end_padding += gfp.framesize;\n        gfp.encoder_padding = end_padding;\n\n        frames_left = (samples_to_encode + end_padding) / gfp.framesize;\n\n        /*\n         * send in a frame of 0 padding until all internal sample buffers are\n         * flushed\n         */\n        while (frames_left > 0 && imp3 >= 0) {\n            var bunch = mf_needed - gfc.mf_size;\n            var frame_num = gfp.frameNum;\n\n            bunch *= gfp.in_samplerate;\n            bunch /= gfp.out_samplerate;\n            if (bunch > 1152)\n                bunch = 1152;\n            if (bunch < 1)\n                bunch = 1;\n\n            mp3buffer_size_remaining = mp3buffer_size - mp3count;\n\n            /* if user specifed buffer size = 0, dont check size */\n            if (mp3buffer_size == 0)\n                mp3buffer_size_remaining = 0;\n\n            imp3 = this.lame_encode_buffer(gfp, buffer[0], buffer[1], bunch,\n                mp3buffer, mp3bufferPos, mp3buffer_size_remaining);\n\n            mp3bufferPos += imp3;\n            mp3count += imp3;\n            frames_left -= (frame_num != gfp.frameNum) ? 1 : 0;\n        }\n        /*\n         * Set gfc.mf_samples_to_encode to 0, so we may detect and break loops\n         * calling it more than once in a row.\n         */\n        gfc.mf_samples_to_encode = 0;\n\n        if (imp3 < 0) {\n            /* some type of fatal error */\n            return imp3;\n        }\n\n        mp3buffer_size_remaining = mp3buffer_size - mp3count;\n        /* if user specifed buffer size = 0, dont check size */\n        if (mp3buffer_size == 0)\n            mp3buffer_size_remaining = 0;\n\n        /* mp3 related stuff. bit buffer might still contain some mp3 data */\n        bs.flush_bitstream(gfp);\n        imp3 = bs.copy_buffer(gfc, mp3buffer, mp3bufferPos,\n            mp3buffer_size_remaining, 1);\n        if (imp3 < 0) {\n            /* some type of fatal error */\n            return imp3;\n        }\n        mp3bufferPos += imp3;\n        mp3count += imp3;\n        mp3buffer_size_remaining = mp3buffer_size - mp3count;\n        /* if user specifed buffer size = 0, dont check size */\n        if (mp3buffer_size == 0)\n            mp3buffer_size_remaining = 0;\n\n        if (gfp.write_id3tag_automatic) {\n            /* write a id3 tag to the bitstream */\n            id3.id3tag_write_v1(gfp);\n\n            imp3 = bs.copy_buffer(gfc, mp3buffer, mp3bufferPos,\n                mp3buffer_size_remaining, 0);\n\n            if (imp3 < 0) {\n                return imp3;\n            }\n            mp3count += imp3;\n        }\n        return mp3count;\n    };\n\n    this.lame_encode_buffer = function (gfp, buffer_l, buffer_r, nsamples, mp3buf, mp3bufPos, mp3buf_size) {\n        var gfc = gfp.internal_flags;\n        var in_buffer = [null, null];\n\n        if (gfc.Class_ID != LAME_ID)\n            return -3;\n\n        if (nsamples == 0)\n            return 0;\n\n        update_inbuffer_size(gfc, nsamples);\n\n        in_buffer[0] = gfc.in_buffer_0;\n        in_buffer[1] = gfc.in_buffer_1;\n\n        /* make a copy of input buffer, changing type to sample_t */\n        for (var i = 0; i < nsamples; i++) {\n            in_buffer[0][i] = buffer_l[i];\n            if (gfc.channels_in > 1)\n                in_buffer[1][i] = buffer_r[i];\n        }\n\n        return lame_encode_buffer_sample(gfp, in_buffer[0], in_buffer[1],\n            nsamples, mp3buf, mp3bufPos, mp3buf_size);\n    }\n\n    function calcNeeded(gfp) {\n        var mf_needed = Encoder.BLKSIZE + gfp.framesize - Encoder.FFTOFFSET;\n        /*\n         * amount needed for FFT\n         */\n        mf_needed = Math.max(mf_needed, 512 + gfp.framesize - 32);\n        assert(LameInternalFlags.MFSIZE >= mf_needed);\n\n        return mf_needed;\n    }\n\n    function lame_encode_buffer_sample(gfp, buffer_l, buffer_r, nsamples, mp3buf, mp3bufPos, mp3buf_size) {\n        var gfc = gfp.internal_flags;\n        var mp3size = 0, ret, i, ch, mf_needed;\n        var mp3out;\n        var mfbuf = [null, null];\n        var in_buffer = [null, null];\n\n        if (gfc.Class_ID != LAME_ID)\n            return -3;\n\n        if (nsamples == 0)\n            return 0;\n\n        /* copy out any tags that may have been written into bitstream */\n        mp3out = bs.copy_buffer(gfc, mp3buf, mp3bufPos, mp3buf_size, 0);\n        if (mp3out < 0)\n            return mp3out;\n        /* not enough buffer space */\n        mp3bufPos += mp3out;\n        mp3size += mp3out;\n\n        in_buffer[0] = buffer_l;\n        in_buffer[1] = buffer_r;\n\n        /* Apply user defined re-scaling */\n\n        /* user selected scaling of the samples */\n        if (BitStream.NEQ(gfp.scale, 0) && BitStream.NEQ(gfp.scale, 1.0)) {\n            for (i = 0; i < nsamples; ++i) {\n                in_buffer[0][i] *= gfp.scale;\n                if (gfc.channels_out == 2)\n                    in_buffer[1][i] *= gfp.scale;\n            }\n        }\n\n        /* user selected scaling of the channel 0 (left) samples */\n        if (BitStream.NEQ(gfp.scale_left, 0)\n            && BitStream.NEQ(gfp.scale_left, 1.0)) {\n            for (i = 0; i < nsamples; ++i) {\n                in_buffer[0][i] *= gfp.scale_left;\n            }\n        }\n\n        /* user selected scaling of the channel 1 (right) samples */\n        if (BitStream.NEQ(gfp.scale_right, 0)\n            && BitStream.NEQ(gfp.scale_right, 1.0)) {\n            for (i = 0; i < nsamples; ++i) {\n                in_buffer[1][i] *= gfp.scale_right;\n            }\n        }\n\n        /* Downsample to Mono if 2 channels in and 1 channel out */\n        if (gfp.num_channels == 2 && gfc.channels_out == 1) {\n            for (i = 0; i < nsamples; ++i) {\n                in_buffer[0][i] = 0.5 * ( in_buffer[0][i] + in_buffer[1][i]);\n                in_buffer[1][i] = 0.0;\n            }\n        }\n\n        mf_needed = calcNeeded(gfp);\n\n        mfbuf[0] = gfc.mfbuf[0];\n        mfbuf[1] = gfc.mfbuf[1];\n\n        var in_bufferPos = 0;\n        while (nsamples > 0) {\n            var in_buffer_ptr = [null, null];\n            var n_in = 0;\n            /* number of input samples processed with fill_buffer */\n            var n_out = 0;\n            /* number of samples output with fill_buffer */\n            /* n_in <> n_out if we are resampling */\n\n            in_buffer_ptr[0] = in_buffer[0];\n            in_buffer_ptr[1] = in_buffer[1];\n            /* copy in new samples into mfbuf, with resampling */\n            var inOut = new InOut();\n            fill_buffer(gfp, mfbuf, in_buffer_ptr, in_bufferPos, nsamples,\n                inOut);\n            n_in = inOut.n_in;\n            n_out = inOut.n_out;\n\n            /* compute ReplayGain of resampled input if requested */\n            if (gfc.findReplayGain && !gfc.decode_on_the_fly)\n                if (ga.AnalyzeSamples(gfc.rgdata, mfbuf[0], gfc.mf_size,\n                        mfbuf[1], gfc.mf_size, n_out, gfc.channels_out) == GainAnalysis.GAIN_ANALYSIS_ERROR)\n                    return -6;\n\n            /* update in_buffer counters */\n            nsamples -= n_in;\n            in_bufferPos += n_in;\n            if (gfc.channels_out == 2)\n                ;// in_bufferPos += n_in;\n\n            /* update mfbuf[] counters */\n            gfc.mf_size += n_out;\n            assert(gfc.mf_size <= LameInternalFlags.MFSIZE);\n\n            /*\n             * lame_encode_flush may have set gfc.mf_sample_to_encode to 0 so we\n             * have to reinitialize it here when that happened.\n             */\n            if (gfc.mf_samples_to_encode < 1) {\n                gfc.mf_samples_to_encode = Encoder.ENCDELAY + Encoder.POSTDELAY;\n            }\n            gfc.mf_samples_to_encode += n_out;\n\n            if (gfc.mf_size >= mf_needed) {\n                /* encode the frame. */\n                /* mp3buf = pointer to current location in buffer */\n                /* mp3buf_size = size of original mp3 output buffer */\n                /* = 0 if we should not worry about the */\n                /* buffer size because calling program is */\n                /* to lazy to compute it */\n                /* mp3size = size of data written to buffer so far */\n                /* mp3buf_size-mp3size = amount of space avalable */\n\n                var buf_size = mp3buf_size - mp3size;\n                if (mp3buf_size == 0)\n                    buf_size = 0;\n\n                ret = lame_encode_frame(gfp, mfbuf[0], mfbuf[1], mp3buf,\n                    mp3bufPos, buf_size);\n\n                if (ret < 0)\n                    return ret;\n                mp3bufPos += ret;\n                mp3size += ret;\n\n                /* shift out old samples */\n                gfc.mf_size -= gfp.framesize;\n                gfc.mf_samples_to_encode -= gfp.framesize;\n                for (ch = 0; ch < gfc.channels_out; ch++)\n                    for (i = 0; i < gfc.mf_size; i++)\n                        mfbuf[ch][i] = mfbuf[ch][i + gfp.framesize];\n            }\n        }\n        assert(nsamples == 0);\n\n        return mp3size;\n    }\n\n    function lame_encode_frame(gfp, inbuf_l, inbuf_r, mp3buf, mp3bufPos, mp3buf_size) {\n        var ret = self.enc.lame_encode_mp3_frame(gfp, inbuf_l, inbuf_r, mp3buf,\n            mp3bufPos, mp3buf_size);\n        gfp.frameNum++;\n        return ret;\n    }\n\n    function InOut() {\n        this.n_in = 0;\n        this.n_out = 0;\n    }\n\n\n    function NumUsed() {\n        this.num_used = 0;\n    }\n\n    /**\n     * Greatest common divisor.\n     * <p>\n     * Joint work of Euclid and M. Hendry\n     */\n    function gcd(i, j) {\n        return j != 0 ? gcd(j, i % j) : i;\n    }\n\n    /**\n     * Resampling via FIR filter, blackman window.\n     */\n    function blackman(x, fcn, l) {\n        /*\n         * This algorithm from: SIGNAL PROCESSING ALGORITHMS IN FORTRAN AND C\n         * S.D. Stearns and R.A. David, Prentice-Hall, 1992\n         */\n        var wcn = (Math.PI * fcn);\n\n        x /= l;\n        if (x < 0)\n            x = 0;\n        if (x > 1)\n            x = 1;\n        var x2 = x - .5;\n\n        var bkwn = 0.42 - 0.5 * Math.cos(2 * x * Math.PI) + 0.08 * Math.cos(4 * x * Math.PI);\n        if (Math.abs(x2) < 1e-9)\n            return (wcn / Math.PI);\n        else\n            return (bkwn * Math.sin(l * wcn * x2) / (Math.PI * l * x2));\n    }\n\n    function fill_buffer_resample(gfp, outbuf, outbufPos, desired_len, inbuf, in_bufferPos, len, num_used, ch) {\n        var gfc = gfp.internal_flags;\n        var i, j = 0, k;\n        /* number of convolution functions to pre-compute */\n        var bpc = gfp.out_samplerate\n            / gcd(gfp.out_samplerate, gfp.in_samplerate);\n        if (bpc > LameInternalFlags.BPC)\n            bpc = LameInternalFlags.BPC;\n\n        var intratio = (Math.abs(gfc.resample_ratio\n            - Math.floor(.5 + gfc.resample_ratio)) < .0001) ? 1 : 0;\n        var fcn = 1.00 / gfc.resample_ratio;\n        if (fcn > 1.00)\n            fcn = 1.00;\n        var filter_l = 31;\n        if (0 == filter_l % 2)\n            --filter_l;\n        /* must be odd */\n        filter_l += intratio;\n        /* unless resample_ratio=int, it must be even */\n\n        var BLACKSIZE = filter_l + 1;\n        /* size of data needed for FIR */\n\n        if (gfc.fill_buffer_resample_init == 0) {\n            gfc.inbuf_old[0] = new_float(BLACKSIZE);\n            gfc.inbuf_old[1] = new_float(BLACKSIZE);\n            for (i = 0; i <= 2 * bpc; ++i)\n                gfc.blackfilt[i] = new_float(BLACKSIZE);\n\n            gfc.itime[0] = 0;\n            gfc.itime[1] = 0;\n\n            /* precompute blackman filter coefficients */\n            for (j = 0; j <= 2 * bpc; j++) {\n                var sum = 0.;\n                var offset = (j - bpc) / (2. * bpc);\n                for (i = 0; i <= filter_l; i++)\n                    sum += gfc.blackfilt[j][i] = blackman(i - offset, fcn,\n                        filter_l);\n                for (i = 0; i <= filter_l; i++)\n                    gfc.blackfilt[j][i] /= sum;\n            }\n            gfc.fill_buffer_resample_init = 1;\n        }\n\n        var inbuf_old = gfc.inbuf_old[ch];\n\n        /* time of j'th element in inbuf = itime + j/ifreq; */\n        /* time of k'th element in outbuf = j/ofreq */\n        for (k = 0; k < desired_len; k++) {\n            var time0;\n            var joff;\n\n            time0 = k * gfc.resample_ratio;\n            /* time of k'th output sample */\n            j = 0 | Math.floor(time0 - gfc.itime[ch]);\n\n            /* check if we need more input data */\n            if ((filter_l + j - filter_l / 2) >= len)\n                break;\n\n            /* blackman filter. by default, window centered at j+.5(filter_l%2) */\n            /* but we want a window centered at time0. */\n            var offset = (time0 - gfc.itime[ch] - (j + .5 * (filter_l % 2)));\n            assert(Math.abs(offset) <= .501);\n\n            /* find the closest precomputed window for this offset: */\n            joff = 0 | Math.floor((offset * 2 * bpc) + bpc + .5);\n            var xvalue = 0.;\n            for (i = 0; i <= filter_l; ++i) {\n\t\t/* force integer index */\n                var j2 = 0 | (i + j - filter_l / 2); \n                var y;\n                assert(j2 < len);\n                assert(j2 + BLACKSIZE >= 0);\n                y = (j2 < 0) ? inbuf_old[BLACKSIZE + j2] : inbuf[in_bufferPos\n                + j2];\n                xvalue += y * gfc.blackfilt[joff][i];\n            }\n            outbuf[outbufPos + k] = xvalue;\n        }\n\n        /* k = number of samples added to outbuf */\n        /* last k sample used data from [j-filter_l/2,j+filter_l-filter_l/2] */\n\n        /* how many samples of input data were used: */\n        num_used.num_used = Math.min(len, filter_l + j - filter_l / 2);\n\n        /*\n         * adjust our input time counter. Incriment by the number of samples\n         * used, then normalize so that next output sample is at time 0, next\n         * input buffer is at time itime[ch]\n         */\n        gfc.itime[ch] += num_used.num_used - k * gfc.resample_ratio;\n\n        /* save the last BLACKSIZE samples into the inbuf_old buffer */\n        if (num_used.num_used >= BLACKSIZE) {\n            for (i = 0; i < BLACKSIZE; i++)\n                inbuf_old[i] = inbuf[in_bufferPos + num_used.num_used + i\n                - BLACKSIZE];\n        } else {\n            /* shift in num_used.num_used samples into inbuf_old */\n            var n_shift = BLACKSIZE - num_used.num_used;\n            /*\n             * number of samples to\n             * shift\n             */\n\n            /*\n             * shift n_shift samples by num_used.num_used, to make room for the\n             * num_used new samples\n             */\n            for (i = 0; i < n_shift; ++i)\n                inbuf_old[i] = inbuf_old[i + num_used.num_used];\n\n            /* shift in the num_used.num_used samples */\n            for (j = 0; i < BLACKSIZE; ++i, ++j)\n                inbuf_old[i] = inbuf[in_bufferPos + j];\n\n            assert(j == num_used.num_used);\n        }\n        return k;\n        /* return the number samples created at the new samplerate */\n    }\n\n    function fill_buffer(gfp, mfbuf, in_buffer, in_bufferPos, nsamples, io) {\n        var gfc = gfp.internal_flags;\n\n        /* copy in new samples into mfbuf, with resampling if necessary */\n        if ((gfc.resample_ratio < .9999) || (gfc.resample_ratio > 1.0001)) {\n            for (var ch = 0; ch < gfc.channels_out; ch++) {\n                var numUsed = new NumUsed();\n                io.n_out = fill_buffer_resample(gfp, mfbuf[ch], gfc.mf_size,\n                    gfp.framesize, in_buffer[ch], in_bufferPos, nsamples,\n                    numUsed, ch);\n                io.n_in = numUsed.num_used;\n            }\n        } else {\n            io.n_out = Math.min(gfp.framesize, nsamples);\n            io.n_in = io.n_out;\n            for (var i = 0; i < io.n_out; ++i) {\n                mfbuf[0][gfc.mf_size + i] = in_buffer[0][in_bufferPos + i];\n                if (gfc.channels_out == 2)\n                    mfbuf[1][gfc.mf_size + i] = in_buffer[1][in_bufferPos + i];\n            }\n        }\n    }\n\n}\n\nmodule.exports = Lame;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL0xhbWUuanMiLCJtYXBwaW5ncyI6IkFBQUEsYUFBYSxtQkFBTyxDQUFDLCtFQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLG1CQUFPLENBQUMsbUZBQWU7QUFDdEMsc0JBQXNCLG1CQUFPLENBQUMsaUdBQXNCO0FBQ3BELHdCQUF3QixtQkFBTyxDQUFDLHFHQUF3QjtBQUN4RCxVQUFVLG1CQUFPLENBQUMseUVBQVU7QUFDNUIsaUJBQWlCLG1CQUFPLENBQUMsdUZBQWlCO0FBQzFDLDBCQUEwQixtQkFBTyxDQUFDLHlHQUEwQjtBQUM1RCxnQkFBZ0IsbUJBQU8sQ0FBQyxxRkFBZ0I7QUFDeEMsYUFBYSxtQkFBTyxDQUFDLCtFQUFhO0FBQ2xDLGNBQWMsbUJBQU8sQ0FBQyxpRkFBYzs7QUFFcEM7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyxtRkFBZTtBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0IsWUFBWTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLFlBQVk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixXQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7O0FBRUEsd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLHlCQUF5QjtBQUNqRDs7QUFFQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCLFFBQVE7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHVCQUF1QjtBQUNwRCxnQ0FBZ0MsaUJBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0REFBNEQ7QUFDNUQ7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7O0FBRUE7QUFDQSx3QkFBd0IsZUFBZTtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2Qix1QkFBdUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xhbWVqcy9zcmMvanMvTGFtZS5qcz8xMTYxIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbi5qcycpO1xudmFyIFN5c3RlbSA9IGNvbW1vbi5TeXN0ZW07XG52YXIgVmJyTW9kZSA9IGNvbW1vbi5WYnJNb2RlO1xudmFyIEZsb2F0ID0gY29tbW9uLkZsb2F0O1xudmFyIFNob3J0QmxvY2sgPSBjb21tb24uU2hvcnRCbG9jaztcbnZhciBVdGlsID0gY29tbW9uLlV0aWw7XG52YXIgQXJyYXlzID0gY29tbW9uLkFycmF5cztcbnZhciBuZXdfYXJyYXlfbiA9IGNvbW1vbi5uZXdfYXJyYXlfbjtcbnZhciBuZXdfYnl0ZSA9IGNvbW1vbi5uZXdfYnl0ZTtcbnZhciBuZXdfZG91YmxlID0gY29tbW9uLm5ld19kb3VibGU7XG52YXIgbmV3X2Zsb2F0ID0gY29tbW9uLm5ld19mbG9hdDtcbnZhciBuZXdfZmxvYXRfbiA9IGNvbW1vbi5uZXdfZmxvYXRfbjtcbnZhciBuZXdfaW50ID0gY29tbW9uLm5ld19pbnQ7XG52YXIgbmV3X2ludF9uID0gY29tbW9uLm5ld19pbnRfbjtcbnZhciBuZXdfc2hvcnRfbiA9IGNvbW1vbi5uZXdfc2hvcnRfbjtcbnZhciBhc3NlcnQgPSBjb21tb24uYXNzZXJ0O1xuXG52YXIgUHN5TW9kZWwgPSByZXF1aXJlKCcuL1BzeU1vZGVsLmpzJyk7XG52YXIgTGFtZUdsb2JhbEZsYWdzID0gcmVxdWlyZSgnLi9MYW1lR2xvYmFsRmxhZ3MuanMnKTtcbnZhciBMYW1lSW50ZXJuYWxGbGFncyA9IHJlcXVpcmUoJy4vTGFtZUludGVybmFsRmxhZ3MuanMnKTtcbnZhciBBVEggPSByZXF1aXJlKCcuL0FUSC5qcycpO1xudmFyIFJlcGxheUdhaW4gPSByZXF1aXJlKCcuL1JlcGxheUdhaW4uanMnKTtcbnZhciBDQlJOZXdJdGVyYXRpb25Mb29wID0gcmVxdWlyZSgnLi9DQlJOZXdJdGVyYXRpb25Mb29wLmpzJyk7XG52YXIgQml0U3RyZWFtID0gcmVxdWlyZSgnLi9CaXRTdHJlYW0uanMnKTtcbnZhciBUYWJsZXMgPSByZXF1aXJlKCcuL1RhYmxlcy5qcycpO1xudmFyIEVuY29kZXIgPSByZXF1aXJlKCcuL0VuY29kZXIuanMnKTtcblxuZnVuY3Rpb24gTGFtZSgpIHtcbiAgICB2YXIgTVBFR01vZGUgPSByZXF1aXJlKCcuL01QRUdNb2RlLmpzJyk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBMQU1FX01BWEFMQlVNQVJUID0gKDEyOCAqIDEwMjQpO1xuXG4gICAgTGFtZS5WOSA9IDQxMDtcbiAgICBMYW1lLlY4ID0gNDIwO1xuICAgIExhbWUuVjcgPSA0MzA7XG4gICAgTGFtZS5WNiA9IDQ0MDtcbiAgICBMYW1lLlY1ID0gNDUwO1xuICAgIExhbWUuVjQgPSA0NjA7XG4gICAgTGFtZS5WMyA9IDQ3MDtcbiAgICBMYW1lLlYyID0gNDgwO1xuICAgIExhbWUuVjEgPSA0OTA7XG4gICAgTGFtZS5WMCA9IDUwMDtcblxuICAgIC8qIHN0aWxsIHRoZXJlIGZvciBjb21wYXRpYmlsaXR5ICovXG5cbiAgICBMYW1lLlIzTUlYID0gMTAwMDtcbiAgICBMYW1lLlNUQU5EQVJEID0gMTAwMTtcbiAgICBMYW1lLkVYVFJFTUUgPSAxMDAyO1xuICAgIExhbWUuSU5TQU5FID0gMTAwMztcbiAgICBMYW1lLlNUQU5EQVJEX0ZBU1QgPSAxMDA0O1xuICAgIExhbWUuRVhUUkVNRV9GQVNUID0gMTAwNTtcbiAgICBMYW1lLk1FRElVTSA9IDEwMDY7XG4gICAgTGFtZS5NRURJVU1fRkFTVCA9IDEwMDc7XG5cbiAgICAvKipcbiAgICAgKiBtYXhpbXVtIHNpemUgb2YgbXAzYnVmZmVyIG5lZWRlZCBpZiB5b3UgZW5jb2RlIGF0IG1vc3QgMTE1MiBzYW1wbGVzIGZvclxuICAgICAqIGVhY2ggY2FsbCB0byBsYW1lX2VuY29kZV9idWZmZXIuIHNlZSBsYW1lX2VuY29kZV9idWZmZXIoKSBiZWxvd1xuICAgICAqIChMQU1FX01BWE1QM0JVRkZFUiBpcyBub3cgb2Jzb2xldGUpXG4gICAgICovXG4gICAgdmFyIExBTUVfTUFYTVAzQlVGRkVSID0gKDE2Mzg0ICsgTEFNRV9NQVhBTEJVTUFSVCk7XG4gICAgTGFtZS5MQU1FX01BWE1QM0JVRkZFUiA9IExBTUVfTUFYTVAzQlVGRkVSO1xuXG4gICAgdmFyIGdhO1xuICAgIHZhciBicztcbiAgICB2YXIgcDtcbiAgICB2YXIgcXVwdnQ7XG4gICAgdmFyIHF1O1xuICAgIHZhciBwc3kgPSBuZXcgUHN5TW9kZWwoKTtcbiAgICB2YXIgdmJyO1xuICAgIHZhciB2ZXI7XG4gICAgdmFyIGlkMztcbiAgICB2YXIgbXBnbGliO1xuICAgIHRoaXMuZW5jID0gbmV3IEVuY29kZXIoKTtcblxuICAgIHRoaXMuc2V0TW9kdWxlcyA9IGZ1bmN0aW9uIChfZ2EsIF9icywgX3AsIF9xdXB2dCwgX3F1LCBfdmJyLCBfdmVyLCBfaWQzLCBfbXBnbGliKSB7XG4gICAgICAgIGdhID0gX2dhO1xuICAgICAgICBicyA9IF9icztcbiAgICAgICAgcCA9IF9wO1xuICAgICAgICBxdXB2dCA9IF9xdXB2dDtcbiAgICAgICAgcXUgPSBfcXU7XG4gICAgICAgIHZiciA9IF92YnI7XG4gICAgICAgIHZlciA9IF92ZXI7XG4gICAgICAgIGlkMyA9IF9pZDM7XG4gICAgICAgIG1wZ2xpYiA9IF9tcGdsaWI7XG4gICAgICAgIHRoaXMuZW5jLnNldE1vZHVsZXMoYnMsIHBzeSwgcXVwdnQsIHZicik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUFNZIE1vZGVsIHJlbGF0ZWQgc3R1ZmZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQU1koKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGJRIHN0dWZmLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXNrX2FkanVzdCA9IDAuO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRiUSBzdHVmZi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWFza19hZGp1c3Rfc2hvcnQgPSAwLjtcbiAgICAgICAgLyogYXQgdHJhbnNpdGlvbiBmcm9tIG9uZSBzY2FsZWZhY3RvciBiYW5kIHRvIG5leHQgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJhbmQgd2VpZ2h0IGxvbmcgc2NhbGVmYWN0b3IgYmFuZHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJvX2xfd2VpZ2h0ID0gbmV3X2Zsb2F0KEVuY29kZXIuU0JNQVhfbCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCYW5kIHdlaWdodCBzaG9ydCBzY2FsZWZhY3RvciBiYW5kcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYm9fc193ZWlnaHQgPSBuZXdfZmxvYXQoRW5jb2Rlci5TQk1BWF9zKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMb3dQYXNzSGlnaFBhc3MoKSB7XG4gICAgICAgIHRoaXMubG93ZXJsaW1pdCA9IDAuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEJhbmRQYXNzKGJpdHJhdGUsIGxQYXNzKSB7XG4gICAgICAgIHRoaXMubG93cGFzcyA9IGxQYXNzO1xuICAgIH1cblxuICAgIHZhciBMQU1FX0lEID0gMHhGRkY4OEUzQjtcblxuICAgIGZ1bmN0aW9uIGxhbWVfaW5pdF9vbGQoZ2ZwKSB7XG4gICAgICAgIHZhciBnZmM7XG5cbiAgICAgICAgZ2ZwLmNsYXNzX2lkID0gTEFNRV9JRDtcblxuICAgICAgICBnZmMgPSBnZnAuaW50ZXJuYWxfZmxhZ3MgPSBuZXcgTGFtZUludGVybmFsRmxhZ3MoKTtcblxuICAgICAgICAvKiBHbG9iYWwgZmxhZ3MuIHNldCBkZWZhdWx0cyBoZXJlIGZvciBub24temVybyB2YWx1ZXMgKi9cbiAgICAgICAgLyogc2VlIGxhbWUuaCBmb3IgZGVzY3JpcHRpb24gKi9cbiAgICAgICAgLypcbiAgICAgICAgICogc2V0IGludGVnZXIgdmFsdWVzIHRvIC0xIHRvIG1lYW4gdGhhdCBMQU1FIHdpbGwgY29tcHV0ZSB0aGUgYmVzdFxuICAgICAgICAgKiB2YWx1ZSwgVU5MRVNTIHRoZSBjYWxsaW5nIHByb2dyYW0gYXMgc2V0IGl0IChhbmQgdGhlIHZhbHVlIGlzIG5vXG4gICAgICAgICAqIGxvbmdlciAtMSlcbiAgICAgICAgICovXG5cbiAgICAgICAgZ2ZwLm1vZGUgPSBNUEVHTW9kZS5OT1RfU0VUO1xuICAgICAgICBnZnAub3JpZ2luYWwgPSAxO1xuICAgICAgICBnZnAuaW5fc2FtcGxlcmF0ZSA9IDQ0MTAwO1xuICAgICAgICBnZnAubnVtX2NoYW5uZWxzID0gMjtcbiAgICAgICAgZ2ZwLm51bV9zYW1wbGVzID0gLTE7XG5cbiAgICAgICAgZ2ZwLmJXcml0ZVZiclRhZyA9IHRydWU7XG4gICAgICAgIGdmcC5xdWFsaXR5ID0gLTE7XG4gICAgICAgIGdmcC5zaG9ydF9ibG9ja3MgPSBudWxsO1xuICAgICAgICBnZmMuc3ViYmxvY2tfZ2FpbiA9IC0xO1xuXG4gICAgICAgIGdmcC5sb3dwYXNzZnJlcSA9IDA7XG4gICAgICAgIGdmcC5oaWdocGFzc2ZyZXEgPSAwO1xuICAgICAgICBnZnAubG93cGFzc3dpZHRoID0gLTE7XG4gICAgICAgIGdmcC5oaWdocGFzc3dpZHRoID0gLTE7XG5cbiAgICAgICAgZ2ZwLlZCUiA9IFZick1vZGUudmJyX29mZjtcbiAgICAgICAgZ2ZwLlZCUl9xID0gNDtcbiAgICAgICAgZ2ZwLkFUSGN1cnZlID0gLTE7XG4gICAgICAgIGdmcC5WQlJfbWVhbl9iaXRyYXRlX2ticHMgPSAxMjg7XG4gICAgICAgIGdmcC5WQlJfbWluX2JpdHJhdGVfa2JwcyA9IDA7XG4gICAgICAgIGdmcC5WQlJfbWF4X2JpdHJhdGVfa2JwcyA9IDA7XG4gICAgICAgIGdmcC5WQlJfaGFyZF9taW4gPSAwO1xuICAgICAgICBnZmMuVkJSX21pbl9iaXRyYXRlID0gMTtcbiAgICAgICAgLyogbm90IDAgPz8/Pz8gKi9cbiAgICAgICAgZ2ZjLlZCUl9tYXhfYml0cmF0ZSA9IDEzO1xuICAgICAgICAvKiBub3QgMTQgPz8/Pz8gKi9cblxuICAgICAgICBnZnAucXVhbnRfY29tcCA9IC0xO1xuICAgICAgICBnZnAucXVhbnRfY29tcF9zaG9ydCA9IC0xO1xuXG4gICAgICAgIGdmcC5tc2ZpeCA9IC0xO1xuXG4gICAgICAgIGdmYy5yZXNhbXBsZV9yYXRpbyA9IDE7XG5cbiAgICAgICAgZ2ZjLk9sZFZhbHVlWzBdID0gMTgwO1xuICAgICAgICBnZmMuT2xkVmFsdWVbMV0gPSAxODA7XG4gICAgICAgIGdmYy5DdXJyZW50U3RlcFswXSA9IDQ7XG4gICAgICAgIGdmYy5DdXJyZW50U3RlcFsxXSA9IDQ7XG4gICAgICAgIGdmYy5tYXNraW5nX2xvd2VyID0gMTtcbiAgICAgICAgZ2ZjLm5zUHN5LmF0dGFja3RocmUgPSAtMTtcbiAgICAgICAgZ2ZjLm5zUHN5LmF0dGFja3RocmVfcyA9IC0xO1xuXG4gICAgICAgIGdmcC5zY2FsZSA9IC0xO1xuXG4gICAgICAgIGdmcC5hdGhhYV90eXBlID0gLTE7XG4gICAgICAgIGdmcC5BVEh0eXBlID0gLTE7XG4gICAgICAgIC8qIGRlZmF1bHQgPSAtMSA9IHNldCBpbiBsYW1lX2luaXRfcGFyYW1zICovXG4gICAgICAgIGdmcC5hdGhhYV9sb3VkYXBwcm94ID0gLTE7XG4gICAgICAgIC8qIDEgPSBmbGF0IGxvdWRuZXNzIGFwcHJveC4gKHRvdGFsIGVuZXJneSkgKi9cbiAgICAgICAgLyogMiA9IGVxdWFsIGxvdWRuZXNzIGN1cnZlICovXG4gICAgICAgIGdmcC5hdGhhYV9zZW5zaXRpdml0eSA9IDAuMDtcbiAgICAgICAgLyogbm8gb2Zmc2V0ICovXG4gICAgICAgIGdmcC51c2VUZW1wb3JhbCA9IG51bGw7XG4gICAgICAgIGdmcC5pbnRlckNoUmF0aW8gPSAtMTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBUaGUgcmVhc29uIGZvciBpbnQgbWZfc2FtcGxlc190b19lbmNvZGUgPSBFTkNERUxBWSArIFBPU1RERUxBWTtcbiAgICAgICAgICogRU5DREVMQVkgPSBpbnRlcm5hbCBlbmNvZGVyIGRlbGF5LiBBbmQgdGhlbiB3ZSBoYXZlIHRvIGFkZFxuICAgICAgICAgKiBQT1NUREVMQVk9Mjg4IGJlY2F1c2Ugb2YgdGhlIDUwJSBNRENUIG92ZXJsYXAuIEEgNTc2IE1EQ1QgZ3JhbnVsZVxuICAgICAgICAgKiBkZWNvZGVzIHRvIDExNTIgc2FtcGxlcy4gVG8gc3ludGhlc2l6ZSB0aGUgNTc2IHNhbXBsZXMgY2VudGVyZWQgdW5kZXJcbiAgICAgICAgICogdGhpcyBncmFudWxlIHdlIG5lZWQgdGhlIHByZXZpb3VzIGdyYW51bGUgZm9yIHRoZSBmaXJzdCAyODggc2FtcGxlc1xuICAgICAgICAgKiAobm8gcHJvYmxlbSksIGFuZCB0aGUgbmV4dCBncmFudWxlIGZvciB0aGUgbmV4dCAyODggc2FtcGxlcyAobm90XG4gICAgICAgICAqIHBvc3NpYmxlIGlmIHRoaXMgaXMgbGFzdCBncmFudWxlKS4gU28gd2UgbmVlZCB0byBwYWQgd2l0aCAyODggc2FtcGxlc1xuICAgICAgICAgKiB0byBtYWtlIHN1cmUgd2UgY2FuIGVuY29kZSB0aGUgNTc2IHNhbXBsZXMgd2UgYXJlIGludGVyZXN0ZWQgaW4uXG4gICAgICAgICAqL1xuICAgICAgICBnZmMubWZfc2FtcGxlc190b19lbmNvZGUgPSBFbmNvZGVyLkVOQ0RFTEFZICsgRW5jb2Rlci5QT1NUREVMQVk7XG4gICAgICAgIGdmcC5lbmNvZGVyX3BhZGRpbmcgPSAwO1xuICAgICAgICBnZmMubWZfc2l6ZSA9IEVuY29kZXIuRU5DREVMQVkgLSBFbmNvZGVyLk1EQ1RERUxBWTtcbiAgICAgICAgLypcbiAgICAgICAgICogd2UgcGFkIGlucHV0IHdpdGggdGhpcyBtYW55IDAnc1xuICAgICAgICAgKi9cblxuICAgICAgICBnZnAuZmluZFJlcGxheUdhaW4gPSBmYWxzZTtcbiAgICAgICAgZ2ZwLmRlY29kZV9vbl90aGVfZmx5ID0gZmFsc2U7XG5cbiAgICAgICAgZ2ZjLmRlY29kZV9vbl90aGVfZmx5ID0gZmFsc2U7XG4gICAgICAgIGdmYy5maW5kUmVwbGF5R2FpbiA9IGZhbHNlO1xuICAgICAgICBnZmMuZmluZFBlYWtTYW1wbGUgPSBmYWxzZTtcblxuICAgICAgICBnZmMuUmFkaW9HYWluID0gMDtcbiAgICAgICAgZ2ZjLkF1ZGlvcGhpbGVHYWluID0gMDtcbiAgICAgICAgZ2ZjLm5vY2xpcEdhaW5DaGFuZ2UgPSAwO1xuICAgICAgICBnZmMubm9jbGlwU2NhbGUgPSAtMS4wO1xuXG4gICAgICAgIGdmcC5wcmVzZXQgPSAwO1xuXG4gICAgICAgIGdmcC53cml0ZV9pZDN0YWdfYXV0b21hdGljID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgdGhpcy5sYW1lX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBnZnAgPSBuZXcgTGFtZUdsb2JhbEZsYWdzKCk7XG5cbiAgICAgICAgdmFyIHJldCA9IGxhbWVfaW5pdF9vbGQoZ2ZwKTtcbiAgICAgICAgaWYgKHJldCAhPSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGdmcC5sYW1lX2FsbG9jYXRlZF9nZnAgPSAxO1xuICAgICAgICByZXR1cm4gZ2ZwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbHRlcl9jb2VmKHgpIHtcbiAgICAgICAgaWYgKHggPiAxLjApXG4gICAgICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgICBpZiAoeCA8PSAwLjApXG4gICAgICAgICAgICByZXR1cm4gMS4wO1xuXG4gICAgICAgIHJldHVybiBNYXRoLmNvcyhNYXRoLlBJIC8gMiAqIHgpO1xuICAgIH1cblxuICAgIHRoaXMubmVhcmVzdEJpdHJhdGVGdWxsSW5kZXggPSBmdW5jdGlvbiAoYml0cmF0ZSkge1xuICAgICAgICAvKiBib3Jyb3dlZCBmcm9tIERNIGFiciBwcmVzZXRzICovXG5cbiAgICAgICAgdmFyIGZ1bGxfYml0cmF0ZV90YWJsZSA9IFs4LCAxNiwgMjQsIDMyLCA0MCwgNDgsIDU2LCA2NCwgODAsXG4gICAgICAgICAgICA5NiwgMTEyLCAxMjgsIDE2MCwgMTkyLCAyMjQsIDI1NiwgMzIwXTtcblxuICAgICAgICB2YXIgbG93ZXJfcmFuZ2UgPSAwLCBsb3dlcl9yYW5nZV9rYnBzID0gMCwgdXBwZXJfcmFuZ2UgPSAwLCB1cHBlcl9yYW5nZV9rYnBzID0gMDtcblxuICAgICAgICAvKiBXZSBhc3N1bWUgc3BlY2lmaWVkIGJpdHJhdGUgd2lsbCBiZSAzMjBrYnBzICovXG4gICAgICAgIHVwcGVyX3JhbmdlX2ticHMgPSBmdWxsX2JpdHJhdGVfdGFibGVbMTZdO1xuICAgICAgICB1cHBlcl9yYW5nZSA9IDE2O1xuICAgICAgICBsb3dlcl9yYW5nZV9rYnBzID0gZnVsbF9iaXRyYXRlX3RhYmxlWzE2XTtcbiAgICAgICAgbG93ZXJfcmFuZ2UgPSAxNjtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBEZXRlcm1pbmUgd2hpY2ggc2lnbmlmaWNhbnQgYml0cmF0ZXMgdGhlIHZhbHVlIHNwZWNpZmllZCBmYWxsc1xuICAgICAgICAgKiBiZXR3ZWVuLCBpZiBsb29wIGVuZHMgd2l0aG91dCBicmVha2luZyB0aGVuIHdlIHdlcmUgY29ycmVjdCBhYm92ZVxuICAgICAgICAgKiB0aGF0IHRoZSB2YWx1ZSB3YXMgMzIwXG4gICAgICAgICAqL1xuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IDE2OyBiKyspIHtcbiAgICAgICAgICAgIGlmICgoTWF0aC5tYXgoYml0cmF0ZSwgZnVsbF9iaXRyYXRlX3RhYmxlW2IgKyAxXSkpICE9IGJpdHJhdGUpIHtcbiAgICAgICAgICAgICAgICB1cHBlcl9yYW5nZV9rYnBzID0gZnVsbF9iaXRyYXRlX3RhYmxlW2IgKyAxXTtcbiAgICAgICAgICAgICAgICB1cHBlcl9yYW5nZSA9IGIgKyAxO1xuICAgICAgICAgICAgICAgIGxvd2VyX3JhbmdlX2ticHMgPSBmdWxsX2JpdHJhdGVfdGFibGVbYl07XG4gICAgICAgICAgICAgICAgbG93ZXJfcmFuZ2UgPSAoYik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgLyogV2UgZm91bmQgdXBwZXIgcmFuZ2UgKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qIERldGVybWluZSB3aGljaCByYW5nZSB0aGUgdmFsdWUgc3BlY2lmaWVkIGlzIGNsb3NlciB0byAqL1xuICAgICAgICBpZiAoKHVwcGVyX3JhbmdlX2ticHMgLSBiaXRyYXRlKSA+IChiaXRyYXRlIC0gbG93ZXJfcmFuZ2Vfa2JwcykpIHtcbiAgICAgICAgICAgIHJldHVybiBsb3dlcl9yYW5nZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXBwZXJfcmFuZ2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb3B0aW11bV9zYW1wbGVmcmVxKGxvd3Bhc3NmcmVxLCBpbnB1dF9zYW1wbGVmcmVxKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAqIFJ1bGVzOlxuICAgICAgICAgKlxuICAgICAgICAgKiAtIGlmIHBvc3NpYmxlLCBzZmIyMSBzaG91bGQgTk9UIGJlIHVzZWRcbiAgICAgICAgICovXG4gICAgICAgIHZhciBzdWdnZXN0ZWRfc2FtcGxlZnJlcSA9IDQ0MTAwO1xuXG4gICAgICAgIGlmIChpbnB1dF9zYW1wbGVmcmVxID49IDQ4MDAwKVxuICAgICAgICAgICAgc3VnZ2VzdGVkX3NhbXBsZWZyZXEgPSA0ODAwMDtcbiAgICAgICAgZWxzZSBpZiAoaW5wdXRfc2FtcGxlZnJlcSA+PSA0NDEwMClcbiAgICAgICAgICAgIHN1Z2dlc3RlZF9zYW1wbGVmcmVxID0gNDQxMDA7XG4gICAgICAgIGVsc2UgaWYgKGlucHV0X3NhbXBsZWZyZXEgPj0gMzIwMDApXG4gICAgICAgICAgICBzdWdnZXN0ZWRfc2FtcGxlZnJlcSA9IDMyMDAwO1xuICAgICAgICBlbHNlIGlmIChpbnB1dF9zYW1wbGVmcmVxID49IDI0MDAwKVxuICAgICAgICAgICAgc3VnZ2VzdGVkX3NhbXBsZWZyZXEgPSAyNDAwMDtcbiAgICAgICAgZWxzZSBpZiAoaW5wdXRfc2FtcGxlZnJlcSA+PSAyMjA1MClcbiAgICAgICAgICAgIHN1Z2dlc3RlZF9zYW1wbGVmcmVxID0gMjIwNTA7XG4gICAgICAgIGVsc2UgaWYgKGlucHV0X3NhbXBsZWZyZXEgPj0gMTYwMDApXG4gICAgICAgICAgICBzdWdnZXN0ZWRfc2FtcGxlZnJlcSA9IDE2MDAwO1xuICAgICAgICBlbHNlIGlmIChpbnB1dF9zYW1wbGVmcmVxID49IDEyMDAwKVxuICAgICAgICAgICAgc3VnZ2VzdGVkX3NhbXBsZWZyZXEgPSAxMjAwMDtcbiAgICAgICAgZWxzZSBpZiAoaW5wdXRfc2FtcGxlZnJlcSA+PSAxMTAyNSlcbiAgICAgICAgICAgIHN1Z2dlc3RlZF9zYW1wbGVmcmVxID0gMTEwMjU7XG4gICAgICAgIGVsc2UgaWYgKGlucHV0X3NhbXBsZWZyZXEgPj0gODAwMClcbiAgICAgICAgICAgIHN1Z2dlc3RlZF9zYW1wbGVmcmVxID0gODAwMDtcblxuICAgICAgICBpZiAobG93cGFzc2ZyZXEgPT0gLTEpXG4gICAgICAgICAgICByZXR1cm4gc3VnZ2VzdGVkX3NhbXBsZWZyZXE7XG5cbiAgICAgICAgaWYgKGxvd3Bhc3NmcmVxIDw9IDE1OTYwKVxuICAgICAgICAgICAgc3VnZ2VzdGVkX3NhbXBsZWZyZXEgPSA0NDEwMDtcbiAgICAgICAgaWYgKGxvd3Bhc3NmcmVxIDw9IDE1MjUwKVxuICAgICAgICAgICAgc3VnZ2VzdGVkX3NhbXBsZWZyZXEgPSAzMjAwMDtcbiAgICAgICAgaWYgKGxvd3Bhc3NmcmVxIDw9IDExMjIwKVxuICAgICAgICAgICAgc3VnZ2VzdGVkX3NhbXBsZWZyZXEgPSAyNDAwMDtcbiAgICAgICAgaWYgKGxvd3Bhc3NmcmVxIDw9IDk5NzApXG4gICAgICAgICAgICBzdWdnZXN0ZWRfc2FtcGxlZnJlcSA9IDIyMDUwO1xuICAgICAgICBpZiAobG93cGFzc2ZyZXEgPD0gNzIzMClcbiAgICAgICAgICAgIHN1Z2dlc3RlZF9zYW1wbGVmcmVxID0gMTYwMDA7XG4gICAgICAgIGlmIChsb3dwYXNzZnJlcSA8PSA1NDIwKVxuICAgICAgICAgICAgc3VnZ2VzdGVkX3NhbXBsZWZyZXEgPSAxMjAwMDtcbiAgICAgICAgaWYgKGxvd3Bhc3NmcmVxIDw9IDQ1MTApXG4gICAgICAgICAgICBzdWdnZXN0ZWRfc2FtcGxlZnJlcSA9IDExMDI1O1xuICAgICAgICBpZiAobG93cGFzc2ZyZXEgPD0gMzk3MClcbiAgICAgICAgICAgIHN1Z2dlc3RlZF9zYW1wbGVmcmVxID0gODAwMDtcblxuICAgICAgICBpZiAoaW5wdXRfc2FtcGxlZnJlcSA8IHN1Z2dlc3RlZF9zYW1wbGVmcmVxKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogY2hvb3NlIGEgdmFsaWQgTVBFRyBzYW1wbGUgZnJlcXVlbmN5IGFib3ZlIHRoZSBpbnB1dCBzYW1wbGVcbiAgICAgICAgICAgICAqIGZyZXF1ZW5jeSB0byBhdm9pZCBTRkIyMS8xMiBiaXRyYXRlIGJsb2F0IHJoIDA2MTExNVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoaW5wdXRfc2FtcGxlZnJlcSA+IDQ0MTAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDQ4MDAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlucHV0X3NhbXBsZWZyZXEgPiAzMjAwMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiA0NDEwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbnB1dF9zYW1wbGVmcmVxID4gMjQwMDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMzIwMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5wdXRfc2FtcGxlZnJlcSA+IDIyMDUwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDI0MDAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlucHV0X3NhbXBsZWZyZXEgPiAxNjAwMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAyMjA1MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbnB1dF9zYW1wbGVmcmVxID4gMTIwMDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTYwMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5wdXRfc2FtcGxlZnJlcSA+IDExMDI1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEyMDAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlucHV0X3NhbXBsZWZyZXEgPiA4MDAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDExMDI1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDgwMDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1Z2dlc3RlZF9zYW1wbGVmcmVxO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNvbnZlcnQgc2FtcCBmcmVxIGluIEh6IHRvIGluZGV4XG4gICAgICovXG4gICAgZnVuY3Rpb24gU21wRnJxSW5kZXgoc2FtcGxlX2ZyZXEsIGdwZikge1xuICAgICAgICBzd2l0Y2ggKHNhbXBsZV9mcmVxKSB7XG4gICAgICAgICAgICBjYXNlIDQ0MTAwOlxuICAgICAgICAgICAgICAgIGdwZi52ZXJzaW9uID0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIGNhc2UgNDgwMDA6XG4gICAgICAgICAgICAgICAgZ3BmLnZlcnNpb24gPSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgY2FzZSAzMjAwMDpcbiAgICAgICAgICAgICAgICBncGYudmVyc2lvbiA9IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgICAgICBjYXNlIDIyMDUwOlxuICAgICAgICAgICAgICAgIGdwZi52ZXJzaW9uID0gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIGNhc2UgMjQwMDA6XG4gICAgICAgICAgICAgICAgZ3BmLnZlcnNpb24gPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgY2FzZSAxNjAwMDpcbiAgICAgICAgICAgICAgICBncGYudmVyc2lvbiA9IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgICAgICBjYXNlIDExMDI1OlxuICAgICAgICAgICAgICAgIGdwZi52ZXJzaW9uID0gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIGNhc2UgMTIwMDA6XG4gICAgICAgICAgICAgICAgZ3BmLnZlcnNpb24gPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgY2FzZSA4MDAwOlxuICAgICAgICAgICAgICAgIGdwZi52ZXJzaW9uID0gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgZ3BmLnZlcnNpb24gPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBiUmF0ZVxuICAgICAqICAgICAgICAgICAgbGVnYWwgcmF0ZXMgZnJvbSA4IHRvIDMyMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEZpbmROZWFyZXN0Qml0cmF0ZShiUmF0ZSwgdmVyc2lvbiwgc2FtcGxlcmF0ZSkge1xuICAgICAgICAvKiBNUEVHLTEgb3IgTVBFRy0yIExTRiAqL1xuICAgICAgICBpZiAoc2FtcGxlcmF0ZSA8IDE2MDAwKVxuICAgICAgICAgICAgdmVyc2lvbiA9IDI7XG5cbiAgICAgICAgdmFyIGJpdHJhdGUgPSBUYWJsZXMuYml0cmF0ZV90YWJsZVt2ZXJzaW9uXVsxXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMjsgaSA8PSAxNDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoVGFibGVzLmJpdHJhdGVfdGFibGVbdmVyc2lvbl1baV0gPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKFRhYmxlcy5iaXRyYXRlX3RhYmxlW3ZlcnNpb25dW2ldIC0gYlJhdGUpIDwgTWF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgLmFicyhiaXRyYXRlIC0gYlJhdGUpKVxuICAgICAgICAgICAgICAgICAgICBiaXRyYXRlID0gVGFibGVzLmJpdHJhdGVfdGFibGVbdmVyc2lvbl1baV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJpdHJhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGJSYXRlXG4gICAgICogICAgICAgICAgICBsZWdhbCByYXRlcyBmcm9tIDMyIHRvIDQ0OCBrYnBzXG4gICAgICogQHBhcmFtIHZlcnNpb25cbiAgICAgKiAgICAgICAgICAgIE1QRUctMSBvciBNUEVHLTIvMi41IExTRlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEJpdHJhdGVJbmRleChiUmF0ZSwgdmVyc2lvbiwgc2FtcGxlcmF0ZSkge1xuICAgICAgICAvKiBjb252ZXJ0IGJpdHJhdGUgaW4ga2JwcyB0byBpbmRleCAqL1xuICAgICAgICBpZiAoc2FtcGxlcmF0ZSA8IDE2MDAwKVxuICAgICAgICAgICAgdmVyc2lvbiA9IDI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IDE0OyBpKyspIHtcbiAgICAgICAgICAgIGlmIChUYWJsZXMuYml0cmF0ZV90YWJsZVt2ZXJzaW9uXVtpXSA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoVGFibGVzLmJpdHJhdGVfdGFibGVbdmVyc2lvbl1baV0gPT0gYlJhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvcHRpbXVtX2JhbmR3aWR0aChsaCwgYml0cmF0ZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogPFBSRT5cbiAgICAgICAgICogIElucHV0OlxuICAgICAgICAgKiAgICAgIGJpdHJhdGUgICAgIHRvdGFsIGJpdHJhdGUgaW4ga2Jwc1xuICAgICAgICAgKlxuICAgICAgICAgKiAgIE91dHB1dDpcbiAgICAgICAgICogICAgICBsb3dlcmxpbWl0OiBiZXN0IGxvd3Bhc3MgZnJlcXVlbmN5IGxpbWl0IGZvciBpbnB1dCBmaWx0ZXIgaW4gSHpcbiAgICAgICAgICogICAgICB1cHBlcmxpbWl0OiBiZXN0IGhpZ2hwYXNzIGZyZXF1ZW5jeSBsaW1pdCBmb3IgaW5wdXQgZmlsdGVyIGluIEh6XG4gICAgICAgICAqIDwvUFJFPlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGZyZXFfbWFwID0gW25ldyBCYW5kUGFzcyg4LCAyMDAwKSxcbiAgICAgICAgICAgIG5ldyBCYW5kUGFzcygxNiwgMzcwMCksIG5ldyBCYW5kUGFzcygyNCwgMzkwMCksXG4gICAgICAgICAgICBuZXcgQmFuZFBhc3MoMzIsIDU1MDApLCBuZXcgQmFuZFBhc3MoNDAsIDcwMDApLFxuICAgICAgICAgICAgbmV3IEJhbmRQYXNzKDQ4LCA3NTAwKSwgbmV3IEJhbmRQYXNzKDU2LCAxMDAwMCksXG4gICAgICAgICAgICBuZXcgQmFuZFBhc3MoNjQsIDExMDAwKSwgbmV3IEJhbmRQYXNzKDgwLCAxMzUwMCksXG4gICAgICAgICAgICBuZXcgQmFuZFBhc3MoOTYsIDE1MTAwKSwgbmV3IEJhbmRQYXNzKDExMiwgMTU2MDApLFxuICAgICAgICAgICAgbmV3IEJhbmRQYXNzKDEyOCwgMTcwMDApLCBuZXcgQmFuZFBhc3MoMTYwLCAxNzUwMCksXG4gICAgICAgICAgICBuZXcgQmFuZFBhc3MoMTkyLCAxODYwMCksIG5ldyBCYW5kUGFzcygyMjQsIDE5NDAwKSxcbiAgICAgICAgICAgIG5ldyBCYW5kUGFzcygyNTYsIDE5NzAwKSwgbmV3IEJhbmRQYXNzKDMyMCwgMjA1MDApXTtcblxuICAgICAgICB2YXIgdGFibGVfaW5kZXggPSBzZWxmLm5lYXJlc3RCaXRyYXRlRnVsbEluZGV4KGJpdHJhdGUpO1xuICAgICAgICBsaC5sb3dlcmxpbWl0ID0gZnJlcV9tYXBbdGFibGVfaW5kZXhdLmxvd3Bhc3M7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGFtZV9pbml0X3BhcmFtc19wcGZsdChnZnApIHtcbiAgICAgICAgdmFyIGdmYyA9IGdmcC5pbnRlcm5hbF9mbGFncztcbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyogY29tcHV0ZSBpbmZvIG5lZWRlZCBmb3IgcG9seXBoYXNlIGZpbHRlciAoZmlsdGVyIHR5cGU9PTAsIGRlZmF1bHQpICovXG4gICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgdmFyIGxvd3Bhc3NfYmFuZCA9IDMyO1xuICAgICAgICB2YXIgaGlnaHBhc3NfYmFuZCA9IC0xO1xuXG4gICAgICAgIGlmIChnZmMubG93cGFzczEgPiAwKSB7XG4gICAgICAgICAgICB2YXIgbWluYmFuZCA9IDk5OTtcbiAgICAgICAgICAgIGZvciAodmFyIGJhbmQgPSAwOyBiYW5kIDw9IDMxOyBiYW5kKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJlcSA9IChiYW5kIC8gMzEuMCk7XG4gICAgICAgICAgICAgICAgLyogdGhpcyBiYW5kIGFuZCBhYm92ZSB3aWxsIGJlIHplcm9lZDogKi9cbiAgICAgICAgICAgICAgICBpZiAoZnJlcSA+PSBnZmMubG93cGFzczIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG93cGFzc19iYW5kID0gTWF0aC5taW4obG93cGFzc19iYW5kLCBiYW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGdmYy5sb3dwYXNzMSA8IGZyZXEgJiYgZnJlcSA8IGdmYy5sb3dwYXNzMikge1xuICAgICAgICAgICAgICAgICAgICBtaW5iYW5kID0gTWF0aC5taW4obWluYmFuZCwgYmFuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogY29tcHV0ZSB0aGUgKmFjdHVhbCogdHJhbnNpdGlvbiBiYW5kIGltcGxlbWVudGVkIGJ5IHRoZSBwb2x5cGhhc2VcbiAgICAgICAgICAgICAqIGZpbHRlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAobWluYmFuZCA9PSA5OTkpIHtcbiAgICAgICAgICAgICAgICBnZmMubG93cGFzczEgPSAobG93cGFzc19iYW5kIC0gLjc1KSAvIDMxLjA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdmYy5sb3dwYXNzMSA9IChtaW5iYW5kIC0gLjc1KSAvIDMxLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZmMubG93cGFzczIgPSBsb3dwYXNzX2JhbmQgLyAzMS4wO1xuICAgICAgICB9XG5cbiAgICAgICAgLypcbiAgICAgICAgICogbWFrZSBzdXJlIGhpZ2hwYXNzIGZpbHRlciBpcyB3aXRoaW4gOTAlIG9mIHdoYXQgdGhlIGVmZmVjdGl2ZVxuICAgICAgICAgKiBoaWdocGFzcyBmcmVxdWVuY3kgd2lsbCBiZVxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGdmYy5oaWdocGFzczIgPiAwKSB7XG4gICAgICAgICAgICBpZiAoZ2ZjLmhpZ2hwYXNzMiA8IC45ICogKC43NSAvIDMxLjApKSB7XG4gICAgICAgICAgICAgICAgZ2ZjLmhpZ2hwYXNzMSA9IDA7XG4gICAgICAgICAgICAgICAgZ2ZjLmhpZ2hwYXNzMiA9IDA7XG4gICAgICAgICAgICAgICAgU3lzdGVtLmVyci5wcmludGxuKFwiV2FybmluZzogaGlnaHBhc3MgZmlsdGVyIGRpc2FibGVkLiAgXCJcbiAgICAgICAgICAgICAgICAgICAgKyBcImhpZ2hwYXNzIGZyZXF1ZW5jeSB0b28gc21hbGxcXG5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2ZjLmhpZ2hwYXNzMiA+IDApIHtcbiAgICAgICAgICAgIHZhciBtYXhiYW5kID0gLTE7XG4gICAgICAgICAgICBmb3IgKHZhciBiYW5kID0gMDsgYmFuZCA8PSAzMTsgYmFuZCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyZXEgPSBiYW5kIC8gMzEuMDtcbiAgICAgICAgICAgICAgICAvKiB0aGlzIGJhbmQgYW5kIGJlbG93IHdpbGwgYmUgemVyZW9kICovXG4gICAgICAgICAgICAgICAgaWYgKGZyZXEgPD0gZ2ZjLmhpZ2hwYXNzMSkge1xuICAgICAgICAgICAgICAgICAgICBoaWdocGFzc19iYW5kID0gTWF0aC5tYXgoaGlnaHBhc3NfYmFuZCwgYmFuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChnZmMuaGlnaHBhc3MxIDwgZnJlcSAmJiBmcmVxIDwgZ2ZjLmhpZ2hwYXNzMikge1xuICAgICAgICAgICAgICAgICAgICBtYXhiYW5kID0gTWF0aC5tYXgobWF4YmFuZCwgYmFuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIGNvbXB1dGUgdGhlICphY3R1YWwqIHRyYW5zaXRpb24gYmFuZCBpbXBsZW1lbnRlZCBieSB0aGUgcG9seXBoYXNlXG4gICAgICAgICAgICAgKiBmaWx0ZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2ZjLmhpZ2hwYXNzMSA9IGhpZ2hwYXNzX2JhbmQgLyAzMS4wO1xuICAgICAgICAgICAgaWYgKG1heGJhbmQgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBnZmMuaGlnaHBhc3MyID0gKGhpZ2hwYXNzX2JhbmQgKyAuNzUpIC8gMzEuMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2ZjLmhpZ2hwYXNzMiA9IChtYXhiYW5kICsgLjc1KSAvIDMxLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBiYW5kID0gMDsgYmFuZCA8IDMyOyBiYW5kKyspIHtcbiAgICAgICAgICAgIHZhciBmYzEsIGZjMjtcbiAgICAgICAgICAgIHZhciBmcmVxID0gYmFuZCAvIDMxLjA7XG4gICAgICAgICAgICBpZiAoZ2ZjLmhpZ2hwYXNzMiA+IGdmYy5oaWdocGFzczEpIHtcbiAgICAgICAgICAgICAgICBmYzEgPSBmaWx0ZXJfY29lZigoZ2ZjLmhpZ2hwYXNzMiAtIGZyZXEpXG4gICAgICAgICAgICAgICAgICAgIC8gKGdmYy5oaWdocGFzczIgLSBnZmMuaGlnaHBhc3MxICsgMWUtMjApKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmMxID0gMS4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdmYy5sb3dwYXNzMiA+IGdmYy5sb3dwYXNzMSkge1xuICAgICAgICAgICAgICAgIGZjMiA9IGZpbHRlcl9jb2VmKChmcmVxIC0gZ2ZjLmxvd3Bhc3MxKVxuICAgICAgICAgICAgICAgICAgICAvIChnZmMubG93cGFzczIgLSBnZmMubG93cGFzczEgKyAxZS0yMCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmYzIgPSAxLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZmMuYW1wX2ZpbHRlcltiYW5kXSA9IChmYzEgKiBmYzIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGFtZV9pbml0X3F2YWwoZ2ZwKSB7XG4gICAgICAgIHZhciBnZmMgPSBnZnAuaW50ZXJuYWxfZmxhZ3M7XG5cbiAgICAgICAgc3dpdGNoIChnZnAucXVhbGl0eSkge1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhc2UgOTogLyogbm8gcHN5bW9kZWwsIG5vIG5vaXNlIHNoYXBpbmcgKi9cbiAgICAgICAgICAgICAgICBnZmMucHN5bW9kZWwgPSAwO1xuICAgICAgICAgICAgICAgIGdmYy5ub2lzZV9zaGFwaW5nID0gMDtcbiAgICAgICAgICAgICAgICBnZmMubm9pc2Vfc2hhcGluZ19hbXAgPSAwO1xuICAgICAgICAgICAgICAgIGdmYy5ub2lzZV9zaGFwaW5nX3N0b3AgPSAwO1xuICAgICAgICAgICAgICAgIGdmYy51c2VfYmVzdF9odWZmbWFuID0gMDtcbiAgICAgICAgICAgICAgICBnZmMuZnVsbF9vdXRlcl9sb29wID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIGdmcC5xdWFsaXR5ID0gNztcbiAgICAgICAgICAgIC8vJEZBTEwtVEhST1VHSCRcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIHVzZSBwc3ltb2RlbCAoZm9yIHNob3J0IGJsb2NrIGFuZCBtL3Mgc3dpdGNoaW5nKSwgYnV0IG5vIG5vaXNlXG4gICAgICAgICAgICAgICAgICogc2hhcHBpbmdcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBnZmMucHN5bW9kZWwgPSAxO1xuICAgICAgICAgICAgICAgIGdmYy5ub2lzZV9zaGFwaW5nID0gMDtcbiAgICAgICAgICAgICAgICBnZmMubm9pc2Vfc2hhcGluZ19hbXAgPSAwO1xuICAgICAgICAgICAgICAgIGdmYy5ub2lzZV9zaGFwaW5nX3N0b3AgPSAwO1xuICAgICAgICAgICAgICAgIGdmYy51c2VfYmVzdF9odWZmbWFuID0gMDtcbiAgICAgICAgICAgICAgICBnZmMuZnVsbF9vdXRlcl9sb29wID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIGdmYy5wc3ltb2RlbCA9IDE7XG4gICAgICAgICAgICAgICAgaWYgKGdmYy5ub2lzZV9zaGFwaW5nID09IDApXG4gICAgICAgICAgICAgICAgICAgIGdmYy5ub2lzZV9zaGFwaW5nID0gMTtcbiAgICAgICAgICAgICAgICBnZmMubm9pc2Vfc2hhcGluZ19hbXAgPSAwO1xuICAgICAgICAgICAgICAgIGdmYy5ub2lzZV9zaGFwaW5nX3N0b3AgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChnZmMuc3ViYmxvY2tfZ2FpbiA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgZ2ZjLnN1YmJsb2NrX2dhaW4gPSAxO1xuICAgICAgICAgICAgICAgIGdmYy51c2VfYmVzdF9odWZmbWFuID0gMDtcbiAgICAgICAgICAgICAgICBnZmMuZnVsbF9vdXRlcl9sb29wID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGdmYy5wc3ltb2RlbCA9IDE7XG4gICAgICAgICAgICAgICAgaWYgKGdmYy5ub2lzZV9zaGFwaW5nID09IDApXG4gICAgICAgICAgICAgICAgICAgIGdmYy5ub2lzZV9zaGFwaW5nID0gMTtcbiAgICAgICAgICAgICAgICBnZmMubm9pc2Vfc2hhcGluZ19hbXAgPSAwO1xuICAgICAgICAgICAgICAgIGdmYy5ub2lzZV9zaGFwaW5nX3N0b3AgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChnZmMuc3ViYmxvY2tfZ2FpbiA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgZ2ZjLnN1YmJsb2NrX2dhaW4gPSAxO1xuICAgICAgICAgICAgICAgIGdmYy51c2VfYmVzdF9odWZmbWFuID0gMDtcbiAgICAgICAgICAgICAgICBnZmMuZnVsbF9vdXRlcl9sb29wID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGdmYy5wc3ltb2RlbCA9IDE7XG4gICAgICAgICAgICAgICAgaWYgKGdmYy5ub2lzZV9zaGFwaW5nID09IDApXG4gICAgICAgICAgICAgICAgICAgIGdmYy5ub2lzZV9zaGFwaW5nID0gMTtcbiAgICAgICAgICAgICAgICBnZmMubm9pc2Vfc2hhcGluZ19hbXAgPSAwO1xuICAgICAgICAgICAgICAgIGdmYy5ub2lzZV9zaGFwaW5nX3N0b3AgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChnZmMuc3ViYmxvY2tfZ2FpbiA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgZ2ZjLnN1YmJsb2NrX2dhaW4gPSAxO1xuICAgICAgICAgICAgICAgIGdmYy51c2VfYmVzdF9odWZmbWFuID0gMTtcbiAgICAgICAgICAgICAgICBnZmMuZnVsbF9vdXRlcl9sb29wID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGdmYy5wc3ltb2RlbCA9IDE7XG4gICAgICAgICAgICAgICAgaWYgKGdmYy5ub2lzZV9zaGFwaW5nID09IDApXG4gICAgICAgICAgICAgICAgICAgIGdmYy5ub2lzZV9zaGFwaW5nID0gMTtcbiAgICAgICAgICAgICAgICBnZmMubm9pc2Vfc2hhcGluZ19hbXAgPSAxO1xuICAgICAgICAgICAgICAgIGdmYy5ub2lzZV9zaGFwaW5nX3N0b3AgPSAxO1xuICAgICAgICAgICAgICAgIGlmIChnZmMuc3ViYmxvY2tfZ2FpbiA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgZ2ZjLnN1YmJsb2NrX2dhaW4gPSAxO1xuICAgICAgICAgICAgICAgIGdmYy51c2VfYmVzdF9odWZmbWFuID0gMTtcbiAgICAgICAgICAgICAgICBnZmMuZnVsbF9vdXRlcl9sb29wID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGdmYy5wc3ltb2RlbCA9IDE7XG4gICAgICAgICAgICAgICAgaWYgKGdmYy5ub2lzZV9zaGFwaW5nID09IDApXG4gICAgICAgICAgICAgICAgICAgIGdmYy5ub2lzZV9zaGFwaW5nID0gMTtcbiAgICAgICAgICAgICAgICBpZiAoZ2ZjLnN1YnN0ZXBfc2hhcGluZyA9PSAwKVxuICAgICAgICAgICAgICAgICAgICBnZmMuc3Vic3RlcF9zaGFwaW5nID0gMjtcbiAgICAgICAgICAgICAgICBnZmMubm9pc2Vfc2hhcGluZ19hbXAgPSAxO1xuICAgICAgICAgICAgICAgIGdmYy5ub2lzZV9zaGFwaW5nX3N0b3AgPSAxO1xuICAgICAgICAgICAgICAgIGlmIChnZmMuc3ViYmxvY2tfZ2FpbiA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgZ2ZjLnN1YmJsb2NrX2dhaW4gPSAxO1xuICAgICAgICAgICAgICAgIGdmYy51c2VfYmVzdF9odWZmbWFuID0gMTtcbiAgICAgICAgICAgICAgICAvKiBpbm5lciBsb29wICovXG4gICAgICAgICAgICAgICAgZ2ZjLmZ1bGxfb3V0ZXJfbG9vcCA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBnZmMucHN5bW9kZWwgPSAxO1xuICAgICAgICAgICAgICAgIGlmIChnZmMubm9pc2Vfc2hhcGluZyA9PSAwKVxuICAgICAgICAgICAgICAgICAgICBnZmMubm9pc2Vfc2hhcGluZyA9IDE7XG4gICAgICAgICAgICAgICAgaWYgKGdmYy5zdWJzdGVwX3NoYXBpbmcgPT0gMClcbiAgICAgICAgICAgICAgICAgICAgZ2ZjLnN1YnN0ZXBfc2hhcGluZyA9IDI7XG4gICAgICAgICAgICAgICAgZ2ZjLm5vaXNlX3NoYXBpbmdfYW1wID0gMjtcbiAgICAgICAgICAgICAgICBnZmMubm9pc2Vfc2hhcGluZ19zdG9wID0gMTtcbiAgICAgICAgICAgICAgICBpZiAoZ2ZjLnN1YmJsb2NrX2dhaW4gPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGdmYy5zdWJibG9ja19nYWluID0gMTtcbiAgICAgICAgICAgICAgICBnZmMudXNlX2Jlc3RfaHVmZm1hbiA9IDE7XG4gICAgICAgICAgICAgICAgZ2ZjLmZ1bGxfb3V0ZXJfbG9vcCA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBnZmMucHN5bW9kZWwgPSAxO1xuICAgICAgICAgICAgICAgIGlmIChnZmMubm9pc2Vfc2hhcGluZyA9PSAwKVxuICAgICAgICAgICAgICAgICAgICBnZmMubm9pc2Vfc2hhcGluZyA9IDE7XG4gICAgICAgICAgICAgICAgaWYgKGdmYy5zdWJzdGVwX3NoYXBpbmcgPT0gMClcbiAgICAgICAgICAgICAgICAgICAgZ2ZjLnN1YnN0ZXBfc2hhcGluZyA9IDI7XG4gICAgICAgICAgICAgICAgZ2ZjLm5vaXNlX3NoYXBpbmdfYW1wID0gMjtcbiAgICAgICAgICAgICAgICBnZmMubm9pc2Vfc2hhcGluZ19zdG9wID0gMTtcbiAgICAgICAgICAgICAgICBpZiAoZ2ZjLnN1YmJsb2NrX2dhaW4gPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGdmYy5zdWJibG9ja19nYWluID0gMTtcbiAgICAgICAgICAgICAgICBnZmMudXNlX2Jlc3RfaHVmZm1hbiA9IDE7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiB0eXBlIDIgZGlzYWJsZWQgYmVjYXVzZSBvZiBpdCBzbG93bmVzcywgaW4gZmF2b3Igb2YgZnVsbCBvdXRlclxuICAgICAgICAgICAgICAgICAqIGxvb3Agc2VhcmNoXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZ2ZjLmZ1bGxfb3V0ZXJfbG9vcCA9IDA7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBmdWxsIG91dGVyIGxvb3Agc2VhcmNoIGRpc2FibGVkIGJlY2F1c2Ugb2YgYXVkaWJsZSBkaXN0b3J0aW9ucyBpdFxuICAgICAgICAgICAgICAgICAqIG1heSBnZW5lcmF0ZSByaCAwNjA2MjlcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGFtZV9pbml0X2JpdHN0cmVhbShnZnApIHtcbiAgICAgICAgdmFyIGdmYyA9IGdmcC5pbnRlcm5hbF9mbGFncztcbiAgICAgICAgZ2ZwLmZyYW1lTnVtID0gMDtcblxuICAgICAgICBpZiAoZ2ZwLndyaXRlX2lkM3RhZ19hdXRvbWF0aWMpIHtcbiAgICAgICAgICAgIGlkMy5pZDN0YWdfd3JpdGVfdjIoZ2ZwKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpbml0aWFsaXplIGhpc3RvZ3JhbSBkYXRhIG9wdGlvbmFsbHkgdXNlZCBieSBmcm9udGVuZCAqL1xuXG4gICAgICAgIGdmYy5iaXRyYXRlX3N0ZXJlb01vZGVfSGlzdCA9IG5ld19pbnRfbihbMTYsIDQgKyAxXSk7XG4gICAgICAgIGdmYy5iaXRyYXRlX2Jsb2NrVHlwZV9IaXN0ID0gbmV3X2ludF9uKFsxNiwgNCArIDEgKyAxXSk7XG5cbiAgICAgICAgZ2ZjLlBlYWtTYW1wbGUgPSAwLjA7XG5cbiAgICAgICAgLyogV3JpdGUgaW5pdGlhbCBWQlIgSGVhZGVyIHRvIGJpdHN0cmVhbSBhbmQgaW5pdCBWQlIgZGF0YSAqL1xuICAgICAgICBpZiAoZ2ZwLmJXcml0ZVZiclRhZylcbiAgICAgICAgICAgIHZici5Jbml0VmJyVGFnKGdmcCk7XG4gICAgfVxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICogaW5pdGlhbGl6ZSBpbnRlcm5hbCBwYXJhbXMgYmFzZWQgb24gZGF0YSBpbiBnZiAoZ2xvYmFsZmxhZ3Mgc3RydWN0IGZpbGxlZFxuICAgICAqIGluIGJ5IGNhbGxpbmcgcHJvZ3JhbSlcbiAgICAgKlxuICAgICAqIE9VVExJTkU6XG4gICAgICpcbiAgICAgKiBXZSBmaXJzdCBoYXZlIHNvbWUgY29tcGxleCBjb2RlIHRvIGRldGVybWluZSBiaXRyYXRlLCBvdXRwdXQgc2FtcGxlcmF0ZVxuICAgICAqIGFuZCBtb2RlLiBJdCBpcyBjb21wbGljYXRlZCBieSB0aGUgZmFjdCB0aGF0IHdlIGFsbG93IHRoZSB1c2VyIHRvIHNldFxuICAgICAqIHNvbWUgb3IgYWxsIG9mIHRoZXNlIHBhcmFtZXRlcnMsIGFuZCBuZWVkIHRvIGRldGVybWluZSBiZXN0IHBvc3NpYmxlXG4gICAgICogdmFsdWVzIGZvciB0aGUgcmVzdCBvZiB0aGVtOlxuICAgICAqXG4gICAgICogMS4gc2V0IHNvbWUgQ1BVIHJlbGF0ZWQgZmxhZ3MgMi4gY2hlY2sgaWYgd2UgYXJlIG1vbm8ubW9ubywgc3RlcmVvLm1vbm9cbiAgICAgKiBvciBzdGVyZW8uc3RlcmVvIDMuIGNvbXB1dGUgYml0cmF0ZSBhbmQgb3V0cHV0IHNhbXBsZXJhdGU6IHVzZXIgbWF5IGhhdmVcbiAgICAgKiBzZXQgY29tcHJlc3Npb24gcmF0aW8gdXNlciBtYXkgaGF2ZSBzZXQgYSBiaXRyYXRlIHVzZXIgbWF5IGhhdmUgc2V0IGFcbiAgICAgKiBvdXRwdXQgc2FtcGxlcmF0ZSA0LiBzZXQgc29tZSBvcHRpb25zIHdoaWNoIGRlcGVuZCBvbiBvdXRwdXQgc2FtcGxlcmF0ZVxuICAgICAqIDUuIGNvbXB1dGUgdGhlIGFjdHVhbCBjb21wcmVzc2lvbiByYXRpbyA2LiBzZXQgbW9kZSBiYXNlZCBvbiBjb21wcmVzc2lvblxuICAgICAqIHJhdGlvXG4gICAgICpcbiAgICAgKiBUaGUgcmVtYWluaW5nIGNvZGUgaXMgbXVjaCBzaW1wbGVyIC0gaXQganVzdCBzZXRzIG9wdGlvbnMgYmFzZWQgb24gdGhlXG4gICAgICogbW9kZSAmIGNvbXByZXNzaW9uIHJhdGlvOlxuICAgICAqXG4gICAgICogc2V0IGFsbG93X2RpZmZfc2hvcnQgYmFzZWQgb24gbW9kZSBzZWxlY3QgbG93cGFzcyBmaWx0ZXIgYmFzZWQgb25cbiAgICAgKiBjb21wcmVzc2lvbiByYXRpbyAmIG1vZGUgc2V0IHRoZSBiaXRyYXRlIGluZGV4LCBhbmQgbWluL21heCBiaXRyYXRlcyBmb3JcbiAgICAgKiBWQlIgbW9kZXMgZGlzYWJsZSBWQlIgdGFnIGlmIGl0IGlzIG5vdCBhcHByb3ByaWF0ZSBpbml0aWFsaXplIHRoZVxuICAgICAqIGJpdHN0cmVhbSBpbml0aWFsaXplIHNjYWxlZmFjX2JhbmQgZGF0YSBzZXQgc2lkZWluZm9fbGVuIChiYXNlZCBvblxuICAgICAqIGNoYW5uZWxzLCBDUkMsIG91dF9zYW1wbGVyYXRlKSB3cml0ZSBhbiBpZDN2MiB0YWcgaW50byB0aGUgYml0c3RyZWFtXG4gICAgICogd3JpdGUgVkJSIHRhZyBpbnRvIHRoZSBiaXRzdHJlYW0gc2V0IG1wZWcxLzIgZmxhZyBlc3RpbWF0ZSB0aGUgbnVtYmVyIG9mXG4gICAgICogZnJhbWVzIChiYXNlZCBvbiBhIGxvdCBvZiBkYXRhKVxuICAgICAqXG4gICAgICogbm93IHdlIHNldCBtb3JlIGZsYWdzOiBuc3BzeXR1bmU6IHNlZSBjb2RlIFZCUiBtb2RlcyBzZWUgY29kZSBDQlIvQUJSIHNlZVxuICAgICAqIGNvZGVcbiAgICAgKlxuICAgICAqIEZpbmFsbHksIHdlIHNldCB0aGUgYWxnb3JpdGhtIGZsYWdzIGJhc2VkIG9uIHRoZSBnZnAucXVhbGl0eSB2YWx1ZVxuICAgICAqIGxhbWVfaW5pdF9xdmFsKGdmcCk7XG4gICAgICpcbiAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgdGhpcy5sYW1lX2luaXRfcGFyYW1zID0gZnVuY3Rpb24gKGdmcCkge1xuICAgICAgICB2YXIgZ2ZjID0gZ2ZwLmludGVybmFsX2ZsYWdzO1xuXG4gICAgICAgIGdmYy5DbGFzc19JRCA9IDA7XG4gICAgICAgIGlmIChnZmMuQVRIID09IG51bGwpXG4gICAgICAgICAgICBnZmMuQVRIID0gbmV3IEFUSCgpO1xuICAgICAgICBpZiAoZ2ZjLlBTWSA9PSBudWxsKVxuICAgICAgICAgICAgZ2ZjLlBTWSA9IG5ldyBQU1koKTtcbiAgICAgICAgaWYgKGdmYy5yZ2RhdGEgPT0gbnVsbClcbiAgICAgICAgICAgIGdmYy5yZ2RhdGEgPSBuZXcgUmVwbGF5R2FpbigpO1xuXG4gICAgICAgIGdmYy5jaGFubmVsc19pbiA9IGdmcC5udW1fY2hhbm5lbHM7XG4gICAgICAgIGlmIChnZmMuY2hhbm5lbHNfaW4gPT0gMSlcbiAgICAgICAgICAgIGdmcC5tb2RlID0gTVBFR01vZGUuTU9OTztcbiAgICAgICAgZ2ZjLmNoYW5uZWxzX291dCA9IChnZnAubW9kZSA9PSBNUEVHTW9kZS5NT05PKSA/IDEgOiAyO1xuICAgICAgICBnZmMubW9kZV9leHQgPSBFbmNvZGVyLk1QR19NRF9NU19MUjtcbiAgICAgICAgaWYgKGdmcC5tb2RlID09IE1QRUdNb2RlLk1PTk8pXG4gICAgICAgICAgICBnZnAuZm9yY2VfbXMgPSBmYWxzZTtcbiAgICAgICAgLypcbiAgICAgICAgICogZG9uJ3QgYWxsb3cgZm9yY2VkIG1pZC9zaWRlIHN0ZXJlbyBmb3IgbW9ubyBvdXRwdXRcbiAgICAgICAgICovXG5cbiAgICAgICAgaWYgKGdmcC5WQlIgPT0gVmJyTW9kZS52YnJfb2ZmICYmIGdmcC5WQlJfbWVhbl9iaXRyYXRlX2ticHMgIT0gMTI4XG4gICAgICAgICAgICAmJiBnZnAuYnJhdGUgPT0gMClcbiAgICAgICAgICAgIGdmcC5icmF0ZSA9IGdmcC5WQlJfbWVhbl9iaXRyYXRlX2ticHM7XG5cbiAgICAgICAgaWYgKGdmcC5WQlIgPT0gVmJyTW9kZS52YnJfb2ZmIHx8IGdmcC5WQlIgPT0gVmJyTW9kZS52YnJfbXRyaFxuICAgICAgICAgICAgfHwgZ2ZwLlZCUiA9PSBWYnJNb2RlLnZicl9tdCkge1xuICAgICAgICAgICAgLyogdGhlc2UgbW9kZXMgY2FuIGhhbmRsZSBmcmVlIGZvcm1hdCBjb25kaXRpb24gKi9cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdmcC5mcmVlX2Zvcm1hdCA9IGZhbHNlO1xuICAgICAgICAgICAgLyogbW9kZSBjYW4ndCBiZSBtaXhlZCB3aXRoIGZyZWUgZm9ybWF0ICovXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2ZwLlZCUiA9PSBWYnJNb2RlLnZicl9vZmYgJiYgZ2ZwLmJyYXRlID09IDApIHtcbiAgICAgICAgICAgIC8qIG5vIGJpdHJhdGUgb3IgY29tcHJlc3Npb24gcmF0aW8gc3BlY2lmaWVkLCB1c2UgMTEuMDI1ICovXG4gICAgICAgICAgICBpZiAoQml0U3RyZWFtLkVRKGdmcC5jb21wcmVzc2lvbl9yYXRpbywgMCkpXG4gICAgICAgICAgICAgICAgZ2ZwLmNvbXByZXNzaW9uX3JhdGlvID0gMTEuMDI1O1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIHJhdGUgdG8gY29tcHJlc3MgYSBDRCBkb3duIHRvIGV4YWN0bHkgMTI4MDAwIGJwc1xuICAgICAgICAgICAgICovXG4gICAgICAgIH1cblxuICAgICAgICAvKiBmaW5kIGJpdHJhdGUgaWYgdXNlciBzcGVjaWZ5IGEgY29tcHJlc3Npb24gcmF0aW8gKi9cbiAgICAgICAgaWYgKGdmcC5WQlIgPT0gVmJyTW9kZS52YnJfb2ZmICYmIGdmcC5jb21wcmVzc2lvbl9yYXRpbyA+IDApIHtcblxuICAgICAgICAgICAgaWYgKGdmcC5vdXRfc2FtcGxlcmF0ZSA9PSAwKVxuICAgICAgICAgICAgICAgIGdmcC5vdXRfc2FtcGxlcmF0ZSA9IG1hcDJNUDNGcmVxdWVuY3koKGludCkoMC45NyAqIGdmcC5pbl9zYW1wbGVyYXRlKSk7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogcm91bmQgdXAgd2l0aCBhIG1hcmdpbiBvZiAzICVcbiAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogY2hvb3NlIGEgYml0cmF0ZSBmb3IgdGhlIG91dHB1dCBzYW1wbGVyYXRlIHdoaWNoIGFjaGlldmVzXG4gICAgICAgICAgICAgKiBzcGVjaWZpZWQgY29tcHJlc3Npb24gcmF0aW9cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2ZwLmJyYXRlID0gMCB8IChnZnAub3V0X3NhbXBsZXJhdGUgKiAxNiAqIGdmYy5jaGFubmVsc19vdXQgLyAoMS5lMyAqIGdmcC5jb21wcmVzc2lvbl9yYXRpbykpO1xuXG4gICAgICAgICAgICAvKiB3ZSBuZWVkIHRoZSB2ZXJzaW9uIGZvciB0aGUgYml0cmF0ZSB0YWJsZSBsb29rIHVwICovXG4gICAgICAgICAgICBnZmMuc2FtcGxlcmF0ZV9pbmRleCA9IFNtcEZycUluZGV4KGdmcC5vdXRfc2FtcGxlcmF0ZSwgZ2ZwKTtcblxuICAgICAgICAgICAgaWYgKCFnZnAuZnJlZV9mb3JtYXQpIC8qXG4gICAgICAgICAgICAgKiBmb3Igbm9uIEZyZWUgRm9ybWF0IGZpbmQgdGhlIG5lYXJlc3QgYWxsb3dlZFxuICAgICAgICAgICAgICogYml0cmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZ2ZwLmJyYXRlID0gRmluZE5lYXJlc3RCaXRyYXRlKGdmcC5icmF0ZSwgZ2ZwLnZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgIGdmcC5vdXRfc2FtcGxlcmF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2ZwLm91dF9zYW1wbGVyYXRlICE9IDApIHtcbiAgICAgICAgICAgIGlmIChnZnAub3V0X3NhbXBsZXJhdGUgPCAxNjAwMCkge1xuICAgICAgICAgICAgICAgIGdmcC5WQlJfbWVhbl9iaXRyYXRlX2ticHMgPSBNYXRoLm1heChnZnAuVkJSX21lYW5fYml0cmF0ZV9rYnBzLFxuICAgICAgICAgICAgICAgICAgICA4KTtcbiAgICAgICAgICAgICAgICBnZnAuVkJSX21lYW5fYml0cmF0ZV9rYnBzID0gTWF0aC5taW4oZ2ZwLlZCUl9tZWFuX2JpdHJhdGVfa2JwcyxcbiAgICAgICAgICAgICAgICAgICAgNjQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChnZnAub3V0X3NhbXBsZXJhdGUgPCAzMjAwMCkge1xuICAgICAgICAgICAgICAgIGdmcC5WQlJfbWVhbl9iaXRyYXRlX2ticHMgPSBNYXRoLm1heChnZnAuVkJSX21lYW5fYml0cmF0ZV9rYnBzLFxuICAgICAgICAgICAgICAgICAgICA4KTtcbiAgICAgICAgICAgICAgICBnZnAuVkJSX21lYW5fYml0cmF0ZV9rYnBzID0gTWF0aC5taW4oZ2ZwLlZCUl9tZWFuX2JpdHJhdGVfa2JwcyxcbiAgICAgICAgICAgICAgICAgICAgMTYwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2ZwLlZCUl9tZWFuX2JpdHJhdGVfa2JwcyA9IE1hdGgubWF4KGdmcC5WQlJfbWVhbl9iaXRyYXRlX2ticHMsXG4gICAgICAgICAgICAgICAgICAgIDMyKTtcbiAgICAgICAgICAgICAgICBnZnAuVkJSX21lYW5fYml0cmF0ZV9rYnBzID0gTWF0aC5taW4oZ2ZwLlZCUl9tZWFuX2JpdHJhdGVfa2JwcyxcbiAgICAgICAgICAgICAgICAgICAgMzIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKiBpZiBhIGZpbHRlciBoYXMgbm90IGJlZW4gZW5hYmxlZCwgc2VlIGlmIHdlIHNob3VsZCBhZGQgb25lOiAqL1xuICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgaWYgKGdmcC5sb3dwYXNzZnJlcSA9PSAwKSB7XG4gICAgICAgICAgICB2YXIgbG93cGFzcyA9IDE2MDAwLjtcblxuICAgICAgICAgICAgc3dpdGNoIChnZnAuVkJSKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBWYnJNb2RlLnZicl9vZmY6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGggPSBuZXcgTG93UGFzc0hpZ2hQYXNzKCk7XG4gICAgICAgICAgICAgICAgICAgIG9wdGltdW1fYmFuZHdpZHRoKGxoLCBnZnAuYnJhdGUpO1xuICAgICAgICAgICAgICAgICAgICBsb3dwYXNzID0gbGgubG93ZXJsaW1pdDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgVmJyTW9kZS52YnJfYWJyOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxoID0gbmV3IExvd1Bhc3NIaWdoUGFzcygpO1xuICAgICAgICAgICAgICAgICAgICBvcHRpbXVtX2JhbmR3aWR0aChsaCwgZ2ZwLlZCUl9tZWFuX2JpdHJhdGVfa2Jwcyk7XG4gICAgICAgICAgICAgICAgICAgIGxvd3Bhc3MgPSBsaC5sb3dlcmxpbWl0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBWYnJNb2RlLnZicl9yaDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gWzE5NTAwLCAxOTAwMCwgMTg2MDAsIDE4MDAwLCAxNzUwMCwgMTYwMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAxNTYwMCwgMTQ5MDAsIDEyNTAwLCAxMDAwMCwgMzk1MF07XG4gICAgICAgICAgICAgICAgICAgIGlmICgwIDw9IGdmcC5WQlJfcSAmJiBnZnAuVkJSX3EgPD0gOSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSB4W2dmcC5WQlJfcV0sIGIgPSB4W2dmcC5WQlJfcSArIDFdLCBtID0gZ2ZwLlZCUl9xX2ZyYWM7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dwYXNzID0gbGluZWFyX2ludChhLCBiLCBtKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd3Bhc3MgPSAxOTUwMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gWzE5NTAwLCAxOTAwMCwgMTg1MDAsIDE4MDAwLCAxNzUwMCwgMTY1MDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAxNTUwMCwgMTQ1MDAsIDEyNTAwLCA5NTAwLCAzOTUwXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKDAgPD0gZ2ZwLlZCUl9xICYmIGdmcC5WQlJfcSA8PSA5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IHhbZ2ZwLlZCUl9xXSwgYiA9IHhbZ2ZwLlZCUl9xICsgMV0sIG0gPSBnZnAuVkJSX3FfZnJhYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd3Bhc3MgPSBsaW5lYXJfaW50KGEsIGIsIG0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG93cGFzcyA9IDE5NTAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdmcC5tb2RlID09IE1QRUdNb2RlLk1PTk9cbiAgICAgICAgICAgICAgICAmJiAoZ2ZwLlZCUiA9PSBWYnJNb2RlLnZicl9vZmYgfHwgZ2ZwLlZCUiA9PSBWYnJNb2RlLnZicl9hYnIpKVxuICAgICAgICAgICAgICAgIGxvd3Bhc3MgKj0gMS41O1xuXG4gICAgICAgICAgICBnZnAubG93cGFzc2ZyZXEgPSBsb3dwYXNzIHwgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnZnAub3V0X3NhbXBsZXJhdGUgPT0gMCkge1xuICAgICAgICAgICAgaWYgKDIgKiBnZnAubG93cGFzc2ZyZXEgPiBnZnAuaW5fc2FtcGxlcmF0ZSkge1xuICAgICAgICAgICAgICAgIGdmcC5sb3dwYXNzZnJlcSA9IGdmcC5pbl9zYW1wbGVyYXRlIC8gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdmcC5vdXRfc2FtcGxlcmF0ZSA9IG9wdGltdW1fc2FtcGxlZnJlcShnZnAubG93cGFzc2ZyZXEgfCAwLFxuICAgICAgICAgICAgICAgIGdmcC5pbl9zYW1wbGVyYXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdmcC5sb3dwYXNzZnJlcSA9IE1hdGgubWluKDIwNTAwLCBnZnAubG93cGFzc2ZyZXEpO1xuICAgICAgICBnZnAubG93cGFzc2ZyZXEgPSBNYXRoLm1pbihnZnAub3V0X3NhbXBsZXJhdGUgLyAyLCBnZnAubG93cGFzc2ZyZXEpO1xuXG4gICAgICAgIGlmIChnZnAuVkJSID09IFZick1vZGUudmJyX29mZikge1xuICAgICAgICAgICAgZ2ZwLmNvbXByZXNzaW9uX3JhdGlvID0gZ2ZwLm91dF9zYW1wbGVyYXRlICogMTYgKiBnZmMuY2hhbm5lbHNfb3V0XG4gICAgICAgICAgICAgICAgLyAoMS5lMyAqIGdmcC5icmF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdmcC5WQlIgPT0gVmJyTW9kZS52YnJfYWJyKSB7XG4gICAgICAgICAgICBnZnAuY29tcHJlc3Npb25fcmF0aW8gPSBnZnAub3V0X3NhbXBsZXJhdGUgKiAxNiAqIGdmYy5jaGFubmVsc19vdXRcbiAgICAgICAgICAgICAgICAvICgxLmUzICogZ2ZwLlZCUl9tZWFuX2JpdHJhdGVfa2Jwcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKlxuICAgICAgICAgKiBkbyBub3QgY29tcHV0ZSBSZXBsYXlHYWluIHZhbHVlcyBhbmQgZG8gbm90IGZpbmQgdGhlIHBlYWsgc2FtcGxlIGlmXG4gICAgICAgICAqIHdlIGNhbid0IHN0b3JlIHRoZW1cbiAgICAgICAgICovXG4gICAgICAgIGlmICghZ2ZwLmJXcml0ZVZiclRhZykge1xuICAgICAgICAgICAgZ2ZwLmZpbmRSZXBsYXlHYWluID0gZmFsc2U7XG4gICAgICAgICAgICBnZnAuZGVjb2RlX29uX3RoZV9mbHkgPSBmYWxzZTtcbiAgICAgICAgICAgIGdmYy5maW5kUGVha1NhbXBsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGdmYy5maW5kUmVwbGF5R2FpbiA9IGdmcC5maW5kUmVwbGF5R2FpbjtcbiAgICAgICAgZ2ZjLmRlY29kZV9vbl90aGVfZmx5ID0gZ2ZwLmRlY29kZV9vbl90aGVfZmx5O1xuXG4gICAgICAgIGlmIChnZmMuZGVjb2RlX29uX3RoZV9mbHkpXG4gICAgICAgICAgICBnZmMuZmluZFBlYWtTYW1wbGUgPSB0cnVlO1xuXG4gICAgICAgIGlmIChnZmMuZmluZFJlcGxheUdhaW4pIHtcbiAgICAgICAgICAgIGlmIChnYS5Jbml0R2FpbkFuYWx5c2lzKGdmYy5yZ2RhdGEsIGdmcC5vdXRfc2FtcGxlcmF0ZSkgPT0gR2FpbkFuYWx5c2lzLklOSVRfR0FJTl9BTkFMWVNJU19FUlJPUikge1xuICAgICAgICAgICAgICAgIGdmcC5pbnRlcm5hbF9mbGFncyA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC02O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdmYy5kZWNvZGVfb25fdGhlX2ZseSAmJiAhZ2ZwLmRlY29kZV9vbmx5KSB7XG4gICAgICAgICAgICBpZiAoZ2ZjLmhpcCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbXBnbGliLmhpcF9kZWNvZGVfZXhpdChnZmMuaGlwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdmYy5oaXAgPSBtcGdsaWIuaGlwX2RlY29kZV9pbml0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBnZmMubW9kZV9nciA9IGdmcC5vdXRfc2FtcGxlcmF0ZSA8PSAyNDAwMCA/IDEgOiAyO1xuICAgICAgICAvKlxuICAgICAgICAgKiBOdW1iZXIgb2YgZ3JhbnVsZXMgcGVyIGZyYW1lXG4gICAgICAgICAqL1xuICAgICAgICBnZnAuZnJhbWVzaXplID0gNTc2ICogZ2ZjLm1vZGVfZ3I7XG4gICAgICAgIGdmcC5lbmNvZGVyX2RlbGF5ID0gRW5jb2Rlci5FTkNERUxBWTtcblxuICAgICAgICBnZmMucmVzYW1wbGVfcmF0aW8gPSBnZnAuaW5fc2FtcGxlcmF0ZSAvIGdmcC5vdXRfc2FtcGxlcmF0ZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogPFBSRT5cbiAgICAgICAgICogIHNhbXBsZSBmcmVxICAgICAgIGJpdHJhdGUgICAgIGNvbXByZXNzaW9uIHJhdGlvXG4gICAgICAgICAqICAgICBba0h6XSAgICAgIFtrYnBzL2NoYW5uZWxdICAgZm9yIDE2IGJpdCBpbnB1dFxuICAgICAgICAgKiAgICAgNDQuMSAgICAgICAgICAgIDU2ICAgICAgICAgICAgICAgMTIuNlxuICAgICAgICAgKiAgICAgNDQuMSAgICAgICAgICAgIDY0ICAgICAgICAgICAgICAgMTEuMDI1XG4gICAgICAgICAqICAgICA0NC4xICAgICAgICAgICAgODAgICAgICAgICAgICAgICAgOC44MlxuICAgICAgICAgKiAgICAgMjIuMDUgICAgICAgICAgIDI0ICAgICAgICAgICAgICAgMTQuN1xuICAgICAgICAgKiAgICAgMjIuMDUgICAgICAgICAgIDMyICAgICAgICAgICAgICAgMTEuMDI1XG4gICAgICAgICAqICAgICAyMi4wNSAgICAgICAgICAgNDAgICAgICAgICAgICAgICAgOC44MlxuICAgICAgICAgKiAgICAgMTYgICAgICAgICAgICAgIDE2ICAgICAgICAgICAgICAgMTYuMFxuICAgICAgICAgKiAgICAgMTYgICAgICAgICAgICAgIDI0ICAgICAgICAgICAgICAgMTAuNjY3XG4gICAgICAgICAqIDwvUFJFPlxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxQUkU+XG4gICAgICAgICAqICBGb3IgVkJSLCB0YWtlIGEgZ3Vlc3MgYXQgdGhlIGNvbXByZXNzaW9uX3JhdGlvLlxuICAgICAgICAgKiAgRm9yIGV4YW1wbGU6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIFZCUl9xICAgIGNvbXByZXNzaW9uICAgICBsaWtlXG4gICAgICAgICAqICAgICAtICAgICAgICA0LjQgICAgICAgICAzMjAga2Jwcy80NCBrSHpcbiAgICAgICAgICogICAwLi4uMSAgICAgIDUuNSAgICAgICAgIDI1NiBrYnBzLzQ0IGtIelxuICAgICAgICAgKiAgICAgMiAgICAgICAgNy4zICAgICAgICAgMTkyIGticHMvNDQga0h6XG4gICAgICAgICAqICAgICA0ICAgICAgICA4LjggICAgICAgICAxNjAga2Jwcy80NCBrSHpcbiAgICAgICAgICogICAgIDYgICAgICAgMTEgICAgICAgICAgIDEyOCBrYnBzLzQ0IGtIelxuICAgICAgICAgKiAgICAgOSAgICAgICAxNC43ICAgICAgICAgIDk2IGticHNcbiAgICAgICAgICpcbiAgICAgICAgICogIGZvciBsb3dlciBiaXRyYXRlcywgZG93bnNhbXBsZSB3aXRoIC0tcmVzYW1wbGVcbiAgICAgICAgICogPC9QUkU+XG4gICAgICAgICAqL1xuICAgICAgICBzd2l0Y2ggKGdmcC5WQlIpIHtcbiAgICAgICAgICAgIGNhc2UgVmJyTW9kZS52YnJfbXQ6XG4gICAgICAgICAgICBjYXNlIFZick1vZGUudmJyX3JoOlxuICAgICAgICAgICAgY2FzZSBWYnJNb2RlLnZicl9tdHJoOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8qIG51bWJlcnMgYXJlIGEgYml0IHN0cmFuZ2UsIGJ1dCB0aGV5IGRldGVybWluZSB0aGUgbG93cGFzcyB2YWx1ZSAqL1xuICAgICAgICAgICAgICAgIHZhciBjbXAgPSBbNS43LCA2LjUsIDcuMywgOC4yLCAxMCwgMTEuOSwgMTMsIDE0LFxuICAgICAgICAgICAgICAgICAgICAxNSwgMTYuNV07XG4gICAgICAgICAgICAgICAgZ2ZwLmNvbXByZXNzaW9uX3JhdGlvID0gY21wW2dmcC5WQlJfcV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFZick1vZGUudmJyX2FicjpcbiAgICAgICAgICAgICAgICBnZnAuY29tcHJlc3Npb25fcmF0aW8gPSBnZnAub3V0X3NhbXBsZXJhdGUgKiAxNiAqIGdmYy5jaGFubmVsc19vdXRcbiAgICAgICAgICAgICAgICAgICAgLyAoMS5lMyAqIGdmcC5WQlJfbWVhbl9iaXRyYXRlX2ticHMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBnZnAuY29tcHJlc3Npb25fcmF0aW8gPSBnZnAub3V0X3NhbXBsZXJhdGUgKiAxNiAqIGdmYy5jaGFubmVsc19vdXRcbiAgICAgICAgICAgICAgICAgICAgLyAoMS5lMyAqIGdmcC5icmF0ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvKlxuICAgICAgICAgKiBtb2RlID0gLTEgKG5vdCBzZXQgYnkgdXNlcikgb3IgbW9kZSA9IE1PTk8gKGJlY2F1c2Ugb2Ygb25seSAxIGlucHV0XG4gICAgICAgICAqIGNoYW5uZWwpLiBJZiBtb2RlIGhhcyBub3QgYmVlbiBzZXQsIHRoZW4gc2VsZWN0IEotU1RFUkVPXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoZ2ZwLm1vZGUgPT0gTVBFR01vZGUuTk9UX1NFVCkge1xuICAgICAgICAgICAgZ2ZwLm1vZGUgPSBNUEVHTW9kZS5KT0lOVF9TVEVSRU87XG4gICAgICAgIH1cblxuICAgICAgICAvKiBhcHBseSB1c2VyIGRyaXZlbiBoaWdoIHBhc3MgZmlsdGVyICovXG4gICAgICAgIGlmIChnZnAuaGlnaHBhc3NmcmVxID4gMCkge1xuICAgICAgICAgICAgZ2ZjLmhpZ2hwYXNzMSA9IDIuICogZ2ZwLmhpZ2hwYXNzZnJlcTtcblxuICAgICAgICAgICAgaWYgKGdmcC5oaWdocGFzc3dpZHRoID49IDApXG4gICAgICAgICAgICAgICAgZ2ZjLmhpZ2hwYXNzMiA9IDIuICogKGdmcC5oaWdocGFzc2ZyZXEgKyBnZnAuaGlnaHBhc3N3aWR0aCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAvKiAwJSBhYm92ZSBvbiBkZWZhdWx0ICovXG4gICAgICAgICAgICAgICAgZ2ZjLmhpZ2hwYXNzMiA9ICgxICsgMC4wMCkgKiAyLiAqIGdmcC5oaWdocGFzc2ZyZXE7XG5cbiAgICAgICAgICAgIGdmYy5oaWdocGFzczEgLz0gZ2ZwLm91dF9zYW1wbGVyYXRlO1xuICAgICAgICAgICAgZ2ZjLmhpZ2hwYXNzMiAvPSBnZnAub3V0X3NhbXBsZXJhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZmMuaGlnaHBhc3MxID0gMDtcbiAgICAgICAgICAgIGdmYy5oaWdocGFzczIgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8qIGFwcGx5IHVzZXIgZHJpdmVuIGxvdyBwYXNzIGZpbHRlciAqL1xuICAgICAgICBpZiAoZ2ZwLmxvd3Bhc3NmcmVxID4gMCkge1xuICAgICAgICAgICAgZ2ZjLmxvd3Bhc3MyID0gMi4gKiBnZnAubG93cGFzc2ZyZXE7XG4gICAgICAgICAgICBpZiAoZ2ZwLmxvd3Bhc3N3aWR0aCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgZ2ZjLmxvd3Bhc3MxID0gMi4gKiAoZ2ZwLmxvd3Bhc3NmcmVxIC0gZ2ZwLmxvd3Bhc3N3aWR0aCk7XG4gICAgICAgICAgICAgICAgaWYgKGdmYy5sb3dwYXNzMSA8IDApIC8qIGhhcyB0byBiZSA+PSAwICovXG4gICAgICAgICAgICAgICAgICAgIGdmYy5sb3dwYXNzMSA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgeyAvKiAwJSBiZWxvdyBvbiBkZWZhdWx0ICovXG4gICAgICAgICAgICAgICAgZ2ZjLmxvd3Bhc3MxID0gKDEgLSAwLjAwKSAqIDIuICogZ2ZwLmxvd3Bhc3NmcmVxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2ZjLmxvd3Bhc3MxIC89IGdmcC5vdXRfc2FtcGxlcmF0ZTtcbiAgICAgICAgICAgIGdmYy5sb3dwYXNzMiAvPSBnZnAub3V0X3NhbXBsZXJhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZmMubG93cGFzczEgPSAwO1xuICAgICAgICAgICAgZ2ZjLmxvd3Bhc3MyID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKiBjb21wdXRlIGluZm8gbmVlZGVkIGZvciBwb2x5cGhhc2UgZmlsdGVyIChmaWx0ZXIgdHlwZT09MCwgZGVmYXVsdCkgKi9cbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIGxhbWVfaW5pdF9wYXJhbXNfcHBmbHQoZ2ZwKTtcbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgICogc2FtcGxlcmF0ZSBhbmQgYml0cmF0ZSBpbmRleFxuICAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgZ2ZjLnNhbXBsZXJhdGVfaW5kZXggPSBTbXBGcnFJbmRleChnZnAub3V0X3NhbXBsZXJhdGUsIGdmcCk7XG4gICAgICAgIGlmIChnZmMuc2FtcGxlcmF0ZV9pbmRleCA8IDApIHtcbiAgICAgICAgICAgIGdmcC5pbnRlcm5hbF9mbGFncyA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2ZwLlZCUiA9PSBWYnJNb2RlLnZicl9vZmYpIHtcbiAgICAgICAgICAgIGlmIChnZnAuZnJlZV9mb3JtYXQpIHtcbiAgICAgICAgICAgICAgICBnZmMuYml0cmF0ZV9pbmRleCA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdmcC5icmF0ZSA9IEZpbmROZWFyZXN0Qml0cmF0ZShnZnAuYnJhdGUsIGdmcC52ZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICBnZnAub3V0X3NhbXBsZXJhdGUpO1xuICAgICAgICAgICAgICAgIGdmYy5iaXRyYXRlX2luZGV4ID0gQml0cmF0ZUluZGV4KGdmcC5icmF0ZSwgZ2ZwLnZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgIGdmcC5vdXRfc2FtcGxlcmF0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGdmYy5iaXRyYXRlX2luZGV4IDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2ZwLmludGVybmFsX2ZsYWdzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdmYy5iaXRyYXRlX2luZGV4ID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGZvciBDQlIsIHdlIHdpbGwgd3JpdGUgYW4gXCJpbmZvXCIgdGFnLiAqL1xuXG4gICAgICAgIGlmIChnZnAuYW5hbHlzaXMpXG4gICAgICAgICAgICBnZnAuYldyaXRlVmJyVGFnID0gZmFsc2U7XG5cbiAgICAgICAgLyogc29tZSBmaWxlIG9wdGlvbnMgbm90IGFsbG93ZWQgaWYgb3V0cHV0IGlzOiBub3Qgc3BlY2lmaWVkIG9yIHN0ZG91dCAqL1xuICAgICAgICBpZiAoZ2ZjLnBpbmZvICE9IG51bGwpXG4gICAgICAgICAgICBnZnAuYldyaXRlVmJyVGFnID0gZmFsc2U7XG4gICAgICAgIC8qIGRpc2FibGUgWGluZyBWQlIgdGFnICovXG5cbiAgICAgICAgYnMuaW5pdF9iaXRfc3RyZWFtX3coZ2ZjKTtcblxuICAgICAgICB2YXIgaiA9IGdmYy5zYW1wbGVyYXRlX2luZGV4ICsgKDMgKiBnZnAudmVyc2lvbikgKyA2XG4gICAgICAgICAgICAqIChnZnAub3V0X3NhbXBsZXJhdGUgPCAxNjAwMCA/IDEgOiAwKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBFbmNvZGVyLlNCTUFYX2wgKyAxOyBpKyspXG4gICAgICAgICAgICBnZmMuc2NhbGVmYWNfYmFuZC5sW2ldID0gcXVwdnQuc2ZCYW5kSW5kZXhbal0ubFtpXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEVuY29kZXIuUFNGQjIxICsgMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IChnZmMuc2NhbGVmYWNfYmFuZC5sWzIyXSAtIGdmYy5zY2FsZWZhY19iYW5kLmxbMjFdKVxuICAgICAgICAgICAgICAgIC8gRW5jb2Rlci5QU0ZCMjE7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBnZmMuc2NhbGVmYWNfYmFuZC5sWzIxXSArIGkgKiBzaXplO1xuICAgICAgICAgICAgZ2ZjLnNjYWxlZmFjX2JhbmQucHNmYjIxW2ldID0gc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2ZjLnNjYWxlZmFjX2JhbmQucHNmYjIxW0VuY29kZXIuUFNGQjIxXSA9IDU3NjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEVuY29kZXIuU0JNQVhfcyArIDE7IGkrKylcbiAgICAgICAgICAgIGdmYy5zY2FsZWZhY19iYW5kLnNbaV0gPSBxdXB2dC5zZkJhbmRJbmRleFtqXS5zW2ldO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgRW5jb2Rlci5QU0ZCMTIgKyAxOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzaXplID0gKGdmYy5zY2FsZWZhY19iYW5kLnNbMTNdIC0gZ2ZjLnNjYWxlZmFjX2JhbmQuc1sxMl0pXG4gICAgICAgICAgICAgICAgLyBFbmNvZGVyLlBTRkIxMjtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGdmYy5zY2FsZWZhY19iYW5kLnNbMTJdICsgaSAqIHNpemU7XG4gICAgICAgICAgICBnZmMuc2NhbGVmYWNfYmFuZC5wc2ZiMTJbaV0gPSBzdGFydDtcbiAgICAgICAgfVxuICAgICAgICBnZmMuc2NhbGVmYWNfYmFuZC5wc2ZiMTJbRW5jb2Rlci5QU0ZCMTJdID0gMTkyO1xuICAgICAgICAvKiBkZXRlcm1pbmUgdGhlIG1lYW4gYml0cmF0ZSBmb3IgbWFpbiBkYXRhICovXG4gICAgICAgIGlmIChnZnAudmVyc2lvbiA9PSAxKSAvKiBNUEVHIDEgKi9cbiAgICAgICAgICAgIGdmYy5zaWRlaW5mb19sZW4gPSAoZ2ZjLmNoYW5uZWxzX291dCA9PSAxKSA/IDQgKyAxNyA6IDQgKyAzMjtcbiAgICAgICAgZWxzZVxuICAgICAgICAvKiBNUEVHIDIgKi9cbiAgICAgICAgICAgIGdmYy5zaWRlaW5mb19sZW4gPSAoZ2ZjLmNoYW5uZWxzX291dCA9PSAxKSA/IDQgKyA5IDogNCArIDE3O1xuXG4gICAgICAgIGlmIChnZnAuZXJyb3JfcHJvdGVjdGlvbilcbiAgICAgICAgICAgIGdmYy5zaWRlaW5mb19sZW4gKz0gMjtcblxuICAgICAgICBsYW1lX2luaXRfYml0c3RyZWFtKGdmcCk7XG5cbiAgICAgICAgZ2ZjLkNsYXNzX0lEID0gTEFNRV9JRDtcblxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgaztcblxuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IDE5OyBrKyspXG4gICAgICAgICAgICAgICAgZ2ZjLm5zUHN5LnBlZmlyYnVmW2tdID0gNzAwICogZ2ZjLm1vZGVfZ3IgKiBnZmMuY2hhbm5lbHNfb3V0O1xuXG4gICAgICAgICAgICBpZiAoZ2ZwLkFUSHR5cGUgPT0gLTEpXG4gICAgICAgICAgICAgICAgZ2ZwLkFUSHR5cGUgPSA0O1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChnZnAuVkJSX3EgPD0gOSk7XG4gICAgICAgIGFzc2VydChnZnAuVkJSX3EgPj0gMCk7XG5cbiAgICAgICAgc3dpdGNoIChnZnAuVkJSKSB7XG5cbiAgICAgICAgICAgIGNhc2UgVmJyTW9kZS52YnJfbXQ6XG4gICAgICAgICAgICAgICAgZ2ZwLlZCUiA9IFZick1vZGUudmJyX210cmg7XG4gICAgICAgICAgICAvLyRGQUxMLVRIUk9VR0gkXG4gICAgICAgICAgICBjYXNlIFZick1vZGUudmJyX210cmg6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKGdmcC51c2VUZW1wb3JhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGdmcC51c2VUZW1wb3JhbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAvKiBvZmYgYnkgZGVmYXVsdCBmb3IgdGhpcyBWQlIgbW9kZSAqL1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHAuYXBwbHlfcHJlc2V0KGdmcCwgNTAwIC0gKGdmcC5WQlJfcSAqIDEwKSwgMCk7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogPFBSRT5cbiAgICAgICAgICAgICAgICAgKiAgIFRoZSBuZXdlciBWQlIgY29kZSBzdXBwb3J0cyBvbmx5IGEgbGltaXRlZFxuICAgICAgICAgICAgICAgICAqICAgICBzdWJzZXQgb2YgcXVhbGl0eSBsZXZlbHM6XG4gICAgICAgICAgICAgICAgICogICAgIDktNT01IGFyZSB0aGUgc2FtZSwgdXNlcyB4XjMvNCBxdWFudGl6YXRpb25cbiAgICAgICAgICAgICAgICAgKiAgIDQtMD0wIGFyZSB0aGUgc2FtZSAgNSBwbHVzIGJlc3QgaHVmZm1hbiBkaXZpZGUgY29kZVxuICAgICAgICAgICAgICAgICAqIDwvUFJFPlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmIChnZnAucXVhbGl0eSA8IDApXG4gICAgICAgICAgICAgICAgICAgIGdmcC5xdWFsaXR5ID0gTEFNRV9ERUZBVUxUX1FVQUxJVFk7XG4gICAgICAgICAgICAgICAgaWYgKGdmcC5xdWFsaXR5IDwgNSlcbiAgICAgICAgICAgICAgICAgICAgZ2ZwLnF1YWxpdHkgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChnZnAucXVhbGl0eSA+IDUpXG4gICAgICAgICAgICAgICAgICAgIGdmcC5xdWFsaXR5ID0gNTtcblxuICAgICAgICAgICAgICAgIGdmYy5QU1kubWFza19hZGp1c3QgPSBnZnAubWFza2luZ2FkanVzdDtcbiAgICAgICAgICAgICAgICBnZmMuUFNZLm1hc2tfYWRqdXN0X3Nob3J0ID0gZ2ZwLm1hc2tpbmdhZGp1c3Rfc2hvcnQ7XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIHNmYjIxIGV4dHJhIG9ubHkgd2l0aCBNUEVHLTEgYXQgaGlnaGVyIHNhbXBsaW5nIHJhdGVzXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKGdmcC5leHBlcmltZW50YWxZKVxuICAgICAgICAgICAgICAgICAgICBnZmMuc2ZiMjFfZXh0cmEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGdmYy5zZmIyMV9leHRyYSA9IChnZnAub3V0X3NhbXBsZXJhdGUgPiA0NDAwMCk7XG5cbiAgICAgICAgICAgICAgICBnZmMuaXRlcmF0aW9uX2xvb3AgPSBuZXcgVkJSTmV3SXRlcmF0aW9uTG9vcChxdSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgVmJyTW9kZS52YnJfcmg6XG4gICAgICAgICAgICB7XG5cbiAgICAgICAgICAgICAgICBwLmFwcGx5X3ByZXNldChnZnAsIDUwMCAtIChnZnAuVkJSX3EgKiAxMCksIDApO1xuXG4gICAgICAgICAgICAgICAgZ2ZjLlBTWS5tYXNrX2FkanVzdCA9IGdmcC5tYXNraW5nYWRqdXN0O1xuICAgICAgICAgICAgICAgIGdmYy5QU1kubWFza19hZGp1c3Rfc2hvcnQgPSBnZnAubWFza2luZ2FkanVzdF9zaG9ydDtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogc2ZiMjEgZXh0cmEgb25seSB3aXRoIE1QRUctMSBhdCBoaWdoZXIgc2FtcGxpbmcgcmF0ZXNcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoZ2ZwLmV4cGVyaW1lbnRhbFkpXG4gICAgICAgICAgICAgICAgICAgIGdmYy5zZmIyMV9leHRyYSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZ2ZjLnNmYjIxX2V4dHJhID0gKGdmcC5vdXRfc2FtcGxlcmF0ZSA+IDQ0MDAwKTtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogVkJSIG5lZWRzIGF0IGxlYXN0IHRoZSBvdXRwdXQgb2YgR1BTWUNITywgc28gd2UgaGF2ZSB0byBnYXJhbnRlZVxuICAgICAgICAgICAgICAgICAqIHRoYXQgYnkgc2V0dGluZyBhIG1pbmltdW0gcXVhbGl0eSBsZXZlbCwgYWN0dWFsbHkgbGV2ZWwgNiBkb2VzXG4gICAgICAgICAgICAgICAgICogaXQuIGRvd24gdG8gbGV2ZWwgNlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmIChnZnAucXVhbGl0eSA+IDYpXG4gICAgICAgICAgICAgICAgICAgIGdmcC5xdWFsaXR5ID0gNjtcblxuICAgICAgICAgICAgICAgIGlmIChnZnAucXVhbGl0eSA8IDApXG4gICAgICAgICAgICAgICAgICAgIGdmcC5xdWFsaXR5ID0gTEFNRV9ERUZBVUxUX1FVQUxJVFk7XG5cbiAgICAgICAgICAgICAgICBnZmMuaXRlcmF0aW9uX2xvb3AgPSBuZXcgVkJST2xkSXRlcmF0aW9uTG9vcChxdSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6IC8qIGNici9hYnIgKi9cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgdmJybW9kZTtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogbm8gc2ZiMjEgZXh0cmEgd2l0aCBDQlIgY29kZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGdmYy5zZmIyMV9leHRyYSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGdmcC5xdWFsaXR5IDwgMClcbiAgICAgICAgICAgICAgICAgICAgZ2ZwLnF1YWxpdHkgPSBMQU1FX0RFRkFVTFRfUVVBTElUWTtcblxuICAgICAgICAgICAgICAgIHZicm1vZGUgPSBnZnAuVkJSO1xuICAgICAgICAgICAgICAgIGlmICh2YnJtb2RlID09IFZick1vZGUudmJyX29mZilcbiAgICAgICAgICAgICAgICAgICAgZ2ZwLlZCUl9tZWFuX2JpdHJhdGVfa2JwcyA9IGdmcC5icmF0ZTtcbiAgICAgICAgICAgICAgICAvKiBzZWNvbmQsIHNldCBwYXJhbWV0ZXJzIGRlcGVuZGluZyBvbiBiaXRyYXRlICovXG4gICAgICAgICAgICAgICAgcC5hcHBseV9wcmVzZXQoZ2ZwLCBnZnAuVkJSX21lYW5fYml0cmF0ZV9rYnBzLCAwKTtcbiAgICAgICAgICAgICAgICBnZnAuVkJSID0gdmJybW9kZTtcblxuICAgICAgICAgICAgICAgIGdmYy5QU1kubWFza19hZGp1c3QgPSBnZnAubWFza2luZ2FkanVzdDtcbiAgICAgICAgICAgICAgICBnZmMuUFNZLm1hc2tfYWRqdXN0X3Nob3J0ID0gZ2ZwLm1hc2tpbmdhZGp1c3Rfc2hvcnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAodmJybW9kZSA9PSBWYnJNb2RlLnZicl9vZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2ZjLml0ZXJhdGlvbl9sb29wID0gbmV3IENCUk5ld0l0ZXJhdGlvbkxvb3AocXUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdmYy5pdGVyYXRpb25fbG9vcCA9IG5ldyBBQlJJdGVyYXRpb25Mb29wKHF1KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KGdmcC5zY2FsZSA+PSAwKTtcbiAgICAgICAgLyogaW5pdGlhbGl6ZSBkZWZhdWx0IHZhbHVlcyBjb21tb24gZm9yIGFsbCBtb2RlcyAqL1xuXG4gICAgICAgIGlmIChnZnAuVkJSICE9IFZick1vZGUudmJyX29mZikgeyAvKiBjaG9vc2UgYSBtaW4vbWF4IGJpdHJhdGUgZm9yIFZCUiAqL1xuICAgICAgICAgICAgLyogaWYgdGhlIHVzZXIgZGlkbid0IHNwZWNpZnkgVkJSX21heF9iaXRyYXRlOiAqL1xuICAgICAgICAgICAgZ2ZjLlZCUl9taW5fYml0cmF0ZSA9IDE7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogZGVmYXVsdDogYWxsb3cgOCBrYnBzIChNUEVHLTIpIG9yIDMyIGticHMgKE1QRUctMSlcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2ZjLlZCUl9tYXhfYml0cmF0ZSA9IDE0O1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIGRlZmF1bHQ6IGFsbG93IDE2MCBrYnBzIChNUEVHLTIpIG9yIDMyMCBrYnBzIChNUEVHLTEpXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChnZnAub3V0X3NhbXBsZXJhdGUgPCAxNjAwMClcbiAgICAgICAgICAgICAgICBnZmMuVkJSX21heF9iaXRyYXRlID0gODtcbiAgICAgICAgICAgIC8qIGRlZmF1bHQ6IGFsbG93IDY0IGticHMgKE1QRUctMi41KSAqL1xuICAgICAgICAgICAgaWYgKGdmcC5WQlJfbWluX2JpdHJhdGVfa2JwcyAhPSAwKSB7XG4gICAgICAgICAgICAgICAgZ2ZwLlZCUl9taW5fYml0cmF0ZV9rYnBzID0gRmluZE5lYXJlc3RCaXRyYXRlKFxuICAgICAgICAgICAgICAgICAgICBnZnAuVkJSX21pbl9iaXRyYXRlX2ticHMsIGdmcC52ZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICBnZnAub3V0X3NhbXBsZXJhdGUpO1xuICAgICAgICAgICAgICAgIGdmYy5WQlJfbWluX2JpdHJhdGUgPSBCaXRyYXRlSW5kZXgoZ2ZwLlZCUl9taW5fYml0cmF0ZV9rYnBzLFxuICAgICAgICAgICAgICAgICAgICBnZnAudmVyc2lvbiwgZ2ZwLm91dF9zYW1wbGVyYXRlKTtcbiAgICAgICAgICAgICAgICBpZiAoZ2ZjLlZCUl9taW5fYml0cmF0ZSA8IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZnAuVkJSX21heF9iaXRyYXRlX2ticHMgIT0gMCkge1xuICAgICAgICAgICAgICAgIGdmcC5WQlJfbWF4X2JpdHJhdGVfa2JwcyA9IEZpbmROZWFyZXN0Qml0cmF0ZShcbiAgICAgICAgICAgICAgICAgICAgZ2ZwLlZCUl9tYXhfYml0cmF0ZV9rYnBzLCBnZnAudmVyc2lvbixcbiAgICAgICAgICAgICAgICAgICAgZ2ZwLm91dF9zYW1wbGVyYXRlKTtcbiAgICAgICAgICAgICAgICBnZmMuVkJSX21heF9iaXRyYXRlID0gQml0cmF0ZUluZGV4KGdmcC5WQlJfbWF4X2JpdHJhdGVfa2JwcyxcbiAgICAgICAgICAgICAgICAgICAgZ2ZwLnZlcnNpb24sIGdmcC5vdXRfc2FtcGxlcmF0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGdmYy5WQlJfbWF4X2JpdHJhdGUgPCAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZnAuVkJSX21pbl9iaXRyYXRlX2ticHMgPSBUYWJsZXMuYml0cmF0ZV90YWJsZVtnZnAudmVyc2lvbl1bZ2ZjLlZCUl9taW5fYml0cmF0ZV07XG4gICAgICAgICAgICBnZnAuVkJSX21heF9iaXRyYXRlX2ticHMgPSBUYWJsZXMuYml0cmF0ZV90YWJsZVtnZnAudmVyc2lvbl1bZ2ZjLlZCUl9tYXhfYml0cmF0ZV07XG4gICAgICAgICAgICBnZnAuVkJSX21lYW5fYml0cmF0ZV9rYnBzID0gTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgVGFibGVzLmJpdHJhdGVfdGFibGVbZ2ZwLnZlcnNpb25dW2dmYy5WQlJfbWF4X2JpdHJhdGVdLFxuICAgICAgICAgICAgICAgIGdmcC5WQlJfbWVhbl9iaXRyYXRlX2ticHMpO1xuICAgICAgICAgICAgZ2ZwLlZCUl9tZWFuX2JpdHJhdGVfa2JwcyA9IE1hdGgubWF4KFxuICAgICAgICAgICAgICAgIFRhYmxlcy5iaXRyYXRlX3RhYmxlW2dmcC52ZXJzaW9uXVtnZmMuVkJSX21pbl9iaXRyYXRlXSxcbiAgICAgICAgICAgICAgICBnZnAuVkJSX21lYW5fYml0cmF0ZV9rYnBzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGp1c3QgYW5vdGhlciBkYWlseSBjaGFuZ2luZyBkZXZlbG9wZXIgc3dpdGNoICovXG4gICAgICAgIGlmIChnZnAudHVuZSkge1xuICAgICAgICAgICAgZ2ZjLlBTWS5tYXNrX2FkanVzdCArPSBnZnAudHVuZV92YWx1ZV9hO1xuICAgICAgICAgICAgZ2ZjLlBTWS5tYXNrX2FkanVzdF9zaG9ydCArPSBnZnAudHVuZV92YWx1ZV9hO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogaW5pdGlhbGl6ZSBpbnRlcm5hbCBxdmFsIHNldHRpbmdzICovXG4gICAgICAgIGxhbWVfaW5pdF9xdmFsKGdmcCk7XG4gICAgICAgIGFzc2VydChnZnAuc2NhbGUgPj0gMCk7XG4gICAgICAgIC8qXG4gICAgICAgICAqIGF1dG9tYXRpYyBBVEggYWRqdXN0bWVudCBvblxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGdmcC5hdGhhYV90eXBlIDwgMClcbiAgICAgICAgICAgIGdmYy5BVEgudXNlQWRqdXN0ID0gMztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZ2ZjLkFUSC51c2VBZGp1c3QgPSBnZnAuYXRoYWFfdHlwZTtcblxuICAgICAgICAvKiBpbml0aWFsaXplIGludGVybmFsIGFkYXB0aXZlIEFUSCBzZXR0aW5ncyAtamQgKi9cbiAgICAgICAgZ2ZjLkFUSC5hYVNlbnNpdGl2aXR5UCA9IE1hdGgucG93KDEwLjAsIGdmcC5hdGhhYV9zZW5zaXRpdml0eVxuICAgICAgICAgICAgLyAtMTAuMCk7XG5cbiAgICAgICAgaWYgKGdmcC5zaG9ydF9ibG9ja3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgZ2ZwLnNob3J0X2Jsb2NrcyA9IFNob3J0QmxvY2suc2hvcnRfYmxvY2tfYWxsb3dlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIE5vdGUgSmFuLzIwMDM6IE1hbnkgaGFyZHdhcmUgZGVjb2RlcnMgY2Fubm90IGhhbmRsZSBzaG9ydCBibG9ja3MgaW5cbiAgICAgICAgICogcmVndWxhciBzdGVyZW8gbW9kZSB1bmxlc3MgdGhleSBhcmUgY291cGxlZCAoc2FtZSB0eXBlIGluIGJvdGhcbiAgICAgICAgICogY2hhbm5lbHMpIGl0IGlzIGEgcmFyZSBldmVudCAoMSBmcmFtZSBwZXIgbWluLiBvciBzbykgdGhhdCBMQU1FIHdvdWxkXG4gICAgICAgICAqIHVzZSB1bmNvdXBsZWQgc2hvcnQgYmxvY2tzLCBzbyBsZXRzIHR1cm4gdGhlbSBvZmYgdW50aWwgd2UgZGVjaWRlIGhvd1xuICAgICAgICAgKiB0byBoYW5kbGUgdGhpcy4gTm8gb3RoZXIgZW5jb2RlcnMgYWxsb3cgdW5jb3VwbGVkIHNob3J0IGJsb2NrcywgZXZlblxuICAgICAgICAgKiB0aG91Z2ggaXQgaXMgaW4gdGhlIHN0YW5kYXJkLlxuICAgICAgICAgKi9cbiAgICAgICAgLypcbiAgICAgICAgICogcmggMjAwNDAyMTc6IGNvdXBsaW5nIG1ha2VzIG5vIHNlbnNlIGZvciBtb25vIGFuZCBkdWFsLW1vbm8gc3RyZWFtc1xuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGdmcC5zaG9ydF9ibG9ja3MgPT0gU2hvcnRCbG9jay5zaG9ydF9ibG9ja19hbGxvd2VkXG4gICAgICAgICAgICAmJiAoZ2ZwLm1vZGUgPT0gTVBFR01vZGUuSk9JTlRfU1RFUkVPIHx8IGdmcC5tb2RlID09IE1QRUdNb2RlLlNURVJFTykpIHtcbiAgICAgICAgICAgIGdmcC5zaG9ydF9ibG9ja3MgPSBTaG9ydEJsb2NrLnNob3J0X2Jsb2NrX2NvdXBsZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2ZwLnF1YW50X2NvbXAgPCAwKVxuICAgICAgICAgICAgZ2ZwLnF1YW50X2NvbXAgPSAxO1xuICAgICAgICBpZiAoZ2ZwLnF1YW50X2NvbXBfc2hvcnQgPCAwKVxuICAgICAgICAgICAgZ2ZwLnF1YW50X2NvbXBfc2hvcnQgPSAwO1xuXG4gICAgICAgIGlmIChnZnAubXNmaXggPCAwKVxuICAgICAgICAgICAgZ2ZwLm1zZml4ID0gMDtcblxuICAgICAgICAvKiBzZWxlY3QgcHN5Y2hvYWNvdXN0aWMgbW9kZWwgKi9cbiAgICAgICAgZ2ZwLmV4cF9uc3BzeXR1bmUgPSBnZnAuZXhwX25zcHN5dHVuZSB8IDE7XG5cbiAgICAgICAgaWYgKGdmcC5pbnRlcm5hbF9mbGFncy5uc1BzeS5hdHRhY2t0aHJlIDwgMClcbiAgICAgICAgICAgIGdmcC5pbnRlcm5hbF9mbGFncy5uc1BzeS5hdHRhY2t0aHJlID0gUHN5TW9kZWwuTlNBVFRBQ0tUSFJFO1xuICAgICAgICBpZiAoZ2ZwLmludGVybmFsX2ZsYWdzLm5zUHN5LmF0dGFja3RocmVfcyA8IDApXG4gICAgICAgICAgICBnZnAuaW50ZXJuYWxfZmxhZ3MubnNQc3kuYXR0YWNrdGhyZV9zID0gUHN5TW9kZWwuTlNBVFRBQ0tUSFJFX1M7XG5cbiAgICAgICAgYXNzZXJ0KGdmcC5zY2FsZSA+PSAwKTtcblxuICAgICAgICBpZiAoZ2ZwLnNjYWxlIDwgMClcbiAgICAgICAgICAgIGdmcC5zY2FsZSA9IDE7XG5cbiAgICAgICAgaWYgKGdmcC5BVEh0eXBlIDwgMClcbiAgICAgICAgICAgIGdmcC5BVEh0eXBlID0gNDtcblxuICAgICAgICBpZiAoZ2ZwLkFUSGN1cnZlIDwgMClcbiAgICAgICAgICAgIGdmcC5BVEhjdXJ2ZSA9IDQ7XG5cbiAgICAgICAgaWYgKGdmcC5hdGhhYV9sb3VkYXBwcm94IDwgMClcbiAgICAgICAgICAgIGdmcC5hdGhhYV9sb3VkYXBwcm94ID0gMjtcblxuICAgICAgICBpZiAoZ2ZwLmludGVyQ2hSYXRpbyA8IDApXG4gICAgICAgICAgICBnZnAuaW50ZXJDaFJhdGlvID0gMDtcblxuICAgICAgICBpZiAoZ2ZwLnVzZVRlbXBvcmFsID09IG51bGwpXG4gICAgICAgICAgICBnZnAudXNlVGVtcG9yYWwgPSB0cnVlO1xuICAgICAgICAvKiBvbiBieSBkZWZhdWx0ICovXG5cbiAgICAgICAgLypcbiAgICAgICAgICogcGFkZGluZyBtZXRob2QgYXMgZGVzY3JpYmVkIGluXG4gICAgICAgICAqIFwiTVBFRy1MYXllcjMgLyBCaXRzdHJlYW0gU3ludGF4IGFuZCBEZWNvZGluZ1wiIGJ5IE1hcnRpbiBTaWVsZXIsIFJhbHBoXG4gICAgICAgICAqIFNwZXJzY2huZWlkZXJcbiAgICAgICAgICpcbiAgICAgICAgICogbm90ZTogdGhlcmUgaXMgbm8gcGFkZGluZyBmb3IgdGhlIHZlcnkgZmlyc3QgZnJhbWVcbiAgICAgICAgICpcbiAgICAgICAgICogUm9iZXJ0IEhlZ2VtYW5uIDIwMDAtMDYtMjJcbiAgICAgICAgICovXG4gICAgICAgIGdmYy5zbG90X2xhZyA9IGdmYy5mcmFjX1NwRiA9IDA7XG4gICAgICAgIGlmIChnZnAuVkJSID09IFZick1vZGUudmJyX29mZilcbiAgICAgICAgICAgIGdmYy5zbG90X2xhZyA9IGdmYy5mcmFjX1NwRiA9ICgoKGdmcC52ZXJzaW9uICsgMSkgKiA3MjAwMCAqIGdmcC5icmF0ZSkgJSBnZnAub3V0X3NhbXBsZXJhdGUpIHwgMDtcblxuICAgICAgICBxdXB2dC5pdGVyYXRpb25faW5pdChnZnApO1xuICAgICAgICBwc3kucHN5bW9kZWxfaW5pdChnZnApO1xuICAgICAgICBhc3NlcnQoZ2ZwLnNjYWxlID49IDApO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVfaW5idWZmZXJfc2l6ZShnZmMsIG5zYW1wbGVzKSB7XG4gICAgICAgIGlmIChnZmMuaW5fYnVmZmVyXzAgPT0gbnVsbCB8fCBnZmMuaW5fYnVmZmVyX25zYW1wbGVzIDwgbnNhbXBsZXMpIHtcbiAgICAgICAgICAgIGdmYy5pbl9idWZmZXJfMCA9IG5ld19mbG9hdChuc2FtcGxlcyk7XG4gICAgICAgICAgICBnZmMuaW5fYnVmZmVyXzEgPSBuZXdfZmxvYXQobnNhbXBsZXMpO1xuICAgICAgICAgICAgZ2ZjLmluX2J1ZmZlcl9uc2FtcGxlcyA9IG5zYW1wbGVzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sYW1lX2VuY29kZV9mbHVzaCA9IGZ1bmN0aW9uIChnZnAsIG1wM2J1ZmZlciwgbXAzYnVmZmVyUG9zLCBtcDNidWZmZXJfc2l6ZSkge1xuICAgICAgICB2YXIgZ2ZjID0gZ2ZwLmludGVybmFsX2ZsYWdzO1xuICAgICAgICB2YXIgYnVmZmVyID0gbmV3X3Nob3J0X24oWzIsIDExNTJdKTtcbiAgICAgICAgdmFyIGltcDMgPSAwLCBtcDNjb3VudCwgbXAzYnVmZmVyX3NpemVfcmVtYWluaW5nO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIHdlIGFsd2F5cyBhZGQgUE9TVERFTEFZPTI4OCBwYWRkaW5nIHRvIG1ha2Ugc3VyZSBncmFudWxlIHdpdGggcmVhbFxuICAgICAgICAgKiBkYXRhIGNhbiBiZSBjb21wbGV0eSBkZWNvZGVkIChiZWNhdXNlIG9mIDUwJSBvdmVybGFwIHdpdGggbmV4dFxuICAgICAgICAgKiBncmFudWxlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgZW5kX3BhZGRpbmc7XG4gICAgICAgIHZhciBmcmFtZXNfbGVmdDtcbiAgICAgICAgdmFyIHNhbXBsZXNfdG9fZW5jb2RlID0gZ2ZjLm1mX3NhbXBsZXNfdG9fZW5jb2RlIC0gRW5jb2Rlci5QT1NUREVMQVk7XG4gICAgICAgIHZhciBtZl9uZWVkZWQgPSBjYWxjTmVlZGVkKGdmcCk7XG5cbiAgICAgICAgLyogV2FzIGZsdXNoIGFscmVhZHkgY2FsbGVkPyAqL1xuICAgICAgICBpZiAoZ2ZjLm1mX3NhbXBsZXNfdG9fZW5jb2RlIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgbXAzY291bnQgPSAwO1xuXG4gICAgICAgIGlmIChnZnAuaW5fc2FtcGxlcmF0ZSAhPSBnZnAub3V0X3NhbXBsZXJhdGUpIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBkZWxheSBkdWUgdG8gcmVzYW1wbGluZzsgbmVlZHMgdG8gYmUgZml4ZWQsIGlmIHJlc2FtcGxpbmcgY29kZVxuICAgICAgICAgICAgICogZ2V0cyBjaGFuZ2VkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNhbXBsZXNfdG9fZW5jb2RlICs9IDE2LiAqIGdmcC5vdXRfc2FtcGxlcmF0ZSAvIGdmcC5pbl9zYW1wbGVyYXRlO1xuICAgICAgICB9XG4gICAgICAgIGVuZF9wYWRkaW5nID0gZ2ZwLmZyYW1lc2l6ZSAtIChzYW1wbGVzX3RvX2VuY29kZSAlIGdmcC5mcmFtZXNpemUpO1xuICAgICAgICBpZiAoZW5kX3BhZGRpbmcgPCA1NzYpXG4gICAgICAgICAgICBlbmRfcGFkZGluZyArPSBnZnAuZnJhbWVzaXplO1xuICAgICAgICBnZnAuZW5jb2Rlcl9wYWRkaW5nID0gZW5kX3BhZGRpbmc7XG5cbiAgICAgICAgZnJhbWVzX2xlZnQgPSAoc2FtcGxlc190b19lbmNvZGUgKyBlbmRfcGFkZGluZykgLyBnZnAuZnJhbWVzaXplO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIHNlbmQgaW4gYSBmcmFtZSBvZiAwIHBhZGRpbmcgdW50aWwgYWxsIGludGVybmFsIHNhbXBsZSBidWZmZXJzIGFyZVxuICAgICAgICAgKiBmbHVzaGVkXG4gICAgICAgICAqL1xuICAgICAgICB3aGlsZSAoZnJhbWVzX2xlZnQgPiAwICYmIGltcDMgPj0gMCkge1xuICAgICAgICAgICAgdmFyIGJ1bmNoID0gbWZfbmVlZGVkIC0gZ2ZjLm1mX3NpemU7XG4gICAgICAgICAgICB2YXIgZnJhbWVfbnVtID0gZ2ZwLmZyYW1lTnVtO1xuXG4gICAgICAgICAgICBidW5jaCAqPSBnZnAuaW5fc2FtcGxlcmF0ZTtcbiAgICAgICAgICAgIGJ1bmNoIC89IGdmcC5vdXRfc2FtcGxlcmF0ZTtcbiAgICAgICAgICAgIGlmIChidW5jaCA+IDExNTIpXG4gICAgICAgICAgICAgICAgYnVuY2ggPSAxMTUyO1xuICAgICAgICAgICAgaWYgKGJ1bmNoIDwgMSlcbiAgICAgICAgICAgICAgICBidW5jaCA9IDE7XG5cbiAgICAgICAgICAgIG1wM2J1ZmZlcl9zaXplX3JlbWFpbmluZyA9IG1wM2J1ZmZlcl9zaXplIC0gbXAzY291bnQ7XG5cbiAgICAgICAgICAgIC8qIGlmIHVzZXIgc3BlY2lmZWQgYnVmZmVyIHNpemUgPSAwLCBkb250IGNoZWNrIHNpemUgKi9cbiAgICAgICAgICAgIGlmIChtcDNidWZmZXJfc2l6ZSA9PSAwKVxuICAgICAgICAgICAgICAgIG1wM2J1ZmZlcl9zaXplX3JlbWFpbmluZyA9IDA7XG5cbiAgICAgICAgICAgIGltcDMgPSB0aGlzLmxhbWVfZW5jb2RlX2J1ZmZlcihnZnAsIGJ1ZmZlclswXSwgYnVmZmVyWzFdLCBidW5jaCxcbiAgICAgICAgICAgICAgICBtcDNidWZmZXIsIG1wM2J1ZmZlclBvcywgbXAzYnVmZmVyX3NpemVfcmVtYWluaW5nKTtcblxuICAgICAgICAgICAgbXAzYnVmZmVyUG9zICs9IGltcDM7XG4gICAgICAgICAgICBtcDNjb3VudCArPSBpbXAzO1xuICAgICAgICAgICAgZnJhbWVzX2xlZnQgLT0gKGZyYW1lX251bSAhPSBnZnAuZnJhbWVOdW0pID8gMSA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgICogU2V0IGdmYy5tZl9zYW1wbGVzX3RvX2VuY29kZSB0byAwLCBzbyB3ZSBtYXkgZGV0ZWN0IGFuZCBicmVhayBsb29wc1xuICAgICAgICAgKiBjYWxsaW5nIGl0IG1vcmUgdGhhbiBvbmNlIGluIGEgcm93LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2ZjLm1mX3NhbXBsZXNfdG9fZW5jb2RlID0gMDtcblxuICAgICAgICBpZiAoaW1wMyA8IDApIHtcbiAgICAgICAgICAgIC8qIHNvbWUgdHlwZSBvZiBmYXRhbCBlcnJvciAqL1xuICAgICAgICAgICAgcmV0dXJuIGltcDM7XG4gICAgICAgIH1cblxuICAgICAgICBtcDNidWZmZXJfc2l6ZV9yZW1haW5pbmcgPSBtcDNidWZmZXJfc2l6ZSAtIG1wM2NvdW50O1xuICAgICAgICAvKiBpZiB1c2VyIHNwZWNpZmVkIGJ1ZmZlciBzaXplID0gMCwgZG9udCBjaGVjayBzaXplICovXG4gICAgICAgIGlmIChtcDNidWZmZXJfc2l6ZSA9PSAwKVxuICAgICAgICAgICAgbXAzYnVmZmVyX3NpemVfcmVtYWluaW5nID0gMDtcblxuICAgICAgICAvKiBtcDMgcmVsYXRlZCBzdHVmZi4gYml0IGJ1ZmZlciBtaWdodCBzdGlsbCBjb250YWluIHNvbWUgbXAzIGRhdGEgKi9cbiAgICAgICAgYnMuZmx1c2hfYml0c3RyZWFtKGdmcCk7XG4gICAgICAgIGltcDMgPSBicy5jb3B5X2J1ZmZlcihnZmMsIG1wM2J1ZmZlciwgbXAzYnVmZmVyUG9zLFxuICAgICAgICAgICAgbXAzYnVmZmVyX3NpemVfcmVtYWluaW5nLCAxKTtcbiAgICAgICAgaWYgKGltcDMgPCAwKSB7XG4gICAgICAgICAgICAvKiBzb21lIHR5cGUgb2YgZmF0YWwgZXJyb3IgKi9cbiAgICAgICAgICAgIHJldHVybiBpbXAzO1xuICAgICAgICB9XG4gICAgICAgIG1wM2J1ZmZlclBvcyArPSBpbXAzO1xuICAgICAgICBtcDNjb3VudCArPSBpbXAzO1xuICAgICAgICBtcDNidWZmZXJfc2l6ZV9yZW1haW5pbmcgPSBtcDNidWZmZXJfc2l6ZSAtIG1wM2NvdW50O1xuICAgICAgICAvKiBpZiB1c2VyIHNwZWNpZmVkIGJ1ZmZlciBzaXplID0gMCwgZG9udCBjaGVjayBzaXplICovXG4gICAgICAgIGlmIChtcDNidWZmZXJfc2l6ZSA9PSAwKVxuICAgICAgICAgICAgbXAzYnVmZmVyX3NpemVfcmVtYWluaW5nID0gMDtcblxuICAgICAgICBpZiAoZ2ZwLndyaXRlX2lkM3RhZ19hdXRvbWF0aWMpIHtcbiAgICAgICAgICAgIC8qIHdyaXRlIGEgaWQzIHRhZyB0byB0aGUgYml0c3RyZWFtICovXG4gICAgICAgICAgICBpZDMuaWQzdGFnX3dyaXRlX3YxKGdmcCk7XG5cbiAgICAgICAgICAgIGltcDMgPSBicy5jb3B5X2J1ZmZlcihnZmMsIG1wM2J1ZmZlciwgbXAzYnVmZmVyUG9zLFxuICAgICAgICAgICAgICAgIG1wM2J1ZmZlcl9zaXplX3JlbWFpbmluZywgMCk7XG5cbiAgICAgICAgICAgIGlmIChpbXAzIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbXAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbXAzY291bnQgKz0gaW1wMztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbXAzY291bnQ7XG4gICAgfTtcblxuICAgIHRoaXMubGFtZV9lbmNvZGVfYnVmZmVyID0gZnVuY3Rpb24gKGdmcCwgYnVmZmVyX2wsIGJ1ZmZlcl9yLCBuc2FtcGxlcywgbXAzYnVmLCBtcDNidWZQb3MsIG1wM2J1Zl9zaXplKSB7XG4gICAgICAgIHZhciBnZmMgPSBnZnAuaW50ZXJuYWxfZmxhZ3M7XG4gICAgICAgIHZhciBpbl9idWZmZXIgPSBbbnVsbCwgbnVsbF07XG5cbiAgICAgICAgaWYgKGdmYy5DbGFzc19JRCAhPSBMQU1FX0lEKVxuICAgICAgICAgICAgcmV0dXJuIC0zO1xuXG4gICAgICAgIGlmIChuc2FtcGxlcyA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG5cbiAgICAgICAgdXBkYXRlX2luYnVmZmVyX3NpemUoZ2ZjLCBuc2FtcGxlcyk7XG5cbiAgICAgICAgaW5fYnVmZmVyWzBdID0gZ2ZjLmluX2J1ZmZlcl8wO1xuICAgICAgICBpbl9idWZmZXJbMV0gPSBnZmMuaW5fYnVmZmVyXzE7XG5cbiAgICAgICAgLyogbWFrZSBhIGNvcHkgb2YgaW5wdXQgYnVmZmVyLCBjaGFuZ2luZyB0eXBlIHRvIHNhbXBsZV90ICovXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnNhbXBsZXM7IGkrKykge1xuICAgICAgICAgICAgaW5fYnVmZmVyWzBdW2ldID0gYnVmZmVyX2xbaV07XG4gICAgICAgICAgICBpZiAoZ2ZjLmNoYW5uZWxzX2luID4gMSlcbiAgICAgICAgICAgICAgICBpbl9idWZmZXJbMV1baV0gPSBidWZmZXJfcltpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsYW1lX2VuY29kZV9idWZmZXJfc2FtcGxlKGdmcCwgaW5fYnVmZmVyWzBdLCBpbl9idWZmZXJbMV0sXG4gICAgICAgICAgICBuc2FtcGxlcywgbXAzYnVmLCBtcDNidWZQb3MsIG1wM2J1Zl9zaXplKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxjTmVlZGVkKGdmcCkge1xuICAgICAgICB2YXIgbWZfbmVlZGVkID0gRW5jb2Rlci5CTEtTSVpFICsgZ2ZwLmZyYW1lc2l6ZSAtIEVuY29kZXIuRkZUT0ZGU0VUO1xuICAgICAgICAvKlxuICAgICAgICAgKiBhbW91bnQgbmVlZGVkIGZvciBGRlRcbiAgICAgICAgICovXG4gICAgICAgIG1mX25lZWRlZCA9IE1hdGgubWF4KG1mX25lZWRlZCwgNTEyICsgZ2ZwLmZyYW1lc2l6ZSAtIDMyKTtcbiAgICAgICAgYXNzZXJ0KExhbWVJbnRlcm5hbEZsYWdzLk1GU0laRSA+PSBtZl9uZWVkZWQpO1xuXG4gICAgICAgIHJldHVybiBtZl9uZWVkZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGFtZV9lbmNvZGVfYnVmZmVyX3NhbXBsZShnZnAsIGJ1ZmZlcl9sLCBidWZmZXJfciwgbnNhbXBsZXMsIG1wM2J1ZiwgbXAzYnVmUG9zLCBtcDNidWZfc2l6ZSkge1xuICAgICAgICB2YXIgZ2ZjID0gZ2ZwLmludGVybmFsX2ZsYWdzO1xuICAgICAgICB2YXIgbXAzc2l6ZSA9IDAsIHJldCwgaSwgY2gsIG1mX25lZWRlZDtcbiAgICAgICAgdmFyIG1wM291dDtcbiAgICAgICAgdmFyIG1mYnVmID0gW251bGwsIG51bGxdO1xuICAgICAgICB2YXIgaW5fYnVmZmVyID0gW251bGwsIG51bGxdO1xuXG4gICAgICAgIGlmIChnZmMuQ2xhc3NfSUQgIT0gTEFNRV9JRClcbiAgICAgICAgICAgIHJldHVybiAtMztcblxuICAgICAgICBpZiAobnNhbXBsZXMgPT0gMClcbiAgICAgICAgICAgIHJldHVybiAwO1xuXG4gICAgICAgIC8qIGNvcHkgb3V0IGFueSB0YWdzIHRoYXQgbWF5IGhhdmUgYmVlbiB3cml0dGVuIGludG8gYml0c3RyZWFtICovXG4gICAgICAgIG1wM291dCA9IGJzLmNvcHlfYnVmZmVyKGdmYywgbXAzYnVmLCBtcDNidWZQb3MsIG1wM2J1Zl9zaXplLCAwKTtcbiAgICAgICAgaWYgKG1wM291dCA8IDApXG4gICAgICAgICAgICByZXR1cm4gbXAzb3V0O1xuICAgICAgICAvKiBub3QgZW5vdWdoIGJ1ZmZlciBzcGFjZSAqL1xuICAgICAgICBtcDNidWZQb3MgKz0gbXAzb3V0O1xuICAgICAgICBtcDNzaXplICs9IG1wM291dDtcblxuICAgICAgICBpbl9idWZmZXJbMF0gPSBidWZmZXJfbDtcbiAgICAgICAgaW5fYnVmZmVyWzFdID0gYnVmZmVyX3I7XG5cbiAgICAgICAgLyogQXBwbHkgdXNlciBkZWZpbmVkIHJlLXNjYWxpbmcgKi9cblxuICAgICAgICAvKiB1c2VyIHNlbGVjdGVkIHNjYWxpbmcgb2YgdGhlIHNhbXBsZXMgKi9cbiAgICAgICAgaWYgKEJpdFN0cmVhbS5ORVEoZ2ZwLnNjYWxlLCAwKSAmJiBCaXRTdHJlYW0uTkVRKGdmcC5zY2FsZSwgMS4wKSkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5zYW1wbGVzOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpbl9idWZmZXJbMF1baV0gKj0gZ2ZwLnNjYWxlO1xuICAgICAgICAgICAgICAgIGlmIChnZmMuY2hhbm5lbHNfb3V0ID09IDIpXG4gICAgICAgICAgICAgICAgICAgIGluX2J1ZmZlclsxXVtpXSAqPSBnZnAuc2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiB1c2VyIHNlbGVjdGVkIHNjYWxpbmcgb2YgdGhlIGNoYW5uZWwgMCAobGVmdCkgc2FtcGxlcyAqL1xuICAgICAgICBpZiAoQml0U3RyZWFtLk5FUShnZnAuc2NhbGVfbGVmdCwgMClcbiAgICAgICAgICAgICYmIEJpdFN0cmVhbS5ORVEoZ2ZwLnNjYWxlX2xlZnQsIDEuMCkpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuc2FtcGxlczsgKytpKSB7XG4gICAgICAgICAgICAgICAgaW5fYnVmZmVyWzBdW2ldICo9IGdmcC5zY2FsZV9sZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyogdXNlciBzZWxlY3RlZCBzY2FsaW5nIG9mIHRoZSBjaGFubmVsIDEgKHJpZ2h0KSBzYW1wbGVzICovXG4gICAgICAgIGlmIChCaXRTdHJlYW0uTkVRKGdmcC5zY2FsZV9yaWdodCwgMClcbiAgICAgICAgICAgICYmIEJpdFN0cmVhbS5ORVEoZ2ZwLnNjYWxlX3JpZ2h0LCAxLjApKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnNhbXBsZXM7ICsraSkge1xuICAgICAgICAgICAgICAgIGluX2J1ZmZlclsxXVtpXSAqPSBnZnAuc2NhbGVfcmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiBEb3duc2FtcGxlIHRvIE1vbm8gaWYgMiBjaGFubmVscyBpbiBhbmQgMSBjaGFubmVsIG91dCAqL1xuICAgICAgICBpZiAoZ2ZwLm51bV9jaGFubmVscyA9PSAyICYmIGdmYy5jaGFubmVsc19vdXQgPT0gMSkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5zYW1wbGVzOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpbl9idWZmZXJbMF1baV0gPSAwLjUgKiAoIGluX2J1ZmZlclswXVtpXSArIGluX2J1ZmZlclsxXVtpXSk7XG4gICAgICAgICAgICAgICAgaW5fYnVmZmVyWzFdW2ldID0gMC4wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWZfbmVlZGVkID0gY2FsY05lZWRlZChnZnApO1xuXG4gICAgICAgIG1mYnVmWzBdID0gZ2ZjLm1mYnVmWzBdO1xuICAgICAgICBtZmJ1ZlsxXSA9IGdmYy5tZmJ1ZlsxXTtcblxuICAgICAgICB2YXIgaW5fYnVmZmVyUG9zID0gMDtcbiAgICAgICAgd2hpbGUgKG5zYW1wbGVzID4gMCkge1xuICAgICAgICAgICAgdmFyIGluX2J1ZmZlcl9wdHIgPSBbbnVsbCwgbnVsbF07XG4gICAgICAgICAgICB2YXIgbl9pbiA9IDA7XG4gICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5wdXQgc2FtcGxlcyBwcm9jZXNzZWQgd2l0aCBmaWxsX2J1ZmZlciAqL1xuICAgICAgICAgICAgdmFyIG5fb3V0ID0gMDtcbiAgICAgICAgICAgIC8qIG51bWJlciBvZiBzYW1wbGVzIG91dHB1dCB3aXRoIGZpbGxfYnVmZmVyICovXG4gICAgICAgICAgICAvKiBuX2luIDw+IG5fb3V0IGlmIHdlIGFyZSByZXNhbXBsaW5nICovXG5cbiAgICAgICAgICAgIGluX2J1ZmZlcl9wdHJbMF0gPSBpbl9idWZmZXJbMF07XG4gICAgICAgICAgICBpbl9idWZmZXJfcHRyWzFdID0gaW5fYnVmZmVyWzFdO1xuICAgICAgICAgICAgLyogY29weSBpbiBuZXcgc2FtcGxlcyBpbnRvIG1mYnVmLCB3aXRoIHJlc2FtcGxpbmcgKi9cbiAgICAgICAgICAgIHZhciBpbk91dCA9IG5ldyBJbk91dCgpO1xuICAgICAgICAgICAgZmlsbF9idWZmZXIoZ2ZwLCBtZmJ1ZiwgaW5fYnVmZmVyX3B0ciwgaW5fYnVmZmVyUG9zLCBuc2FtcGxlcyxcbiAgICAgICAgICAgICAgICBpbk91dCk7XG4gICAgICAgICAgICBuX2luID0gaW5PdXQubl9pbjtcbiAgICAgICAgICAgIG5fb3V0ID0gaW5PdXQubl9vdXQ7XG5cbiAgICAgICAgICAgIC8qIGNvbXB1dGUgUmVwbGF5R2FpbiBvZiByZXNhbXBsZWQgaW5wdXQgaWYgcmVxdWVzdGVkICovXG4gICAgICAgICAgICBpZiAoZ2ZjLmZpbmRSZXBsYXlHYWluICYmICFnZmMuZGVjb2RlX29uX3RoZV9mbHkpXG4gICAgICAgICAgICAgICAgaWYgKGdhLkFuYWx5emVTYW1wbGVzKGdmYy5yZ2RhdGEsIG1mYnVmWzBdLCBnZmMubWZfc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1mYnVmWzFdLCBnZmMubWZfc2l6ZSwgbl9vdXQsIGdmYy5jaGFubmVsc19vdXQpID09IEdhaW5BbmFseXNpcy5HQUlOX0FOQUxZU0lTX0VSUk9SKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTY7XG5cbiAgICAgICAgICAgIC8qIHVwZGF0ZSBpbl9idWZmZXIgY291bnRlcnMgKi9cbiAgICAgICAgICAgIG5zYW1wbGVzIC09IG5faW47XG4gICAgICAgICAgICBpbl9idWZmZXJQb3MgKz0gbl9pbjtcbiAgICAgICAgICAgIGlmIChnZmMuY2hhbm5lbHNfb3V0ID09IDIpXG4gICAgICAgICAgICAgICAgOy8vIGluX2J1ZmZlclBvcyArPSBuX2luO1xuXG4gICAgICAgICAgICAvKiB1cGRhdGUgbWZidWZbXSBjb3VudGVycyAqL1xuICAgICAgICAgICAgZ2ZjLm1mX3NpemUgKz0gbl9vdXQ7XG4gICAgICAgICAgICBhc3NlcnQoZ2ZjLm1mX3NpemUgPD0gTGFtZUludGVybmFsRmxhZ3MuTUZTSVpFKTtcblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIGxhbWVfZW5jb2RlX2ZsdXNoIG1heSBoYXZlIHNldCBnZmMubWZfc2FtcGxlX3RvX2VuY29kZSB0byAwIHNvIHdlXG4gICAgICAgICAgICAgKiBoYXZlIHRvIHJlaW5pdGlhbGl6ZSBpdCBoZXJlIHdoZW4gdGhhdCBoYXBwZW5lZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGdmYy5tZl9zYW1wbGVzX3RvX2VuY29kZSA8IDEpIHtcbiAgICAgICAgICAgICAgICBnZmMubWZfc2FtcGxlc190b19lbmNvZGUgPSBFbmNvZGVyLkVOQ0RFTEFZICsgRW5jb2Rlci5QT1NUREVMQVk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZmMubWZfc2FtcGxlc190b19lbmNvZGUgKz0gbl9vdXQ7XG5cbiAgICAgICAgICAgIGlmIChnZmMubWZfc2l6ZSA+PSBtZl9uZWVkZWQpIHtcbiAgICAgICAgICAgICAgICAvKiBlbmNvZGUgdGhlIGZyYW1lLiAqL1xuICAgICAgICAgICAgICAgIC8qIG1wM2J1ZiA9IHBvaW50ZXIgdG8gY3VycmVudCBsb2NhdGlvbiBpbiBidWZmZXIgKi9cbiAgICAgICAgICAgICAgICAvKiBtcDNidWZfc2l6ZSA9IHNpemUgb2Ygb3JpZ2luYWwgbXAzIG91dHB1dCBidWZmZXIgKi9cbiAgICAgICAgICAgICAgICAvKiA9IDAgaWYgd2Ugc2hvdWxkIG5vdCB3b3JyeSBhYm91dCB0aGUgKi9cbiAgICAgICAgICAgICAgICAvKiBidWZmZXIgc2l6ZSBiZWNhdXNlIGNhbGxpbmcgcHJvZ3JhbSBpcyAqL1xuICAgICAgICAgICAgICAgIC8qIHRvIGxhenkgdG8gY29tcHV0ZSBpdCAqL1xuICAgICAgICAgICAgICAgIC8qIG1wM3NpemUgPSBzaXplIG9mIGRhdGEgd3JpdHRlbiB0byBidWZmZXIgc28gZmFyICovXG4gICAgICAgICAgICAgICAgLyogbXAzYnVmX3NpemUtbXAzc2l6ZSA9IGFtb3VudCBvZiBzcGFjZSBhdmFsYWJsZSAqL1xuXG4gICAgICAgICAgICAgICAgdmFyIGJ1Zl9zaXplID0gbXAzYnVmX3NpemUgLSBtcDNzaXplO1xuICAgICAgICAgICAgICAgIGlmIChtcDNidWZfc2l6ZSA9PSAwKVxuICAgICAgICAgICAgICAgICAgICBidWZfc2l6ZSA9IDA7XG5cbiAgICAgICAgICAgICAgICByZXQgPSBsYW1lX2VuY29kZV9mcmFtZShnZnAsIG1mYnVmWzBdLCBtZmJ1ZlsxXSwgbXAzYnVmLFxuICAgICAgICAgICAgICAgICAgICBtcDNidWZQb3MsIGJ1Zl9zaXplKTtcblxuICAgICAgICAgICAgICAgIGlmIChyZXQgPCAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgIG1wM2J1ZlBvcyArPSByZXQ7XG4gICAgICAgICAgICAgICAgbXAzc2l6ZSArPSByZXQ7XG5cbiAgICAgICAgICAgICAgICAvKiBzaGlmdCBvdXQgb2xkIHNhbXBsZXMgKi9cbiAgICAgICAgICAgICAgICBnZmMubWZfc2l6ZSAtPSBnZnAuZnJhbWVzaXplO1xuICAgICAgICAgICAgICAgIGdmYy5tZl9zYW1wbGVzX3RvX2VuY29kZSAtPSBnZnAuZnJhbWVzaXplO1xuICAgICAgICAgICAgICAgIGZvciAoY2ggPSAwOyBjaCA8IGdmYy5jaGFubmVsc19vdXQ7IGNoKyspXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBnZmMubWZfc2l6ZTsgaSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWZidWZbY2hdW2ldID0gbWZidWZbY2hdW2kgKyBnZnAuZnJhbWVzaXplXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQobnNhbXBsZXMgPT0gMCk7XG5cbiAgICAgICAgcmV0dXJuIG1wM3NpemU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGFtZV9lbmNvZGVfZnJhbWUoZ2ZwLCBpbmJ1Zl9sLCBpbmJ1Zl9yLCBtcDNidWYsIG1wM2J1ZlBvcywgbXAzYnVmX3NpemUpIHtcbiAgICAgICAgdmFyIHJldCA9IHNlbGYuZW5jLmxhbWVfZW5jb2RlX21wM19mcmFtZShnZnAsIGluYnVmX2wsIGluYnVmX3IsIG1wM2J1ZixcbiAgICAgICAgICAgIG1wM2J1ZlBvcywgbXAzYnVmX3NpemUpO1xuICAgICAgICBnZnAuZnJhbWVOdW0rKztcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBJbk91dCgpIHtcbiAgICAgICAgdGhpcy5uX2luID0gMDtcbiAgICAgICAgdGhpcy5uX291dCA9IDA7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBOdW1Vc2VkKCkge1xuICAgICAgICB0aGlzLm51bV91c2VkID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHcmVhdGVzdCBjb21tb24gZGl2aXNvci5cbiAgICAgKiA8cD5cbiAgICAgKiBKb2ludCB3b3JrIG9mIEV1Y2xpZCBhbmQgTS4gSGVuZHJ5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2NkKGksIGopIHtcbiAgICAgICAgcmV0dXJuIGogIT0gMCA/IGdjZChqLCBpICUgaikgOiBpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2FtcGxpbmcgdmlhIEZJUiBmaWx0ZXIsIGJsYWNrbWFuIHdpbmRvdy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBibGFja21hbih4LCBmY24sIGwpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogVGhpcyBhbGdvcml0aG0gZnJvbTogU0lHTkFMIFBST0NFU1NJTkcgQUxHT1JJVEhNUyBJTiBGT1JUUkFOIEFORCBDXG4gICAgICAgICAqIFMuRC4gU3RlYXJucyBhbmQgUi5BLiBEYXZpZCwgUHJlbnRpY2UtSGFsbCwgMTk5MlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHdjbiA9IChNYXRoLlBJICogZmNuKTtcblxuICAgICAgICB4IC89IGw7XG4gICAgICAgIGlmICh4IDwgMClcbiAgICAgICAgICAgIHggPSAwO1xuICAgICAgICBpZiAoeCA+IDEpXG4gICAgICAgICAgICB4ID0gMTtcbiAgICAgICAgdmFyIHgyID0geCAtIC41O1xuXG4gICAgICAgIHZhciBia3duID0gMC40MiAtIDAuNSAqIE1hdGguY29zKDIgKiB4ICogTWF0aC5QSSkgKyAwLjA4ICogTWF0aC5jb3MoNCAqIHggKiBNYXRoLlBJKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHgyKSA8IDFlLTkpXG4gICAgICAgICAgICByZXR1cm4gKHdjbiAvIE1hdGguUEkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gKGJrd24gKiBNYXRoLnNpbihsICogd2NuICogeDIpIC8gKE1hdGguUEkgKiBsICogeDIpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaWxsX2J1ZmZlcl9yZXNhbXBsZShnZnAsIG91dGJ1Ziwgb3V0YnVmUG9zLCBkZXNpcmVkX2xlbiwgaW5idWYsIGluX2J1ZmZlclBvcywgbGVuLCBudW1fdXNlZCwgY2gpIHtcbiAgICAgICAgdmFyIGdmYyA9IGdmcC5pbnRlcm5hbF9mbGFncztcbiAgICAgICAgdmFyIGksIGogPSAwLCBrO1xuICAgICAgICAvKiBudW1iZXIgb2YgY29udm9sdXRpb24gZnVuY3Rpb25zIHRvIHByZS1jb21wdXRlICovXG4gICAgICAgIHZhciBicGMgPSBnZnAub3V0X3NhbXBsZXJhdGVcbiAgICAgICAgICAgIC8gZ2NkKGdmcC5vdXRfc2FtcGxlcmF0ZSwgZ2ZwLmluX3NhbXBsZXJhdGUpO1xuICAgICAgICBpZiAoYnBjID4gTGFtZUludGVybmFsRmxhZ3MuQlBDKVxuICAgICAgICAgICAgYnBjID0gTGFtZUludGVybmFsRmxhZ3MuQlBDO1xuXG4gICAgICAgIHZhciBpbnRyYXRpbyA9IChNYXRoLmFicyhnZmMucmVzYW1wbGVfcmF0aW9cbiAgICAgICAgICAgIC0gTWF0aC5mbG9vciguNSArIGdmYy5yZXNhbXBsZV9yYXRpbykpIDwgLjAwMDEpID8gMSA6IDA7XG4gICAgICAgIHZhciBmY24gPSAxLjAwIC8gZ2ZjLnJlc2FtcGxlX3JhdGlvO1xuICAgICAgICBpZiAoZmNuID4gMS4wMClcbiAgICAgICAgICAgIGZjbiA9IDEuMDA7XG4gICAgICAgIHZhciBmaWx0ZXJfbCA9IDMxO1xuICAgICAgICBpZiAoMCA9PSBmaWx0ZXJfbCAlIDIpXG4gICAgICAgICAgICAtLWZpbHRlcl9sO1xuICAgICAgICAvKiBtdXN0IGJlIG9kZCAqL1xuICAgICAgICBmaWx0ZXJfbCArPSBpbnRyYXRpbztcbiAgICAgICAgLyogdW5sZXNzIHJlc2FtcGxlX3JhdGlvPWludCwgaXQgbXVzdCBiZSBldmVuICovXG5cbiAgICAgICAgdmFyIEJMQUNLU0laRSA9IGZpbHRlcl9sICsgMTtcbiAgICAgICAgLyogc2l6ZSBvZiBkYXRhIG5lZWRlZCBmb3IgRklSICovXG5cbiAgICAgICAgaWYgKGdmYy5maWxsX2J1ZmZlcl9yZXNhbXBsZV9pbml0ID09IDApIHtcbiAgICAgICAgICAgIGdmYy5pbmJ1Zl9vbGRbMF0gPSBuZXdfZmxvYXQoQkxBQ0tTSVpFKTtcbiAgICAgICAgICAgIGdmYy5pbmJ1Zl9vbGRbMV0gPSBuZXdfZmxvYXQoQkxBQ0tTSVpFKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPD0gMiAqIGJwYzsgKytpKVxuICAgICAgICAgICAgICAgIGdmYy5ibGFja2ZpbHRbaV0gPSBuZXdfZmxvYXQoQkxBQ0tTSVpFKTtcblxuICAgICAgICAgICAgZ2ZjLml0aW1lWzBdID0gMDtcbiAgICAgICAgICAgIGdmYy5pdGltZVsxXSA9IDA7XG5cbiAgICAgICAgICAgIC8qIHByZWNvbXB1dGUgYmxhY2ttYW4gZmlsdGVyIGNvZWZmaWNpZW50cyAqL1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8PSAyICogYnBjOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3VtID0gMC47XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IChqIC0gYnBjKSAvICgyLiAqIGJwYyk7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8PSBmaWx0ZXJfbDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gZ2ZjLmJsYWNrZmlsdFtqXVtpXSA9IGJsYWNrbWFuKGkgLSBvZmZzZXQsIGZjbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcl9sKTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDw9IGZpbHRlcl9sOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGdmYy5ibGFja2ZpbHRbal1baV0gLz0gc3VtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2ZjLmZpbGxfYnVmZmVyX3Jlc2FtcGxlX2luaXQgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluYnVmX29sZCA9IGdmYy5pbmJ1Zl9vbGRbY2hdO1xuXG4gICAgICAgIC8qIHRpbWUgb2Ygaid0aCBlbGVtZW50IGluIGluYnVmID0gaXRpbWUgKyBqL2lmcmVxOyAqL1xuICAgICAgICAvKiB0aW1lIG9mIGsndGggZWxlbWVudCBpbiBvdXRidWYgPSBqL29mcmVxICovXG4gICAgICAgIGZvciAoayA9IDA7IGsgPCBkZXNpcmVkX2xlbjsgaysrKSB7XG4gICAgICAgICAgICB2YXIgdGltZTA7XG4gICAgICAgICAgICB2YXIgam9mZjtcblxuICAgICAgICAgICAgdGltZTAgPSBrICogZ2ZjLnJlc2FtcGxlX3JhdGlvO1xuICAgICAgICAgICAgLyogdGltZSBvZiBrJ3RoIG91dHB1dCBzYW1wbGUgKi9cbiAgICAgICAgICAgIGogPSAwIHwgTWF0aC5mbG9vcih0aW1lMCAtIGdmYy5pdGltZVtjaF0pO1xuXG4gICAgICAgICAgICAvKiBjaGVjayBpZiB3ZSBuZWVkIG1vcmUgaW5wdXQgZGF0YSAqL1xuICAgICAgICAgICAgaWYgKChmaWx0ZXJfbCArIGogLSBmaWx0ZXJfbCAvIDIpID49IGxlbilcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgLyogYmxhY2ttYW4gZmlsdGVyLiBieSBkZWZhdWx0LCB3aW5kb3cgY2VudGVyZWQgYXQgaisuNShmaWx0ZXJfbCUyKSAqL1xuICAgICAgICAgICAgLyogYnV0IHdlIHdhbnQgYSB3aW5kb3cgY2VudGVyZWQgYXQgdGltZTAuICovXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gKHRpbWUwIC0gZ2ZjLml0aW1lW2NoXSAtIChqICsgLjUgKiAoZmlsdGVyX2wgJSAyKSkpO1xuICAgICAgICAgICAgYXNzZXJ0KE1hdGguYWJzKG9mZnNldCkgPD0gLjUwMSk7XG5cbiAgICAgICAgICAgIC8qIGZpbmQgdGhlIGNsb3Nlc3QgcHJlY29tcHV0ZWQgd2luZG93IGZvciB0aGlzIG9mZnNldDogKi9cbiAgICAgICAgICAgIGpvZmYgPSAwIHwgTWF0aC5mbG9vcigob2Zmc2V0ICogMiAqIGJwYykgKyBicGMgKyAuNSk7XG4gICAgICAgICAgICB2YXIgeHZhbHVlID0gMC47XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDw9IGZpbHRlcl9sOyArK2kpIHtcblx0XHQvKiBmb3JjZSBpbnRlZ2VyIGluZGV4ICovXG4gICAgICAgICAgICAgICAgdmFyIGoyID0gMCB8IChpICsgaiAtIGZpbHRlcl9sIC8gMik7IFxuICAgICAgICAgICAgICAgIHZhciB5O1xuICAgICAgICAgICAgICAgIGFzc2VydChqMiA8IGxlbik7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGoyICsgQkxBQ0tTSVpFID49IDApO1xuICAgICAgICAgICAgICAgIHkgPSAoajIgPCAwKSA/IGluYnVmX29sZFtCTEFDS1NJWkUgKyBqMl0gOiBpbmJ1Zltpbl9idWZmZXJQb3NcbiAgICAgICAgICAgICAgICArIGoyXTtcbiAgICAgICAgICAgICAgICB4dmFsdWUgKz0geSAqIGdmYy5ibGFja2ZpbHRbam9mZl1baV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRidWZbb3V0YnVmUG9zICsga10gPSB4dmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBrID0gbnVtYmVyIG9mIHNhbXBsZXMgYWRkZWQgdG8gb3V0YnVmICovXG4gICAgICAgIC8qIGxhc3QgayBzYW1wbGUgdXNlZCBkYXRhIGZyb20gW2otZmlsdGVyX2wvMixqK2ZpbHRlcl9sLWZpbHRlcl9sLzJdICovXG5cbiAgICAgICAgLyogaG93IG1hbnkgc2FtcGxlcyBvZiBpbnB1dCBkYXRhIHdlcmUgdXNlZDogKi9cbiAgICAgICAgbnVtX3VzZWQubnVtX3VzZWQgPSBNYXRoLm1pbihsZW4sIGZpbHRlcl9sICsgaiAtIGZpbHRlcl9sIC8gMik7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogYWRqdXN0IG91ciBpbnB1dCB0aW1lIGNvdW50ZXIuIEluY3JpbWVudCBieSB0aGUgbnVtYmVyIG9mIHNhbXBsZXNcbiAgICAgICAgICogdXNlZCwgdGhlbiBub3JtYWxpemUgc28gdGhhdCBuZXh0IG91dHB1dCBzYW1wbGUgaXMgYXQgdGltZSAwLCBuZXh0XG4gICAgICAgICAqIGlucHV0IGJ1ZmZlciBpcyBhdCB0aW1lIGl0aW1lW2NoXVxuICAgICAgICAgKi9cbiAgICAgICAgZ2ZjLml0aW1lW2NoXSArPSBudW1fdXNlZC5udW1fdXNlZCAtIGsgKiBnZmMucmVzYW1wbGVfcmF0aW87XG5cbiAgICAgICAgLyogc2F2ZSB0aGUgbGFzdCBCTEFDS1NJWkUgc2FtcGxlcyBpbnRvIHRoZSBpbmJ1Zl9vbGQgYnVmZmVyICovXG4gICAgICAgIGlmIChudW1fdXNlZC5udW1fdXNlZCA+PSBCTEFDS1NJWkUpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBCTEFDS1NJWkU7IGkrKylcbiAgICAgICAgICAgICAgICBpbmJ1Zl9vbGRbaV0gPSBpbmJ1Zltpbl9idWZmZXJQb3MgKyBudW1fdXNlZC5udW1fdXNlZCArIGlcbiAgICAgICAgICAgICAgICAtIEJMQUNLU0laRV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvKiBzaGlmdCBpbiBudW1fdXNlZC5udW1fdXNlZCBzYW1wbGVzIGludG8gaW5idWZfb2xkICovXG4gICAgICAgICAgICB2YXIgbl9zaGlmdCA9IEJMQUNLU0laRSAtIG51bV91c2VkLm51bV91c2VkO1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIG51bWJlciBvZiBzYW1wbGVzIHRvXG4gICAgICAgICAgICAgKiBzaGlmdFxuICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBzaGlmdCBuX3NoaWZ0IHNhbXBsZXMgYnkgbnVtX3VzZWQubnVtX3VzZWQsIHRvIG1ha2Ugcm9vbSBmb3IgdGhlXG4gICAgICAgICAgICAgKiBudW1fdXNlZCBuZXcgc2FtcGxlc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbl9zaGlmdDsgKytpKVxuICAgICAgICAgICAgICAgIGluYnVmX29sZFtpXSA9IGluYnVmX29sZFtpICsgbnVtX3VzZWQubnVtX3VzZWRdO1xuXG4gICAgICAgICAgICAvKiBzaGlmdCBpbiB0aGUgbnVtX3VzZWQubnVtX3VzZWQgc2FtcGxlcyAqL1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaSA8IEJMQUNLU0laRTsgKytpLCArK2opXG4gICAgICAgICAgICAgICAgaW5idWZfb2xkW2ldID0gaW5idWZbaW5fYnVmZmVyUG9zICsgal07XG5cbiAgICAgICAgICAgIGFzc2VydChqID09IG51bV91c2VkLm51bV91c2VkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaztcbiAgICAgICAgLyogcmV0dXJuIHRoZSBudW1iZXIgc2FtcGxlcyBjcmVhdGVkIGF0IHRoZSBuZXcgc2FtcGxlcmF0ZSAqL1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbGxfYnVmZmVyKGdmcCwgbWZidWYsIGluX2J1ZmZlciwgaW5fYnVmZmVyUG9zLCBuc2FtcGxlcywgaW8pIHtcbiAgICAgICAgdmFyIGdmYyA9IGdmcC5pbnRlcm5hbF9mbGFncztcblxuICAgICAgICAvKiBjb3B5IGluIG5ldyBzYW1wbGVzIGludG8gbWZidWYsIHdpdGggcmVzYW1wbGluZyBpZiBuZWNlc3NhcnkgKi9cbiAgICAgICAgaWYgKChnZmMucmVzYW1wbGVfcmF0aW8gPCAuOTk5OSkgfHwgKGdmYy5yZXNhbXBsZV9yYXRpbyA+IDEuMDAwMSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGNoID0gMDsgY2ggPCBnZmMuY2hhbm5lbHNfb3V0OyBjaCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG51bVVzZWQgPSBuZXcgTnVtVXNlZCgpO1xuICAgICAgICAgICAgICAgIGlvLm5fb3V0ID0gZmlsbF9idWZmZXJfcmVzYW1wbGUoZ2ZwLCBtZmJ1ZltjaF0sIGdmYy5tZl9zaXplLFxuICAgICAgICAgICAgICAgICAgICBnZnAuZnJhbWVzaXplLCBpbl9idWZmZXJbY2hdLCBpbl9idWZmZXJQb3MsIG5zYW1wbGVzLFxuICAgICAgICAgICAgICAgICAgICBudW1Vc2VkLCBjaCk7XG4gICAgICAgICAgICAgICAgaW8ubl9pbiA9IG51bVVzZWQubnVtX3VzZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpby5uX291dCA9IE1hdGgubWluKGdmcC5mcmFtZXNpemUsIG5zYW1wbGVzKTtcbiAgICAgICAgICAgIGlvLm5faW4gPSBpby5uX291dDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW8ubl9vdXQ7ICsraSkge1xuICAgICAgICAgICAgICAgIG1mYnVmWzBdW2dmYy5tZl9zaXplICsgaV0gPSBpbl9idWZmZXJbMF1baW5fYnVmZmVyUG9zICsgaV07XG4gICAgICAgICAgICAgICAgaWYgKGdmYy5jaGFubmVsc19vdXQgPT0gMilcbiAgICAgICAgICAgICAgICAgICAgbWZidWZbMV1bZ2ZjLm1mX3NpemUgKyBpXSA9IGluX2J1ZmZlclsxXVtpbl9idWZmZXJQb3MgKyBpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExhbWU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lamejs/src/js/Lame.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lamejs/src/js/LameGlobalFlags.js":
/*!*******************************************************!*\
  !*** ./node_modules/lamejs/src/js/LameGlobalFlags.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var MPEGMode = __webpack_require__(/*! ./MPEGMode.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/MPEGMode.js\");\n\nfunction LameGlobalFlags() {\n\n    this.class_id = 0;\n\n    /* input description */\n\n    /**\n     * number of samples. default=-1\n     */\n    this.num_samples = 0;\n    /**\n     * input number of channels. default=2\n     */\n    this.num_channels = 0;\n    /**\n     * input_samp_rate in Hz. default=44.1 kHz\n     */\n    this.in_samplerate = 0;\n    /**\n     * output_samp_rate. default: LAME picks best value at least not used for\n     * MP3 decoding: Remember 44.1 kHz MP3s and AC97\n     */\n    this.out_samplerate = 0;\n    /**\n     * scale input by this amount before encoding at least not used for MP3\n     * decoding\n     */\n    this.scale = 0.;\n    /**\n     * scale input of channel 0 (left) by this amount before encoding\n     */\n    this.scale_left = 0.;\n    /**\n     * scale input of channel 1 (right) by this amount before encoding\n     */\n    this.scale_right = 0.;\n\n    /* general control params */\n    /**\n     * collect data for a MP3 frame analyzer?\n     */\n    this.analysis = false;\n    /**\n     * add Xing VBR tag?\n     */\n    this.bWriteVbrTag = false;\n\n    /**\n     * use lame/mpglib to convert mp3 to wav\n     */\n    this.decode_only = false;\n    /**\n     * quality setting 0=best, 9=worst default=5\n     */\n    this.quality = 0;\n    /**\n     * see enum default = LAME picks best value\n     */\n    this.mode = MPEGMode.STEREO;\n    /**\n     * force M/S mode. requires mode=1\n     */\n    this.force_ms = false;\n    /**\n     * use free format? default=0\n     */\n    this.free_format = false;\n    /**\n     * find the RG value? default=0\n     */\n    this.findReplayGain = false;\n    /**\n     * decode on the fly? default=0\n     */\n    this.decode_on_the_fly = false;\n    /**\n     * 1 (default) writes ID3 tags, 0 not\n     */\n    this.write_id3tag_automatic = false;\n\n    /*\n     * set either brate>0 or compression_ratio>0, LAME will compute the value of\n     * the variable not set. Default is compression_ratio = 11.025\n     */\n    /**\n     * bitrate\n     */\n    this.brate = 0;\n    /**\n     * sizeof(wav file)/sizeof(mp3 file)\n     */\n    this.compression_ratio = 0.;\n\n    /* frame params */\n    /**\n     * mark as copyright. default=0\n     */\n    this.copyright = 0;\n    /**\n     * mark as original. default=1\n     */\n    this.original = 0;\n    /**\n     * the MP3 'private extension' bit. Meaningless\n     */\n    this.extension = 0;\n    /**\n     * Input PCM is emphased PCM (for instance from one of the rarely emphased\n     * CDs), it is STRONGLY not recommended to use this, because psycho does not\n     * take it into account, and last but not least many decoders don't care\n     * about these bits\n     */\n    this.emphasis = 0;\n    /**\n     * use 2 bytes per frame for a CRC checksum. default=0\n     */\n    this.error_protection = 0;\n    /**\n     * enforce ISO spec as much as possible\n     */\n    this.strict_ISO = false;\n\n    /**\n     * use bit reservoir?\n     */\n    this.disable_reservoir = false;\n\n    /* quantization/noise shaping */\n    this.quant_comp = 0;\n    this.quant_comp_short = 0;\n    this.experimentalY = false;\n    this.experimentalZ = 0;\n    this.exp_nspsytune = 0;\n\n    this.preset = 0;\n\n    /* VBR control */\n    this.VBR = null;\n    /**\n     * Range [0,...,1[\n     */\n    this.VBR_q_frac = 0.;\n    /**\n     * Range [0,...,9]\n     */\n    this.VBR_q = 0;\n    this.VBR_mean_bitrate_kbps = 0;\n    this.VBR_min_bitrate_kbps = 0;\n    this.VBR_max_bitrate_kbps = 0;\n    /**\n     * strictly enforce VBR_min_bitrate normaly, it will be violated for analog\n     * silence\n     */\n    this.VBR_hard_min = 0;\n\n    /* resampling and filtering */\n\n    /**\n     * freq in Hz. 0=lame choses. -1=no filter\n     */\n    this.lowpassfreq = 0;\n    /**\n     * freq in Hz. 0=lame choses. -1=no filter\n     */\n    this.highpassfreq = 0;\n    /**\n     * freq width of filter, in Hz (default=15%)\n     */\n    this.lowpasswidth = 0;\n    /**\n     * freq width of filter, in Hz (default=15%)\n     */\n    this.highpasswidth = 0;\n\n    /*\n     * psycho acoustics and other arguments which you should not change unless\n     * you know what you are doing\n     */\n\n    this.maskingadjust = 0.;\n    this.maskingadjust_short = 0.;\n    /**\n     * only use ATH\n     */\n    this.ATHonly = false;\n    /**\n     * only use ATH for short blocks\n     */\n    this.ATHshort = false;\n    /**\n     * disable ATH\n     */\n    this.noATH = false;\n    /**\n     * select ATH formula\n     */\n    this.ATHtype = 0;\n    /**\n     * change ATH formula 4 shape\n     */\n    this.ATHcurve = 0.;\n    /**\n     * lower ATH by this many db\n     */\n    this.ATHlower = 0.;\n    /**\n     * select ATH auto-adjust scheme\n     */\n    this.athaa_type = 0;\n    /**\n     * select ATH auto-adjust loudness calc\n     */\n    this.athaa_loudapprox = 0;\n    /**\n     * dB, tune active region of auto-level\n     */\n    this.athaa_sensitivity = 0.;\n    this.short_blocks = null;\n    /**\n     * use temporal masking effect\n     */\n    this.useTemporal = false;\n    this.interChRatio = 0.;\n    /**\n     * Naoki's adjustment of Mid/Side maskings\n     */\n    this.msfix = 0.;\n\n    /**\n     * 0 off, 1 on\n     */\n    this.tune = false;\n    /**\n     * used to pass values for debugging and stuff\n     */\n    this.tune_value_a = 0.;\n\n    /************************************************************************/\n    /* internal variables, do not set... */\n    /* provided because they may be of use to calling application */\n    /************************************************************************/\n\n    /**\n     * 0=MPEG-2/2.5 1=MPEG-1\n     */\n    this.version = 0;\n    this.encoder_delay = 0;\n    /**\n     * number of samples of padding appended to input\n     */\n    this.encoder_padding = 0;\n    this.framesize = 0;\n    /**\n     * number of frames encoded\n     */\n    this.frameNum = 0;\n    /**\n     * is this struct owned by calling program or lame?\n     */\n    this.lame_allocated_gfp = 0;\n    /**************************************************************************/\n    /* more internal variables are stored in this structure: */\n    /**************************************************************************/\n    this.internal_flags = null;\n}\n\nmodule.exports = LameGlobalFlags;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL0xhbWVHbG9iYWxGbGFncy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsbUZBQWU7O0FBRXRDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL0xhbWVHbG9iYWxGbGFncy5qcz8xNWI4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBNUEVHTW9kZSA9IHJlcXVpcmUoJy4vTVBFR01vZGUuanMnKTtcblxuZnVuY3Rpb24gTGFtZUdsb2JhbEZsYWdzKCkge1xuXG4gICAgdGhpcy5jbGFzc19pZCA9IDA7XG5cbiAgICAvKiBpbnB1dCBkZXNjcmlwdGlvbiAqL1xuXG4gICAgLyoqXG4gICAgICogbnVtYmVyIG9mIHNhbXBsZXMuIGRlZmF1bHQ9LTFcbiAgICAgKi9cbiAgICB0aGlzLm51bV9zYW1wbGVzID0gMDtcbiAgICAvKipcbiAgICAgKiBpbnB1dCBudW1iZXIgb2YgY2hhbm5lbHMuIGRlZmF1bHQ9MlxuICAgICAqL1xuICAgIHRoaXMubnVtX2NoYW5uZWxzID0gMDtcbiAgICAvKipcbiAgICAgKiBpbnB1dF9zYW1wX3JhdGUgaW4gSHouIGRlZmF1bHQ9NDQuMSBrSHpcbiAgICAgKi9cbiAgICB0aGlzLmluX3NhbXBsZXJhdGUgPSAwO1xuICAgIC8qKlxuICAgICAqIG91dHB1dF9zYW1wX3JhdGUuIGRlZmF1bHQ6IExBTUUgcGlja3MgYmVzdCB2YWx1ZSBhdCBsZWFzdCBub3QgdXNlZCBmb3JcbiAgICAgKiBNUDMgZGVjb2Rpbmc6IFJlbWVtYmVyIDQ0LjEga0h6IE1QM3MgYW5kIEFDOTdcbiAgICAgKi9cbiAgICB0aGlzLm91dF9zYW1wbGVyYXRlID0gMDtcbiAgICAvKipcbiAgICAgKiBzY2FsZSBpbnB1dCBieSB0aGlzIGFtb3VudCBiZWZvcmUgZW5jb2RpbmcgYXQgbGVhc3Qgbm90IHVzZWQgZm9yIE1QM1xuICAgICAqIGRlY29kaW5nXG4gICAgICovXG4gICAgdGhpcy5zY2FsZSA9IDAuO1xuICAgIC8qKlxuICAgICAqIHNjYWxlIGlucHV0IG9mIGNoYW5uZWwgMCAobGVmdCkgYnkgdGhpcyBhbW91bnQgYmVmb3JlIGVuY29kaW5nXG4gICAgICovXG4gICAgdGhpcy5zY2FsZV9sZWZ0ID0gMC47XG4gICAgLyoqXG4gICAgICogc2NhbGUgaW5wdXQgb2YgY2hhbm5lbCAxIChyaWdodCkgYnkgdGhpcyBhbW91bnQgYmVmb3JlIGVuY29kaW5nXG4gICAgICovXG4gICAgdGhpcy5zY2FsZV9yaWdodCA9IDAuO1xuXG4gICAgLyogZ2VuZXJhbCBjb250cm9sIHBhcmFtcyAqL1xuICAgIC8qKlxuICAgICAqIGNvbGxlY3QgZGF0YSBmb3IgYSBNUDMgZnJhbWUgYW5hbHl6ZXI/XG4gICAgICovXG4gICAgdGhpcy5hbmFseXNpcyA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIGFkZCBYaW5nIFZCUiB0YWc/XG4gICAgICovXG4gICAgdGhpcy5iV3JpdGVWYnJUYWcgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIHVzZSBsYW1lL21wZ2xpYiB0byBjb252ZXJ0IG1wMyB0byB3YXZcbiAgICAgKi9cbiAgICB0aGlzLmRlY29kZV9vbmx5ID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogcXVhbGl0eSBzZXR0aW5nIDA9YmVzdCwgOT13b3JzdCBkZWZhdWx0PTVcbiAgICAgKi9cbiAgICB0aGlzLnF1YWxpdHkgPSAwO1xuICAgIC8qKlxuICAgICAqIHNlZSBlbnVtIGRlZmF1bHQgPSBMQU1FIHBpY2tzIGJlc3QgdmFsdWVcbiAgICAgKi9cbiAgICB0aGlzLm1vZGUgPSBNUEVHTW9kZS5TVEVSRU87XG4gICAgLyoqXG4gICAgICogZm9yY2UgTS9TIG1vZGUuIHJlcXVpcmVzIG1vZGU9MVxuICAgICAqL1xuICAgIHRoaXMuZm9yY2VfbXMgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiB1c2UgZnJlZSBmb3JtYXQ/IGRlZmF1bHQ9MFxuICAgICAqL1xuICAgIHRoaXMuZnJlZV9mb3JtYXQgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBmaW5kIHRoZSBSRyB2YWx1ZT8gZGVmYXVsdD0wXG4gICAgICovXG4gICAgdGhpcy5maW5kUmVwbGF5R2FpbiA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIGRlY29kZSBvbiB0aGUgZmx5PyBkZWZhdWx0PTBcbiAgICAgKi9cbiAgICB0aGlzLmRlY29kZV9vbl90aGVfZmx5ID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogMSAoZGVmYXVsdCkgd3JpdGVzIElEMyB0YWdzLCAwIG5vdFxuICAgICAqL1xuICAgIHRoaXMud3JpdGVfaWQzdGFnX2F1dG9tYXRpYyA9IGZhbHNlO1xuXG4gICAgLypcbiAgICAgKiBzZXQgZWl0aGVyIGJyYXRlPjAgb3IgY29tcHJlc3Npb25fcmF0aW8+MCwgTEFNRSB3aWxsIGNvbXB1dGUgdGhlIHZhbHVlIG9mXG4gICAgICogdGhlIHZhcmlhYmxlIG5vdCBzZXQuIERlZmF1bHQgaXMgY29tcHJlc3Npb25fcmF0aW8gPSAxMS4wMjVcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBiaXRyYXRlXG4gICAgICovXG4gICAgdGhpcy5icmF0ZSA9IDA7XG4gICAgLyoqXG4gICAgICogc2l6ZW9mKHdhdiBmaWxlKS9zaXplb2YobXAzIGZpbGUpXG4gICAgICovXG4gICAgdGhpcy5jb21wcmVzc2lvbl9yYXRpbyA9IDAuO1xuXG4gICAgLyogZnJhbWUgcGFyYW1zICovXG4gICAgLyoqXG4gICAgICogbWFyayBhcyBjb3B5cmlnaHQuIGRlZmF1bHQ9MFxuICAgICAqL1xuICAgIHRoaXMuY29weXJpZ2h0ID0gMDtcbiAgICAvKipcbiAgICAgKiBtYXJrIGFzIG9yaWdpbmFsLiBkZWZhdWx0PTFcbiAgICAgKi9cbiAgICB0aGlzLm9yaWdpbmFsID0gMDtcbiAgICAvKipcbiAgICAgKiB0aGUgTVAzICdwcml2YXRlIGV4dGVuc2lvbicgYml0LiBNZWFuaW5nbGVzc1xuICAgICAqL1xuICAgIHRoaXMuZXh0ZW5zaW9uID0gMDtcbiAgICAvKipcbiAgICAgKiBJbnB1dCBQQ00gaXMgZW1waGFzZWQgUENNIChmb3IgaW5zdGFuY2UgZnJvbSBvbmUgb2YgdGhlIHJhcmVseSBlbXBoYXNlZFxuICAgICAqIENEcyksIGl0IGlzIFNUUk9OR0xZIG5vdCByZWNvbW1lbmRlZCB0byB1c2UgdGhpcywgYmVjYXVzZSBwc3ljaG8gZG9lcyBub3RcbiAgICAgKiB0YWtlIGl0IGludG8gYWNjb3VudCwgYW5kIGxhc3QgYnV0IG5vdCBsZWFzdCBtYW55IGRlY29kZXJzIGRvbid0IGNhcmVcbiAgICAgKiBhYm91dCB0aGVzZSBiaXRzXG4gICAgICovXG4gICAgdGhpcy5lbXBoYXNpcyA9IDA7XG4gICAgLyoqXG4gICAgICogdXNlIDIgYnl0ZXMgcGVyIGZyYW1lIGZvciBhIENSQyBjaGVja3N1bS4gZGVmYXVsdD0wXG4gICAgICovXG4gICAgdGhpcy5lcnJvcl9wcm90ZWN0aW9uID0gMDtcbiAgICAvKipcbiAgICAgKiBlbmZvcmNlIElTTyBzcGVjIGFzIG11Y2ggYXMgcG9zc2libGVcbiAgICAgKi9cbiAgICB0aGlzLnN0cmljdF9JU08gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIHVzZSBiaXQgcmVzZXJ2b2lyP1xuICAgICAqL1xuICAgIHRoaXMuZGlzYWJsZV9yZXNlcnZvaXIgPSBmYWxzZTtcblxuICAgIC8qIHF1YW50aXphdGlvbi9ub2lzZSBzaGFwaW5nICovXG4gICAgdGhpcy5xdWFudF9jb21wID0gMDtcbiAgICB0aGlzLnF1YW50X2NvbXBfc2hvcnQgPSAwO1xuICAgIHRoaXMuZXhwZXJpbWVudGFsWSA9IGZhbHNlO1xuICAgIHRoaXMuZXhwZXJpbWVudGFsWiA9IDA7XG4gICAgdGhpcy5leHBfbnNwc3l0dW5lID0gMDtcblxuICAgIHRoaXMucHJlc2V0ID0gMDtcblxuICAgIC8qIFZCUiBjb250cm9sICovXG4gICAgdGhpcy5WQlIgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIFJhbmdlIFswLC4uLiwxW1xuICAgICAqL1xuICAgIHRoaXMuVkJSX3FfZnJhYyA9IDAuO1xuICAgIC8qKlxuICAgICAqIFJhbmdlIFswLC4uLiw5XVxuICAgICAqL1xuICAgIHRoaXMuVkJSX3EgPSAwO1xuICAgIHRoaXMuVkJSX21lYW5fYml0cmF0ZV9rYnBzID0gMDtcbiAgICB0aGlzLlZCUl9taW5fYml0cmF0ZV9rYnBzID0gMDtcbiAgICB0aGlzLlZCUl9tYXhfYml0cmF0ZV9rYnBzID0gMDtcbiAgICAvKipcbiAgICAgKiBzdHJpY3RseSBlbmZvcmNlIFZCUl9taW5fYml0cmF0ZSBub3JtYWx5LCBpdCB3aWxsIGJlIHZpb2xhdGVkIGZvciBhbmFsb2dcbiAgICAgKiBzaWxlbmNlXG4gICAgICovXG4gICAgdGhpcy5WQlJfaGFyZF9taW4gPSAwO1xuXG4gICAgLyogcmVzYW1wbGluZyBhbmQgZmlsdGVyaW5nICovXG5cbiAgICAvKipcbiAgICAgKiBmcmVxIGluIEh6LiAwPWxhbWUgY2hvc2VzLiAtMT1ubyBmaWx0ZXJcbiAgICAgKi9cbiAgICB0aGlzLmxvd3Bhc3NmcmVxID0gMDtcbiAgICAvKipcbiAgICAgKiBmcmVxIGluIEh6LiAwPWxhbWUgY2hvc2VzLiAtMT1ubyBmaWx0ZXJcbiAgICAgKi9cbiAgICB0aGlzLmhpZ2hwYXNzZnJlcSA9IDA7XG4gICAgLyoqXG4gICAgICogZnJlcSB3aWR0aCBvZiBmaWx0ZXIsIGluIEh6IChkZWZhdWx0PTE1JSlcbiAgICAgKi9cbiAgICB0aGlzLmxvd3Bhc3N3aWR0aCA9IDA7XG4gICAgLyoqXG4gICAgICogZnJlcSB3aWR0aCBvZiBmaWx0ZXIsIGluIEh6IChkZWZhdWx0PTE1JSlcbiAgICAgKi9cbiAgICB0aGlzLmhpZ2hwYXNzd2lkdGggPSAwO1xuXG4gICAgLypcbiAgICAgKiBwc3ljaG8gYWNvdXN0aWNzIGFuZCBvdGhlciBhcmd1bWVudHMgd2hpY2ggeW91IHNob3VsZCBub3QgY2hhbmdlIHVubGVzc1xuICAgICAqIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZ1xuICAgICAqL1xuXG4gICAgdGhpcy5tYXNraW5nYWRqdXN0ID0gMC47XG4gICAgdGhpcy5tYXNraW5nYWRqdXN0X3Nob3J0ID0gMC47XG4gICAgLyoqXG4gICAgICogb25seSB1c2UgQVRIXG4gICAgICovXG4gICAgdGhpcy5BVEhvbmx5ID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogb25seSB1c2UgQVRIIGZvciBzaG9ydCBibG9ja3NcbiAgICAgKi9cbiAgICB0aGlzLkFUSHNob3J0ID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogZGlzYWJsZSBBVEhcbiAgICAgKi9cbiAgICB0aGlzLm5vQVRIID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogc2VsZWN0IEFUSCBmb3JtdWxhXG4gICAgICovXG4gICAgdGhpcy5BVEh0eXBlID0gMDtcbiAgICAvKipcbiAgICAgKiBjaGFuZ2UgQVRIIGZvcm11bGEgNCBzaGFwZVxuICAgICAqL1xuICAgIHRoaXMuQVRIY3VydmUgPSAwLjtcbiAgICAvKipcbiAgICAgKiBsb3dlciBBVEggYnkgdGhpcyBtYW55IGRiXG4gICAgICovXG4gICAgdGhpcy5BVEhsb3dlciA9IDAuO1xuICAgIC8qKlxuICAgICAqIHNlbGVjdCBBVEggYXV0by1hZGp1c3Qgc2NoZW1lXG4gICAgICovXG4gICAgdGhpcy5hdGhhYV90eXBlID0gMDtcbiAgICAvKipcbiAgICAgKiBzZWxlY3QgQVRIIGF1dG8tYWRqdXN0IGxvdWRuZXNzIGNhbGNcbiAgICAgKi9cbiAgICB0aGlzLmF0aGFhX2xvdWRhcHByb3ggPSAwO1xuICAgIC8qKlxuICAgICAqIGRCLCB0dW5lIGFjdGl2ZSByZWdpb24gb2YgYXV0by1sZXZlbFxuICAgICAqL1xuICAgIHRoaXMuYXRoYWFfc2Vuc2l0aXZpdHkgPSAwLjtcbiAgICB0aGlzLnNob3J0X2Jsb2NrcyA9IG51bGw7XG4gICAgLyoqXG4gICAgICogdXNlIHRlbXBvcmFsIG1hc2tpbmcgZWZmZWN0XG4gICAgICovXG4gICAgdGhpcy51c2VUZW1wb3JhbCA9IGZhbHNlO1xuICAgIHRoaXMuaW50ZXJDaFJhdGlvID0gMC47XG4gICAgLyoqXG4gICAgICogTmFva2kncyBhZGp1c3RtZW50IG9mIE1pZC9TaWRlIG1hc2tpbmdzXG4gICAgICovXG4gICAgdGhpcy5tc2ZpeCA9IDAuO1xuXG4gICAgLyoqXG4gICAgICogMCBvZmYsIDEgb25cbiAgICAgKi9cbiAgICB0aGlzLnR1bmUgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiB1c2VkIHRvIHBhc3MgdmFsdWVzIGZvciBkZWJ1Z2dpbmcgYW5kIHN0dWZmXG4gICAgICovXG4gICAgdGhpcy50dW5lX3ZhbHVlX2EgPSAwLjtcblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgLyogaW50ZXJuYWwgdmFyaWFibGVzLCBkbyBub3Qgc2V0Li4uICovXG4gICAgLyogcHJvdmlkZWQgYmVjYXVzZSB0aGV5IG1heSBiZSBvZiB1c2UgdG8gY2FsbGluZyBhcHBsaWNhdGlvbiAqL1xuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAvKipcbiAgICAgKiAwPU1QRUctMi8yLjUgMT1NUEVHLTFcbiAgICAgKi9cbiAgICB0aGlzLnZlcnNpb24gPSAwO1xuICAgIHRoaXMuZW5jb2Rlcl9kZWxheSA9IDA7XG4gICAgLyoqXG4gICAgICogbnVtYmVyIG9mIHNhbXBsZXMgb2YgcGFkZGluZyBhcHBlbmRlZCB0byBpbnB1dFxuICAgICAqL1xuICAgIHRoaXMuZW5jb2Rlcl9wYWRkaW5nID0gMDtcbiAgICB0aGlzLmZyYW1lc2l6ZSA9IDA7XG4gICAgLyoqXG4gICAgICogbnVtYmVyIG9mIGZyYW1lcyBlbmNvZGVkXG4gICAgICovXG4gICAgdGhpcy5mcmFtZU51bSA9IDA7XG4gICAgLyoqXG4gICAgICogaXMgdGhpcyBzdHJ1Y3Qgb3duZWQgYnkgY2FsbGluZyBwcm9ncmFtIG9yIGxhbWU/XG4gICAgICovXG4gICAgdGhpcy5sYW1lX2FsbG9jYXRlZF9nZnAgPSAwO1xuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAvKiBtb3JlIGludGVybmFsIHZhcmlhYmxlcyBhcmUgc3RvcmVkIGluIHRoaXMgc3RydWN0dXJlOiAqL1xuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICB0aGlzLmludGVybmFsX2ZsYWdzID0gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMYW1lR2xvYmFsRmxhZ3M7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lamejs/src/js/LameGlobalFlags.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lamejs/src/js/LameInternalFlags.js":
/*!*********************************************************!*\
  !*** ./node_modules/lamejs/src/js/LameInternalFlags.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var common = __webpack_require__(/*! ./common.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/common.js\");\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\nvar IIISideInfo = __webpack_require__(/*! ./IIISideInfo.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/IIISideInfo.js\");\nvar ScaleFac = __webpack_require__(/*! ./ScaleFac.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/ScaleFac.js\");\nvar NsPsy = __webpack_require__(/*! ./NsPsy.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/NsPsy.js\");\nvar VBRSeekInfo = __webpack_require__(/*! ./VBRSeekInfo.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/VBRSeekInfo.js\");\nvar III_psy_xmin = __webpack_require__(/*! ./III_psy_xmin.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/III_psy_xmin.js\");\nvar Encoder = __webpack_require__(/*! ./Encoder.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/Encoder.js\");\nvar L3Side = __webpack_require__(/*! ./L3Side.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/L3Side.js\");\n\n\nLameInternalFlags.MFSIZE = (3 * 1152 + Encoder.ENCDELAY - Encoder.MDCTDELAY);\nLameInternalFlags.MAX_HEADER_BUF = 256;\nLameInternalFlags.MAX_BITS_PER_CHANNEL = 4095;\nLameInternalFlags.MAX_BITS_PER_GRANULE = 7680;\nLameInternalFlags.BPC = 320;\n\nfunction LameInternalFlags() {\n    var MAX_HEADER_LEN = 40;\n\n\n    /********************************************************************\n     * internal variables NOT set by calling program, and should not be *\n     * modified by the calling program *\n     ********************************************************************/\n\n    /**\n     * Some remarks to the Class_ID field: The Class ID is an Identifier for a\n     * pointer to this struct. It is very unlikely that a pointer to\n     * lame_global_flags has the same 32 bits in it's structure (large and other\n     * special properties, for instance prime).\n     *\n     * To test that the structure is right and initialized, use: if ( gfc .\n     * Class_ID == LAME_ID ) ... Other remark: If you set a flag to 0 for uninit\n     * data and 1 for init data, the right test should be \"if (flag == 1)\" and\n     * NOT \"if (flag)\". Unintended modification of this element will be\n     * otherwise misinterpreted as an init.\n     */\n    this.Class_ID = 0;\n\n    this.lame_encode_frame_init = 0;\n    this.iteration_init_init = 0;\n    this.fill_buffer_resample_init = 0;\n\n    //public float mfbuf[][] = new float[2][MFSIZE];\n    this.mfbuf = new_float_n([2, LameInternalFlags.MFSIZE]);\n\n    /**\n     * granules per frame\n     */\n    this.mode_gr = 0;\n    /**\n     * number of channels in the input data stream (PCM or decoded PCM)\n     */\n    this.channels_in = 0;\n    /**\n     * number of channels in the output data stream (not used for decoding)\n     */\n    this.channels_out = 0;\n    /**\n     * input_samp_rate/output_samp_rate\n     */\n        //public double resample_ratio;\n    this.resample_ratio = 0.;\n\n    this.mf_samples_to_encode = 0;\n    this.mf_size = 0;\n    /**\n     * min bitrate index\n     */\n    this.VBR_min_bitrate = 0;\n    /**\n     * max bitrate index\n     */\n    this.VBR_max_bitrate = 0;\n    this.bitrate_index = 0;\n    this.samplerate_index = 0;\n    this.mode_ext = 0;\n\n    /* lowpass and highpass filter control */\n    /**\n     * normalized frequency bounds of passband\n     */\n    this.lowpass1 = 0.;\n    this.lowpass2 = 0.;\n    /**\n     * normalized frequency bounds of passband\n     */\n    this.highpass1 = 0.;\n    this.highpass2 = 0.;\n\n    /**\n     * 0 = none 1 = ISO AAC model 2 = allow scalefac_select=1\n     */\n    this.noise_shaping = 0;\n\n    /**\n     * 0 = ISO model: amplify all distorted bands<BR>\n     * 1 = amplify within 50% of max (on db scale)<BR>\n     * 2 = amplify only most distorted band<BR>\n     * 3 = method 1 and refine with method 2<BR>\n     */\n    this.noise_shaping_amp = 0;\n    /**\n     * 0 = no substep<BR>\n     * 1 = use substep shaping at last step(VBR only)<BR>\n     * (not implemented yet)<BR>\n     * 2 = use substep inside loop<BR>\n     * 3 = use substep inside loop and last step<BR>\n     */\n    this.substep_shaping = 0;\n\n    /**\n     * 1 = gpsycho. 0 = none\n     */\n    this.psymodel = 0;\n    /**\n     * 0 = stop at over=0, all scalefacs amplified or<BR>\n     * a scalefac has reached max value<BR>\n     * 1 = stop when all scalefacs amplified or a scalefac has reached max value<BR>\n     * 2 = stop when all scalefacs amplified\n     */\n    this.noise_shaping_stop = 0;\n\n    /**\n     * 0 = no, 1 = yes\n     */\n    this.subblock_gain = 0;\n    /**\n     * 0 = no. 1=outside loop 2=inside loop(slow)\n     */\n    this.use_best_huffman = 0;\n\n    /**\n     * 0 = stop early after 0 distortion found. 1 = full search\n     */\n    this.full_outer_loop = 0;\n\n    //public IIISideInfo l3_side = new IIISideInfo();\n    this.l3_side = new IIISideInfo();\n    this.ms_ratio = new_float(2);\n\n    /* used for padding */\n    /**\n     * padding for the current frame?\n     */\n    this.padding = 0;\n    this.frac_SpF = 0;\n    this.slot_lag = 0;\n\n    /**\n     * optional ID3 tags\n     */\n        //public ID3TagSpec tag_spec;\n    this.tag_spec = null;\n    this.nMusicCRC = 0;\n\n    /* variables used by Quantize */\n    //public int OldValue[] = new int[2];\n    this.OldValue = new_int(2);\n    //public int CurrentStep[] = new int[2];\n    this.CurrentStep = new_int(2);\n\n    this.masking_lower = 0.;\n    //public int bv_scf[] = new int[576];\n    this.bv_scf = new_int(576);\n    //public int pseudohalf[] = new int[L3Side.SFBMAX];\n    this.pseudohalf = new_int(L3Side.SFBMAX);\n\n    /**\n     * will be set in lame_init_params\n     */\n    this.sfb21_extra = false;\n\n    /* BPC = maximum number of filter convolution windows to precompute */\n    //public float[][] inbuf_old = new float[2][];\n    this.inbuf_old = new Array(2);\n    //public float[][] blackfilt = new float[2 * BPC + 1][];\n    this.blackfilt = new Array(2 * LameInternalFlags.BPC + 1);\n    //public double itime[] = new double[2];\n    this.itime = new_double(2);\n    this.sideinfo_len = 0;\n\n    /* variables for newmdct.c */\n    //public float sb_sample[][][][] = new float[2][2][18][Encoder.SBLIMIT];\n    this.sb_sample = new_float_n([2, 2, 18, Encoder.SBLIMIT]);\n    this.amp_filter = new_float(32);\n\n    /* variables for BitStream */\n\n    /**\n     * <PRE>\n     * mpeg1: buffer=511 bytes  smallest frame: 96-38(sideinfo)=58\n     * max number of frames in reservoir:  8\n     * mpeg2: buffer=255 bytes.  smallest frame: 24-23bytes=1\n     * with VBR, if you are encoding all silence, it is possible to\n     * have 8kbs/24khz frames with 1byte of data each, which means we need\n     * to buffer up to 255 headers!\n     * </PRE>\n     */\n    /**\n     * also, max_header_buf has to be a power of two\n     */\n    /**\n     * max size of header is 38\n     */\n\n    function Header() {\n        this.write_timing = 0;\n        this.ptr = 0;\n        //public byte buf[] = new byte[MAX_HEADER_LEN];\n        this.buf = new_byte(MAX_HEADER_LEN);\n    }\n\n    this.header = new Array(LameInternalFlags.MAX_HEADER_BUF);\n\n    this.h_ptr = 0;\n    this.w_ptr = 0;\n    this.ancillary_flag = 0;\n\n    /* variables for Reservoir */\n    /**\n     * in bits\n     */\n    this.ResvSize = 0;\n    /**\n     * in bits\n     */\n    this.ResvMax = 0;\n\n    //public ScaleFac scalefac_band = new ScaleFac();\n    this.scalefac_band = new ScaleFac();\n\n    /* daa from PsyModel */\n    /* The static variables \"r\", \"phi_sav\", \"new\", \"old\" and \"oldest\" have */\n    /* to be remembered for the unpredictability measure. For \"r\" and */\n    /* \"phi_sav\", the first index from the left is the channel select and */\n    /* the second index is the \"age\" of the data. */\n    this.minval_l = new_float(Encoder.CBANDS);\n    this.minval_s = new_float(Encoder.CBANDS);\n    this.nb_1 = new_float_n([4, Encoder.CBANDS]);\n    this.nb_2 = new_float_n([4, Encoder.CBANDS]);\n    this.nb_s1 = new_float_n([4, Encoder.CBANDS]);\n    this.nb_s2 = new_float_n([4, Encoder.CBANDS]);\n    this.s3_ss = null;\n    this.s3_ll = null;\n    this.decay = 0.;\n\n    //public III_psy_xmin[] thm = new III_psy_xmin[4];\n    //public III_psy_xmin[] en = new III_psy_xmin[4];\n    this.thm = new Array(4);\n    this.en = new Array(4);\n\n    /**\n     * fft and energy calculation\n     */\n    this.tot_ener = new_float(4);\n\n    /* loudness calculation (for adaptive threshold of hearing) */\n    /**\n     * loudness^2 approx. per granule and channel\n     */\n    this.loudness_sq = new_float_n([2, 2]);\n    /**\n     * account for granule delay of L3psycho_anal\n     */\n    this.loudness_sq_save = new_float(2);\n\n    /**\n     * Scale Factor Bands\n     */\n    this.mld_l = new_float(Encoder.SBMAX_l);\n    this.mld_s = new_float(Encoder.SBMAX_s);\n    this.bm_l = new_int(Encoder.SBMAX_l);\n    this.bo_l = new_int(Encoder.SBMAX_l);\n    this.bm_s = new_int(Encoder.SBMAX_s);\n    this.bo_s = new_int(Encoder.SBMAX_s);\n    this.npart_l = 0;\n    this.npart_s = 0;\n\n    this.s3ind = new_int_n([Encoder.CBANDS, 2]);\n    this.s3ind_s = new_int_n([Encoder.CBANDS, 2]);\n\n    this.numlines_s = new_int(Encoder.CBANDS);\n    this.numlines_l = new_int(Encoder.CBANDS);\n    this.rnumlines_l = new_float(Encoder.CBANDS);\n    this.mld_cb_l = new_float(Encoder.CBANDS);\n    this.mld_cb_s = new_float(Encoder.CBANDS);\n    this.numlines_s_num1 = 0;\n    this.numlines_l_num1 = 0;\n\n    /* ratios */\n    this.pe = new_float(4);\n    this.ms_ratio_s_old = 0.;\n    this.ms_ratio_l_old = 0.;\n    this.ms_ener_ratio_old = 0.;\n\n    /**\n     * block type\n     */\n    this.blocktype_old = new_int(2);\n\n    /**\n     * variables used for --nspsytune\n     */\n    this.nsPsy = new NsPsy();\n\n    /**\n     * used for Xing VBR header\n     */\n    this.VBR_seek_table = new VBRSeekInfo();\n\n    /**\n     * all ATH related stuff\n     */\n        //public ATH ATH;\n    this.ATH = null;\n\n    this.PSY = null;\n\n    this.nogap_total = 0;\n    this.nogap_current = 0;\n\n    /* ReplayGain */\n    this.decode_on_the_fly = true;\n    this.findReplayGain = true;\n    this.findPeakSample = true;\n    this.PeakSample = 0.;\n    this.RadioGain = 0;\n    this.AudiophileGain = 0;\n    //public ReplayGain rgdata;\n    this.rgdata = null;\n\n    /**\n     * gain change required for preventing clipping\n     */\n    this.noclipGainChange = 0;\n    /**\n     * user-specified scale factor required for preventing clipping\n     */\n    this.noclipScale = 0.;\n\n    /* simple statistics */\n    this.bitrate_stereoMode_Hist = new_int_n([16, 4 + 1]);\n    /**\n     * norm/start/short/stop/mixed(short)/sum\n     */\n    this.bitrate_blockType_Hist = new_int_n([16, 4 + 1 + 1]);\n\n    //public PlottingData pinfo;\n    //public MPGLib.mpstr_tag hip;\n    this.pinfo = null;\n    this.hip = null;\n\n    this.in_buffer_nsamples = 0;\n    //public float[] in_buffer_0;\n    //public float[] in_buffer_1;\n    this.in_buffer_0 = null;\n    this.in_buffer_1 = null;\n\n    //public IIterationLoop iteration_loop;\n    this.iteration_loop = null;\n\n    for (var i = 0; i < this.en.length; i++) {\n        this.en[i] = new III_psy_xmin();\n    }\n    for (var i = 0; i < this.thm.length; i++) {\n        this.thm[i] = new III_psy_xmin();\n    }\n    for (var i = 0; i < this.header.length; i++) {\n        this.header[i] = new Header();\n    }\n\n}\n\nmodule.exports = LameInternalFlags;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL0xhbWVJbnRlcm5hbEZsYWdzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGFBQWEsbUJBQU8sQ0FBQywrRUFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixtQkFBTyxDQUFDLHlGQUFrQjtBQUM1QyxlQUFlLG1CQUFPLENBQUMsbUZBQWU7QUFDdEMsWUFBWSxtQkFBTyxDQUFDLDZFQUFZO0FBQ2hDLGtCQUFrQixtQkFBTyxDQUFDLHlGQUFrQjtBQUM1QyxtQkFBbUIsbUJBQU8sQ0FBQywyRkFBbUI7QUFDOUMsY0FBYyxtQkFBTyxDQUFDLGlGQUFjO0FBQ3BDLGFBQWEsbUJBQU8sQ0FBQywrRUFBYTs7O0FBR2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTs7QUFFQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbGFtZWpzL3NyYy9qcy9MYW1lSW50ZXJuYWxGbGFncy5qcz81MTk2Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbi5qcycpO1xudmFyIFN5c3RlbSA9IGNvbW1vbi5TeXN0ZW07XG52YXIgVmJyTW9kZSA9IGNvbW1vbi5WYnJNb2RlO1xudmFyIEZsb2F0ID0gY29tbW9uLkZsb2F0O1xudmFyIFNob3J0QmxvY2sgPSBjb21tb24uU2hvcnRCbG9jaztcbnZhciBVdGlsID0gY29tbW9uLlV0aWw7XG52YXIgQXJyYXlzID0gY29tbW9uLkFycmF5cztcbnZhciBuZXdfYXJyYXlfbiA9IGNvbW1vbi5uZXdfYXJyYXlfbjtcbnZhciBuZXdfYnl0ZSA9IGNvbW1vbi5uZXdfYnl0ZTtcbnZhciBuZXdfZG91YmxlID0gY29tbW9uLm5ld19kb3VibGU7XG52YXIgbmV3X2Zsb2F0ID0gY29tbW9uLm5ld19mbG9hdDtcbnZhciBuZXdfZmxvYXRfbiA9IGNvbW1vbi5uZXdfZmxvYXRfbjtcbnZhciBuZXdfaW50ID0gY29tbW9uLm5ld19pbnQ7XG52YXIgbmV3X2ludF9uID0gY29tbW9uLm5ld19pbnRfbjtcbnZhciBhc3NlcnQgPSBjb21tb24uYXNzZXJ0O1xuXG52YXIgSUlJU2lkZUluZm8gPSByZXF1aXJlKCcuL0lJSVNpZGVJbmZvLmpzJyk7XG52YXIgU2NhbGVGYWMgPSByZXF1aXJlKCcuL1NjYWxlRmFjLmpzJyk7XG52YXIgTnNQc3kgPSByZXF1aXJlKCcuL05zUHN5LmpzJyk7XG52YXIgVkJSU2Vla0luZm8gPSByZXF1aXJlKCcuL1ZCUlNlZWtJbmZvLmpzJyk7XG52YXIgSUlJX3BzeV94bWluID0gcmVxdWlyZSgnLi9JSUlfcHN5X3htaW4uanMnKTtcbnZhciBFbmNvZGVyID0gcmVxdWlyZSgnLi9FbmNvZGVyLmpzJyk7XG52YXIgTDNTaWRlID0gcmVxdWlyZSgnLi9MM1NpZGUuanMnKTtcblxuXG5MYW1lSW50ZXJuYWxGbGFncy5NRlNJWkUgPSAoMyAqIDExNTIgKyBFbmNvZGVyLkVOQ0RFTEFZIC0gRW5jb2Rlci5NRENUREVMQVkpO1xuTGFtZUludGVybmFsRmxhZ3MuTUFYX0hFQURFUl9CVUYgPSAyNTY7XG5MYW1lSW50ZXJuYWxGbGFncy5NQVhfQklUU19QRVJfQ0hBTk5FTCA9IDQwOTU7XG5MYW1lSW50ZXJuYWxGbGFncy5NQVhfQklUU19QRVJfR1JBTlVMRSA9IDc2ODA7XG5MYW1lSW50ZXJuYWxGbGFncy5CUEMgPSAzMjA7XG5cbmZ1bmN0aW9uIExhbWVJbnRlcm5hbEZsYWdzKCkge1xuICAgIHZhciBNQVhfSEVBREVSX0xFTiA9IDQwO1xuXG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgKiBpbnRlcm5hbCB2YXJpYWJsZXMgTk9UIHNldCBieSBjYWxsaW5nIHByb2dyYW0sIGFuZCBzaG91bGQgbm90IGJlICpcbiAgICAgKiBtb2RpZmllZCBieSB0aGUgY2FsbGluZyBwcm9ncmFtICpcbiAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAvKipcbiAgICAgKiBTb21lIHJlbWFya3MgdG8gdGhlIENsYXNzX0lEIGZpZWxkOiBUaGUgQ2xhc3MgSUQgaXMgYW4gSWRlbnRpZmllciBmb3IgYVxuICAgICAqIHBvaW50ZXIgdG8gdGhpcyBzdHJ1Y3QuIEl0IGlzIHZlcnkgdW5saWtlbHkgdGhhdCBhIHBvaW50ZXIgdG9cbiAgICAgKiBsYW1lX2dsb2JhbF9mbGFncyBoYXMgdGhlIHNhbWUgMzIgYml0cyBpbiBpdCdzIHN0cnVjdHVyZSAobGFyZ2UgYW5kIG90aGVyXG4gICAgICogc3BlY2lhbCBwcm9wZXJ0aWVzLCBmb3IgaW5zdGFuY2UgcHJpbWUpLlxuICAgICAqXG4gICAgICogVG8gdGVzdCB0aGF0IHRoZSBzdHJ1Y3R1cmUgaXMgcmlnaHQgYW5kIGluaXRpYWxpemVkLCB1c2U6IGlmICggZ2ZjIC5cbiAgICAgKiBDbGFzc19JRCA9PSBMQU1FX0lEICkgLi4uIE90aGVyIHJlbWFyazogSWYgeW91IHNldCBhIGZsYWcgdG8gMCBmb3IgdW5pbml0XG4gICAgICogZGF0YSBhbmQgMSBmb3IgaW5pdCBkYXRhLCB0aGUgcmlnaHQgdGVzdCBzaG91bGQgYmUgXCJpZiAoZmxhZyA9PSAxKVwiIGFuZFxuICAgICAqIE5PVCBcImlmIChmbGFnKVwiLiBVbmludGVuZGVkIG1vZGlmaWNhdGlvbiBvZiB0aGlzIGVsZW1lbnQgd2lsbCBiZVxuICAgICAqIG90aGVyd2lzZSBtaXNpbnRlcnByZXRlZCBhcyBhbiBpbml0LlxuICAgICAqL1xuICAgIHRoaXMuQ2xhc3NfSUQgPSAwO1xuXG4gICAgdGhpcy5sYW1lX2VuY29kZV9mcmFtZV9pbml0ID0gMDtcbiAgICB0aGlzLml0ZXJhdGlvbl9pbml0X2luaXQgPSAwO1xuICAgIHRoaXMuZmlsbF9idWZmZXJfcmVzYW1wbGVfaW5pdCA9IDA7XG5cbiAgICAvL3B1YmxpYyBmbG9hdCBtZmJ1ZltdW10gPSBuZXcgZmxvYXRbMl1bTUZTSVpFXTtcbiAgICB0aGlzLm1mYnVmID0gbmV3X2Zsb2F0X24oWzIsIExhbWVJbnRlcm5hbEZsYWdzLk1GU0laRV0pO1xuXG4gICAgLyoqXG4gICAgICogZ3JhbnVsZXMgcGVyIGZyYW1lXG4gICAgICovXG4gICAgdGhpcy5tb2RlX2dyID0gMDtcbiAgICAvKipcbiAgICAgKiBudW1iZXIgb2YgY2hhbm5lbHMgaW4gdGhlIGlucHV0IGRhdGEgc3RyZWFtIChQQ00gb3IgZGVjb2RlZCBQQ00pXG4gICAgICovXG4gICAgdGhpcy5jaGFubmVsc19pbiA9IDA7XG4gICAgLyoqXG4gICAgICogbnVtYmVyIG9mIGNoYW5uZWxzIGluIHRoZSBvdXRwdXQgZGF0YSBzdHJlYW0gKG5vdCB1c2VkIGZvciBkZWNvZGluZylcbiAgICAgKi9cbiAgICB0aGlzLmNoYW5uZWxzX291dCA9IDA7XG4gICAgLyoqXG4gICAgICogaW5wdXRfc2FtcF9yYXRlL291dHB1dF9zYW1wX3JhdGVcbiAgICAgKi9cbiAgICAgICAgLy9wdWJsaWMgZG91YmxlIHJlc2FtcGxlX3JhdGlvO1xuICAgIHRoaXMucmVzYW1wbGVfcmF0aW8gPSAwLjtcblxuICAgIHRoaXMubWZfc2FtcGxlc190b19lbmNvZGUgPSAwO1xuICAgIHRoaXMubWZfc2l6ZSA9IDA7XG4gICAgLyoqXG4gICAgICogbWluIGJpdHJhdGUgaW5kZXhcbiAgICAgKi9cbiAgICB0aGlzLlZCUl9taW5fYml0cmF0ZSA9IDA7XG4gICAgLyoqXG4gICAgICogbWF4IGJpdHJhdGUgaW5kZXhcbiAgICAgKi9cbiAgICB0aGlzLlZCUl9tYXhfYml0cmF0ZSA9IDA7XG4gICAgdGhpcy5iaXRyYXRlX2luZGV4ID0gMDtcbiAgICB0aGlzLnNhbXBsZXJhdGVfaW5kZXggPSAwO1xuICAgIHRoaXMubW9kZV9leHQgPSAwO1xuXG4gICAgLyogbG93cGFzcyBhbmQgaGlnaHBhc3MgZmlsdGVyIGNvbnRyb2wgKi9cbiAgICAvKipcbiAgICAgKiBub3JtYWxpemVkIGZyZXF1ZW5jeSBib3VuZHMgb2YgcGFzc2JhbmRcbiAgICAgKi9cbiAgICB0aGlzLmxvd3Bhc3MxID0gMC47XG4gICAgdGhpcy5sb3dwYXNzMiA9IDAuO1xuICAgIC8qKlxuICAgICAqIG5vcm1hbGl6ZWQgZnJlcXVlbmN5IGJvdW5kcyBvZiBwYXNzYmFuZFxuICAgICAqL1xuICAgIHRoaXMuaGlnaHBhc3MxID0gMC47XG4gICAgdGhpcy5oaWdocGFzczIgPSAwLjtcblxuICAgIC8qKlxuICAgICAqIDAgPSBub25lIDEgPSBJU08gQUFDIG1vZGVsIDIgPSBhbGxvdyBzY2FsZWZhY19zZWxlY3Q9MVxuICAgICAqL1xuICAgIHRoaXMubm9pc2Vfc2hhcGluZyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiAwID0gSVNPIG1vZGVsOiBhbXBsaWZ5IGFsbCBkaXN0b3J0ZWQgYmFuZHM8QlI+XG4gICAgICogMSA9IGFtcGxpZnkgd2l0aGluIDUwJSBvZiBtYXggKG9uIGRiIHNjYWxlKTxCUj5cbiAgICAgKiAyID0gYW1wbGlmeSBvbmx5IG1vc3QgZGlzdG9ydGVkIGJhbmQ8QlI+XG4gICAgICogMyA9IG1ldGhvZCAxIGFuZCByZWZpbmUgd2l0aCBtZXRob2QgMjxCUj5cbiAgICAgKi9cbiAgICB0aGlzLm5vaXNlX3NoYXBpbmdfYW1wID0gMDtcbiAgICAvKipcbiAgICAgKiAwID0gbm8gc3Vic3RlcDxCUj5cbiAgICAgKiAxID0gdXNlIHN1YnN0ZXAgc2hhcGluZyBhdCBsYXN0IHN0ZXAoVkJSIG9ubHkpPEJSPlxuICAgICAqIChub3QgaW1wbGVtZW50ZWQgeWV0KTxCUj5cbiAgICAgKiAyID0gdXNlIHN1YnN0ZXAgaW5zaWRlIGxvb3A8QlI+XG4gICAgICogMyA9IHVzZSBzdWJzdGVwIGluc2lkZSBsb29wIGFuZCBsYXN0IHN0ZXA8QlI+XG4gICAgICovXG4gICAgdGhpcy5zdWJzdGVwX3NoYXBpbmcgPSAwO1xuXG4gICAgLyoqXG4gICAgICogMSA9IGdwc3ljaG8uIDAgPSBub25lXG4gICAgICovXG4gICAgdGhpcy5wc3ltb2RlbCA9IDA7XG4gICAgLyoqXG4gICAgICogMCA9IHN0b3AgYXQgb3Zlcj0wLCBhbGwgc2NhbGVmYWNzIGFtcGxpZmllZCBvcjxCUj5cbiAgICAgKiBhIHNjYWxlZmFjIGhhcyByZWFjaGVkIG1heCB2YWx1ZTxCUj5cbiAgICAgKiAxID0gc3RvcCB3aGVuIGFsbCBzY2FsZWZhY3MgYW1wbGlmaWVkIG9yIGEgc2NhbGVmYWMgaGFzIHJlYWNoZWQgbWF4IHZhbHVlPEJSPlxuICAgICAqIDIgPSBzdG9wIHdoZW4gYWxsIHNjYWxlZmFjcyBhbXBsaWZpZWRcbiAgICAgKi9cbiAgICB0aGlzLm5vaXNlX3NoYXBpbmdfc3RvcCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiAwID0gbm8sIDEgPSB5ZXNcbiAgICAgKi9cbiAgICB0aGlzLnN1YmJsb2NrX2dhaW4gPSAwO1xuICAgIC8qKlxuICAgICAqIDAgPSBuby4gMT1vdXRzaWRlIGxvb3AgMj1pbnNpZGUgbG9vcChzbG93KVxuICAgICAqL1xuICAgIHRoaXMudXNlX2Jlc3RfaHVmZm1hbiA9IDA7XG5cbiAgICAvKipcbiAgICAgKiAwID0gc3RvcCBlYXJseSBhZnRlciAwIGRpc3RvcnRpb24gZm91bmQuIDEgPSBmdWxsIHNlYXJjaFxuICAgICAqL1xuICAgIHRoaXMuZnVsbF9vdXRlcl9sb29wID0gMDtcblxuICAgIC8vcHVibGljIElJSVNpZGVJbmZvIGwzX3NpZGUgPSBuZXcgSUlJU2lkZUluZm8oKTtcbiAgICB0aGlzLmwzX3NpZGUgPSBuZXcgSUlJU2lkZUluZm8oKTtcbiAgICB0aGlzLm1zX3JhdGlvID0gbmV3X2Zsb2F0KDIpO1xuXG4gICAgLyogdXNlZCBmb3IgcGFkZGluZyAqL1xuICAgIC8qKlxuICAgICAqIHBhZGRpbmcgZm9yIHRoZSBjdXJyZW50IGZyYW1lP1xuICAgICAqL1xuICAgIHRoaXMucGFkZGluZyA9IDA7XG4gICAgdGhpcy5mcmFjX1NwRiA9IDA7XG4gICAgdGhpcy5zbG90X2xhZyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBvcHRpb25hbCBJRDMgdGFnc1xuICAgICAqL1xuICAgICAgICAvL3B1YmxpYyBJRDNUYWdTcGVjIHRhZ19zcGVjO1xuICAgIHRoaXMudGFnX3NwZWMgPSBudWxsO1xuICAgIHRoaXMubk11c2ljQ1JDID0gMDtcblxuICAgIC8qIHZhcmlhYmxlcyB1c2VkIGJ5IFF1YW50aXplICovXG4gICAgLy9wdWJsaWMgaW50IE9sZFZhbHVlW10gPSBuZXcgaW50WzJdO1xuICAgIHRoaXMuT2xkVmFsdWUgPSBuZXdfaW50KDIpO1xuICAgIC8vcHVibGljIGludCBDdXJyZW50U3RlcFtdID0gbmV3IGludFsyXTtcbiAgICB0aGlzLkN1cnJlbnRTdGVwID0gbmV3X2ludCgyKTtcblxuICAgIHRoaXMubWFza2luZ19sb3dlciA9IDAuO1xuICAgIC8vcHVibGljIGludCBidl9zY2ZbXSA9IG5ldyBpbnRbNTc2XTtcbiAgICB0aGlzLmJ2X3NjZiA9IG5ld19pbnQoNTc2KTtcbiAgICAvL3B1YmxpYyBpbnQgcHNldWRvaGFsZltdID0gbmV3IGludFtMM1NpZGUuU0ZCTUFYXTtcbiAgICB0aGlzLnBzZXVkb2hhbGYgPSBuZXdfaW50KEwzU2lkZS5TRkJNQVgpO1xuXG4gICAgLyoqXG4gICAgICogd2lsbCBiZSBzZXQgaW4gbGFtZV9pbml0X3BhcmFtc1xuICAgICAqL1xuICAgIHRoaXMuc2ZiMjFfZXh0cmEgPSBmYWxzZTtcblxuICAgIC8qIEJQQyA9IG1heGltdW0gbnVtYmVyIG9mIGZpbHRlciBjb252b2x1dGlvbiB3aW5kb3dzIHRvIHByZWNvbXB1dGUgKi9cbiAgICAvL3B1YmxpYyBmbG9hdFtdW10gaW5idWZfb2xkID0gbmV3IGZsb2F0WzJdW107XG4gICAgdGhpcy5pbmJ1Zl9vbGQgPSBuZXcgQXJyYXkoMik7XG4gICAgLy9wdWJsaWMgZmxvYXRbXVtdIGJsYWNrZmlsdCA9IG5ldyBmbG9hdFsyICogQlBDICsgMV1bXTtcbiAgICB0aGlzLmJsYWNrZmlsdCA9IG5ldyBBcnJheSgyICogTGFtZUludGVybmFsRmxhZ3MuQlBDICsgMSk7XG4gICAgLy9wdWJsaWMgZG91YmxlIGl0aW1lW10gPSBuZXcgZG91YmxlWzJdO1xuICAgIHRoaXMuaXRpbWUgPSBuZXdfZG91YmxlKDIpO1xuICAgIHRoaXMuc2lkZWluZm9fbGVuID0gMDtcblxuICAgIC8qIHZhcmlhYmxlcyBmb3IgbmV3bWRjdC5jICovXG4gICAgLy9wdWJsaWMgZmxvYXQgc2Jfc2FtcGxlW11bXVtdW10gPSBuZXcgZmxvYXRbMl1bMl1bMThdW0VuY29kZXIuU0JMSU1JVF07XG4gICAgdGhpcy5zYl9zYW1wbGUgPSBuZXdfZmxvYXRfbihbMiwgMiwgMTgsIEVuY29kZXIuU0JMSU1JVF0pO1xuICAgIHRoaXMuYW1wX2ZpbHRlciA9IG5ld19mbG9hdCgzMik7XG5cbiAgICAvKiB2YXJpYWJsZXMgZm9yIEJpdFN0cmVhbSAqL1xuXG4gICAgLyoqXG4gICAgICogPFBSRT5cbiAgICAgKiBtcGVnMTogYnVmZmVyPTUxMSBieXRlcyAgc21hbGxlc3QgZnJhbWU6IDk2LTM4KHNpZGVpbmZvKT01OFxuICAgICAqIG1heCBudW1iZXIgb2YgZnJhbWVzIGluIHJlc2Vydm9pcjogIDhcbiAgICAgKiBtcGVnMjogYnVmZmVyPTI1NSBieXRlcy4gIHNtYWxsZXN0IGZyYW1lOiAyNC0yM2J5dGVzPTFcbiAgICAgKiB3aXRoIFZCUiwgaWYgeW91IGFyZSBlbmNvZGluZyBhbGwgc2lsZW5jZSwgaXQgaXMgcG9zc2libGUgdG9cbiAgICAgKiBoYXZlIDhrYnMvMjRraHogZnJhbWVzIHdpdGggMWJ5dGUgb2YgZGF0YSBlYWNoLCB3aGljaCBtZWFucyB3ZSBuZWVkXG4gICAgICogdG8gYnVmZmVyIHVwIHRvIDI1NSBoZWFkZXJzIVxuICAgICAqIDwvUFJFPlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIGFsc28sIG1heF9oZWFkZXJfYnVmIGhhcyB0byBiZSBhIHBvd2VyIG9mIHR3b1xuICAgICAqL1xuICAgIC8qKlxuICAgICAqIG1heCBzaXplIG9mIGhlYWRlciBpcyAzOFxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gSGVhZGVyKCkge1xuICAgICAgICB0aGlzLndyaXRlX3RpbWluZyA9IDA7XG4gICAgICAgIHRoaXMucHRyID0gMDtcbiAgICAgICAgLy9wdWJsaWMgYnl0ZSBidWZbXSA9IG5ldyBieXRlW01BWF9IRUFERVJfTEVOXTtcbiAgICAgICAgdGhpcy5idWYgPSBuZXdfYnl0ZShNQVhfSEVBREVSX0xFTik7XG4gICAgfVxuXG4gICAgdGhpcy5oZWFkZXIgPSBuZXcgQXJyYXkoTGFtZUludGVybmFsRmxhZ3MuTUFYX0hFQURFUl9CVUYpO1xuXG4gICAgdGhpcy5oX3B0ciA9IDA7XG4gICAgdGhpcy53X3B0ciA9IDA7XG4gICAgdGhpcy5hbmNpbGxhcnlfZmxhZyA9IDA7XG5cbiAgICAvKiB2YXJpYWJsZXMgZm9yIFJlc2Vydm9pciAqL1xuICAgIC8qKlxuICAgICAqIGluIGJpdHNcbiAgICAgKi9cbiAgICB0aGlzLlJlc3ZTaXplID0gMDtcbiAgICAvKipcbiAgICAgKiBpbiBiaXRzXG4gICAgICovXG4gICAgdGhpcy5SZXN2TWF4ID0gMDtcblxuICAgIC8vcHVibGljIFNjYWxlRmFjIHNjYWxlZmFjX2JhbmQgPSBuZXcgU2NhbGVGYWMoKTtcbiAgICB0aGlzLnNjYWxlZmFjX2JhbmQgPSBuZXcgU2NhbGVGYWMoKTtcblxuICAgIC8qIGRhYSBmcm9tIFBzeU1vZGVsICovXG4gICAgLyogVGhlIHN0YXRpYyB2YXJpYWJsZXMgXCJyXCIsIFwicGhpX3NhdlwiLCBcIm5ld1wiLCBcIm9sZFwiIGFuZCBcIm9sZGVzdFwiIGhhdmUgKi9cbiAgICAvKiB0byBiZSByZW1lbWJlcmVkIGZvciB0aGUgdW5wcmVkaWN0YWJpbGl0eSBtZWFzdXJlLiBGb3IgXCJyXCIgYW5kICovXG4gICAgLyogXCJwaGlfc2F2XCIsIHRoZSBmaXJzdCBpbmRleCBmcm9tIHRoZSBsZWZ0IGlzIHRoZSBjaGFubmVsIHNlbGVjdCBhbmQgKi9cbiAgICAvKiB0aGUgc2Vjb25kIGluZGV4IGlzIHRoZSBcImFnZVwiIG9mIHRoZSBkYXRhLiAqL1xuICAgIHRoaXMubWludmFsX2wgPSBuZXdfZmxvYXQoRW5jb2Rlci5DQkFORFMpO1xuICAgIHRoaXMubWludmFsX3MgPSBuZXdfZmxvYXQoRW5jb2Rlci5DQkFORFMpO1xuICAgIHRoaXMubmJfMSA9IG5ld19mbG9hdF9uKFs0LCBFbmNvZGVyLkNCQU5EU10pO1xuICAgIHRoaXMubmJfMiA9IG5ld19mbG9hdF9uKFs0LCBFbmNvZGVyLkNCQU5EU10pO1xuICAgIHRoaXMubmJfczEgPSBuZXdfZmxvYXRfbihbNCwgRW5jb2Rlci5DQkFORFNdKTtcbiAgICB0aGlzLm5iX3MyID0gbmV3X2Zsb2F0X24oWzQsIEVuY29kZXIuQ0JBTkRTXSk7XG4gICAgdGhpcy5zM19zcyA9IG51bGw7XG4gICAgdGhpcy5zM19sbCA9IG51bGw7XG4gICAgdGhpcy5kZWNheSA9IDAuO1xuXG4gICAgLy9wdWJsaWMgSUlJX3BzeV94bWluW10gdGhtID0gbmV3IElJSV9wc3lfeG1pbls0XTtcbiAgICAvL3B1YmxpYyBJSUlfcHN5X3htaW5bXSBlbiA9IG5ldyBJSUlfcHN5X3htaW5bNF07XG4gICAgdGhpcy50aG0gPSBuZXcgQXJyYXkoNCk7XG4gICAgdGhpcy5lbiA9IG5ldyBBcnJheSg0KTtcblxuICAgIC8qKlxuICAgICAqIGZmdCBhbmQgZW5lcmd5IGNhbGN1bGF0aW9uXG4gICAgICovXG4gICAgdGhpcy50b3RfZW5lciA9IG5ld19mbG9hdCg0KTtcblxuICAgIC8qIGxvdWRuZXNzIGNhbGN1bGF0aW9uIChmb3IgYWRhcHRpdmUgdGhyZXNob2xkIG9mIGhlYXJpbmcpICovXG4gICAgLyoqXG4gICAgICogbG91ZG5lc3NeMiBhcHByb3guIHBlciBncmFudWxlIGFuZCBjaGFubmVsXG4gICAgICovXG4gICAgdGhpcy5sb3VkbmVzc19zcSA9IG5ld19mbG9hdF9uKFsyLCAyXSk7XG4gICAgLyoqXG4gICAgICogYWNjb3VudCBmb3IgZ3JhbnVsZSBkZWxheSBvZiBMM3BzeWNob19hbmFsXG4gICAgICovXG4gICAgdGhpcy5sb3VkbmVzc19zcV9zYXZlID0gbmV3X2Zsb2F0KDIpO1xuXG4gICAgLyoqXG4gICAgICogU2NhbGUgRmFjdG9yIEJhbmRzXG4gICAgICovXG4gICAgdGhpcy5tbGRfbCA9IG5ld19mbG9hdChFbmNvZGVyLlNCTUFYX2wpO1xuICAgIHRoaXMubWxkX3MgPSBuZXdfZmxvYXQoRW5jb2Rlci5TQk1BWF9zKTtcbiAgICB0aGlzLmJtX2wgPSBuZXdfaW50KEVuY29kZXIuU0JNQVhfbCk7XG4gICAgdGhpcy5ib19sID0gbmV3X2ludChFbmNvZGVyLlNCTUFYX2wpO1xuICAgIHRoaXMuYm1fcyA9IG5ld19pbnQoRW5jb2Rlci5TQk1BWF9zKTtcbiAgICB0aGlzLmJvX3MgPSBuZXdfaW50KEVuY29kZXIuU0JNQVhfcyk7XG4gICAgdGhpcy5ucGFydF9sID0gMDtcbiAgICB0aGlzLm5wYXJ0X3MgPSAwO1xuXG4gICAgdGhpcy5zM2luZCA9IG5ld19pbnRfbihbRW5jb2Rlci5DQkFORFMsIDJdKTtcbiAgICB0aGlzLnMzaW5kX3MgPSBuZXdfaW50X24oW0VuY29kZXIuQ0JBTkRTLCAyXSk7XG5cbiAgICB0aGlzLm51bWxpbmVzX3MgPSBuZXdfaW50KEVuY29kZXIuQ0JBTkRTKTtcbiAgICB0aGlzLm51bWxpbmVzX2wgPSBuZXdfaW50KEVuY29kZXIuQ0JBTkRTKTtcbiAgICB0aGlzLnJudW1saW5lc19sID0gbmV3X2Zsb2F0KEVuY29kZXIuQ0JBTkRTKTtcbiAgICB0aGlzLm1sZF9jYl9sID0gbmV3X2Zsb2F0KEVuY29kZXIuQ0JBTkRTKTtcbiAgICB0aGlzLm1sZF9jYl9zID0gbmV3X2Zsb2F0KEVuY29kZXIuQ0JBTkRTKTtcbiAgICB0aGlzLm51bWxpbmVzX3NfbnVtMSA9IDA7XG4gICAgdGhpcy5udW1saW5lc19sX251bTEgPSAwO1xuXG4gICAgLyogcmF0aW9zICovXG4gICAgdGhpcy5wZSA9IG5ld19mbG9hdCg0KTtcbiAgICB0aGlzLm1zX3JhdGlvX3Nfb2xkID0gMC47XG4gICAgdGhpcy5tc19yYXRpb19sX29sZCA9IDAuO1xuICAgIHRoaXMubXNfZW5lcl9yYXRpb19vbGQgPSAwLjtcblxuICAgIC8qKlxuICAgICAqIGJsb2NrIHR5cGVcbiAgICAgKi9cbiAgICB0aGlzLmJsb2NrdHlwZV9vbGQgPSBuZXdfaW50KDIpO1xuXG4gICAgLyoqXG4gICAgICogdmFyaWFibGVzIHVzZWQgZm9yIC0tbnNwc3l0dW5lXG4gICAgICovXG4gICAgdGhpcy5uc1BzeSA9IG5ldyBOc1BzeSgpO1xuXG4gICAgLyoqXG4gICAgICogdXNlZCBmb3IgWGluZyBWQlIgaGVhZGVyXG4gICAgICovXG4gICAgdGhpcy5WQlJfc2Vla190YWJsZSA9IG5ldyBWQlJTZWVrSW5mbygpO1xuXG4gICAgLyoqXG4gICAgICogYWxsIEFUSCByZWxhdGVkIHN0dWZmXG4gICAgICovXG4gICAgICAgIC8vcHVibGljIEFUSCBBVEg7XG4gICAgdGhpcy5BVEggPSBudWxsO1xuXG4gICAgdGhpcy5QU1kgPSBudWxsO1xuXG4gICAgdGhpcy5ub2dhcF90b3RhbCA9IDA7XG4gICAgdGhpcy5ub2dhcF9jdXJyZW50ID0gMDtcblxuICAgIC8qIFJlcGxheUdhaW4gKi9cbiAgICB0aGlzLmRlY29kZV9vbl90aGVfZmx5ID0gdHJ1ZTtcbiAgICB0aGlzLmZpbmRSZXBsYXlHYWluID0gdHJ1ZTtcbiAgICB0aGlzLmZpbmRQZWFrU2FtcGxlID0gdHJ1ZTtcbiAgICB0aGlzLlBlYWtTYW1wbGUgPSAwLjtcbiAgICB0aGlzLlJhZGlvR2FpbiA9IDA7XG4gICAgdGhpcy5BdWRpb3BoaWxlR2FpbiA9IDA7XG4gICAgLy9wdWJsaWMgUmVwbGF5R2FpbiByZ2RhdGE7XG4gICAgdGhpcy5yZ2RhdGEgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogZ2FpbiBjaGFuZ2UgcmVxdWlyZWQgZm9yIHByZXZlbnRpbmcgY2xpcHBpbmdcbiAgICAgKi9cbiAgICB0aGlzLm5vY2xpcEdhaW5DaGFuZ2UgPSAwO1xuICAgIC8qKlxuICAgICAqIHVzZXItc3BlY2lmaWVkIHNjYWxlIGZhY3RvciByZXF1aXJlZCBmb3IgcHJldmVudGluZyBjbGlwcGluZ1xuICAgICAqL1xuICAgIHRoaXMubm9jbGlwU2NhbGUgPSAwLjtcblxuICAgIC8qIHNpbXBsZSBzdGF0aXN0aWNzICovXG4gICAgdGhpcy5iaXRyYXRlX3N0ZXJlb01vZGVfSGlzdCA9IG5ld19pbnRfbihbMTYsIDQgKyAxXSk7XG4gICAgLyoqXG4gICAgICogbm9ybS9zdGFydC9zaG9ydC9zdG9wL21peGVkKHNob3J0KS9zdW1cbiAgICAgKi9cbiAgICB0aGlzLmJpdHJhdGVfYmxvY2tUeXBlX0hpc3QgPSBuZXdfaW50X24oWzE2LCA0ICsgMSArIDFdKTtcblxuICAgIC8vcHVibGljIFBsb3R0aW5nRGF0YSBwaW5mbztcbiAgICAvL3B1YmxpYyBNUEdMaWIubXBzdHJfdGFnIGhpcDtcbiAgICB0aGlzLnBpbmZvID0gbnVsbDtcbiAgICB0aGlzLmhpcCA9IG51bGw7XG5cbiAgICB0aGlzLmluX2J1ZmZlcl9uc2FtcGxlcyA9IDA7XG4gICAgLy9wdWJsaWMgZmxvYXRbXSBpbl9idWZmZXJfMDtcbiAgICAvL3B1YmxpYyBmbG9hdFtdIGluX2J1ZmZlcl8xO1xuICAgIHRoaXMuaW5fYnVmZmVyXzAgPSBudWxsO1xuICAgIHRoaXMuaW5fYnVmZmVyXzEgPSBudWxsO1xuXG4gICAgLy9wdWJsaWMgSUl0ZXJhdGlvbkxvb3AgaXRlcmF0aW9uX2xvb3A7XG4gICAgdGhpcy5pdGVyYXRpb25fbG9vcCA9IG51bGw7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5lbltpXSA9IG5ldyBJSUlfcHN5X3htaW4oKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRobS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnRobVtpXSA9IG5ldyBJSUlfcHN5X3htaW4oKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmhlYWRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmhlYWRlcltpXSA9IG5ldyBIZWFkZXIoKTtcbiAgICB9XG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMYW1lSW50ZXJuYWxGbGFncztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lamejs/src/js/LameInternalFlags.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lamejs/src/js/MPEGMode.js":
/*!************************************************!*\
  !*** ./node_modules/lamejs/src/js/MPEGMode.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("//package mp3;\n\n/* MPEG modes */\nfunction MPEGMode(ordinal) {\n    var _ordinal = ordinal;\n    this.ordinal = function () {\n        return _ordinal;\n    }\n}\n\nMPEGMode.STEREO = new MPEGMode(0);\nMPEGMode.JOINT_STEREO = new MPEGMode(1);\nMPEGMode.DUAL_CHANNEL = new MPEGMode(2);\nMPEGMode.MONO = new MPEGMode(3);\nMPEGMode.NOT_SET = new MPEGMode(4);\n\nmodule.exports = MPEGMode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL01QRUdNb2RlLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xhbWVqcy9zcmMvanMvTVBFR01vZGUuanM/MzEzNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvL3BhY2thZ2UgbXAzO1xuXG4vKiBNUEVHIG1vZGVzICovXG5mdW5jdGlvbiBNUEVHTW9kZShvcmRpbmFsKSB7XG4gICAgdmFyIF9vcmRpbmFsID0gb3JkaW5hbDtcbiAgICB0aGlzLm9yZGluYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfb3JkaW5hbDtcbiAgICB9XG59XG5cbk1QRUdNb2RlLlNURVJFTyA9IG5ldyBNUEVHTW9kZSgwKTtcbk1QRUdNb2RlLkpPSU5UX1NURVJFTyA9IG5ldyBNUEVHTW9kZSgxKTtcbk1QRUdNb2RlLkRVQUxfQ0hBTk5FTCA9IG5ldyBNUEVHTW9kZSgyKTtcbk1QRUdNb2RlLk1PTk8gPSBuZXcgTVBFR01vZGUoMyk7XG5NUEVHTW9kZS5OT1RfU0VUID0gbmV3IE1QRUdNb2RlKDQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1QRUdNb2RlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lamejs/src/js/MPEGMode.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lamejs/src/js/MeanBits.js":
/*!************************************************!*\
  !*** ./node_modules/lamejs/src/js/MeanBits.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function MeanBits(meanBits) {\n    this.bits = meanBits;\n}\n\nmodule.exports = MeanBits;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL01lYW5CaXRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbGFtZWpzL3NyYy9qcy9NZWFuQml0cy5qcz8zZmRhIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIE1lYW5CaXRzKG1lYW5CaXRzKSB7XG4gICAgdGhpcy5iaXRzID0gbWVhbkJpdHM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTWVhbkJpdHM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lamejs/src/js/MeanBits.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lamejs/src/js/NewMDCT.js":
/*!***********************************************!*\
  !*** ./node_modules/lamejs/src/js/NewMDCT.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/*\n *      MP3 window subband -> subband filtering -> mdct routine\n *\n *      Copyright (c) 1999-2000 Takehiro Tominaga\n *\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Library General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */\n/*\n *         Special Thanks to Patrick De Smet for your advices.\n */\n\n/* $Id: NewMDCT.java,v 1.11 2011/05/24 20:48:06 kenchis Exp $ */\n\n//package mp3;\n\n//import java.util.Arrays;\nvar common = __webpack_require__(/*! ./common.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/common.js\");\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\nvar Encoder = __webpack_require__(/*! ./Encoder.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/Encoder.js\");\n\n\nfunction NewMDCT() {\n\n\tvar enwindow = [\n\t\t\t-4.77e-07 * 0.740951125354959 / 2.384e-06,\n\t\t\t1.03951e-04 * 0.740951125354959 / 2.384e-06,\n\t\t\t9.53674e-04 * 0.740951125354959 / 2.384e-06,\n\t\t\t2.841473e-03 * 0.740951125354959 / 2.384e-06,\n\t\t\t3.5758972e-02 * 0.740951125354959 / 2.384e-06,\n\t\t\t3.401756e-03 * 0.740951125354959 / 2.384e-06,\n\t\t\t9.83715e-04 * 0.740951125354959 / 2.384e-06,\n\t\t\t9.9182e-05 * 0.740951125354959 / 2.384e-06, /* 15 */\n\t\t\t1.2398e-05 * 0.740951125354959 / 2.384e-06,\n\t\t\t1.91212e-04 * 0.740951125354959 / 2.384e-06,\n\t\t\t2.283096e-03 * 0.740951125354959 / 2.384e-06,\n\t\t\t1.6994476e-02 * 0.740951125354959 / 2.384e-06,\n\t\t\t-1.8756866e-02 * 0.740951125354959 / 2.384e-06,\n\t\t\t-2.630711e-03 * 0.740951125354959 / 2.384e-06,\n\t\t\t-2.47478e-04 * 0.740951125354959 / 2.384e-06,\n\t\t\t-1.4782e-05 * 0.740951125354959 / 2.384e-06,\n\t\t\t9.063471690191471e-01, 1.960342806591213e-01,\n\n\t\t\t-4.77e-07 * 0.773010453362737 / 2.384e-06,\n\t\t\t1.05858e-04 * 0.773010453362737 / 2.384e-06,\n\t\t\t9.30786e-04 * 0.773010453362737 / 2.384e-06,\n\t\t\t2.521515e-03 * 0.773010453362737 / 2.384e-06,\n\t\t\t3.5694122e-02 * 0.773010453362737 / 2.384e-06,\n\t\t\t3.643036e-03 * 0.773010453362737 / 2.384e-06,\n\t\t\t9.91821e-04 * 0.773010453362737 / 2.384e-06,\n\t\t\t9.6321e-05 * 0.773010453362737 / 2.384e-06, /* 14 */\n\t\t\t1.1444e-05 * 0.773010453362737 / 2.384e-06,\n\t\t\t1.65462e-04 * 0.773010453362737 / 2.384e-06,\n\t\t\t2.110004e-03 * 0.773010453362737 / 2.384e-06,\n\t\t\t1.6112804e-02 * 0.773010453362737 / 2.384e-06,\n\t\t\t-1.9634247e-02 * 0.773010453362737 / 2.384e-06,\n\t\t\t-2.803326e-03 * 0.773010453362737 / 2.384e-06,\n\t\t\t-2.77042e-04 * 0.773010453362737 / 2.384e-06,\n\t\t\t-1.6689e-05 * 0.773010453362737 / 2.384e-06,\n\t\t\t8.206787908286602e-01, 3.901806440322567e-01,\n\n\t\t\t-4.77e-07 * 0.803207531480645 / 2.384e-06,\n\t\t\t1.07288e-04 * 0.803207531480645 / 2.384e-06,\n\t\t\t9.02653e-04 * 0.803207531480645 / 2.384e-06,\n\t\t\t2.174854e-03 * 0.803207531480645 / 2.384e-06,\n\t\t\t3.5586357e-02 * 0.803207531480645 / 2.384e-06,\n\t\t\t3.858566e-03 * 0.803207531480645 / 2.384e-06,\n\t\t\t9.95159e-04 * 0.803207531480645 / 2.384e-06,\n\t\t\t9.3460e-05 * 0.803207531480645 / 2.384e-06, /* 13 */\n\t\t\t1.0014e-05 * 0.803207531480645 / 2.384e-06,\n\t\t\t1.40190e-04 * 0.803207531480645 / 2.384e-06,\n\t\t\t1.937389e-03 * 0.803207531480645 / 2.384e-06,\n\t\t\t1.5233517e-02 * 0.803207531480645 / 2.384e-06,\n\t\t\t-2.0506859e-02 * 0.803207531480645 / 2.384e-06,\n\t\t\t-2.974033e-03 * 0.803207531480645 / 2.384e-06,\n\t\t\t-3.07560e-04 * 0.803207531480645 / 2.384e-06,\n\t\t\t-1.8120e-05 * 0.803207531480645 / 2.384e-06,\n\t\t\t7.416505462720353e-01, 5.805693545089249e-01,\n\n\t\t\t-4.77e-07 * 0.831469612302545 / 2.384e-06,\n\t\t\t1.08242e-04 * 0.831469612302545 / 2.384e-06,\n\t\t\t8.68797e-04 * 0.831469612302545 / 2.384e-06,\n\t\t\t1.800537e-03 * 0.831469612302545 / 2.384e-06,\n\t\t\t3.5435200e-02 * 0.831469612302545 / 2.384e-06,\n\t\t\t4.049301e-03 * 0.831469612302545 / 2.384e-06,\n\t\t\t9.94205e-04 * 0.831469612302545 / 2.384e-06,\n\t\t\t9.0599e-05 * 0.831469612302545 / 2.384e-06, /* 12 */\n\t\t\t9.060e-06 * 0.831469612302545 / 2.384e-06,\n\t\t\t1.16348e-04 * 0.831469612302545 / 2.384e-06,\n\t\t\t1.766682e-03 * 0.831469612302545 / 2.384e-06,\n\t\t\t1.4358521e-02 * 0.831469612302545 / 2.384e-06,\n\t\t\t-2.1372318e-02 * 0.831469612302545 / 2.384e-06,\n\t\t\t-3.14188e-03 * 0.831469612302545 / 2.384e-06,\n\t\t\t-3.39031e-04 * 0.831469612302545 / 2.384e-06,\n\t\t\t-1.9550e-05 * 0.831469612302545 / 2.384e-06,\n\t\t\t6.681786379192989e-01, 7.653668647301797e-01,\n\n\t\t\t-4.77e-07 * 0.857728610000272 / 2.384e-06,\n\t\t\t1.08719e-04 * 0.857728610000272 / 2.384e-06,\n\t\t\t8.29220e-04 * 0.857728610000272 / 2.384e-06,\n\t\t\t1.399517e-03 * 0.857728610000272 / 2.384e-06,\n\t\t\t3.5242081e-02 * 0.857728610000272 / 2.384e-06,\n\t\t\t4.215240e-03 * 0.857728610000272 / 2.384e-06,\n\t\t\t9.89437e-04 * 0.857728610000272 / 2.384e-06,\n\t\t\t8.7261e-05 * 0.857728610000272 / 2.384e-06, /* 11 */\n\t\t\t8.106e-06 * 0.857728610000272 / 2.384e-06,\n\t\t\t9.3937e-05 * 0.857728610000272 / 2.384e-06,\n\t\t\t1.597881e-03 * 0.857728610000272 / 2.384e-06,\n\t\t\t1.3489246e-02 * 0.857728610000272 / 2.384e-06,\n\t\t\t-2.2228718e-02 * 0.857728610000272 / 2.384e-06,\n\t\t\t-3.306866e-03 * 0.857728610000272 / 2.384e-06,\n\t\t\t-3.71456e-04 * 0.857728610000272 / 2.384e-06,\n\t\t\t-2.1458e-05 * 0.857728610000272 / 2.384e-06,\n\t\t\t5.993769336819237e-01, 9.427934736519954e-01,\n\n\t\t\t-4.77e-07 * 0.881921264348355 / 2.384e-06,\n\t\t\t1.08719e-04 * 0.881921264348355 / 2.384e-06,\n\t\t\t7.8392e-04 * 0.881921264348355 / 2.384e-06,\n\t\t\t9.71317e-04 * 0.881921264348355 / 2.384e-06,\n\t\t\t3.5007000e-02 * 0.881921264348355 / 2.384e-06,\n\t\t\t4.357815e-03 * 0.881921264348355 / 2.384e-06,\n\t\t\t9.80854e-04 * 0.881921264348355 / 2.384e-06,\n\t\t\t8.3923e-05 * 0.881921264348355 / 2.384e-06, /* 10 */\n\t\t\t7.629e-06 * 0.881921264348355 / 2.384e-06,\n\t\t\t7.2956e-05 * 0.881921264348355 / 2.384e-06,\n\t\t\t1.432419e-03 * 0.881921264348355 / 2.384e-06,\n\t\t\t1.2627602e-02 * 0.881921264348355 / 2.384e-06,\n\t\t\t-2.3074150e-02 * 0.881921264348355 / 2.384e-06,\n\t\t\t-3.467083e-03 * 0.881921264348355 / 2.384e-06,\n\t\t\t-4.04358e-04 * 0.881921264348355 / 2.384e-06,\n\t\t\t-2.3365e-05 * 0.881921264348355 / 2.384e-06,\n\t\t\t5.345111359507916e-01, 1.111140466039205e+00,\n\n\t\t\t-9.54e-07 * 0.903989293123443 / 2.384e-06,\n\t\t\t1.08242e-04 * 0.903989293123443 / 2.384e-06,\n\t\t\t7.31945e-04 * 0.903989293123443 / 2.384e-06,\n\t\t\t5.15938e-04 * 0.903989293123443 / 2.384e-06,\n\t\t\t3.4730434e-02 * 0.903989293123443 / 2.384e-06,\n\t\t\t4.477024e-03 * 0.903989293123443 / 2.384e-06,\n\t\t\t9.68933e-04 * 0.903989293123443 / 2.384e-06,\n\t\t\t8.0585e-05 * 0.903989293123443 / 2.384e-06, /* 9 */\n\t\t\t6.676e-06 * 0.903989293123443 / 2.384e-06,\n\t\t\t5.2929e-05 * 0.903989293123443 / 2.384e-06,\n\t\t\t1.269817e-03 * 0.903989293123443 / 2.384e-06,\n\t\t\t1.1775017e-02 * 0.903989293123443 / 2.384e-06,\n\t\t\t-2.3907185e-02 * 0.903989293123443 / 2.384e-06,\n\t\t\t-3.622532e-03 * 0.903989293123443 / 2.384e-06,\n\t\t\t-4.38213e-04 * 0.903989293123443 / 2.384e-06,\n\t\t\t-2.5272e-05 * 0.903989293123443 / 2.384e-06,\n\t\t\t4.729647758913199e-01, 1.268786568327291e+00,\n\n\t\t\t-9.54e-07 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t1.06812e-04 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t6.74248e-04 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t3.3379e-05 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t3.4412861e-02 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t4.573822e-03 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t9.54151e-04 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t7.6771e-05 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t6.199e-06 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t3.4332e-05 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t1.111031e-03 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t1.0933399e-02 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t-2.4725437e-02 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t-3.771782e-03 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t-4.72546e-04 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t-2.7657e-05 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t4.1421356237309504879e-01, /* tan(PI/8) */\n\t\t\t1.414213562373095e+00,\n\n\t\t\t-9.54e-07 * 0.941544065183021 / 2.384e-06,\n\t\t\t1.05381e-04 * 0.941544065183021 / 2.384e-06,\n\t\t\t6.10352e-04 * 0.941544065183021 / 2.384e-06,\n\t\t\t-4.75883e-04 * 0.941544065183021 / 2.384e-06,\n\t\t\t3.4055710e-02 * 0.941544065183021 / 2.384e-06,\n\t\t\t4.649162e-03 * 0.941544065183021 / 2.384e-06,\n\t\t\t9.35555e-04 * 0.941544065183021 / 2.384e-06,\n\t\t\t7.3433e-05 * 0.941544065183021 / 2.384e-06, /* 7 */\n\t\t\t5.245e-06 * 0.941544065183021 / 2.384e-06,\n\t\t\t1.7166e-05 * 0.941544065183021 / 2.384e-06,\n\t\t\t9.56535e-04 * 0.941544065183021 / 2.384e-06,\n\t\t\t1.0103703e-02 * 0.941544065183021 / 2.384e-06,\n\t\t\t-2.5527000e-02 * 0.941544065183021 / 2.384e-06,\n\t\t\t-3.914356e-03 * 0.941544065183021 / 2.384e-06,\n\t\t\t-5.07355e-04 * 0.941544065183021 / 2.384e-06,\n\t\t\t-3.0041e-05 * 0.941544065183021 / 2.384e-06,\n\t\t\t3.578057213145241e-01, 1.546020906725474e+00,\n\n\t\t\t-9.54e-07 * 0.956940335732209 / 2.384e-06,\n\t\t\t1.02520e-04 * 0.956940335732209 / 2.384e-06,\n\t\t\t5.39303e-04 * 0.956940335732209 / 2.384e-06,\n\t\t\t-1.011848e-03 * 0.956940335732209 / 2.384e-06,\n\t\t\t3.3659935e-02 * 0.956940335732209 / 2.384e-06,\n\t\t\t4.703045e-03 * 0.956940335732209 / 2.384e-06,\n\t\t\t9.15051e-04 * 0.956940335732209 / 2.384e-06,\n\t\t\t7.0095e-05 * 0.956940335732209 / 2.384e-06, /* 6 */\n\t\t\t4.768e-06 * 0.956940335732209 / 2.384e-06,\n\t\t\t9.54e-07 * 0.956940335732209 / 2.384e-06,\n\t\t\t8.06808e-04 * 0.956940335732209 / 2.384e-06,\n\t\t\t9.287834e-03 * 0.956940335732209 / 2.384e-06,\n\t\t\t-2.6310921e-02 * 0.956940335732209 / 2.384e-06,\n\t\t\t-4.048824e-03 * 0.956940335732209 / 2.384e-06,\n\t\t\t-5.42164e-04 * 0.956940335732209 / 2.384e-06,\n\t\t\t-3.2425e-05 * 0.956940335732209 / 2.384e-06,\n\t\t\t3.033466836073424e-01, 1.662939224605090e+00,\n\n\t\t\t-1.431e-06 * 0.970031253194544 / 2.384e-06,\n\t\t\t9.9182e-05 * 0.970031253194544 / 2.384e-06,\n\t\t\t4.62532e-04 * 0.970031253194544 / 2.384e-06,\n\t\t\t-1.573563e-03 * 0.970031253194544 / 2.384e-06,\n\t\t\t3.3225536e-02 * 0.970031253194544 / 2.384e-06,\n\t\t\t4.737377e-03 * 0.970031253194544 / 2.384e-06,\n\t\t\t8.91685e-04 * 0.970031253194544 / 2.384e-06,\n\t\t\t6.6280e-05 * 0.970031253194544 / 2.384e-06, /* 5 */\n\t\t\t4.292e-06 * 0.970031253194544 / 2.384e-06,\n\t\t\t-1.3828e-05 * 0.970031253194544 / 2.384e-06,\n\t\t\t6.61850e-04 * 0.970031253194544 / 2.384e-06,\n\t\t\t8.487225e-03 * 0.970031253194544 / 2.384e-06,\n\t\t\t-2.7073860e-02 * 0.970031253194544 / 2.384e-06,\n\t\t\t-4.174709e-03 * 0.970031253194544 / 2.384e-06,\n\t\t\t-5.76973e-04 * 0.970031253194544 / 2.384e-06,\n\t\t\t-3.4809e-05 * 0.970031253194544 / 2.384e-06,\n\t\t\t2.504869601913055e-01, 1.763842528696710e+00,\n\n\t\t\t-1.431e-06 * 0.98078528040323 / 2.384e-06,\n\t\t\t9.5367e-05 * 0.98078528040323 / 2.384e-06,\n\t\t\t3.78609e-04 * 0.98078528040323 / 2.384e-06,\n\t\t\t-2.161503e-03 * 0.98078528040323 / 2.384e-06,\n\t\t\t3.2754898e-02 * 0.98078528040323 / 2.384e-06,\n\t\t\t4.752159e-03 * 0.98078528040323 / 2.384e-06,\n\t\t\t8.66413e-04 * 0.98078528040323 / 2.384e-06,\n\t\t\t6.2943e-05 * 0.98078528040323 / 2.384e-06, /* 4 */\n\t\t\t3.815e-06 * 0.98078528040323 / 2.384e-06,\n\t\t\t-2.718e-05 * 0.98078528040323 / 2.384e-06,\n\t\t\t5.22137e-04 * 0.98078528040323 / 2.384e-06,\n\t\t\t7.703304e-03 * 0.98078528040323 / 2.384e-06,\n\t\t\t-2.7815342e-02 * 0.98078528040323 / 2.384e-06,\n\t\t\t-4.290581e-03 * 0.98078528040323 / 2.384e-06,\n\t\t\t-6.11782e-04 * 0.98078528040323 / 2.384e-06,\n\t\t\t-3.7670e-05 * 0.98078528040323 / 2.384e-06,\n\t\t\t1.989123673796580e-01, 1.847759065022573e+00,\n\n\t\t\t-1.907e-06 * 0.989176509964781 / 2.384e-06,\n\t\t\t9.0122e-05 * 0.989176509964781 / 2.384e-06,\n\t\t\t2.88486e-04 * 0.989176509964781 / 2.384e-06,\n\t\t\t-2.774239e-03 * 0.989176509964781 / 2.384e-06,\n\t\t\t3.2248020e-02 * 0.989176509964781 / 2.384e-06,\n\t\t\t4.748821e-03 * 0.989176509964781 / 2.384e-06,\n\t\t\t8.38757e-04 * 0.989176509964781 / 2.384e-06,\n\t\t\t5.9605e-05 * 0.989176509964781 / 2.384e-06, /* 3 */\n\t\t\t3.338e-06 * 0.989176509964781 / 2.384e-06,\n\t\t\t-3.9577e-05 * 0.989176509964781 / 2.384e-06,\n\t\t\t3.88145e-04 * 0.989176509964781 / 2.384e-06,\n\t\t\t6.937027e-03 * 0.989176509964781 / 2.384e-06,\n\t\t\t-2.8532982e-02 * 0.989176509964781 / 2.384e-06,\n\t\t\t-4.395962e-03 * 0.989176509964781 / 2.384e-06,\n\t\t\t-6.46591e-04 * 0.989176509964781 / 2.384e-06,\n\t\t\t-4.0531e-05 * 0.989176509964781 / 2.384e-06,\n\t\t\t1.483359875383474e-01, 1.913880671464418e+00,\n\n\t\t\t-1.907e-06 * 0.995184726672197 / 2.384e-06,\n\t\t\t8.4400e-05 * 0.995184726672197 / 2.384e-06,\n\t\t\t1.91689e-04 * 0.995184726672197 / 2.384e-06,\n\t\t\t-3.411293e-03 * 0.995184726672197 / 2.384e-06,\n\t\t\t3.1706810e-02 * 0.995184726672197 / 2.384e-06,\n\t\t\t4.728317e-03 * 0.995184726672197 / 2.384e-06,\n\t\t\t8.09669e-04 * 0.995184726672197 / 2.384e-06,\n\t\t\t5.579e-05 * 0.995184726672197 / 2.384e-06,\n\t\t\t3.338e-06 * 0.995184726672197 / 2.384e-06,\n\t\t\t-5.0545e-05 * 0.995184726672197 / 2.384e-06,\n\t\t\t2.59876e-04 * 0.995184726672197 / 2.384e-06,\n\t\t\t6.189346e-03 * 0.995184726672197 / 2.384e-06,\n\t\t\t-2.9224873e-02 * 0.995184726672197 / 2.384e-06,\n\t\t\t-4.489899e-03 * 0.995184726672197 / 2.384e-06,\n\t\t\t-6.80923e-04 * 0.995184726672197 / 2.384e-06,\n\t\t\t-4.3392e-05 * 0.995184726672197 / 2.384e-06,\n\t\t\t9.849140335716425e-02, 1.961570560806461e+00,\n\n\t\t\t-2.384e-06 * 0.998795456205172 / 2.384e-06,\n\t\t\t7.7724e-05 * 0.998795456205172 / 2.384e-06,\n\t\t\t8.8215e-05 * 0.998795456205172 / 2.384e-06,\n\t\t\t-4.072189e-03 * 0.998795456205172 / 2.384e-06,\n\t\t\t3.1132698e-02 * 0.998795456205172 / 2.384e-06,\n\t\t\t4.691124e-03 * 0.998795456205172 / 2.384e-06,\n\t\t\t7.79152e-04 * 0.998795456205172 / 2.384e-06,\n\t\t\t5.2929e-05 * 0.998795456205172 / 2.384e-06,\n\t\t\t2.861e-06 * 0.998795456205172 / 2.384e-06,\n\t\t\t-6.0558e-05 * 0.998795456205172 / 2.384e-06,\n\t\t\t1.37329e-04 * 0.998795456205172 / 2.384e-06,\n\t\t\t5.462170e-03 * 0.998795456205172 / 2.384e-06,\n\t\t\t-2.9890060e-02 * 0.998795456205172 / 2.384e-06,\n\t\t\t-4.570484e-03 * 0.998795456205172 / 2.384e-06,\n\t\t\t-7.14302e-04 * 0.998795456205172 / 2.384e-06,\n\t\t\t-4.6253e-05 * 0.998795456205172 / 2.384e-06,\n\t\t\t4.912684976946725e-02, 1.990369453344394e+00,\n\n\t\t\t3.5780907e-02 * Util.SQRT2 * 0.5 / 2.384e-06,\n\t\t\t1.7876148e-02 * Util.SQRT2 * 0.5 / 2.384e-06,\n\t\t\t3.134727e-03 * Util.SQRT2 * 0.5 / 2.384e-06,\n\t\t\t2.457142e-03 * Util.SQRT2 * 0.5 / 2.384e-06,\n\t\t\t9.71317e-04 * Util.SQRT2 * 0.5 / 2.384e-06,\n\t\t\t2.18868e-04 * Util.SQRT2 * 0.5 / 2.384e-06,\n\t\t\t1.01566e-04 * Util.SQRT2 * 0.5 / 2.384e-06,\n\t\t\t1.3828e-05 * Util.SQRT2 * 0.5 / 2.384e-06,\n\n\t\t\t3.0526638e-02 / 2.384e-06, 4.638195e-03 / 2.384e-06,\n\t\t\t7.47204e-04 / 2.384e-06, 4.9591e-05 / 2.384e-06,\n\t\t\t4.756451e-03 / 2.384e-06, 2.1458e-05 / 2.384e-06,\n\t\t\t-6.9618e-05 / 2.384e-06, /* 2.384e-06/2.384e-06 */\n\t];\n\n\tvar NS = 12;\n\tvar NL = 36;\n\n\tvar win = [\n\t    [\n\t     2.382191739347913e-13,\n\t     6.423305872147834e-13,\n\t     9.400849094049688e-13,\n\t     1.122435026096556e-12,\n\t     1.183840321267481e-12,\n\t     1.122435026096556e-12,\n\t     9.400849094049690e-13,\n\t     6.423305872147839e-13,\n\t     2.382191739347918e-13,\n\n\t     5.456116108943412e-12,\n\t     4.878985199565852e-12,\n\t     4.240448995017367e-12,\n\t     3.559909094758252e-12,\n\t     2.858043359288075e-12,\n\t     2.156177623817898e-12,\n\t     1.475637723558783e-12,\n\t     8.371015190102974e-13,\n\t     2.599706096327376e-13,\n\n\t     -5.456116108943412e-12,\n\t     -4.878985199565852e-12,\n\t     -4.240448995017367e-12,\n\t     -3.559909094758252e-12,\n\t     -2.858043359288076e-12,\n\t     -2.156177623817898e-12,\n\t     -1.475637723558783e-12,\n\t     -8.371015190102975e-13,\n\t     -2.599706096327376e-13,\n\n\t     -2.382191739347923e-13,\n\t     -6.423305872147843e-13,\n\t     -9.400849094049696e-13,\n\t     -1.122435026096556e-12,\n\t     -1.183840321267481e-12,\n\t     -1.122435026096556e-12,\n\t     -9.400849094049694e-13,\n\t     -6.423305872147840e-13,\n\t     -2.382191739347918e-13,\n\t     ],\n\t    [\n\t     2.382191739347913e-13,\n\t     6.423305872147834e-13,\n\t     9.400849094049688e-13,\n\t     1.122435026096556e-12,\n\t     1.183840321267481e-12,\n\t     1.122435026096556e-12,\n\t     9.400849094049688e-13,\n\t     6.423305872147841e-13,\n\t     2.382191739347918e-13,\n\n\t     5.456116108943413e-12,\n\t     4.878985199565852e-12,\n\t     4.240448995017367e-12,\n\t     3.559909094758253e-12,\n\t     2.858043359288075e-12,\n\t     2.156177623817898e-12,\n\t     1.475637723558782e-12,\n\t     8.371015190102975e-13,\n\t     2.599706096327376e-13,\n\n\t     -5.461314069809755e-12,\n\t     -4.921085770524055e-12,\n\t     -4.343405037091838e-12,\n\t     -3.732668368707687e-12,\n\t     -3.093523840190885e-12,\n\t     -2.430835727329465e-12,\n\t     -1.734679010007751e-12,\n\t     -9.748253656609281e-13,\n\t     -2.797435120168326e-13,\n\n\t     0.000000000000000e+00,\n\t     0.000000000000000e+00,\n\t     0.000000000000000e+00,\n\t     0.000000000000000e+00,\n\t     0.000000000000000e+00,\n\t     0.000000000000000e+00,\n\t     -2.283748241799531e-13,\n\t     -4.037858874020686e-13,\n\t     -2.146547464825323e-13,\n\t     ],\n\t    [\n\t     1.316524975873958e-01, /* win[SHORT_TYPE] */\n\t     4.142135623730950e-01,\n\t     7.673269879789602e-01,\n\n\t     1.091308501069271e+00, /* tantab_l */\n\t     1.303225372841206e+00,\n\t     1.569685577117490e+00,\n\t     1.920982126971166e+00,\n\t     2.414213562373094e+00,\n\t     3.171594802363212e+00,\n\t     4.510708503662055e+00,\n\t     7.595754112725146e+00,\n\t     2.290376554843115e+01,\n\n\t     0.98480775301220802032, /* cx */\n\t     0.64278760968653936292,\n\t     0.34202014332566882393,\n\t     0.93969262078590842791,\n\t     -0.17364817766693030343,\n\t     -0.76604444311897790243,\n\t     0.86602540378443870761,\n\t     0.500000000000000e+00,\n\n\t     -5.144957554275265e-01, /* ca */\n\t     -4.717319685649723e-01,\n\t     -3.133774542039019e-01,\n\t     -1.819131996109812e-01,\n\t     -9.457419252642064e-02,\n\t     -4.096558288530405e-02,\n\t     -1.419856857247115e-02,\n\t     -3.699974673760037e-03,\n\n\t     8.574929257125442e-01, /* cs */\n\t     8.817419973177052e-01,\n\t     9.496286491027329e-01,\n\t     9.833145924917901e-01,\n\t     9.955178160675857e-01,\n\t     9.991605581781475e-01,\n\t     9.998991952444470e-01,\n\t     9.999931550702802e-01,\n\t     ],\n\t    [\n\t     0.000000000000000e+00,\n\t     0.000000000000000e+00,\n\t     0.000000000000000e+00,\n\t     0.000000000000000e+00,\n\t     0.000000000000000e+00,\n\t     0.000000000000000e+00,\n\t     2.283748241799531e-13,\n\t     4.037858874020686e-13,\n\t     2.146547464825323e-13,\n\n\t     5.461314069809755e-12,\n\t     4.921085770524055e-12,\n\t     4.343405037091838e-12,\n\t     3.732668368707687e-12,\n\t     3.093523840190885e-12,\n\t     2.430835727329466e-12,\n\t     1.734679010007751e-12,\n\t     9.748253656609281e-13,\n\t     2.797435120168326e-13,\n\n\t     -5.456116108943413e-12,\n\t     -4.878985199565852e-12,\n\t     -4.240448995017367e-12,\n\t     -3.559909094758253e-12,\n\t     -2.858043359288075e-12,\n\t     -2.156177623817898e-12,\n\t     -1.475637723558782e-12,\n\t     -8.371015190102975e-13,\n\t     -2.599706096327376e-13,\n\n\t     -2.382191739347913e-13,\n\t     -6.423305872147834e-13,\n\t     -9.400849094049688e-13,\n\t     -1.122435026096556e-12,\n\t     -1.183840321267481e-12,\n\t     -1.122435026096556e-12,\n\t     -9.400849094049688e-13,\n\t     -6.423305872147841e-13,\n\t     -2.382191739347918e-13,\n\t     ]\n\t];\n\n\tvar tantab_l = win[Encoder.SHORT_TYPE];\n\tvar cx = win[Encoder.SHORT_TYPE];\n\tvar ca = win[Encoder.SHORT_TYPE];\n\tvar cs = win[Encoder.SHORT_TYPE];\n\n\t/**\n\t * new IDCT routine written by Takehiro TOMINAGA\n\t *\n\t * PURPOSE: Overlapping window on PCM samples<BR>\n\t *\n\t * SEMANTICS:<BR>\n\t * 32 16-bit pcm samples are scaled to fractional 2's complement and\n\t * concatenated to the end of the window buffer #x#. The updated window\n\t * buffer #x# is then windowed by the analysis window #c# to produce the\n\t * windowed sample #z#\n\t */\n\tvar order = [\n\t    0, 1, 16, 17, 8, 9, 24, 25, 4, 5, 20, 21, 12, 13, 28, 29,\n\t    2, 3, 18, 19, 10, 11, 26, 27, 6, 7, 22, 23, 14, 15, 30, 31\n\t];\n\n\t/**\n\t * returns sum_j=0^31 a[j]*cos(PI*j*(k+1/2)/32), 0<=k<32\n\t */\n\tfunction window_subband(x1, x1Pos, a) {\n\t\tvar wp = 10;\n\n\t\tvar x2 = x1Pos + 238 - 14 - 286;\n\n\t\tfor (var i = -15; i < 0; i++) {\n\t\t\tvar w, s, t;\n\n\t\t\tw = enwindow[wp + -10];\n\t\t\ts = x1[x2 + -224] * w;\n\t\t\tt = x1[x1Pos + 224] * w;\n\t\t\tw = enwindow[wp + -9];\n\t\t\ts += x1[x2 + -160] * w;\n\t\t\tt += x1[x1Pos + 160] * w;\n\t\t\tw = enwindow[wp + -8];\n\t\t\ts += x1[x2 + -96] * w;\n\t\t\tt += x1[x1Pos + 96] * w;\n\t\t\tw = enwindow[wp + -7];\n\t\t\ts += x1[x2 + -32] * w;\n\t\t\tt += x1[x1Pos + 32] * w;\n\t\t\tw = enwindow[wp + -6];\n\t\t\ts += x1[x2 + 32] * w;\n\t\t\tt += x1[x1Pos + -32] * w;\n\t\t\tw = enwindow[wp + -5];\n\t\t\ts += x1[x2 + 96] * w;\n\t\t\tt += x1[x1Pos + -96] * w;\n\t\t\tw = enwindow[wp + -4];\n\t\t\ts += x1[x2 + 160] * w;\n\t\t\tt += x1[x1Pos + -160] * w;\n\t\t\tw = enwindow[wp + -3];\n\t\t\ts += x1[x2 + 224] * w;\n\t\t\tt += x1[x1Pos + -224] * w;\n\n\t\t\tw = enwindow[wp + -2];\n\t\t\ts += x1[x1Pos + -256] * w;\n\t\t\tt -= x1[x2 + 256] * w;\n\t\t\tw = enwindow[wp + -1];\n\t\t\ts += x1[x1Pos + -192] * w;\n\t\t\tt -= x1[x2 + 192] * w;\n\t\t\tw = enwindow[wp + 0];\n\t\t\ts += x1[x1Pos + -128] * w;\n\t\t\tt -= x1[x2 + 128] * w;\n\t\t\tw = enwindow[wp + 1];\n\t\t\ts += x1[x1Pos + -64] * w;\n\t\t\tt -= x1[x2 + 64] * w;\n\t\t\tw = enwindow[wp + 2];\n\t\t\ts += x1[x1Pos + 0] * w;\n\t\t\tt -= x1[x2 + 0] * w;\n\t\t\tw = enwindow[wp + 3];\n\t\t\ts += x1[x1Pos + 64] * w;\n\t\t\tt -= x1[x2 + -64] * w;\n\t\t\tw = enwindow[wp + 4];\n\t\t\ts += x1[x1Pos + 128] * w;\n\t\t\tt -= x1[x2 + -128] * w;\n\t\t\tw = enwindow[wp + 5];\n\t\t\ts += x1[x1Pos + 192] * w;\n\t\t\tt -= x1[x2 + -192] * w;\n\n\t\t\t/*\n\t\t\t * this multiplyer could be removed, but it needs more 256 FLOAT\n\t\t\t * data. thinking about the data cache performance, I think we\n\t\t\t * should not use such a huge table. tt 2000/Oct/25\n\t\t\t */\n\t\t\ts *= enwindow[wp + 6];\n\t\t\tw = t - s;\n\t\t\ta[30 + i * 2] = t + s;\n\t\t\ta[31 + i * 2] = enwindow[wp + 7] * w;\n\t\t\twp += 18;\n\t\t\tx1Pos--;\n\t\t\tx2++;\n\t\t}\n\t\t{\n\t\t\tvar s, t, u, v;\n\t\t\tt = x1[x1Pos + -16] * enwindow[wp + -10];\n\t\t\ts = x1[x1Pos + -32] * enwindow[wp + -2];\n\t\t\tt += (x1[x1Pos + -48] - x1[x1Pos + 16]) * enwindow[wp + -9];\n\t\t\ts += x1[x1Pos + -96] * enwindow[wp + -1];\n\t\t\tt += (x1[x1Pos + -80] + x1[x1Pos + 48]) * enwindow[wp + -8];\n\t\t\ts += x1[x1Pos + -160] * enwindow[wp + 0];\n\t\t\tt += (x1[x1Pos + -112] - x1[x1Pos + 80]) * enwindow[wp + -7];\n\t\t\ts += x1[x1Pos + -224] * enwindow[wp + 1];\n\t\t\tt += (x1[x1Pos + -144] + x1[x1Pos + 112]) * enwindow[wp + -6];\n\t\t\ts -= x1[x1Pos + 32] * enwindow[wp + 2];\n\t\t\tt += (x1[x1Pos + -176] - x1[x1Pos + 144]) * enwindow[wp + -5];\n\t\t\ts -= x1[x1Pos + 96] * enwindow[wp + 3];\n\t\t\tt += (x1[x1Pos + -208] + x1[x1Pos + 176]) * enwindow[wp + -4];\n\t\t\ts -= x1[x1Pos + 160] * enwindow[wp + 4];\n\t\t\tt += (x1[x1Pos + -240] - x1[x1Pos + 208]) * enwindow[wp + -3];\n\t\t\ts -= x1[x1Pos + 224];\n\n\t\t\tu = s - t;\n\t\t\tv = s + t;\n\n\t\t\tt = a[14];\n\t\t\ts = a[15] - t;\n\n\t\t\ta[31] = v + t; /* A0 */\n\t\t\ta[30] = u + s; /* A1 */\n\t\t\ta[15] = u - s; /* A2 */\n\t\t\ta[14] = v - t; /* A3 */\n\t\t}\n\t\t{\n\t\t\tvar xr;\n\t\t\txr = a[28] - a[0];\n\t\t\ta[0] += a[28];\n\t\t\ta[28] = xr * enwindow[wp + -2 * 18 + 7];\n\t\t\txr = a[29] - a[1];\n\t\t\ta[1] += a[29];\n\t\t\ta[29] = xr * enwindow[wp + -2 * 18 + 7];\n\n\t\t\txr = a[26] - a[2];\n\t\t\ta[2] += a[26];\n\t\t\ta[26] = xr * enwindow[wp + -4 * 18 + 7];\n\t\t\txr = a[27] - a[3];\n\t\t\ta[3] += a[27];\n\t\t\ta[27] = xr * enwindow[wp + -4 * 18 + 7];\n\n\t\t\txr = a[24] - a[4];\n\t\t\ta[4] += a[24];\n\t\t\ta[24] = xr * enwindow[wp + -6 * 18 + 7];\n\t\t\txr = a[25] - a[5];\n\t\t\ta[5] += a[25];\n\t\t\ta[25] = xr * enwindow[wp + -6 * 18 + 7];\n\n\t\t\txr = a[22] - a[6];\n\t\t\ta[6] += a[22];\n\t\t\ta[22] = xr * Util.SQRT2;\n\t\t\txr = a[23] - a[7];\n\t\t\ta[7] += a[23];\n\t\t\ta[23] = xr * Util.SQRT2 - a[7];\n\t\t\ta[7] -= a[6];\n\t\t\ta[22] -= a[7];\n\t\t\ta[23] -= a[22];\n\n\t\t\txr = a[6];\n\t\t\ta[6] = a[31] - xr;\n\t\t\ta[31] = a[31] + xr;\n\t\t\txr = a[7];\n\t\t\ta[7] = a[30] - xr;\n\t\t\ta[30] = a[30] + xr;\n\t\t\txr = a[22];\n\t\t\ta[22] = a[15] - xr;\n\t\t\ta[15] = a[15] + xr;\n\t\t\txr = a[23];\n\t\t\ta[23] = a[14] - xr;\n\t\t\ta[14] = a[14] + xr;\n\n\t\t\txr = a[20] - a[8];\n\t\t\ta[8] += a[20];\n\t\t\ta[20] = xr * enwindow[wp + -10 * 18 + 7];\n\t\t\txr = a[21] - a[9];\n\t\t\ta[9] += a[21];\n\t\t\ta[21] = xr * enwindow[wp + -10 * 18 + 7];\n\n\t\t\txr = a[18] - a[10];\n\t\t\ta[10] += a[18];\n\t\t\ta[18] = xr * enwindow[wp + -12 * 18 + 7];\n\t\t\txr = a[19] - a[11];\n\t\t\ta[11] += a[19];\n\t\t\ta[19] = xr * enwindow[wp + -12 * 18 + 7];\n\n\t\t\txr = a[16] - a[12];\n\t\t\ta[12] += a[16];\n\t\t\ta[16] = xr * enwindow[wp + -14 * 18 + 7];\n\t\t\txr = a[17] - a[13];\n\t\t\ta[13] += a[17];\n\t\t\ta[17] = xr * enwindow[wp + -14 * 18 + 7];\n\n\t\t\txr = -a[20] + a[24];\n\t\t\ta[20] += a[24];\n\t\t\ta[24] = xr * enwindow[wp + -12 * 18 + 7];\n\t\t\txr = -a[21] + a[25];\n\t\t\ta[21] += a[25];\n\t\t\ta[25] = xr * enwindow[wp + -12 * 18 + 7];\n\n\t\t\txr = a[4] - a[8];\n\t\t\ta[4] += a[8];\n\t\t\ta[8] = xr * enwindow[wp + -12 * 18 + 7];\n\t\t\txr = a[5] - a[9];\n\t\t\ta[5] += a[9];\n\t\t\ta[9] = xr * enwindow[wp + -12 * 18 + 7];\n\n\t\t\txr = a[0] - a[12];\n\t\t\ta[0] += a[12];\n\t\t\ta[12] = xr * enwindow[wp + -4 * 18 + 7];\n\t\t\txr = a[1] - a[13];\n\t\t\ta[1] += a[13];\n\t\t\ta[13] = xr * enwindow[wp + -4 * 18 + 7];\n\t\t\txr = a[16] - a[28];\n\t\t\ta[16] += a[28];\n\t\t\ta[28] = xr * enwindow[wp + -4 * 18 + 7];\n\t\t\txr = -a[17] + a[29];\n\t\t\ta[17] += a[29];\n\t\t\ta[29] = xr * enwindow[wp + -4 * 18 + 7];\n\n\t\t\txr = Util.SQRT2 * (a[2] - a[10]);\n\t\t\ta[2] += a[10];\n\t\t\ta[10] = xr;\n\t\t\txr = Util.SQRT2 * (a[3] - a[11]);\n\t\t\ta[3] += a[11];\n\t\t\ta[11] = xr;\n\t\t\txr = Util.SQRT2 * (-a[18] + a[26]);\n\t\t\ta[18] += a[26];\n\t\t\ta[26] = xr - a[18];\n\t\t\txr = Util.SQRT2 * (-a[19] + a[27]);\n\t\t\ta[19] += a[27];\n\t\t\ta[27] = xr - a[19];\n\n\t\t\txr = a[2];\n\t\t\ta[19] -= a[3];\n\t\t\ta[3] -= xr;\n\t\t\ta[2] = a[31] - xr;\n\t\t\ta[31] += xr;\n\t\t\txr = a[3];\n\t\t\ta[11] -= a[19];\n\t\t\ta[18] -= xr;\n\t\t\ta[3] = a[30] - xr;\n\t\t\ta[30] += xr;\n\t\t\txr = a[18];\n\t\t\ta[27] -= a[11];\n\t\t\ta[19] -= xr;\n\t\t\ta[18] = a[15] - xr;\n\t\t\ta[15] += xr;\n\n\t\t\txr = a[19];\n\t\t\ta[10] -= xr;\n\t\t\ta[19] = a[14] - xr;\n\t\t\ta[14] += xr;\n\t\t\txr = a[10];\n\t\t\ta[11] -= xr;\n\t\t\ta[10] = a[23] - xr;\n\t\t\ta[23] += xr;\n\t\t\txr = a[11];\n\t\t\ta[26] -= xr;\n\t\t\ta[11] = a[22] - xr;\n\t\t\ta[22] += xr;\n\t\t\txr = a[26];\n\t\t\ta[27] -= xr;\n\t\t\ta[26] = a[7] - xr;\n\t\t\ta[7] += xr;\n\n\t\t\txr = a[27];\n\t\t\ta[27] = a[6] - xr;\n\t\t\ta[6] += xr;\n\n\t\t\txr = Util.SQRT2 * (a[0] - a[4]);\n\t\t\ta[0] += a[4];\n\t\t\ta[4] = xr;\n\t\t\txr = Util.SQRT2 * (a[1] - a[5]);\n\t\t\ta[1] += a[5];\n\t\t\ta[5] = xr;\n\t\t\txr = Util.SQRT2 * (a[16] - a[20]);\n\t\t\ta[16] += a[20];\n\t\t\ta[20] = xr;\n\t\t\txr = Util.SQRT2 * (a[17] - a[21]);\n\t\t\ta[17] += a[21];\n\t\t\ta[21] = xr;\n\n\t\t\txr = -Util.SQRT2 * (a[8] - a[12]);\n\t\t\ta[8] += a[12];\n\t\t\ta[12] = xr - a[8];\n\t\t\txr = -Util.SQRT2 * (a[9] - a[13]);\n\t\t\ta[9] += a[13];\n\t\t\ta[13] = xr - a[9];\n\t\t\txr = -Util.SQRT2 * (a[25] - a[29]);\n\t\t\ta[25] += a[29];\n\t\t\ta[29] = xr - a[25];\n\t\t\txr = -Util.SQRT2 * (a[24] + a[28]);\n\t\t\ta[24] -= a[28];\n\t\t\ta[28] = xr - a[24];\n\n\t\t\txr = a[24] - a[16];\n\t\t\ta[24] = xr;\n\t\t\txr = a[20] - xr;\n\t\t\ta[20] = xr;\n\t\t\txr = a[28] - xr;\n\t\t\ta[28] = xr;\n\n\t\t\txr = a[25] - a[17];\n\t\t\ta[25] = xr;\n\t\t\txr = a[21] - xr;\n\t\t\ta[21] = xr;\n\t\t\txr = a[29] - xr;\n\t\t\ta[29] = xr;\n\n\t\t\txr = a[17] - a[1];\n\t\t\ta[17] = xr;\n\t\t\txr = a[9] - xr;\n\t\t\ta[9] = xr;\n\t\t\txr = a[25] - xr;\n\t\t\ta[25] = xr;\n\t\t\txr = a[5] - xr;\n\t\t\ta[5] = xr;\n\t\t\txr = a[21] - xr;\n\t\t\ta[21] = xr;\n\t\t\txr = a[13] - xr;\n\t\t\ta[13] = xr;\n\t\t\txr = a[29] - xr;\n\t\t\ta[29] = xr;\n\n\t\t\txr = a[1] - a[0];\n\t\t\ta[1] = xr;\n\t\t\txr = a[16] - xr;\n\t\t\ta[16] = xr;\n\t\t\txr = a[17] - xr;\n\t\t\ta[17] = xr;\n\t\t\txr = a[8] - xr;\n\t\t\ta[8] = xr;\n\t\t\txr = a[9] - xr;\n\t\t\ta[9] = xr;\n\t\t\txr = a[24] - xr;\n\t\t\ta[24] = xr;\n\t\t\txr = a[25] - xr;\n\t\t\ta[25] = xr;\n\t\t\txr = a[4] - xr;\n\t\t\ta[4] = xr;\n\t\t\txr = a[5] - xr;\n\t\t\ta[5] = xr;\n\t\t\txr = a[20] - xr;\n\t\t\ta[20] = xr;\n\t\t\txr = a[21] - xr;\n\t\t\ta[21] = xr;\n\t\t\txr = a[12] - xr;\n\t\t\ta[12] = xr;\n\t\t\txr = a[13] - xr;\n\t\t\ta[13] = xr;\n\t\t\txr = a[28] - xr;\n\t\t\ta[28] = xr;\n\t\t\txr = a[29] - xr;\n\t\t\ta[29] = xr;\n\n\t\t\txr = a[0];\n\t\t\ta[0] += a[31];\n\t\t\ta[31] -= xr;\n\t\t\txr = a[1];\n\t\t\ta[1] += a[30];\n\t\t\ta[30] -= xr;\n\t\t\txr = a[16];\n\t\t\ta[16] += a[15];\n\t\t\ta[15] -= xr;\n\t\t\txr = a[17];\n\t\t\ta[17] += a[14];\n\t\t\ta[14] -= xr;\n\t\t\txr = a[8];\n\t\t\ta[8] += a[23];\n\t\t\ta[23] -= xr;\n\t\t\txr = a[9];\n\t\t\ta[9] += a[22];\n\t\t\ta[22] -= xr;\n\t\t\txr = a[24];\n\t\t\ta[24] += a[7];\n\t\t\ta[7] -= xr;\n\t\t\txr = a[25];\n\t\t\ta[25] += a[6];\n\t\t\ta[6] -= xr;\n\t\t\txr = a[4];\n\t\t\ta[4] += a[27];\n\t\t\ta[27] -= xr;\n\t\t\txr = a[5];\n\t\t\ta[5] += a[26];\n\t\t\ta[26] -= xr;\n\t\t\txr = a[20];\n\t\t\ta[20] += a[11];\n\t\t\ta[11] -= xr;\n\t\t\txr = a[21];\n\t\t\ta[21] += a[10];\n\t\t\ta[10] -= xr;\n\t\t\txr = a[12];\n\t\t\ta[12] += a[19];\n\t\t\ta[19] -= xr;\n\t\t\txr = a[13];\n\t\t\ta[13] += a[18];\n\t\t\ta[18] -= xr;\n\t\t\txr = a[28];\n\t\t\ta[28] += a[3];\n\t\t\ta[3] -= xr;\n\t\t\txr = a[29];\n\t\t\ta[29] += a[2];\n\t\t\ta[2] -= xr;\n\t\t}\n\t}\n\n\t/**\n\t * Function: Calculation of the MDCT In the case of long blocks (type 0,1,3)\n\t * there are 36 coefficents in the time domain and 18 in the frequency\n\t * domain.<BR>\n\t * In the case of short blocks (type 2) there are 3 transformations with\n\t * short length. This leads to 12 coefficents in the time and 6 in the\n\t * frequency domain. In this case the results are stored side by side in the\n\t * vector out[].\n\t *\n\t * New layer3\n\t */\n\tfunction mdct_short(inout, inoutPos) {\n\t\tfor (var l = 0; l < 3; l++) {\n\t\t\tvar tc0, tc1, tc2, ts0, ts1, ts2;\n\n\t\t\tts0 = inout[inoutPos + 2 * 3] * win[Encoder.SHORT_TYPE][0]\n\t\t\t\t\t- inout[inoutPos + 5 * 3];\n\t\t\ttc0 = inout[inoutPos + 0 * 3] * win[Encoder.SHORT_TYPE][2]\n\t\t\t\t\t- inout[inoutPos + 3 * 3];\n\t\t\ttc1 = ts0 + tc0;\n\t\t\ttc2 = ts0 - tc0;\n\n\t\t\tts0 = inout[inoutPos + 5 * 3] * win[Encoder.SHORT_TYPE][0]\n\t\t\t\t\t+ inout[inoutPos + 2 * 3];\n\t\t\ttc0 = inout[inoutPos + 3 * 3] * win[Encoder.SHORT_TYPE][2]\n\t\t\t\t\t+ inout[inoutPos + 0 * 3];\n\t\t\tts1 = ts0 + tc0;\n\t\t\tts2 = -ts0 + tc0;\n\n\t\t\ttc0 = (inout[inoutPos + 1 * 3] * win[Encoder.SHORT_TYPE][1] - inout[inoutPos + 4 * 3]) * 2.069978111953089e-11;\n\t\t\t/*\n\t\t\t * tritab_s [ 1 ]\n\t\t\t */\n\t\t\tts0 = (inout[inoutPos + 4 * 3] * win[Encoder.SHORT_TYPE][1] + inout[inoutPos + 1 * 3]) * 2.069978111953089e-11;\n\t\t\t/*\n\t\t\t * tritab_s [ 1 ]\n\t\t\t */\n\t\t\tinout[inoutPos + 3 * 0] = tc1 * 1.907525191737280e-11 + tc0;\n\t\t\t/*\n\t\t\t * tritab_s[ 2 ]\n\t\t\t */\n\t\t\tinout[inoutPos + 3 * 5] = -ts1 * 1.907525191737280e-11 + ts0;\n\t\t\t/*\n\t\t\t * tritab_s[0 ]\n\t\t\t */\n\t\t\ttc2 = tc2 * 0.86602540378443870761 * 1.907525191737281e-11;\n\t\t\t/*\n\t\t\t * tritab_s[ 2]\n\t\t\t */\n\t\t\tts1 = ts1 * 0.5 * 1.907525191737281e-11 + ts0;\n\t\t\tinout[inoutPos + 3 * 1] = tc2 - ts1;\n\t\t\tinout[inoutPos + 3 * 2] = tc2 + ts1;\n\n\t\t\ttc1 = tc1 * 0.5 * 1.907525191737281e-11 - tc0;\n\t\t\tts2 = ts2 * 0.86602540378443870761 * 1.907525191737281e-11;\n\t\t\t/*\n\t\t\t * tritab_s[ 0]\n\t\t\t */\n\t\t\tinout[inoutPos + 3 * 3] = tc1 + ts2;\n\t\t\tinout[inoutPos + 3 * 4] = tc1 - ts2;\n\n\t\t\tinoutPos++;\n\t\t}\n\t}\n\n\tfunction mdct_long(out, outPos, _in) {\n\t\tvar ct, st;\n\t\t{\n\t\t\tvar tc1, tc2, tc3, tc4, ts5, ts6, ts7, ts8;\n\t\t\t/* 1,2, 5,6, 9,10, 13,14, 17 */\n\t\t\ttc1 = _in[17] - _in[9];\n\t\t\ttc3 = _in[15] - _in[11];\n\t\t\ttc4 = _in[14] - _in[12];\n\t\t\tts5 = _in[0] + _in[8];\n\t\t\tts6 = _in[1] + _in[7];\n\t\t\tts7 = _in[2] + _in[6];\n\t\t\tts8 = _in[3] + _in[5];\n\n\t\t\tout[outPos + 17] = (ts5 + ts7 - ts8) - (ts6 - _in[4]);\n\t\t\tst = (ts5 + ts7 - ts8) * cx[12 + 7] + (ts6 - _in[4]);\n\t\t\tct = (tc1 - tc3 - tc4) * cx[12 + 6];\n\t\t\tout[outPos + 5] = ct + st;\n\t\t\tout[outPos + 6] = ct - st;\n\n\t\t\ttc2 = (_in[16] - _in[10]) * cx[12 + 6];\n\t\t\tts6 = ts6 * cx[12 + 7] + _in[4];\n\t\t\tct = tc1 * cx[12 + 0] + tc2 + tc3 * cx[12 + 1] + tc4 * cx[12 + 2];\n\t\t\tst = -ts5 * cx[12 + 4] + ts6 - ts7 * cx[12 + 5] + ts8 * cx[12 + 3];\n\t\t\tout[outPos + 1] = ct + st;\n\t\t\tout[outPos + 2] = ct - st;\n\n\t\t\tct = tc1 * cx[12 + 1] - tc2 - tc3 * cx[12 + 2] + tc4 * cx[12 + 0];\n\t\t\tst = -ts5 * cx[12 + 5] + ts6 - ts7 * cx[12 + 3] + ts8 * cx[12 + 4];\n\t\t\tout[outPos + 9] = ct + st;\n\t\t\tout[outPos + 10] = ct - st;\n\n\t\t\tct = tc1 * cx[12 + 2] - tc2 + tc3 * cx[12 + 0] - tc4 * cx[12 + 1];\n\t\t\tst = ts5 * cx[12 + 3] - ts6 + ts7 * cx[12 + 4] - ts8 * cx[12 + 5];\n\t\t\tout[outPos + 13] = ct + st;\n\t\t\tout[outPos + 14] = ct - st;\n\t\t}\n\t\t{\n\t\t\tvar ts1, ts2, ts3, ts4, tc5, tc6, tc7, tc8;\n\n\t\t\tts1 = _in[8] - _in[0];\n\t\t\tts3 = _in[6] - _in[2];\n\t\t\tts4 = _in[5] - _in[3];\n\t\t\ttc5 = _in[17] + _in[9];\n\t\t\ttc6 = _in[16] + _in[10];\n\t\t\ttc7 = _in[15] + _in[11];\n\t\t\ttc8 = _in[14] + _in[12];\n\n\t\t\tout[outPos + 0] = (tc5 + tc7 + tc8) + (tc6 + _in[13]);\n\t\t\tct = (tc5 + tc7 + tc8) * cx[12 + 7] - (tc6 + _in[13]);\n\t\t\tst = (ts1 - ts3 + ts4) * cx[12 + 6];\n\t\t\tout[outPos + 11] = ct + st;\n\t\t\tout[outPos + 12] = ct - st;\n\n\t\t\tts2 = (_in[7] - _in[1]) * cx[12 + 6];\n\t\t\ttc6 = _in[13] - tc6 * cx[12 + 7];\n\t\t\tct = tc5 * cx[12 + 3] - tc6 + tc7 * cx[12 + 4] + tc8 * cx[12 + 5];\n\t\t\tst = ts1 * cx[12 + 2] + ts2 + ts3 * cx[12 + 0] + ts4 * cx[12 + 1];\n\t\t\tout[outPos + 3] = ct + st;\n\t\t\tout[outPos + 4] = ct - st;\n\n\t\t\tct = -tc5 * cx[12 + 5] + tc6 - tc7 * cx[12 + 3] - tc8 * cx[12 + 4];\n\t\t\tst = ts1 * cx[12 + 1] + ts2 - ts3 * cx[12 + 2] - ts4 * cx[12 + 0];\n\t\t\tout[outPos + 7] = ct + st;\n\t\t\tout[outPos + 8] = ct - st;\n\n\t\t\tct = -tc5 * cx[12 + 4] + tc6 - tc7 * cx[12 + 5] - tc8 * cx[12 + 3];\n\t\t\tst = ts1 * cx[12 + 0] - ts2 + ts3 * cx[12 + 1] - ts4 * cx[12 + 2];\n\t\t\tout[outPos + 15] = ct + st;\n\t\t\tout[outPos + 16] = ct - st;\n\t\t}\n\t}\n\n\tthis.mdct_sub48 = function(gfc, w0, w1) {\n\t\tvar wk = w0;\n\t\tvar wkPos = 286;\n\t\t/* thinking cache performance, ch->gr loop is better than gr->ch loop */\n\t\tfor (var ch = 0; ch < gfc.channels_out; ch++) {\n\t\t\tfor (var gr = 0; gr < gfc.mode_gr; gr++) {\n\t\t\t\tvar band;\n\t\t\t\tvar gi = (gfc.l3_side.tt[gr][ch]);\n\t\t\t\tvar mdct_enc = gi.xr;\n\t\t\t\tvar mdct_encPos = 0;\n\t\t\t\tvar samp = gfc.sb_sample[ch][1 - gr];\n\t\t\t\tvar sampPos = 0;\n\n\t\t\t\tfor (var k = 0; k < 18 / 2; k++) {\n\t\t\t\t\twindow_subband(wk, wkPos, samp[sampPos]);\n\t\t\t\t\twindow_subband(wk, wkPos + 32, samp[sampPos + 1]);\n\t\t\t\t\tsampPos += 2;\n\t\t\t\t\twkPos += 64;\n\t\t\t\t\t/*\n\t\t\t\t\t * Compensate for inversion in the analysis filter\n\t\t\t\t\t */\n\t\t\t\t\tfor (band = 1; band < 32; band += 2) {\n\t\t\t\t\t\tsamp[sampPos - 1][band] *= -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Perform imdct of 18 previous subband samples + 18 current\n\t\t\t\t * subband samples\n\t\t\t\t */\n\t\t\t\tfor (band = 0; band < 32; band++, mdct_encPos += 18) {\n\t\t\t\t\tvar type = gi.block_type;\n\t\t\t\t\tvar band0 = gfc.sb_sample[ch][gr];\n\t\t\t\t\tvar band1 = gfc.sb_sample[ch][1 - gr];\n\t\t\t\t\tif (gi.mixed_block_flag != 0 && band < 2)\n\t\t\t\t\t\ttype = 0;\n\t\t\t\t\tif (gfc.amp_filter[band] < 1e-12) {\n\t\t\t\t\t\tArrays.fill(mdct_enc, mdct_encPos + 0,\n\t\t\t\t\t\t\t\tmdct_encPos + 18, 0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (gfc.amp_filter[band] < 1.0) {\n\t\t\t\t\t\t\tfor (var k = 0; k < 18; k++)\n\t\t\t\t\t\t\t\tband1[k][order[band]] *= gfc.amp_filter[band];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (type == Encoder.SHORT_TYPE) {\n\t\t\t\t\t\t\tfor (var k = -NS / 4; k < 0; k++) {\n\t\t\t\t\t\t\t\tvar w = win[Encoder.SHORT_TYPE][k + 3];\n\t\t\t\t\t\t\t\tmdct_enc[mdct_encPos + k * 3 + 9] = band0[9 + k][order[band]]\n\t\t\t\t\t\t\t\t\t\t* w - band0[8 - k][order[band]];\n\t\t\t\t\t\t\t\tmdct_enc[mdct_encPos + k * 3 + 18] = band0[14 - k][order[band]]\n\t\t\t\t\t\t\t\t\t\t* w + band0[15 + k][order[band]];\n\t\t\t\t\t\t\t\tmdct_enc[mdct_encPos + k * 3 + 10] = band0[15 + k][order[band]]\n\t\t\t\t\t\t\t\t\t\t* w - band0[14 - k][order[band]];\n\t\t\t\t\t\t\t\tmdct_enc[mdct_encPos + k * 3 + 19] = band1[2 - k][order[band]]\n\t\t\t\t\t\t\t\t\t\t* w + band1[3 + k][order[band]];\n\t\t\t\t\t\t\t\tmdct_enc[mdct_encPos + k * 3 + 11] = band1[3 + k][order[band]]\n\t\t\t\t\t\t\t\t\t\t* w - band1[2 - k][order[band]];\n\t\t\t\t\t\t\t\tmdct_enc[mdct_encPos + k * 3 + 20] = band1[8 - k][order[band]]\n\t\t\t\t\t\t\t\t\t\t* w + band1[9 + k][order[band]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmdct_short(mdct_enc, mdct_encPos);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar work = new_float(18);\n\t\t\t\t\t\t\tfor (var k = -NL / 4; k < 0; k++) {\n\t\t\t\t\t\t\t\tvar a, b;\n\t\t\t\t\t\t\t\ta = win[type][k + 27]\n\t\t\t\t\t\t\t\t\t\t* band1[k + 9][order[band]]\n\t\t\t\t\t\t\t\t\t\t+ win[type][k + 36]\n\t\t\t\t\t\t\t\t\t\t* band1[8 - k][order[band]];\n\t\t\t\t\t\t\t\tb = win[type][k + 9]\n\t\t\t\t\t\t\t\t\t\t* band0[k + 9][order[band]]\n\t\t\t\t\t\t\t\t\t\t- win[type][k + 18]\n\t\t\t\t\t\t\t\t\t\t* band0[8 - k][order[band]];\n\t\t\t\t\t\t\t\twork[k + 9] = a - b * tantab_l[3 + k + 9];\n\t\t\t\t\t\t\t\twork[k + 18] = a * tantab_l[3 + k + 9] + b;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tmdct_long(mdct_enc, mdct_encPos, work);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * Perform aliasing reduction butterfly\n\t\t\t\t\t */\n\t\t\t\t\tif (type != Encoder.SHORT_TYPE && band != 0) {\n\t\t\t\t\t\tfor (var k = 7; k >= 0; --k) {\n\t\t\t\t\t\t\tvar bu, bd;\n\t\t\t\t\t\t\tbu = mdct_enc[mdct_encPos + k] * ca[20 + k]\n\t\t\t\t\t\t\t\t\t+ mdct_enc[mdct_encPos + -1 - k]\n\t\t\t\t\t\t\t\t\t* cs[28 + k];\n\t\t\t\t\t\t\tbd = mdct_enc[mdct_encPos + k] * cs[28 + k]\n\t\t\t\t\t\t\t\t\t- mdct_enc[mdct_encPos + -1 - k]\n\t\t\t\t\t\t\t\t\t* ca[20 + k];\n\n\t\t\t\t\t\t\tmdct_enc[mdct_encPos + -1 - k] = bu;\n\t\t\t\t\t\t\tmdct_enc[mdct_encPos + k] = bd;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twk = w1;\n\t\t\twkPos = 286;\n\t\t\tif (gfc.mode_gr == 1) {\n\t\t\t\tfor (var i = 0; i < 18; i++) {\n\t\t\t\t\tSystem.arraycopy(gfc.sb_sample[ch][1][i], 0,\n\t\t\t\t\t\t\tgfc.sb_sample[ch][0][i], 0, 32);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nmodule.exports = NewMDCT;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL05ld01EQ1QuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxhQUFhLG1CQUFPLENBQUMsK0VBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLG1CQUFPLENBQUMsaUZBQWM7OztBQUdwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQixPQUFPO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUMsb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsV0FBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE9BQU87QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsNkJBQTZCLE9BQU87QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xhbWVqcy9zcmMvanMvTmV3TURDVC5qcz9mMjc2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiAgICAgIE1QMyB3aW5kb3cgc3ViYmFuZCAtPiBzdWJiYW5kIGZpbHRlcmluZyAtPiBtZGN0IHJvdXRpbmVcbiAqXG4gKiAgICAgIENvcHlyaWdodCAoYykgMTk5OS0yMDAwIFRha2VoaXJvIFRvbWluYWdhXG4gKlxuICpcbiAqIFRoaXMgbGlicmFyeSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAqIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcbiAqIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb247IGVpdGhlclxuICogdmVyc2lvbiAyIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuICpcbiAqIFRoaXMgbGlicmFyeSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGUgR05VXG4gKiBMaWJyYXJ5IEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGlicmFyeSBHZW5lcmFsIFB1YmxpY1xuICogTGljZW5zZSBhbG9uZyB3aXRoIHRoaXMgbGlicmFyeTsgaWYgbm90LCB3cml0ZSB0byB0aGVcbiAqIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLFxuICogQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG4gKi9cbi8qXG4gKiAgICAgICAgIFNwZWNpYWwgVGhhbmtzIHRvIFBhdHJpY2sgRGUgU21ldCBmb3IgeW91ciBhZHZpY2VzLlxuICovXG5cbi8qICRJZDogTmV3TURDVC5qYXZhLHYgMS4xMSAyMDExLzA1LzI0IDIwOjQ4OjA2IGtlbmNoaXMgRXhwICQgKi9cblxuLy9wYWNrYWdlIG1wMztcblxuLy9pbXBvcnQgamF2YS51dGlsLkFycmF5cztcbnZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbi5qcycpO1xudmFyIFN5c3RlbSA9IGNvbW1vbi5TeXN0ZW07XG52YXIgVmJyTW9kZSA9IGNvbW1vbi5WYnJNb2RlO1xudmFyIEZsb2F0ID0gY29tbW9uLkZsb2F0O1xudmFyIFNob3J0QmxvY2sgPSBjb21tb24uU2hvcnRCbG9jaztcbnZhciBVdGlsID0gY29tbW9uLlV0aWw7XG52YXIgQXJyYXlzID0gY29tbW9uLkFycmF5cztcbnZhciBuZXdfYXJyYXlfbiA9IGNvbW1vbi5uZXdfYXJyYXlfbjtcbnZhciBuZXdfYnl0ZSA9IGNvbW1vbi5uZXdfYnl0ZTtcbnZhciBuZXdfZG91YmxlID0gY29tbW9uLm5ld19kb3VibGU7XG52YXIgbmV3X2Zsb2F0ID0gY29tbW9uLm5ld19mbG9hdDtcbnZhciBuZXdfZmxvYXRfbiA9IGNvbW1vbi5uZXdfZmxvYXRfbjtcbnZhciBuZXdfaW50ID0gY29tbW9uLm5ld19pbnQ7XG52YXIgbmV3X2ludF9uID0gY29tbW9uLm5ld19pbnRfbjtcbnZhciBhc3NlcnQgPSBjb21tb24uYXNzZXJ0O1xuXG52YXIgRW5jb2RlciA9IHJlcXVpcmUoJy4vRW5jb2Rlci5qcycpO1xuXG5cbmZ1bmN0aW9uIE5ld01EQ1QoKSB7XG5cblx0dmFyIGVud2luZG93ID0gW1xuXHRcdFx0LTQuNzdlLTA3ICogMC43NDA5NTExMjUzNTQ5NTkgLyAyLjM4NGUtMDYsXG5cdFx0XHQxLjAzOTUxZS0wNCAqIDAuNzQwOTUxMTI1MzU0OTU5IC8gMi4zODRlLTA2LFxuXHRcdFx0OS41MzY3NGUtMDQgKiAwLjc0MDk1MTEyNTM1NDk1OSAvIDIuMzg0ZS0wNixcblx0XHRcdDIuODQxNDczZS0wMyAqIDAuNzQwOTUxMTI1MzU0OTU5IC8gMi4zODRlLTA2LFxuXHRcdFx0My41NzU4OTcyZS0wMiAqIDAuNzQwOTUxMTI1MzU0OTU5IC8gMi4zODRlLTA2LFxuXHRcdFx0My40MDE3NTZlLTAzICogMC43NDA5NTExMjUzNTQ5NTkgLyAyLjM4NGUtMDYsXG5cdFx0XHQ5LjgzNzE1ZS0wNCAqIDAuNzQwOTUxMTI1MzU0OTU5IC8gMi4zODRlLTA2LFxuXHRcdFx0OS45MTgyZS0wNSAqIDAuNzQwOTUxMTI1MzU0OTU5IC8gMi4zODRlLTA2LCAvKiAxNSAqL1xuXHRcdFx0MS4yMzk4ZS0wNSAqIDAuNzQwOTUxMTI1MzU0OTU5IC8gMi4zODRlLTA2LFxuXHRcdFx0MS45MTIxMmUtMDQgKiAwLjc0MDk1MTEyNTM1NDk1OSAvIDIuMzg0ZS0wNixcblx0XHRcdDIuMjgzMDk2ZS0wMyAqIDAuNzQwOTUxMTI1MzU0OTU5IC8gMi4zODRlLTA2LFxuXHRcdFx0MS42OTk0NDc2ZS0wMiAqIDAuNzQwOTUxMTI1MzU0OTU5IC8gMi4zODRlLTA2LFxuXHRcdFx0LTEuODc1Njg2NmUtMDIgKiAwLjc0MDk1MTEyNTM1NDk1OSAvIDIuMzg0ZS0wNixcblx0XHRcdC0yLjYzMDcxMWUtMDMgKiAwLjc0MDk1MTEyNTM1NDk1OSAvIDIuMzg0ZS0wNixcblx0XHRcdC0yLjQ3NDc4ZS0wNCAqIDAuNzQwOTUxMTI1MzU0OTU5IC8gMi4zODRlLTA2LFxuXHRcdFx0LTEuNDc4MmUtMDUgKiAwLjc0MDk1MTEyNTM1NDk1OSAvIDIuMzg0ZS0wNixcblx0XHRcdDkuMDYzNDcxNjkwMTkxNDcxZS0wMSwgMS45NjAzNDI4MDY1OTEyMTNlLTAxLFxuXG5cdFx0XHQtNC43N2UtMDcgKiAwLjc3MzAxMDQ1MzM2MjczNyAvIDIuMzg0ZS0wNixcblx0XHRcdDEuMDU4NThlLTA0ICogMC43NzMwMTA0NTMzNjI3MzcgLyAyLjM4NGUtMDYsXG5cdFx0XHQ5LjMwNzg2ZS0wNCAqIDAuNzczMDEwNDUzMzYyNzM3IC8gMi4zODRlLTA2LFxuXHRcdFx0Mi41MjE1MTVlLTAzICogMC43NzMwMTA0NTMzNjI3MzcgLyAyLjM4NGUtMDYsXG5cdFx0XHQzLjU2OTQxMjJlLTAyICogMC43NzMwMTA0NTMzNjI3MzcgLyAyLjM4NGUtMDYsXG5cdFx0XHQzLjY0MzAzNmUtMDMgKiAwLjc3MzAxMDQ1MzM2MjczNyAvIDIuMzg0ZS0wNixcblx0XHRcdDkuOTE4MjFlLTA0ICogMC43NzMwMTA0NTMzNjI3MzcgLyAyLjM4NGUtMDYsXG5cdFx0XHQ5LjYzMjFlLTA1ICogMC43NzMwMTA0NTMzNjI3MzcgLyAyLjM4NGUtMDYsIC8qIDE0ICovXG5cdFx0XHQxLjE0NDRlLTA1ICogMC43NzMwMTA0NTMzNjI3MzcgLyAyLjM4NGUtMDYsXG5cdFx0XHQxLjY1NDYyZS0wNCAqIDAuNzczMDEwNDUzMzYyNzM3IC8gMi4zODRlLTA2LFxuXHRcdFx0Mi4xMTAwMDRlLTAzICogMC43NzMwMTA0NTMzNjI3MzcgLyAyLjM4NGUtMDYsXG5cdFx0XHQxLjYxMTI4MDRlLTAyICogMC43NzMwMTA0NTMzNjI3MzcgLyAyLjM4NGUtMDYsXG5cdFx0XHQtMS45NjM0MjQ3ZS0wMiAqIDAuNzczMDEwNDUzMzYyNzM3IC8gMi4zODRlLTA2LFxuXHRcdFx0LTIuODAzMzI2ZS0wMyAqIDAuNzczMDEwNDUzMzYyNzM3IC8gMi4zODRlLTA2LFxuXHRcdFx0LTIuNzcwNDJlLTA0ICogMC43NzMwMTA0NTMzNjI3MzcgLyAyLjM4NGUtMDYsXG5cdFx0XHQtMS42Njg5ZS0wNSAqIDAuNzczMDEwNDUzMzYyNzM3IC8gMi4zODRlLTA2LFxuXHRcdFx0OC4yMDY3ODc5MDgyODY2MDJlLTAxLCAzLjkwMTgwNjQ0MDMyMjU2N2UtMDEsXG5cblx0XHRcdC00Ljc3ZS0wNyAqIDAuODAzMjA3NTMxNDgwNjQ1IC8gMi4zODRlLTA2LFxuXHRcdFx0MS4wNzI4OGUtMDQgKiAwLjgwMzIwNzUzMTQ4MDY0NSAvIDIuMzg0ZS0wNixcblx0XHRcdDkuMDI2NTNlLTA0ICogMC44MDMyMDc1MzE0ODA2NDUgLyAyLjM4NGUtMDYsXG5cdFx0XHQyLjE3NDg1NGUtMDMgKiAwLjgwMzIwNzUzMTQ4MDY0NSAvIDIuMzg0ZS0wNixcblx0XHRcdDMuNTU4NjM1N2UtMDIgKiAwLjgwMzIwNzUzMTQ4MDY0NSAvIDIuMzg0ZS0wNixcblx0XHRcdDMuODU4NTY2ZS0wMyAqIDAuODAzMjA3NTMxNDgwNjQ1IC8gMi4zODRlLTA2LFxuXHRcdFx0OS45NTE1OWUtMDQgKiAwLjgwMzIwNzUzMTQ4MDY0NSAvIDIuMzg0ZS0wNixcblx0XHRcdDkuMzQ2MGUtMDUgKiAwLjgwMzIwNzUzMTQ4MDY0NSAvIDIuMzg0ZS0wNiwgLyogMTMgKi9cblx0XHRcdDEuMDAxNGUtMDUgKiAwLjgwMzIwNzUzMTQ4MDY0NSAvIDIuMzg0ZS0wNixcblx0XHRcdDEuNDAxOTBlLTA0ICogMC44MDMyMDc1MzE0ODA2NDUgLyAyLjM4NGUtMDYsXG5cdFx0XHQxLjkzNzM4OWUtMDMgKiAwLjgwMzIwNzUzMTQ4MDY0NSAvIDIuMzg0ZS0wNixcblx0XHRcdDEuNTIzMzUxN2UtMDIgKiAwLjgwMzIwNzUzMTQ4MDY0NSAvIDIuMzg0ZS0wNixcblx0XHRcdC0yLjA1MDY4NTllLTAyICogMC44MDMyMDc1MzE0ODA2NDUgLyAyLjM4NGUtMDYsXG5cdFx0XHQtMi45NzQwMzNlLTAzICogMC44MDMyMDc1MzE0ODA2NDUgLyAyLjM4NGUtMDYsXG5cdFx0XHQtMy4wNzU2MGUtMDQgKiAwLjgwMzIwNzUzMTQ4MDY0NSAvIDIuMzg0ZS0wNixcblx0XHRcdC0xLjgxMjBlLTA1ICogMC44MDMyMDc1MzE0ODA2NDUgLyAyLjM4NGUtMDYsXG5cdFx0XHQ3LjQxNjUwNTQ2MjcyMDM1M2UtMDEsIDUuODA1NjkzNTQ1MDg5MjQ5ZS0wMSxcblxuXHRcdFx0LTQuNzdlLTA3ICogMC44MzE0Njk2MTIzMDI1NDUgLyAyLjM4NGUtMDYsXG5cdFx0XHQxLjA4MjQyZS0wNCAqIDAuODMxNDY5NjEyMzAyNTQ1IC8gMi4zODRlLTA2LFxuXHRcdFx0OC42ODc5N2UtMDQgKiAwLjgzMTQ2OTYxMjMwMjU0NSAvIDIuMzg0ZS0wNixcblx0XHRcdDEuODAwNTM3ZS0wMyAqIDAuODMxNDY5NjEyMzAyNTQ1IC8gMi4zODRlLTA2LFxuXHRcdFx0My41NDM1MjAwZS0wMiAqIDAuODMxNDY5NjEyMzAyNTQ1IC8gMi4zODRlLTA2LFxuXHRcdFx0NC4wNDkzMDFlLTAzICogMC44MzE0Njk2MTIzMDI1NDUgLyAyLjM4NGUtMDYsXG5cdFx0XHQ5Ljk0MjA1ZS0wNCAqIDAuODMxNDY5NjEyMzAyNTQ1IC8gMi4zODRlLTA2LFxuXHRcdFx0OS4wNTk5ZS0wNSAqIDAuODMxNDY5NjEyMzAyNTQ1IC8gMi4zODRlLTA2LCAvKiAxMiAqL1xuXHRcdFx0OS4wNjBlLTA2ICogMC44MzE0Njk2MTIzMDI1NDUgLyAyLjM4NGUtMDYsXG5cdFx0XHQxLjE2MzQ4ZS0wNCAqIDAuODMxNDY5NjEyMzAyNTQ1IC8gMi4zODRlLTA2LFxuXHRcdFx0MS43NjY2ODJlLTAzICogMC44MzE0Njk2MTIzMDI1NDUgLyAyLjM4NGUtMDYsXG5cdFx0XHQxLjQzNTg1MjFlLTAyICogMC44MzE0Njk2MTIzMDI1NDUgLyAyLjM4NGUtMDYsXG5cdFx0XHQtMi4xMzcyMzE4ZS0wMiAqIDAuODMxNDY5NjEyMzAyNTQ1IC8gMi4zODRlLTA2LFxuXHRcdFx0LTMuMTQxODhlLTAzICogMC44MzE0Njk2MTIzMDI1NDUgLyAyLjM4NGUtMDYsXG5cdFx0XHQtMy4zOTAzMWUtMDQgKiAwLjgzMTQ2OTYxMjMwMjU0NSAvIDIuMzg0ZS0wNixcblx0XHRcdC0xLjk1NTBlLTA1ICogMC44MzE0Njk2MTIzMDI1NDUgLyAyLjM4NGUtMDYsXG5cdFx0XHQ2LjY4MTc4NjM3OTE5Mjk4OWUtMDEsIDcuNjUzNjY4NjQ3MzAxNzk3ZS0wMSxcblxuXHRcdFx0LTQuNzdlLTA3ICogMC44NTc3Mjg2MTAwMDAyNzIgLyAyLjM4NGUtMDYsXG5cdFx0XHQxLjA4NzE5ZS0wNCAqIDAuODU3NzI4NjEwMDAwMjcyIC8gMi4zODRlLTA2LFxuXHRcdFx0OC4yOTIyMGUtMDQgKiAwLjg1NzcyODYxMDAwMDI3MiAvIDIuMzg0ZS0wNixcblx0XHRcdDEuMzk5NTE3ZS0wMyAqIDAuODU3NzI4NjEwMDAwMjcyIC8gMi4zODRlLTA2LFxuXHRcdFx0My41MjQyMDgxZS0wMiAqIDAuODU3NzI4NjEwMDAwMjcyIC8gMi4zODRlLTA2LFxuXHRcdFx0NC4yMTUyNDBlLTAzICogMC44NTc3Mjg2MTAwMDAyNzIgLyAyLjM4NGUtMDYsXG5cdFx0XHQ5Ljg5NDM3ZS0wNCAqIDAuODU3NzI4NjEwMDAwMjcyIC8gMi4zODRlLTA2LFxuXHRcdFx0OC43MjYxZS0wNSAqIDAuODU3NzI4NjEwMDAwMjcyIC8gMi4zODRlLTA2LCAvKiAxMSAqL1xuXHRcdFx0OC4xMDZlLTA2ICogMC44NTc3Mjg2MTAwMDAyNzIgLyAyLjM4NGUtMDYsXG5cdFx0XHQ5LjM5MzdlLTA1ICogMC44NTc3Mjg2MTAwMDAyNzIgLyAyLjM4NGUtMDYsXG5cdFx0XHQxLjU5Nzg4MWUtMDMgKiAwLjg1NzcyODYxMDAwMDI3MiAvIDIuMzg0ZS0wNixcblx0XHRcdDEuMzQ4OTI0NmUtMDIgKiAwLjg1NzcyODYxMDAwMDI3MiAvIDIuMzg0ZS0wNixcblx0XHRcdC0yLjIyMjg3MThlLTAyICogMC44NTc3Mjg2MTAwMDAyNzIgLyAyLjM4NGUtMDYsXG5cdFx0XHQtMy4zMDY4NjZlLTAzICogMC44NTc3Mjg2MTAwMDAyNzIgLyAyLjM4NGUtMDYsXG5cdFx0XHQtMy43MTQ1NmUtMDQgKiAwLjg1NzcyODYxMDAwMDI3MiAvIDIuMzg0ZS0wNixcblx0XHRcdC0yLjE0NThlLTA1ICogMC44NTc3Mjg2MTAwMDAyNzIgLyAyLjM4NGUtMDYsXG5cdFx0XHQ1Ljk5Mzc2OTMzNjgxOTIzN2UtMDEsIDkuNDI3OTM0NzM2NTE5OTU0ZS0wMSxcblxuXHRcdFx0LTQuNzdlLTA3ICogMC44ODE5MjEyNjQzNDgzNTUgLyAyLjM4NGUtMDYsXG5cdFx0XHQxLjA4NzE5ZS0wNCAqIDAuODgxOTIxMjY0MzQ4MzU1IC8gMi4zODRlLTA2LFxuXHRcdFx0Ny44MzkyZS0wNCAqIDAuODgxOTIxMjY0MzQ4MzU1IC8gMi4zODRlLTA2LFxuXHRcdFx0OS43MTMxN2UtMDQgKiAwLjg4MTkyMTI2NDM0ODM1NSAvIDIuMzg0ZS0wNixcblx0XHRcdDMuNTAwNzAwMGUtMDIgKiAwLjg4MTkyMTI2NDM0ODM1NSAvIDIuMzg0ZS0wNixcblx0XHRcdDQuMzU3ODE1ZS0wMyAqIDAuODgxOTIxMjY0MzQ4MzU1IC8gMi4zODRlLTA2LFxuXHRcdFx0OS44MDg1NGUtMDQgKiAwLjg4MTkyMTI2NDM0ODM1NSAvIDIuMzg0ZS0wNixcblx0XHRcdDguMzkyM2UtMDUgKiAwLjg4MTkyMTI2NDM0ODM1NSAvIDIuMzg0ZS0wNiwgLyogMTAgKi9cblx0XHRcdDcuNjI5ZS0wNiAqIDAuODgxOTIxMjY0MzQ4MzU1IC8gMi4zODRlLTA2LFxuXHRcdFx0Ny4yOTU2ZS0wNSAqIDAuODgxOTIxMjY0MzQ4MzU1IC8gMi4zODRlLTA2LFxuXHRcdFx0MS40MzI0MTllLTAzICogMC44ODE5MjEyNjQzNDgzNTUgLyAyLjM4NGUtMDYsXG5cdFx0XHQxLjI2Mjc2MDJlLTAyICogMC44ODE5MjEyNjQzNDgzNTUgLyAyLjM4NGUtMDYsXG5cdFx0XHQtMi4zMDc0MTUwZS0wMiAqIDAuODgxOTIxMjY0MzQ4MzU1IC8gMi4zODRlLTA2LFxuXHRcdFx0LTMuNDY3MDgzZS0wMyAqIDAuODgxOTIxMjY0MzQ4MzU1IC8gMi4zODRlLTA2LFxuXHRcdFx0LTQuMDQzNThlLTA0ICogMC44ODE5MjEyNjQzNDgzNTUgLyAyLjM4NGUtMDYsXG5cdFx0XHQtMi4zMzY1ZS0wNSAqIDAuODgxOTIxMjY0MzQ4MzU1IC8gMi4zODRlLTA2LFxuXHRcdFx0NS4zNDUxMTEzNTk1MDc5MTZlLTAxLCAxLjExMTE0MDQ2NjAzOTIwNWUrMDAsXG5cblx0XHRcdC05LjU0ZS0wNyAqIDAuOTAzOTg5MjkzMTIzNDQzIC8gMi4zODRlLTA2LFxuXHRcdFx0MS4wODI0MmUtMDQgKiAwLjkwMzk4OTI5MzEyMzQ0MyAvIDIuMzg0ZS0wNixcblx0XHRcdDcuMzE5NDVlLTA0ICogMC45MDM5ODkyOTMxMjM0NDMgLyAyLjM4NGUtMDYsXG5cdFx0XHQ1LjE1OTM4ZS0wNCAqIDAuOTAzOTg5MjkzMTIzNDQzIC8gMi4zODRlLTA2LFxuXHRcdFx0My40NzMwNDM0ZS0wMiAqIDAuOTAzOTg5MjkzMTIzNDQzIC8gMi4zODRlLTA2LFxuXHRcdFx0NC40NzcwMjRlLTAzICogMC45MDM5ODkyOTMxMjM0NDMgLyAyLjM4NGUtMDYsXG5cdFx0XHQ5LjY4OTMzZS0wNCAqIDAuOTAzOTg5MjkzMTIzNDQzIC8gMi4zODRlLTA2LFxuXHRcdFx0OC4wNTg1ZS0wNSAqIDAuOTAzOTg5MjkzMTIzNDQzIC8gMi4zODRlLTA2LCAvKiA5ICovXG5cdFx0XHQ2LjY3NmUtMDYgKiAwLjkwMzk4OTI5MzEyMzQ0MyAvIDIuMzg0ZS0wNixcblx0XHRcdDUuMjkyOWUtMDUgKiAwLjkwMzk4OTI5MzEyMzQ0MyAvIDIuMzg0ZS0wNixcblx0XHRcdDEuMjY5ODE3ZS0wMyAqIDAuOTAzOTg5MjkzMTIzNDQzIC8gMi4zODRlLTA2LFxuXHRcdFx0MS4xNzc1MDE3ZS0wMiAqIDAuOTAzOTg5MjkzMTIzNDQzIC8gMi4zODRlLTA2LFxuXHRcdFx0LTIuMzkwNzE4NWUtMDIgKiAwLjkwMzk4OTI5MzEyMzQ0MyAvIDIuMzg0ZS0wNixcblx0XHRcdC0zLjYyMjUzMmUtMDMgKiAwLjkwMzk4OTI5MzEyMzQ0MyAvIDIuMzg0ZS0wNixcblx0XHRcdC00LjM4MjEzZS0wNCAqIDAuOTAzOTg5MjkzMTIzNDQzIC8gMi4zODRlLTA2LFxuXHRcdFx0LTIuNTI3MmUtMDUgKiAwLjkwMzk4OTI5MzEyMzQ0MyAvIDIuMzg0ZS0wNixcblx0XHRcdDQuNzI5NjQ3NzU4OTEzMTk5ZS0wMSwgMS4yNjg3ODY1NjgzMjcyOTFlKzAwLFxuXG5cdFx0XHQtOS41NGUtMDcgKiAwLjkyMzg3OTUzMjUxMTI4Njc1NjEzIC8gMi4zODRlLTA2LFxuXHRcdFx0MS4wNjgxMmUtMDQgKiAwLjkyMzg3OTUzMjUxMTI4Njc1NjEzIC8gMi4zODRlLTA2LFxuXHRcdFx0Ni43NDI0OGUtMDQgKiAwLjkyMzg3OTUzMjUxMTI4Njc1NjEzIC8gMi4zODRlLTA2LFxuXHRcdFx0My4zMzc5ZS0wNSAqIDAuOTIzODc5NTMyNTExMjg2NzU2MTMgLyAyLjM4NGUtMDYsXG5cdFx0XHQzLjQ0MTI4NjFlLTAyICogMC45MjM4Nzk1MzI1MTEyODY3NTYxMyAvIDIuMzg0ZS0wNixcblx0XHRcdDQuNTczODIyZS0wMyAqIDAuOTIzODc5NTMyNTExMjg2NzU2MTMgLyAyLjM4NGUtMDYsXG5cdFx0XHQ5LjU0MTUxZS0wNCAqIDAuOTIzODc5NTMyNTExMjg2NzU2MTMgLyAyLjM4NGUtMDYsXG5cdFx0XHQ3LjY3NzFlLTA1ICogMC45MjM4Nzk1MzI1MTEyODY3NTYxMyAvIDIuMzg0ZS0wNixcblx0XHRcdDYuMTk5ZS0wNiAqIDAuOTIzODc5NTMyNTExMjg2NzU2MTMgLyAyLjM4NGUtMDYsXG5cdFx0XHQzLjQzMzJlLTA1ICogMC45MjM4Nzk1MzI1MTEyODY3NTYxMyAvIDIuMzg0ZS0wNixcblx0XHRcdDEuMTExMDMxZS0wMyAqIDAuOTIzODc5NTMyNTExMjg2NzU2MTMgLyAyLjM4NGUtMDYsXG5cdFx0XHQxLjA5MzMzOTllLTAyICogMC45MjM4Nzk1MzI1MTEyODY3NTYxMyAvIDIuMzg0ZS0wNixcblx0XHRcdC0yLjQ3MjU0MzdlLTAyICogMC45MjM4Nzk1MzI1MTEyODY3NTYxMyAvIDIuMzg0ZS0wNixcblx0XHRcdC0zLjc3MTc4MmUtMDMgKiAwLjkyMzg3OTUzMjUxMTI4Njc1NjEzIC8gMi4zODRlLTA2LFxuXHRcdFx0LTQuNzI1NDZlLTA0ICogMC45MjM4Nzk1MzI1MTEyODY3NTYxMyAvIDIuMzg0ZS0wNixcblx0XHRcdC0yLjc2NTdlLTA1ICogMC45MjM4Nzk1MzI1MTEyODY3NTYxMyAvIDIuMzg0ZS0wNixcblx0XHRcdDQuMTQyMTM1NjIzNzMwOTUwNDg3OWUtMDEsIC8qIHRhbihQSS84KSAqL1xuXHRcdFx0MS40MTQyMTM1NjIzNzMwOTVlKzAwLFxuXG5cdFx0XHQtOS41NGUtMDcgKiAwLjk0MTU0NDA2NTE4MzAyMSAvIDIuMzg0ZS0wNixcblx0XHRcdDEuMDUzODFlLTA0ICogMC45NDE1NDQwNjUxODMwMjEgLyAyLjM4NGUtMDYsXG5cdFx0XHQ2LjEwMzUyZS0wNCAqIDAuOTQxNTQ0MDY1MTgzMDIxIC8gMi4zODRlLTA2LFxuXHRcdFx0LTQuNzU4ODNlLTA0ICogMC45NDE1NDQwNjUxODMwMjEgLyAyLjM4NGUtMDYsXG5cdFx0XHQzLjQwNTU3MTBlLTAyICogMC45NDE1NDQwNjUxODMwMjEgLyAyLjM4NGUtMDYsXG5cdFx0XHQ0LjY0OTE2MmUtMDMgKiAwLjk0MTU0NDA2NTE4MzAyMSAvIDIuMzg0ZS0wNixcblx0XHRcdDkuMzU1NTVlLTA0ICogMC45NDE1NDQwNjUxODMwMjEgLyAyLjM4NGUtMDYsXG5cdFx0XHQ3LjM0MzNlLTA1ICogMC45NDE1NDQwNjUxODMwMjEgLyAyLjM4NGUtMDYsIC8qIDcgKi9cblx0XHRcdDUuMjQ1ZS0wNiAqIDAuOTQxNTQ0MDY1MTgzMDIxIC8gMi4zODRlLTA2LFxuXHRcdFx0MS43MTY2ZS0wNSAqIDAuOTQxNTQ0MDY1MTgzMDIxIC8gMi4zODRlLTA2LFxuXHRcdFx0OS41NjUzNWUtMDQgKiAwLjk0MTU0NDA2NTE4MzAyMSAvIDIuMzg0ZS0wNixcblx0XHRcdDEuMDEwMzcwM2UtMDIgKiAwLjk0MTU0NDA2NTE4MzAyMSAvIDIuMzg0ZS0wNixcblx0XHRcdC0yLjU1MjcwMDBlLTAyICogMC45NDE1NDQwNjUxODMwMjEgLyAyLjM4NGUtMDYsXG5cdFx0XHQtMy45MTQzNTZlLTAzICogMC45NDE1NDQwNjUxODMwMjEgLyAyLjM4NGUtMDYsXG5cdFx0XHQtNS4wNzM1NWUtMDQgKiAwLjk0MTU0NDA2NTE4MzAyMSAvIDIuMzg0ZS0wNixcblx0XHRcdC0zLjAwNDFlLTA1ICogMC45NDE1NDQwNjUxODMwMjEgLyAyLjM4NGUtMDYsXG5cdFx0XHQzLjU3ODA1NzIxMzE0NTI0MWUtMDEsIDEuNTQ2MDIwOTA2NzI1NDc0ZSswMCxcblxuXHRcdFx0LTkuNTRlLTA3ICogMC45NTY5NDAzMzU3MzIyMDkgLyAyLjM4NGUtMDYsXG5cdFx0XHQxLjAyNTIwZS0wNCAqIDAuOTU2OTQwMzM1NzMyMjA5IC8gMi4zODRlLTA2LFxuXHRcdFx0NS4zOTMwM2UtMDQgKiAwLjk1Njk0MDMzNTczMjIwOSAvIDIuMzg0ZS0wNixcblx0XHRcdC0xLjAxMTg0OGUtMDMgKiAwLjk1Njk0MDMzNTczMjIwOSAvIDIuMzg0ZS0wNixcblx0XHRcdDMuMzY1OTkzNWUtMDIgKiAwLjk1Njk0MDMzNTczMjIwOSAvIDIuMzg0ZS0wNixcblx0XHRcdDQuNzAzMDQ1ZS0wMyAqIDAuOTU2OTQwMzM1NzMyMjA5IC8gMi4zODRlLTA2LFxuXHRcdFx0OS4xNTA1MWUtMDQgKiAwLjk1Njk0MDMzNTczMjIwOSAvIDIuMzg0ZS0wNixcblx0XHRcdDcuMDA5NWUtMDUgKiAwLjk1Njk0MDMzNTczMjIwOSAvIDIuMzg0ZS0wNiwgLyogNiAqL1xuXHRcdFx0NC43NjhlLTA2ICogMC45NTY5NDAzMzU3MzIyMDkgLyAyLjM4NGUtMDYsXG5cdFx0XHQ5LjU0ZS0wNyAqIDAuOTU2OTQwMzM1NzMyMjA5IC8gMi4zODRlLTA2LFxuXHRcdFx0OC4wNjgwOGUtMDQgKiAwLjk1Njk0MDMzNTczMjIwOSAvIDIuMzg0ZS0wNixcblx0XHRcdDkuMjg3ODM0ZS0wMyAqIDAuOTU2OTQwMzM1NzMyMjA5IC8gMi4zODRlLTA2LFxuXHRcdFx0LTIuNjMxMDkyMWUtMDIgKiAwLjk1Njk0MDMzNTczMjIwOSAvIDIuMzg0ZS0wNixcblx0XHRcdC00LjA0ODgyNGUtMDMgKiAwLjk1Njk0MDMzNTczMjIwOSAvIDIuMzg0ZS0wNixcblx0XHRcdC01LjQyMTY0ZS0wNCAqIDAuOTU2OTQwMzM1NzMyMjA5IC8gMi4zODRlLTA2LFxuXHRcdFx0LTMuMjQyNWUtMDUgKiAwLjk1Njk0MDMzNTczMjIwOSAvIDIuMzg0ZS0wNixcblx0XHRcdDMuMDMzNDY2ODM2MDczNDI0ZS0wMSwgMS42NjI5MzkyMjQ2MDUwOTBlKzAwLFxuXG5cdFx0XHQtMS40MzFlLTA2ICogMC45NzAwMzEyNTMxOTQ1NDQgLyAyLjM4NGUtMDYsXG5cdFx0XHQ5LjkxODJlLTA1ICogMC45NzAwMzEyNTMxOTQ1NDQgLyAyLjM4NGUtMDYsXG5cdFx0XHQ0LjYyNTMyZS0wNCAqIDAuOTcwMDMxMjUzMTk0NTQ0IC8gMi4zODRlLTA2LFxuXHRcdFx0LTEuNTczNTYzZS0wMyAqIDAuOTcwMDMxMjUzMTk0NTQ0IC8gMi4zODRlLTA2LFxuXHRcdFx0My4zMjI1NTM2ZS0wMiAqIDAuOTcwMDMxMjUzMTk0NTQ0IC8gMi4zODRlLTA2LFxuXHRcdFx0NC43MzczNzdlLTAzICogMC45NzAwMzEyNTMxOTQ1NDQgLyAyLjM4NGUtMDYsXG5cdFx0XHQ4LjkxNjg1ZS0wNCAqIDAuOTcwMDMxMjUzMTk0NTQ0IC8gMi4zODRlLTA2LFxuXHRcdFx0Ni42MjgwZS0wNSAqIDAuOTcwMDMxMjUzMTk0NTQ0IC8gMi4zODRlLTA2LCAvKiA1ICovXG5cdFx0XHQ0LjI5MmUtMDYgKiAwLjk3MDAzMTI1MzE5NDU0NCAvIDIuMzg0ZS0wNixcblx0XHRcdC0xLjM4MjhlLTA1ICogMC45NzAwMzEyNTMxOTQ1NDQgLyAyLjM4NGUtMDYsXG5cdFx0XHQ2LjYxODUwZS0wNCAqIDAuOTcwMDMxMjUzMTk0NTQ0IC8gMi4zODRlLTA2LFxuXHRcdFx0OC40ODcyMjVlLTAzICogMC45NzAwMzEyNTMxOTQ1NDQgLyAyLjM4NGUtMDYsXG5cdFx0XHQtMi43MDczODYwZS0wMiAqIDAuOTcwMDMxMjUzMTk0NTQ0IC8gMi4zODRlLTA2LFxuXHRcdFx0LTQuMTc0NzA5ZS0wMyAqIDAuOTcwMDMxMjUzMTk0NTQ0IC8gMi4zODRlLTA2LFxuXHRcdFx0LTUuNzY5NzNlLTA0ICogMC45NzAwMzEyNTMxOTQ1NDQgLyAyLjM4NGUtMDYsXG5cdFx0XHQtMy40ODA5ZS0wNSAqIDAuOTcwMDMxMjUzMTk0NTQ0IC8gMi4zODRlLTA2LFxuXHRcdFx0Mi41MDQ4Njk2MDE5MTMwNTVlLTAxLCAxLjc2Mzg0MjUyODY5NjcxMGUrMDAsXG5cblx0XHRcdC0xLjQzMWUtMDYgKiAwLjk4MDc4NTI4MDQwMzIzIC8gMi4zODRlLTA2LFxuXHRcdFx0OS41MzY3ZS0wNSAqIDAuOTgwNzg1MjgwNDAzMjMgLyAyLjM4NGUtMDYsXG5cdFx0XHQzLjc4NjA5ZS0wNCAqIDAuOTgwNzg1MjgwNDAzMjMgLyAyLjM4NGUtMDYsXG5cdFx0XHQtMi4xNjE1MDNlLTAzICogMC45ODA3ODUyODA0MDMyMyAvIDIuMzg0ZS0wNixcblx0XHRcdDMuMjc1NDg5OGUtMDIgKiAwLjk4MDc4NTI4MDQwMzIzIC8gMi4zODRlLTA2LFxuXHRcdFx0NC43NTIxNTllLTAzICogMC45ODA3ODUyODA0MDMyMyAvIDIuMzg0ZS0wNixcblx0XHRcdDguNjY0MTNlLTA0ICogMC45ODA3ODUyODA0MDMyMyAvIDIuMzg0ZS0wNixcblx0XHRcdDYuMjk0M2UtMDUgKiAwLjk4MDc4NTI4MDQwMzIzIC8gMi4zODRlLTA2LCAvKiA0ICovXG5cdFx0XHQzLjgxNWUtMDYgKiAwLjk4MDc4NTI4MDQwMzIzIC8gMi4zODRlLTA2LFxuXHRcdFx0LTIuNzE4ZS0wNSAqIDAuOTgwNzg1MjgwNDAzMjMgLyAyLjM4NGUtMDYsXG5cdFx0XHQ1LjIyMTM3ZS0wNCAqIDAuOTgwNzg1MjgwNDAzMjMgLyAyLjM4NGUtMDYsXG5cdFx0XHQ3LjcwMzMwNGUtMDMgKiAwLjk4MDc4NTI4MDQwMzIzIC8gMi4zODRlLTA2LFxuXHRcdFx0LTIuNzgxNTM0MmUtMDIgKiAwLjk4MDc4NTI4MDQwMzIzIC8gMi4zODRlLTA2LFxuXHRcdFx0LTQuMjkwNTgxZS0wMyAqIDAuOTgwNzg1MjgwNDAzMjMgLyAyLjM4NGUtMDYsXG5cdFx0XHQtNi4xMTc4MmUtMDQgKiAwLjk4MDc4NTI4MDQwMzIzIC8gMi4zODRlLTA2LFxuXHRcdFx0LTMuNzY3MGUtMDUgKiAwLjk4MDc4NTI4MDQwMzIzIC8gMi4zODRlLTA2LFxuXHRcdFx0MS45ODkxMjM2NzM3OTY1ODBlLTAxLCAxLjg0Nzc1OTA2NTAyMjU3M2UrMDAsXG5cblx0XHRcdC0xLjkwN2UtMDYgKiAwLjk4OTE3NjUwOTk2NDc4MSAvIDIuMzg0ZS0wNixcblx0XHRcdDkuMDEyMmUtMDUgKiAwLjk4OTE3NjUwOTk2NDc4MSAvIDIuMzg0ZS0wNixcblx0XHRcdDIuODg0ODZlLTA0ICogMC45ODkxNzY1MDk5NjQ3ODEgLyAyLjM4NGUtMDYsXG5cdFx0XHQtMi43NzQyMzllLTAzICogMC45ODkxNzY1MDk5NjQ3ODEgLyAyLjM4NGUtMDYsXG5cdFx0XHQzLjIyNDgwMjBlLTAyICogMC45ODkxNzY1MDk5NjQ3ODEgLyAyLjM4NGUtMDYsXG5cdFx0XHQ0Ljc0ODgyMWUtMDMgKiAwLjk4OTE3NjUwOTk2NDc4MSAvIDIuMzg0ZS0wNixcblx0XHRcdDguMzg3NTdlLTA0ICogMC45ODkxNzY1MDk5NjQ3ODEgLyAyLjM4NGUtMDYsXG5cdFx0XHQ1Ljk2MDVlLTA1ICogMC45ODkxNzY1MDk5NjQ3ODEgLyAyLjM4NGUtMDYsIC8qIDMgKi9cblx0XHRcdDMuMzM4ZS0wNiAqIDAuOTg5MTc2NTA5OTY0NzgxIC8gMi4zODRlLTA2LFxuXHRcdFx0LTMuOTU3N2UtMDUgKiAwLjk4OTE3NjUwOTk2NDc4MSAvIDIuMzg0ZS0wNixcblx0XHRcdDMuODgxNDVlLTA0ICogMC45ODkxNzY1MDk5NjQ3ODEgLyAyLjM4NGUtMDYsXG5cdFx0XHQ2LjkzNzAyN2UtMDMgKiAwLjk4OTE3NjUwOTk2NDc4MSAvIDIuMzg0ZS0wNixcblx0XHRcdC0yLjg1MzI5ODJlLTAyICogMC45ODkxNzY1MDk5NjQ3ODEgLyAyLjM4NGUtMDYsXG5cdFx0XHQtNC4zOTU5NjJlLTAzICogMC45ODkxNzY1MDk5NjQ3ODEgLyAyLjM4NGUtMDYsXG5cdFx0XHQtNi40NjU5MWUtMDQgKiAwLjk4OTE3NjUwOTk2NDc4MSAvIDIuMzg0ZS0wNixcblx0XHRcdC00LjA1MzFlLTA1ICogMC45ODkxNzY1MDk5NjQ3ODEgLyAyLjM4NGUtMDYsXG5cdFx0XHQxLjQ4MzM1OTg3NTM4MzQ3NGUtMDEsIDEuOTEzODgwNjcxNDY0NDE4ZSswMCxcblxuXHRcdFx0LTEuOTA3ZS0wNiAqIDAuOTk1MTg0NzI2NjcyMTk3IC8gMi4zODRlLTA2LFxuXHRcdFx0OC40NDAwZS0wNSAqIDAuOTk1MTg0NzI2NjcyMTk3IC8gMi4zODRlLTA2LFxuXHRcdFx0MS45MTY4OWUtMDQgKiAwLjk5NTE4NDcyNjY3MjE5NyAvIDIuMzg0ZS0wNixcblx0XHRcdC0zLjQxMTI5M2UtMDMgKiAwLjk5NTE4NDcyNjY3MjE5NyAvIDIuMzg0ZS0wNixcblx0XHRcdDMuMTcwNjgxMGUtMDIgKiAwLjk5NTE4NDcyNjY3MjE5NyAvIDIuMzg0ZS0wNixcblx0XHRcdDQuNzI4MzE3ZS0wMyAqIDAuOTk1MTg0NzI2NjcyMTk3IC8gMi4zODRlLTA2LFxuXHRcdFx0OC4wOTY2OWUtMDQgKiAwLjk5NTE4NDcyNjY3MjE5NyAvIDIuMzg0ZS0wNixcblx0XHRcdDUuNTc5ZS0wNSAqIDAuOTk1MTg0NzI2NjcyMTk3IC8gMi4zODRlLTA2LFxuXHRcdFx0My4zMzhlLTA2ICogMC45OTUxODQ3MjY2NzIxOTcgLyAyLjM4NGUtMDYsXG5cdFx0XHQtNS4wNTQ1ZS0wNSAqIDAuOTk1MTg0NzI2NjcyMTk3IC8gMi4zODRlLTA2LFxuXHRcdFx0Mi41OTg3NmUtMDQgKiAwLjk5NTE4NDcyNjY3MjE5NyAvIDIuMzg0ZS0wNixcblx0XHRcdDYuMTg5MzQ2ZS0wMyAqIDAuOTk1MTg0NzI2NjcyMTk3IC8gMi4zODRlLTA2LFxuXHRcdFx0LTIuOTIyNDg3M2UtMDIgKiAwLjk5NTE4NDcyNjY3MjE5NyAvIDIuMzg0ZS0wNixcblx0XHRcdC00LjQ4OTg5OWUtMDMgKiAwLjk5NTE4NDcyNjY3MjE5NyAvIDIuMzg0ZS0wNixcblx0XHRcdC02LjgwOTIzZS0wNCAqIDAuOTk1MTg0NzI2NjcyMTk3IC8gMi4zODRlLTA2LFxuXHRcdFx0LTQuMzM5MmUtMDUgKiAwLjk5NTE4NDcyNjY3MjE5NyAvIDIuMzg0ZS0wNixcblx0XHRcdDkuODQ5MTQwMzM1NzE2NDI1ZS0wMiwgMS45NjE1NzA1NjA4MDY0NjFlKzAwLFxuXG5cdFx0XHQtMi4zODRlLTA2ICogMC45OTg3OTU0NTYyMDUxNzIgLyAyLjM4NGUtMDYsXG5cdFx0XHQ3Ljc3MjRlLTA1ICogMC45OTg3OTU0NTYyMDUxNzIgLyAyLjM4NGUtMDYsXG5cdFx0XHQ4LjgyMTVlLTA1ICogMC45OTg3OTU0NTYyMDUxNzIgLyAyLjM4NGUtMDYsXG5cdFx0XHQtNC4wNzIxODllLTAzICogMC45OTg3OTU0NTYyMDUxNzIgLyAyLjM4NGUtMDYsXG5cdFx0XHQzLjExMzI2OThlLTAyICogMC45OTg3OTU0NTYyMDUxNzIgLyAyLjM4NGUtMDYsXG5cdFx0XHQ0LjY5MTEyNGUtMDMgKiAwLjk5ODc5NTQ1NjIwNTE3MiAvIDIuMzg0ZS0wNixcblx0XHRcdDcuNzkxNTJlLTA0ICogMC45OTg3OTU0NTYyMDUxNzIgLyAyLjM4NGUtMDYsXG5cdFx0XHQ1LjI5MjllLTA1ICogMC45OTg3OTU0NTYyMDUxNzIgLyAyLjM4NGUtMDYsXG5cdFx0XHQyLjg2MWUtMDYgKiAwLjk5ODc5NTQ1NjIwNTE3MiAvIDIuMzg0ZS0wNixcblx0XHRcdC02LjA1NThlLTA1ICogMC45OTg3OTU0NTYyMDUxNzIgLyAyLjM4NGUtMDYsXG5cdFx0XHQxLjM3MzI5ZS0wNCAqIDAuOTk4Nzk1NDU2MjA1MTcyIC8gMi4zODRlLTA2LFxuXHRcdFx0NS40NjIxNzBlLTAzICogMC45OTg3OTU0NTYyMDUxNzIgLyAyLjM4NGUtMDYsXG5cdFx0XHQtMi45ODkwMDYwZS0wMiAqIDAuOTk4Nzk1NDU2MjA1MTcyIC8gMi4zODRlLTA2LFxuXHRcdFx0LTQuNTcwNDg0ZS0wMyAqIDAuOTk4Nzk1NDU2MjA1MTcyIC8gMi4zODRlLTA2LFxuXHRcdFx0LTcuMTQzMDJlLTA0ICogMC45OTg3OTU0NTYyMDUxNzIgLyAyLjM4NGUtMDYsXG5cdFx0XHQtNC42MjUzZS0wNSAqIDAuOTk4Nzk1NDU2MjA1MTcyIC8gMi4zODRlLTA2LFxuXHRcdFx0NC45MTI2ODQ5NzY5NDY3MjVlLTAyLCAxLjk5MDM2OTQ1MzM0NDM5NGUrMDAsXG5cblx0XHRcdDMuNTc4MDkwN2UtMDIgKiBVdGlsLlNRUlQyICogMC41IC8gMi4zODRlLTA2LFxuXHRcdFx0MS43ODc2MTQ4ZS0wMiAqIFV0aWwuU1FSVDIgKiAwLjUgLyAyLjM4NGUtMDYsXG5cdFx0XHQzLjEzNDcyN2UtMDMgKiBVdGlsLlNRUlQyICogMC41IC8gMi4zODRlLTA2LFxuXHRcdFx0Mi40NTcxNDJlLTAzICogVXRpbC5TUVJUMiAqIDAuNSAvIDIuMzg0ZS0wNixcblx0XHRcdDkuNzEzMTdlLTA0ICogVXRpbC5TUVJUMiAqIDAuNSAvIDIuMzg0ZS0wNixcblx0XHRcdDIuMTg4NjhlLTA0ICogVXRpbC5TUVJUMiAqIDAuNSAvIDIuMzg0ZS0wNixcblx0XHRcdDEuMDE1NjZlLTA0ICogVXRpbC5TUVJUMiAqIDAuNSAvIDIuMzg0ZS0wNixcblx0XHRcdDEuMzgyOGUtMDUgKiBVdGlsLlNRUlQyICogMC41IC8gMi4zODRlLTA2LFxuXG5cdFx0XHQzLjA1MjY2MzhlLTAyIC8gMi4zODRlLTA2LCA0LjYzODE5NWUtMDMgLyAyLjM4NGUtMDYsXG5cdFx0XHQ3LjQ3MjA0ZS0wNCAvIDIuMzg0ZS0wNiwgNC45NTkxZS0wNSAvIDIuMzg0ZS0wNixcblx0XHRcdDQuNzU2NDUxZS0wMyAvIDIuMzg0ZS0wNiwgMi4xNDU4ZS0wNSAvIDIuMzg0ZS0wNixcblx0XHRcdC02Ljk2MThlLTA1IC8gMi4zODRlLTA2LCAvKiAyLjM4NGUtMDYvMi4zODRlLTA2ICovXG5cdF07XG5cblx0dmFyIE5TID0gMTI7XG5cdHZhciBOTCA9IDM2O1xuXG5cdHZhciB3aW4gPSBbXG5cdCAgICBbXG5cdCAgICAgMi4zODIxOTE3MzkzNDc5MTNlLTEzLFxuXHQgICAgIDYuNDIzMzA1ODcyMTQ3ODM0ZS0xMyxcblx0ICAgICA5LjQwMDg0OTA5NDA0OTY4OGUtMTMsXG5cdCAgICAgMS4xMjI0MzUwMjYwOTY1NTZlLTEyLFxuXHQgICAgIDEuMTgzODQwMzIxMjY3NDgxZS0xMixcblx0ICAgICAxLjEyMjQzNTAyNjA5NjU1NmUtMTIsXG5cdCAgICAgOS40MDA4NDkwOTQwNDk2OTBlLTEzLFxuXHQgICAgIDYuNDIzMzA1ODcyMTQ3ODM5ZS0xMyxcblx0ICAgICAyLjM4MjE5MTczOTM0NzkxOGUtMTMsXG5cblx0ICAgICA1LjQ1NjExNjEwODk0MzQxMmUtMTIsXG5cdCAgICAgNC44Nzg5ODUxOTk1NjU4NTJlLTEyLFxuXHQgICAgIDQuMjQwNDQ4OTk1MDE3MzY3ZS0xMixcblx0ICAgICAzLjU1OTkwOTA5NDc1ODI1MmUtMTIsXG5cdCAgICAgMi44NTgwNDMzNTkyODgwNzVlLTEyLFxuXHQgICAgIDIuMTU2MTc3NjIzODE3ODk4ZS0xMixcblx0ICAgICAxLjQ3NTYzNzcyMzU1ODc4M2UtMTIsXG5cdCAgICAgOC4zNzEwMTUxOTAxMDI5NzRlLTEzLFxuXHQgICAgIDIuNTk5NzA2MDk2MzI3Mzc2ZS0xMyxcblxuXHQgICAgIC01LjQ1NjExNjEwODk0MzQxMmUtMTIsXG5cdCAgICAgLTQuODc4OTg1MTk5NTY1ODUyZS0xMixcblx0ICAgICAtNC4yNDA0NDg5OTUwMTczNjdlLTEyLFxuXHQgICAgIC0zLjU1OTkwOTA5NDc1ODI1MmUtMTIsXG5cdCAgICAgLTIuODU4MDQzMzU5Mjg4MDc2ZS0xMixcblx0ICAgICAtMi4xNTYxNzc2MjM4MTc4OThlLTEyLFxuXHQgICAgIC0xLjQ3NTYzNzcyMzU1ODc4M2UtMTIsXG5cdCAgICAgLTguMzcxMDE1MTkwMTAyOTc1ZS0xMyxcblx0ICAgICAtMi41OTk3MDYwOTYzMjczNzZlLTEzLFxuXG5cdCAgICAgLTIuMzgyMTkxNzM5MzQ3OTIzZS0xMyxcblx0ICAgICAtNi40MjMzMDU4NzIxNDc4NDNlLTEzLFxuXHQgICAgIC05LjQwMDg0OTA5NDA0OTY5NmUtMTMsXG5cdCAgICAgLTEuMTIyNDM1MDI2MDk2NTU2ZS0xMixcblx0ICAgICAtMS4xODM4NDAzMjEyNjc0ODFlLTEyLFxuXHQgICAgIC0xLjEyMjQzNTAyNjA5NjU1NmUtMTIsXG5cdCAgICAgLTkuNDAwODQ5MDk0MDQ5Njk0ZS0xMyxcblx0ICAgICAtNi40MjMzMDU4NzIxNDc4NDBlLTEzLFxuXHQgICAgIC0yLjM4MjE5MTczOTM0NzkxOGUtMTMsXG5cdCAgICAgXSxcblx0ICAgIFtcblx0ICAgICAyLjM4MjE5MTczOTM0NzkxM2UtMTMsXG5cdCAgICAgNi40MjMzMDU4NzIxNDc4MzRlLTEzLFxuXHQgICAgIDkuNDAwODQ5MDk0MDQ5Njg4ZS0xMyxcblx0ICAgICAxLjEyMjQzNTAyNjA5NjU1NmUtMTIsXG5cdCAgICAgMS4xODM4NDAzMjEyNjc0ODFlLTEyLFxuXHQgICAgIDEuMTIyNDM1MDI2MDk2NTU2ZS0xMixcblx0ICAgICA5LjQwMDg0OTA5NDA0OTY4OGUtMTMsXG5cdCAgICAgNi40MjMzMDU4NzIxNDc4NDFlLTEzLFxuXHQgICAgIDIuMzgyMTkxNzM5MzQ3OTE4ZS0xMyxcblxuXHQgICAgIDUuNDU2MTE2MTA4OTQzNDEzZS0xMixcblx0ICAgICA0Ljg3ODk4NTE5OTU2NTg1MmUtMTIsXG5cdCAgICAgNC4yNDA0NDg5OTUwMTczNjdlLTEyLFxuXHQgICAgIDMuNTU5OTA5MDk0NzU4MjUzZS0xMixcblx0ICAgICAyLjg1ODA0MzM1OTI4ODA3NWUtMTIsXG5cdCAgICAgMi4xNTYxNzc2MjM4MTc4OThlLTEyLFxuXHQgICAgIDEuNDc1NjM3NzIzNTU4NzgyZS0xMixcblx0ICAgICA4LjM3MTAxNTE5MDEwMjk3NWUtMTMsXG5cdCAgICAgMi41OTk3MDYwOTYzMjczNzZlLTEzLFxuXG5cdCAgICAgLTUuNDYxMzE0MDY5ODA5NzU1ZS0xMixcblx0ICAgICAtNC45MjEwODU3NzA1MjQwNTVlLTEyLFxuXHQgICAgIC00LjM0MzQwNTAzNzA5MTgzOGUtMTIsXG5cdCAgICAgLTMuNzMyNjY4MzY4NzA3Njg3ZS0xMixcblx0ICAgICAtMy4wOTM1MjM4NDAxOTA4ODVlLTEyLFxuXHQgICAgIC0yLjQzMDgzNTcyNzMyOTQ2NWUtMTIsXG5cdCAgICAgLTEuNzM0Njc5MDEwMDA3NzUxZS0xMixcblx0ICAgICAtOS43NDgyNTM2NTY2MDkyODFlLTEzLFxuXHQgICAgIC0yLjc5NzQzNTEyMDE2ODMyNmUtMTMsXG5cblx0ICAgICAwLjAwMDAwMDAwMDAwMDAwMGUrMDAsXG5cdCAgICAgMC4wMDAwMDAwMDAwMDAwMDBlKzAwLFxuXHQgICAgIDAuMDAwMDAwMDAwMDAwMDAwZSswMCxcblx0ICAgICAwLjAwMDAwMDAwMDAwMDAwMGUrMDAsXG5cdCAgICAgMC4wMDAwMDAwMDAwMDAwMDBlKzAwLFxuXHQgICAgIDAuMDAwMDAwMDAwMDAwMDAwZSswMCxcblx0ICAgICAtMi4yODM3NDgyNDE3OTk1MzFlLTEzLFxuXHQgICAgIC00LjAzNzg1ODg3NDAyMDY4NmUtMTMsXG5cdCAgICAgLTIuMTQ2NTQ3NDY0ODI1MzIzZS0xMyxcblx0ICAgICBdLFxuXHQgICAgW1xuXHQgICAgIDEuMzE2NTI0OTc1ODczOTU4ZS0wMSwgLyogd2luW1NIT1JUX1RZUEVdICovXG5cdCAgICAgNC4xNDIxMzU2MjM3MzA5NTBlLTAxLFxuXHQgICAgIDcuNjczMjY5ODc5Nzg5NjAyZS0wMSxcblxuXHQgICAgIDEuMDkxMzA4NTAxMDY5MjcxZSswMCwgLyogdGFudGFiX2wgKi9cblx0ICAgICAxLjMwMzIyNTM3Mjg0MTIwNmUrMDAsXG5cdCAgICAgMS41Njk2ODU1NzcxMTc0OTBlKzAwLFxuXHQgICAgIDEuOTIwOTgyMTI2OTcxMTY2ZSswMCxcblx0ICAgICAyLjQxNDIxMzU2MjM3MzA5NGUrMDAsXG5cdCAgICAgMy4xNzE1OTQ4MDIzNjMyMTJlKzAwLFxuXHQgICAgIDQuNTEwNzA4NTAzNjYyMDU1ZSswMCxcblx0ICAgICA3LjU5NTc1NDExMjcyNTE0NmUrMDAsXG5cdCAgICAgMi4yOTAzNzY1NTQ4NDMxMTVlKzAxLFxuXG5cdCAgICAgMC45ODQ4MDc3NTMwMTIyMDgwMjAzMiwgLyogY3ggKi9cblx0ICAgICAwLjY0Mjc4NzYwOTY4NjUzOTM2MjkyLFxuXHQgICAgIDAuMzQyMDIwMTQzMzI1NjY4ODIzOTMsXG5cdCAgICAgMC45Mzk2OTI2MjA3ODU5MDg0Mjc5MSxcblx0ICAgICAtMC4xNzM2NDgxNzc2NjY5MzAzMDM0Myxcblx0ICAgICAtMC43NjYwNDQ0NDMxMTg5Nzc5MDI0Myxcblx0ICAgICAwLjg2NjAyNTQwMzc4NDQzODcwNzYxLFxuXHQgICAgIDAuNTAwMDAwMDAwMDAwMDAwZSswMCxcblxuXHQgICAgIC01LjE0NDk1NzU1NDI3NTI2NWUtMDEsIC8qIGNhICovXG5cdCAgICAgLTQuNzE3MzE5Njg1NjQ5NzIzZS0wMSxcblx0ICAgICAtMy4xMzM3NzQ1NDIwMzkwMTllLTAxLFxuXHQgICAgIC0xLjgxOTEzMTk5NjEwOTgxMmUtMDEsXG5cdCAgICAgLTkuNDU3NDE5MjUyNjQyMDY0ZS0wMixcblx0ICAgICAtNC4wOTY1NTgyODg1MzA0MDVlLTAyLFxuXHQgICAgIC0xLjQxOTg1Njg1NzI0NzExNWUtMDIsXG5cdCAgICAgLTMuNjk5OTc0NjczNzYwMDM3ZS0wMyxcblxuXHQgICAgIDguNTc0OTI5MjU3MTI1NDQyZS0wMSwgLyogY3MgKi9cblx0ICAgICA4LjgxNzQxOTk3MzE3NzA1MmUtMDEsXG5cdCAgICAgOS40OTYyODY0OTEwMjczMjllLTAxLFxuXHQgICAgIDkuODMzMTQ1OTI0OTE3OTAxZS0wMSxcblx0ICAgICA5Ljk1NTE3ODE2MDY3NTg1N2UtMDEsXG5cdCAgICAgOS45OTE2MDU1ODE3ODE0NzVlLTAxLFxuXHQgICAgIDkuOTk4OTkxOTUyNDQ0NDcwZS0wMSxcblx0ICAgICA5Ljk5OTkzMTU1MDcwMjgwMmUtMDEsXG5cdCAgICAgXSxcblx0ICAgIFtcblx0ICAgICAwLjAwMDAwMDAwMDAwMDAwMGUrMDAsXG5cdCAgICAgMC4wMDAwMDAwMDAwMDAwMDBlKzAwLFxuXHQgICAgIDAuMDAwMDAwMDAwMDAwMDAwZSswMCxcblx0ICAgICAwLjAwMDAwMDAwMDAwMDAwMGUrMDAsXG5cdCAgICAgMC4wMDAwMDAwMDAwMDAwMDBlKzAwLFxuXHQgICAgIDAuMDAwMDAwMDAwMDAwMDAwZSswMCxcblx0ICAgICAyLjI4Mzc0ODI0MTc5OTUzMWUtMTMsXG5cdCAgICAgNC4wMzc4NTg4NzQwMjA2ODZlLTEzLFxuXHQgICAgIDIuMTQ2NTQ3NDY0ODI1MzIzZS0xMyxcblxuXHQgICAgIDUuNDYxMzE0MDY5ODA5NzU1ZS0xMixcblx0ICAgICA0LjkyMTA4NTc3MDUyNDA1NWUtMTIsXG5cdCAgICAgNC4zNDM0MDUwMzcwOTE4MzhlLTEyLFxuXHQgICAgIDMuNzMyNjY4MzY4NzA3Njg3ZS0xMixcblx0ICAgICAzLjA5MzUyMzg0MDE5MDg4NWUtMTIsXG5cdCAgICAgMi40MzA4MzU3MjczMjk0NjZlLTEyLFxuXHQgICAgIDEuNzM0Njc5MDEwMDA3NzUxZS0xMixcblx0ICAgICA5Ljc0ODI1MzY1NjYwOTI4MWUtMTMsXG5cdCAgICAgMi43OTc0MzUxMjAxNjgzMjZlLTEzLFxuXG5cdCAgICAgLTUuNDU2MTE2MTA4OTQzNDEzZS0xMixcblx0ICAgICAtNC44Nzg5ODUxOTk1NjU4NTJlLTEyLFxuXHQgICAgIC00LjI0MDQ0ODk5NTAxNzM2N2UtMTIsXG5cdCAgICAgLTMuNTU5OTA5MDk0NzU4MjUzZS0xMixcblx0ICAgICAtMi44NTgwNDMzNTkyODgwNzVlLTEyLFxuXHQgICAgIC0yLjE1NjE3NzYyMzgxNzg5OGUtMTIsXG5cdCAgICAgLTEuNDc1NjM3NzIzNTU4NzgyZS0xMixcblx0ICAgICAtOC4zNzEwMTUxOTAxMDI5NzVlLTEzLFxuXHQgICAgIC0yLjU5OTcwNjA5NjMyNzM3NmUtMTMsXG5cblx0ICAgICAtMi4zODIxOTE3MzkzNDc5MTNlLTEzLFxuXHQgICAgIC02LjQyMzMwNTg3MjE0NzgzNGUtMTMsXG5cdCAgICAgLTkuNDAwODQ5MDk0MDQ5Njg4ZS0xMyxcblx0ICAgICAtMS4xMjI0MzUwMjYwOTY1NTZlLTEyLFxuXHQgICAgIC0xLjE4Mzg0MDMyMTI2NzQ4MWUtMTIsXG5cdCAgICAgLTEuMTIyNDM1MDI2MDk2NTU2ZS0xMixcblx0ICAgICAtOS40MDA4NDkwOTQwNDk2ODhlLTEzLFxuXHQgICAgIC02LjQyMzMwNTg3MjE0Nzg0MWUtMTMsXG5cdCAgICAgLTIuMzgyMTkxNzM5MzQ3OTE4ZS0xMyxcblx0ICAgICBdXG5cdF07XG5cblx0dmFyIHRhbnRhYl9sID0gd2luW0VuY29kZXIuU0hPUlRfVFlQRV07XG5cdHZhciBjeCA9IHdpbltFbmNvZGVyLlNIT1JUX1RZUEVdO1xuXHR2YXIgY2EgPSB3aW5bRW5jb2Rlci5TSE9SVF9UWVBFXTtcblx0dmFyIGNzID0gd2luW0VuY29kZXIuU0hPUlRfVFlQRV07XG5cblx0LyoqXG5cdCAqIG5ldyBJRENUIHJvdXRpbmUgd3JpdHRlbiBieSBUYWtlaGlybyBUT01JTkFHQVxuXHQgKlxuXHQgKiBQVVJQT1NFOiBPdmVybGFwcGluZyB3aW5kb3cgb24gUENNIHNhbXBsZXM8QlI+XG5cdCAqXG5cdCAqIFNFTUFOVElDUzo8QlI+XG5cdCAqIDMyIDE2LWJpdCBwY20gc2FtcGxlcyBhcmUgc2NhbGVkIHRvIGZyYWN0aW9uYWwgMidzIGNvbXBsZW1lbnQgYW5kXG5cdCAqIGNvbmNhdGVuYXRlZCB0byB0aGUgZW5kIG9mIHRoZSB3aW5kb3cgYnVmZmVyICN4Iy4gVGhlIHVwZGF0ZWQgd2luZG93XG5cdCAqIGJ1ZmZlciAjeCMgaXMgdGhlbiB3aW5kb3dlZCBieSB0aGUgYW5hbHlzaXMgd2luZG93ICNjIyB0byBwcm9kdWNlIHRoZVxuXHQgKiB3aW5kb3dlZCBzYW1wbGUgI3ojXG5cdCAqL1xuXHR2YXIgb3JkZXIgPSBbXG5cdCAgICAwLCAxLCAxNiwgMTcsIDgsIDksIDI0LCAyNSwgNCwgNSwgMjAsIDIxLCAxMiwgMTMsIDI4LCAyOSxcblx0ICAgIDIsIDMsIDE4LCAxOSwgMTAsIDExLCAyNiwgMjcsIDYsIDcsIDIyLCAyMywgMTQsIDE1LCAzMCwgMzFcblx0XTtcblxuXHQvKipcblx0ICogcmV0dXJucyBzdW1faj0wXjMxIGFbal0qY29zKFBJKmoqKGsrMS8yKS8zMiksIDA8PWs8MzJcblx0ICovXG5cdGZ1bmN0aW9uIHdpbmRvd19zdWJiYW5kKHgxLCB4MVBvcywgYSkge1xuXHRcdHZhciB3cCA9IDEwO1xuXG5cdFx0dmFyIHgyID0geDFQb3MgKyAyMzggLSAxNCAtIDI4NjtcblxuXHRcdGZvciAodmFyIGkgPSAtMTU7IGkgPCAwOyBpKyspIHtcblx0XHRcdHZhciB3LCBzLCB0O1xuXG5cdFx0XHR3ID0gZW53aW5kb3dbd3AgKyAtMTBdO1xuXHRcdFx0cyA9IHgxW3gyICsgLTIyNF0gKiB3O1xuXHRcdFx0dCA9IHgxW3gxUG9zICsgMjI0XSAqIHc7XG5cdFx0XHR3ID0gZW53aW5kb3dbd3AgKyAtOV07XG5cdFx0XHRzICs9IHgxW3gyICsgLTE2MF0gKiB3O1xuXHRcdFx0dCArPSB4MVt4MVBvcyArIDE2MF0gKiB3O1xuXHRcdFx0dyA9IGVud2luZG93W3dwICsgLThdO1xuXHRcdFx0cyArPSB4MVt4MiArIC05Nl0gKiB3O1xuXHRcdFx0dCArPSB4MVt4MVBvcyArIDk2XSAqIHc7XG5cdFx0XHR3ID0gZW53aW5kb3dbd3AgKyAtN107XG5cdFx0XHRzICs9IHgxW3gyICsgLTMyXSAqIHc7XG5cdFx0XHR0ICs9IHgxW3gxUG9zICsgMzJdICogdztcblx0XHRcdHcgPSBlbndpbmRvd1t3cCArIC02XTtcblx0XHRcdHMgKz0geDFbeDIgKyAzMl0gKiB3O1xuXHRcdFx0dCArPSB4MVt4MVBvcyArIC0zMl0gKiB3O1xuXHRcdFx0dyA9IGVud2luZG93W3dwICsgLTVdO1xuXHRcdFx0cyArPSB4MVt4MiArIDk2XSAqIHc7XG5cdFx0XHR0ICs9IHgxW3gxUG9zICsgLTk2XSAqIHc7XG5cdFx0XHR3ID0gZW53aW5kb3dbd3AgKyAtNF07XG5cdFx0XHRzICs9IHgxW3gyICsgMTYwXSAqIHc7XG5cdFx0XHR0ICs9IHgxW3gxUG9zICsgLTE2MF0gKiB3O1xuXHRcdFx0dyA9IGVud2luZG93W3dwICsgLTNdO1xuXHRcdFx0cyArPSB4MVt4MiArIDIyNF0gKiB3O1xuXHRcdFx0dCArPSB4MVt4MVBvcyArIC0yMjRdICogdztcblxuXHRcdFx0dyA9IGVud2luZG93W3dwICsgLTJdO1xuXHRcdFx0cyArPSB4MVt4MVBvcyArIC0yNTZdICogdztcblx0XHRcdHQgLT0geDFbeDIgKyAyNTZdICogdztcblx0XHRcdHcgPSBlbndpbmRvd1t3cCArIC0xXTtcblx0XHRcdHMgKz0geDFbeDFQb3MgKyAtMTkyXSAqIHc7XG5cdFx0XHR0IC09IHgxW3gyICsgMTkyXSAqIHc7XG5cdFx0XHR3ID0gZW53aW5kb3dbd3AgKyAwXTtcblx0XHRcdHMgKz0geDFbeDFQb3MgKyAtMTI4XSAqIHc7XG5cdFx0XHR0IC09IHgxW3gyICsgMTI4XSAqIHc7XG5cdFx0XHR3ID0gZW53aW5kb3dbd3AgKyAxXTtcblx0XHRcdHMgKz0geDFbeDFQb3MgKyAtNjRdICogdztcblx0XHRcdHQgLT0geDFbeDIgKyA2NF0gKiB3O1xuXHRcdFx0dyA9IGVud2luZG93W3dwICsgMl07XG5cdFx0XHRzICs9IHgxW3gxUG9zICsgMF0gKiB3O1xuXHRcdFx0dCAtPSB4MVt4MiArIDBdICogdztcblx0XHRcdHcgPSBlbndpbmRvd1t3cCArIDNdO1xuXHRcdFx0cyArPSB4MVt4MVBvcyArIDY0XSAqIHc7XG5cdFx0XHR0IC09IHgxW3gyICsgLTY0XSAqIHc7XG5cdFx0XHR3ID0gZW53aW5kb3dbd3AgKyA0XTtcblx0XHRcdHMgKz0geDFbeDFQb3MgKyAxMjhdICogdztcblx0XHRcdHQgLT0geDFbeDIgKyAtMTI4XSAqIHc7XG5cdFx0XHR3ID0gZW53aW5kb3dbd3AgKyA1XTtcblx0XHRcdHMgKz0geDFbeDFQb3MgKyAxOTJdICogdztcblx0XHRcdHQgLT0geDFbeDIgKyAtMTkyXSAqIHc7XG5cblx0XHRcdC8qXG5cdFx0XHQgKiB0aGlzIG11bHRpcGx5ZXIgY291bGQgYmUgcmVtb3ZlZCwgYnV0IGl0IG5lZWRzIG1vcmUgMjU2IEZMT0FUXG5cdFx0XHQgKiBkYXRhLiB0aGlua2luZyBhYm91dCB0aGUgZGF0YSBjYWNoZSBwZXJmb3JtYW5jZSwgSSB0aGluayB3ZVxuXHRcdFx0ICogc2hvdWxkIG5vdCB1c2Ugc3VjaCBhIGh1Z2UgdGFibGUuIHR0IDIwMDAvT2N0LzI1XG5cdFx0XHQgKi9cblx0XHRcdHMgKj0gZW53aW5kb3dbd3AgKyA2XTtcblx0XHRcdHcgPSB0IC0gcztcblx0XHRcdGFbMzAgKyBpICogMl0gPSB0ICsgcztcblx0XHRcdGFbMzEgKyBpICogMl0gPSBlbndpbmRvd1t3cCArIDddICogdztcblx0XHRcdHdwICs9IDE4O1xuXHRcdFx0eDFQb3MtLTtcblx0XHRcdHgyKys7XG5cdFx0fVxuXHRcdHtcblx0XHRcdHZhciBzLCB0LCB1LCB2O1xuXHRcdFx0dCA9IHgxW3gxUG9zICsgLTE2XSAqIGVud2luZG93W3dwICsgLTEwXTtcblx0XHRcdHMgPSB4MVt4MVBvcyArIC0zMl0gKiBlbndpbmRvd1t3cCArIC0yXTtcblx0XHRcdHQgKz0gKHgxW3gxUG9zICsgLTQ4XSAtIHgxW3gxUG9zICsgMTZdKSAqIGVud2luZG93W3dwICsgLTldO1xuXHRcdFx0cyArPSB4MVt4MVBvcyArIC05Nl0gKiBlbndpbmRvd1t3cCArIC0xXTtcblx0XHRcdHQgKz0gKHgxW3gxUG9zICsgLTgwXSArIHgxW3gxUG9zICsgNDhdKSAqIGVud2luZG93W3dwICsgLThdO1xuXHRcdFx0cyArPSB4MVt4MVBvcyArIC0xNjBdICogZW53aW5kb3dbd3AgKyAwXTtcblx0XHRcdHQgKz0gKHgxW3gxUG9zICsgLTExMl0gLSB4MVt4MVBvcyArIDgwXSkgKiBlbndpbmRvd1t3cCArIC03XTtcblx0XHRcdHMgKz0geDFbeDFQb3MgKyAtMjI0XSAqIGVud2luZG93W3dwICsgMV07XG5cdFx0XHR0ICs9ICh4MVt4MVBvcyArIC0xNDRdICsgeDFbeDFQb3MgKyAxMTJdKSAqIGVud2luZG93W3dwICsgLTZdO1xuXHRcdFx0cyAtPSB4MVt4MVBvcyArIDMyXSAqIGVud2luZG93W3dwICsgMl07XG5cdFx0XHR0ICs9ICh4MVt4MVBvcyArIC0xNzZdIC0geDFbeDFQb3MgKyAxNDRdKSAqIGVud2luZG93W3dwICsgLTVdO1xuXHRcdFx0cyAtPSB4MVt4MVBvcyArIDk2XSAqIGVud2luZG93W3dwICsgM107XG5cdFx0XHR0ICs9ICh4MVt4MVBvcyArIC0yMDhdICsgeDFbeDFQb3MgKyAxNzZdKSAqIGVud2luZG93W3dwICsgLTRdO1xuXHRcdFx0cyAtPSB4MVt4MVBvcyArIDE2MF0gKiBlbndpbmRvd1t3cCArIDRdO1xuXHRcdFx0dCArPSAoeDFbeDFQb3MgKyAtMjQwXSAtIHgxW3gxUG9zICsgMjA4XSkgKiBlbndpbmRvd1t3cCArIC0zXTtcblx0XHRcdHMgLT0geDFbeDFQb3MgKyAyMjRdO1xuXG5cdFx0XHR1ID0gcyAtIHQ7XG5cdFx0XHR2ID0gcyArIHQ7XG5cblx0XHRcdHQgPSBhWzE0XTtcblx0XHRcdHMgPSBhWzE1XSAtIHQ7XG5cblx0XHRcdGFbMzFdID0gdiArIHQ7IC8qIEEwICovXG5cdFx0XHRhWzMwXSA9IHUgKyBzOyAvKiBBMSAqL1xuXHRcdFx0YVsxNV0gPSB1IC0gczsgLyogQTIgKi9cblx0XHRcdGFbMTRdID0gdiAtIHQ7IC8qIEEzICovXG5cdFx0fVxuXHRcdHtcblx0XHRcdHZhciB4cjtcblx0XHRcdHhyID0gYVsyOF0gLSBhWzBdO1xuXHRcdFx0YVswXSArPSBhWzI4XTtcblx0XHRcdGFbMjhdID0geHIgKiBlbndpbmRvd1t3cCArIC0yICogMTggKyA3XTtcblx0XHRcdHhyID0gYVsyOV0gLSBhWzFdO1xuXHRcdFx0YVsxXSArPSBhWzI5XTtcblx0XHRcdGFbMjldID0geHIgKiBlbndpbmRvd1t3cCArIC0yICogMTggKyA3XTtcblxuXHRcdFx0eHIgPSBhWzI2XSAtIGFbMl07XG5cdFx0XHRhWzJdICs9IGFbMjZdO1xuXHRcdFx0YVsyNl0gPSB4ciAqIGVud2luZG93W3dwICsgLTQgKiAxOCArIDddO1xuXHRcdFx0eHIgPSBhWzI3XSAtIGFbM107XG5cdFx0XHRhWzNdICs9IGFbMjddO1xuXHRcdFx0YVsyN10gPSB4ciAqIGVud2luZG93W3dwICsgLTQgKiAxOCArIDddO1xuXG5cdFx0XHR4ciA9IGFbMjRdIC0gYVs0XTtcblx0XHRcdGFbNF0gKz0gYVsyNF07XG5cdFx0XHRhWzI0XSA9IHhyICogZW53aW5kb3dbd3AgKyAtNiAqIDE4ICsgN107XG5cdFx0XHR4ciA9IGFbMjVdIC0gYVs1XTtcblx0XHRcdGFbNV0gKz0gYVsyNV07XG5cdFx0XHRhWzI1XSA9IHhyICogZW53aW5kb3dbd3AgKyAtNiAqIDE4ICsgN107XG5cblx0XHRcdHhyID0gYVsyMl0gLSBhWzZdO1xuXHRcdFx0YVs2XSArPSBhWzIyXTtcblx0XHRcdGFbMjJdID0geHIgKiBVdGlsLlNRUlQyO1xuXHRcdFx0eHIgPSBhWzIzXSAtIGFbN107XG5cdFx0XHRhWzddICs9IGFbMjNdO1xuXHRcdFx0YVsyM10gPSB4ciAqIFV0aWwuU1FSVDIgLSBhWzddO1xuXHRcdFx0YVs3XSAtPSBhWzZdO1xuXHRcdFx0YVsyMl0gLT0gYVs3XTtcblx0XHRcdGFbMjNdIC09IGFbMjJdO1xuXG5cdFx0XHR4ciA9IGFbNl07XG5cdFx0XHRhWzZdID0gYVszMV0gLSB4cjtcblx0XHRcdGFbMzFdID0gYVszMV0gKyB4cjtcblx0XHRcdHhyID0gYVs3XTtcblx0XHRcdGFbN10gPSBhWzMwXSAtIHhyO1xuXHRcdFx0YVszMF0gPSBhWzMwXSArIHhyO1xuXHRcdFx0eHIgPSBhWzIyXTtcblx0XHRcdGFbMjJdID0gYVsxNV0gLSB4cjtcblx0XHRcdGFbMTVdID0gYVsxNV0gKyB4cjtcblx0XHRcdHhyID0gYVsyM107XG5cdFx0XHRhWzIzXSA9IGFbMTRdIC0geHI7XG5cdFx0XHRhWzE0XSA9IGFbMTRdICsgeHI7XG5cblx0XHRcdHhyID0gYVsyMF0gLSBhWzhdO1xuXHRcdFx0YVs4XSArPSBhWzIwXTtcblx0XHRcdGFbMjBdID0geHIgKiBlbndpbmRvd1t3cCArIC0xMCAqIDE4ICsgN107XG5cdFx0XHR4ciA9IGFbMjFdIC0gYVs5XTtcblx0XHRcdGFbOV0gKz0gYVsyMV07XG5cdFx0XHRhWzIxXSA9IHhyICogZW53aW5kb3dbd3AgKyAtMTAgKiAxOCArIDddO1xuXG5cdFx0XHR4ciA9IGFbMThdIC0gYVsxMF07XG5cdFx0XHRhWzEwXSArPSBhWzE4XTtcblx0XHRcdGFbMThdID0geHIgKiBlbndpbmRvd1t3cCArIC0xMiAqIDE4ICsgN107XG5cdFx0XHR4ciA9IGFbMTldIC0gYVsxMV07XG5cdFx0XHRhWzExXSArPSBhWzE5XTtcblx0XHRcdGFbMTldID0geHIgKiBlbndpbmRvd1t3cCArIC0xMiAqIDE4ICsgN107XG5cblx0XHRcdHhyID0gYVsxNl0gLSBhWzEyXTtcblx0XHRcdGFbMTJdICs9IGFbMTZdO1xuXHRcdFx0YVsxNl0gPSB4ciAqIGVud2luZG93W3dwICsgLTE0ICogMTggKyA3XTtcblx0XHRcdHhyID0gYVsxN10gLSBhWzEzXTtcblx0XHRcdGFbMTNdICs9IGFbMTddO1xuXHRcdFx0YVsxN10gPSB4ciAqIGVud2luZG93W3dwICsgLTE0ICogMTggKyA3XTtcblxuXHRcdFx0eHIgPSAtYVsyMF0gKyBhWzI0XTtcblx0XHRcdGFbMjBdICs9IGFbMjRdO1xuXHRcdFx0YVsyNF0gPSB4ciAqIGVud2luZG93W3dwICsgLTEyICogMTggKyA3XTtcblx0XHRcdHhyID0gLWFbMjFdICsgYVsyNV07XG5cdFx0XHRhWzIxXSArPSBhWzI1XTtcblx0XHRcdGFbMjVdID0geHIgKiBlbndpbmRvd1t3cCArIC0xMiAqIDE4ICsgN107XG5cblx0XHRcdHhyID0gYVs0XSAtIGFbOF07XG5cdFx0XHRhWzRdICs9IGFbOF07XG5cdFx0XHRhWzhdID0geHIgKiBlbndpbmRvd1t3cCArIC0xMiAqIDE4ICsgN107XG5cdFx0XHR4ciA9IGFbNV0gLSBhWzldO1xuXHRcdFx0YVs1XSArPSBhWzldO1xuXHRcdFx0YVs5XSA9IHhyICogZW53aW5kb3dbd3AgKyAtMTIgKiAxOCArIDddO1xuXG5cdFx0XHR4ciA9IGFbMF0gLSBhWzEyXTtcblx0XHRcdGFbMF0gKz0gYVsxMl07XG5cdFx0XHRhWzEyXSA9IHhyICogZW53aW5kb3dbd3AgKyAtNCAqIDE4ICsgN107XG5cdFx0XHR4ciA9IGFbMV0gLSBhWzEzXTtcblx0XHRcdGFbMV0gKz0gYVsxM107XG5cdFx0XHRhWzEzXSA9IHhyICogZW53aW5kb3dbd3AgKyAtNCAqIDE4ICsgN107XG5cdFx0XHR4ciA9IGFbMTZdIC0gYVsyOF07XG5cdFx0XHRhWzE2XSArPSBhWzI4XTtcblx0XHRcdGFbMjhdID0geHIgKiBlbndpbmRvd1t3cCArIC00ICogMTggKyA3XTtcblx0XHRcdHhyID0gLWFbMTddICsgYVsyOV07XG5cdFx0XHRhWzE3XSArPSBhWzI5XTtcblx0XHRcdGFbMjldID0geHIgKiBlbndpbmRvd1t3cCArIC00ICogMTggKyA3XTtcblxuXHRcdFx0eHIgPSBVdGlsLlNRUlQyICogKGFbMl0gLSBhWzEwXSk7XG5cdFx0XHRhWzJdICs9IGFbMTBdO1xuXHRcdFx0YVsxMF0gPSB4cjtcblx0XHRcdHhyID0gVXRpbC5TUVJUMiAqIChhWzNdIC0gYVsxMV0pO1xuXHRcdFx0YVszXSArPSBhWzExXTtcblx0XHRcdGFbMTFdID0geHI7XG5cdFx0XHR4ciA9IFV0aWwuU1FSVDIgKiAoLWFbMThdICsgYVsyNl0pO1xuXHRcdFx0YVsxOF0gKz0gYVsyNl07XG5cdFx0XHRhWzI2XSA9IHhyIC0gYVsxOF07XG5cdFx0XHR4ciA9IFV0aWwuU1FSVDIgKiAoLWFbMTldICsgYVsyN10pO1xuXHRcdFx0YVsxOV0gKz0gYVsyN107XG5cdFx0XHRhWzI3XSA9IHhyIC0gYVsxOV07XG5cblx0XHRcdHhyID0gYVsyXTtcblx0XHRcdGFbMTldIC09IGFbM107XG5cdFx0XHRhWzNdIC09IHhyO1xuXHRcdFx0YVsyXSA9IGFbMzFdIC0geHI7XG5cdFx0XHRhWzMxXSArPSB4cjtcblx0XHRcdHhyID0gYVszXTtcblx0XHRcdGFbMTFdIC09IGFbMTldO1xuXHRcdFx0YVsxOF0gLT0geHI7XG5cdFx0XHRhWzNdID0gYVszMF0gLSB4cjtcblx0XHRcdGFbMzBdICs9IHhyO1xuXHRcdFx0eHIgPSBhWzE4XTtcblx0XHRcdGFbMjddIC09IGFbMTFdO1xuXHRcdFx0YVsxOV0gLT0geHI7XG5cdFx0XHRhWzE4XSA9IGFbMTVdIC0geHI7XG5cdFx0XHRhWzE1XSArPSB4cjtcblxuXHRcdFx0eHIgPSBhWzE5XTtcblx0XHRcdGFbMTBdIC09IHhyO1xuXHRcdFx0YVsxOV0gPSBhWzE0XSAtIHhyO1xuXHRcdFx0YVsxNF0gKz0geHI7XG5cdFx0XHR4ciA9IGFbMTBdO1xuXHRcdFx0YVsxMV0gLT0geHI7XG5cdFx0XHRhWzEwXSA9IGFbMjNdIC0geHI7XG5cdFx0XHRhWzIzXSArPSB4cjtcblx0XHRcdHhyID0gYVsxMV07XG5cdFx0XHRhWzI2XSAtPSB4cjtcblx0XHRcdGFbMTFdID0gYVsyMl0gLSB4cjtcblx0XHRcdGFbMjJdICs9IHhyO1xuXHRcdFx0eHIgPSBhWzI2XTtcblx0XHRcdGFbMjddIC09IHhyO1xuXHRcdFx0YVsyNl0gPSBhWzddIC0geHI7XG5cdFx0XHRhWzddICs9IHhyO1xuXG5cdFx0XHR4ciA9IGFbMjddO1xuXHRcdFx0YVsyN10gPSBhWzZdIC0geHI7XG5cdFx0XHRhWzZdICs9IHhyO1xuXG5cdFx0XHR4ciA9IFV0aWwuU1FSVDIgKiAoYVswXSAtIGFbNF0pO1xuXHRcdFx0YVswXSArPSBhWzRdO1xuXHRcdFx0YVs0XSA9IHhyO1xuXHRcdFx0eHIgPSBVdGlsLlNRUlQyICogKGFbMV0gLSBhWzVdKTtcblx0XHRcdGFbMV0gKz0gYVs1XTtcblx0XHRcdGFbNV0gPSB4cjtcblx0XHRcdHhyID0gVXRpbC5TUVJUMiAqIChhWzE2XSAtIGFbMjBdKTtcblx0XHRcdGFbMTZdICs9IGFbMjBdO1xuXHRcdFx0YVsyMF0gPSB4cjtcblx0XHRcdHhyID0gVXRpbC5TUVJUMiAqIChhWzE3XSAtIGFbMjFdKTtcblx0XHRcdGFbMTddICs9IGFbMjFdO1xuXHRcdFx0YVsyMV0gPSB4cjtcblxuXHRcdFx0eHIgPSAtVXRpbC5TUVJUMiAqIChhWzhdIC0gYVsxMl0pO1xuXHRcdFx0YVs4XSArPSBhWzEyXTtcblx0XHRcdGFbMTJdID0geHIgLSBhWzhdO1xuXHRcdFx0eHIgPSAtVXRpbC5TUVJUMiAqIChhWzldIC0gYVsxM10pO1xuXHRcdFx0YVs5XSArPSBhWzEzXTtcblx0XHRcdGFbMTNdID0geHIgLSBhWzldO1xuXHRcdFx0eHIgPSAtVXRpbC5TUVJUMiAqIChhWzI1XSAtIGFbMjldKTtcblx0XHRcdGFbMjVdICs9IGFbMjldO1xuXHRcdFx0YVsyOV0gPSB4ciAtIGFbMjVdO1xuXHRcdFx0eHIgPSAtVXRpbC5TUVJUMiAqIChhWzI0XSArIGFbMjhdKTtcblx0XHRcdGFbMjRdIC09IGFbMjhdO1xuXHRcdFx0YVsyOF0gPSB4ciAtIGFbMjRdO1xuXG5cdFx0XHR4ciA9IGFbMjRdIC0gYVsxNl07XG5cdFx0XHRhWzI0XSA9IHhyO1xuXHRcdFx0eHIgPSBhWzIwXSAtIHhyO1xuXHRcdFx0YVsyMF0gPSB4cjtcblx0XHRcdHhyID0gYVsyOF0gLSB4cjtcblx0XHRcdGFbMjhdID0geHI7XG5cblx0XHRcdHhyID0gYVsyNV0gLSBhWzE3XTtcblx0XHRcdGFbMjVdID0geHI7XG5cdFx0XHR4ciA9IGFbMjFdIC0geHI7XG5cdFx0XHRhWzIxXSA9IHhyO1xuXHRcdFx0eHIgPSBhWzI5XSAtIHhyO1xuXHRcdFx0YVsyOV0gPSB4cjtcblxuXHRcdFx0eHIgPSBhWzE3XSAtIGFbMV07XG5cdFx0XHRhWzE3XSA9IHhyO1xuXHRcdFx0eHIgPSBhWzldIC0geHI7XG5cdFx0XHRhWzldID0geHI7XG5cdFx0XHR4ciA9IGFbMjVdIC0geHI7XG5cdFx0XHRhWzI1XSA9IHhyO1xuXHRcdFx0eHIgPSBhWzVdIC0geHI7XG5cdFx0XHRhWzVdID0geHI7XG5cdFx0XHR4ciA9IGFbMjFdIC0geHI7XG5cdFx0XHRhWzIxXSA9IHhyO1xuXHRcdFx0eHIgPSBhWzEzXSAtIHhyO1xuXHRcdFx0YVsxM10gPSB4cjtcblx0XHRcdHhyID0gYVsyOV0gLSB4cjtcblx0XHRcdGFbMjldID0geHI7XG5cblx0XHRcdHhyID0gYVsxXSAtIGFbMF07XG5cdFx0XHRhWzFdID0geHI7XG5cdFx0XHR4ciA9IGFbMTZdIC0geHI7XG5cdFx0XHRhWzE2XSA9IHhyO1xuXHRcdFx0eHIgPSBhWzE3XSAtIHhyO1xuXHRcdFx0YVsxN10gPSB4cjtcblx0XHRcdHhyID0gYVs4XSAtIHhyO1xuXHRcdFx0YVs4XSA9IHhyO1xuXHRcdFx0eHIgPSBhWzldIC0geHI7XG5cdFx0XHRhWzldID0geHI7XG5cdFx0XHR4ciA9IGFbMjRdIC0geHI7XG5cdFx0XHRhWzI0XSA9IHhyO1xuXHRcdFx0eHIgPSBhWzI1XSAtIHhyO1xuXHRcdFx0YVsyNV0gPSB4cjtcblx0XHRcdHhyID0gYVs0XSAtIHhyO1xuXHRcdFx0YVs0XSA9IHhyO1xuXHRcdFx0eHIgPSBhWzVdIC0geHI7XG5cdFx0XHRhWzVdID0geHI7XG5cdFx0XHR4ciA9IGFbMjBdIC0geHI7XG5cdFx0XHRhWzIwXSA9IHhyO1xuXHRcdFx0eHIgPSBhWzIxXSAtIHhyO1xuXHRcdFx0YVsyMV0gPSB4cjtcblx0XHRcdHhyID0gYVsxMl0gLSB4cjtcblx0XHRcdGFbMTJdID0geHI7XG5cdFx0XHR4ciA9IGFbMTNdIC0geHI7XG5cdFx0XHRhWzEzXSA9IHhyO1xuXHRcdFx0eHIgPSBhWzI4XSAtIHhyO1xuXHRcdFx0YVsyOF0gPSB4cjtcblx0XHRcdHhyID0gYVsyOV0gLSB4cjtcblx0XHRcdGFbMjldID0geHI7XG5cblx0XHRcdHhyID0gYVswXTtcblx0XHRcdGFbMF0gKz0gYVszMV07XG5cdFx0XHRhWzMxXSAtPSB4cjtcblx0XHRcdHhyID0gYVsxXTtcblx0XHRcdGFbMV0gKz0gYVszMF07XG5cdFx0XHRhWzMwXSAtPSB4cjtcblx0XHRcdHhyID0gYVsxNl07XG5cdFx0XHRhWzE2XSArPSBhWzE1XTtcblx0XHRcdGFbMTVdIC09IHhyO1xuXHRcdFx0eHIgPSBhWzE3XTtcblx0XHRcdGFbMTddICs9IGFbMTRdO1xuXHRcdFx0YVsxNF0gLT0geHI7XG5cdFx0XHR4ciA9IGFbOF07XG5cdFx0XHRhWzhdICs9IGFbMjNdO1xuXHRcdFx0YVsyM10gLT0geHI7XG5cdFx0XHR4ciA9IGFbOV07XG5cdFx0XHRhWzldICs9IGFbMjJdO1xuXHRcdFx0YVsyMl0gLT0geHI7XG5cdFx0XHR4ciA9IGFbMjRdO1xuXHRcdFx0YVsyNF0gKz0gYVs3XTtcblx0XHRcdGFbN10gLT0geHI7XG5cdFx0XHR4ciA9IGFbMjVdO1xuXHRcdFx0YVsyNV0gKz0gYVs2XTtcblx0XHRcdGFbNl0gLT0geHI7XG5cdFx0XHR4ciA9IGFbNF07XG5cdFx0XHRhWzRdICs9IGFbMjddO1xuXHRcdFx0YVsyN10gLT0geHI7XG5cdFx0XHR4ciA9IGFbNV07XG5cdFx0XHRhWzVdICs9IGFbMjZdO1xuXHRcdFx0YVsyNl0gLT0geHI7XG5cdFx0XHR4ciA9IGFbMjBdO1xuXHRcdFx0YVsyMF0gKz0gYVsxMV07XG5cdFx0XHRhWzExXSAtPSB4cjtcblx0XHRcdHhyID0gYVsyMV07XG5cdFx0XHRhWzIxXSArPSBhWzEwXTtcblx0XHRcdGFbMTBdIC09IHhyO1xuXHRcdFx0eHIgPSBhWzEyXTtcblx0XHRcdGFbMTJdICs9IGFbMTldO1xuXHRcdFx0YVsxOV0gLT0geHI7XG5cdFx0XHR4ciA9IGFbMTNdO1xuXHRcdFx0YVsxM10gKz0gYVsxOF07XG5cdFx0XHRhWzE4XSAtPSB4cjtcblx0XHRcdHhyID0gYVsyOF07XG5cdFx0XHRhWzI4XSArPSBhWzNdO1xuXHRcdFx0YVszXSAtPSB4cjtcblx0XHRcdHhyID0gYVsyOV07XG5cdFx0XHRhWzI5XSArPSBhWzJdO1xuXHRcdFx0YVsyXSAtPSB4cjtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogRnVuY3Rpb246IENhbGN1bGF0aW9uIG9mIHRoZSBNRENUIEluIHRoZSBjYXNlIG9mIGxvbmcgYmxvY2tzICh0eXBlIDAsMSwzKVxuXHQgKiB0aGVyZSBhcmUgMzYgY29lZmZpY2VudHMgaW4gdGhlIHRpbWUgZG9tYWluIGFuZCAxOCBpbiB0aGUgZnJlcXVlbmN5XG5cdCAqIGRvbWFpbi48QlI+XG5cdCAqIEluIHRoZSBjYXNlIG9mIHNob3J0IGJsb2NrcyAodHlwZSAyKSB0aGVyZSBhcmUgMyB0cmFuc2Zvcm1hdGlvbnMgd2l0aFxuXHQgKiBzaG9ydCBsZW5ndGguIFRoaXMgbGVhZHMgdG8gMTIgY29lZmZpY2VudHMgaW4gdGhlIHRpbWUgYW5kIDYgaW4gdGhlXG5cdCAqIGZyZXF1ZW5jeSBkb21haW4uIEluIHRoaXMgY2FzZSB0aGUgcmVzdWx0cyBhcmUgc3RvcmVkIHNpZGUgYnkgc2lkZSBpbiB0aGVcblx0ICogdmVjdG9yIG91dFtdLlxuXHQgKlxuXHQgKiBOZXcgbGF5ZXIzXG5cdCAqL1xuXHRmdW5jdGlvbiBtZGN0X3Nob3J0KGlub3V0LCBpbm91dFBvcykge1xuXHRcdGZvciAodmFyIGwgPSAwOyBsIDwgMzsgbCsrKSB7XG5cdFx0XHR2YXIgdGMwLCB0YzEsIHRjMiwgdHMwLCB0czEsIHRzMjtcblxuXHRcdFx0dHMwID0gaW5vdXRbaW5vdXRQb3MgKyAyICogM10gKiB3aW5bRW5jb2Rlci5TSE9SVF9UWVBFXVswXVxuXHRcdFx0XHRcdC0gaW5vdXRbaW5vdXRQb3MgKyA1ICogM107XG5cdFx0XHR0YzAgPSBpbm91dFtpbm91dFBvcyArIDAgKiAzXSAqIHdpbltFbmNvZGVyLlNIT1JUX1RZUEVdWzJdXG5cdFx0XHRcdFx0LSBpbm91dFtpbm91dFBvcyArIDMgKiAzXTtcblx0XHRcdHRjMSA9IHRzMCArIHRjMDtcblx0XHRcdHRjMiA9IHRzMCAtIHRjMDtcblxuXHRcdFx0dHMwID0gaW5vdXRbaW5vdXRQb3MgKyA1ICogM10gKiB3aW5bRW5jb2Rlci5TSE9SVF9UWVBFXVswXVxuXHRcdFx0XHRcdCsgaW5vdXRbaW5vdXRQb3MgKyAyICogM107XG5cdFx0XHR0YzAgPSBpbm91dFtpbm91dFBvcyArIDMgKiAzXSAqIHdpbltFbmNvZGVyLlNIT1JUX1RZUEVdWzJdXG5cdFx0XHRcdFx0KyBpbm91dFtpbm91dFBvcyArIDAgKiAzXTtcblx0XHRcdHRzMSA9IHRzMCArIHRjMDtcblx0XHRcdHRzMiA9IC10czAgKyB0YzA7XG5cblx0XHRcdHRjMCA9IChpbm91dFtpbm91dFBvcyArIDEgKiAzXSAqIHdpbltFbmNvZGVyLlNIT1JUX1RZUEVdWzFdIC0gaW5vdXRbaW5vdXRQb3MgKyA0ICogM10pICogMi4wNjk5NzgxMTE5NTMwODllLTExO1xuXHRcdFx0Lypcblx0XHRcdCAqIHRyaXRhYl9zIFsgMSBdXG5cdFx0XHQgKi9cblx0XHRcdHRzMCA9IChpbm91dFtpbm91dFBvcyArIDQgKiAzXSAqIHdpbltFbmNvZGVyLlNIT1JUX1RZUEVdWzFdICsgaW5vdXRbaW5vdXRQb3MgKyAxICogM10pICogMi4wNjk5NzgxMTE5NTMwODllLTExO1xuXHRcdFx0Lypcblx0XHRcdCAqIHRyaXRhYl9zIFsgMSBdXG5cdFx0XHQgKi9cblx0XHRcdGlub3V0W2lub3V0UG9zICsgMyAqIDBdID0gdGMxICogMS45MDc1MjUxOTE3MzcyODBlLTExICsgdGMwO1xuXHRcdFx0Lypcblx0XHRcdCAqIHRyaXRhYl9zWyAyIF1cblx0XHRcdCAqL1xuXHRcdFx0aW5vdXRbaW5vdXRQb3MgKyAzICogNV0gPSAtdHMxICogMS45MDc1MjUxOTE3MzcyODBlLTExICsgdHMwO1xuXHRcdFx0Lypcblx0XHRcdCAqIHRyaXRhYl9zWzAgXVxuXHRcdFx0ICovXG5cdFx0XHR0YzIgPSB0YzIgKiAwLjg2NjAyNTQwMzc4NDQzODcwNzYxICogMS45MDc1MjUxOTE3MzcyODFlLTExO1xuXHRcdFx0Lypcblx0XHRcdCAqIHRyaXRhYl9zWyAyXVxuXHRcdFx0ICovXG5cdFx0XHR0czEgPSB0czEgKiAwLjUgKiAxLjkwNzUyNTE5MTczNzI4MWUtMTEgKyB0czA7XG5cdFx0XHRpbm91dFtpbm91dFBvcyArIDMgKiAxXSA9IHRjMiAtIHRzMTtcblx0XHRcdGlub3V0W2lub3V0UG9zICsgMyAqIDJdID0gdGMyICsgdHMxO1xuXG5cdFx0XHR0YzEgPSB0YzEgKiAwLjUgKiAxLjkwNzUyNTE5MTczNzI4MWUtMTEgLSB0YzA7XG5cdFx0XHR0czIgPSB0czIgKiAwLjg2NjAyNTQwMzc4NDQzODcwNzYxICogMS45MDc1MjUxOTE3MzcyODFlLTExO1xuXHRcdFx0Lypcblx0XHRcdCAqIHRyaXRhYl9zWyAwXVxuXHRcdFx0ICovXG5cdFx0XHRpbm91dFtpbm91dFBvcyArIDMgKiAzXSA9IHRjMSArIHRzMjtcblx0XHRcdGlub3V0W2lub3V0UG9zICsgMyAqIDRdID0gdGMxIC0gdHMyO1xuXG5cdFx0XHRpbm91dFBvcysrO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIG1kY3RfbG9uZyhvdXQsIG91dFBvcywgX2luKSB7XG5cdFx0dmFyIGN0LCBzdDtcblx0XHR7XG5cdFx0XHR2YXIgdGMxLCB0YzIsIHRjMywgdGM0LCB0czUsIHRzNiwgdHM3LCB0czg7XG5cdFx0XHQvKiAxLDIsIDUsNiwgOSwxMCwgMTMsMTQsIDE3ICovXG5cdFx0XHR0YzEgPSBfaW5bMTddIC0gX2luWzldO1xuXHRcdFx0dGMzID0gX2luWzE1XSAtIF9pblsxMV07XG5cdFx0XHR0YzQgPSBfaW5bMTRdIC0gX2luWzEyXTtcblx0XHRcdHRzNSA9IF9pblswXSArIF9pbls4XTtcblx0XHRcdHRzNiA9IF9pblsxXSArIF9pbls3XTtcblx0XHRcdHRzNyA9IF9pblsyXSArIF9pbls2XTtcblx0XHRcdHRzOCA9IF9pblszXSArIF9pbls1XTtcblxuXHRcdFx0b3V0W291dFBvcyArIDE3XSA9ICh0czUgKyB0czcgLSB0czgpIC0gKHRzNiAtIF9pbls0XSk7XG5cdFx0XHRzdCA9ICh0czUgKyB0czcgLSB0czgpICogY3hbMTIgKyA3XSArICh0czYgLSBfaW5bNF0pO1xuXHRcdFx0Y3QgPSAodGMxIC0gdGMzIC0gdGM0KSAqIGN4WzEyICsgNl07XG5cdFx0XHRvdXRbb3V0UG9zICsgNV0gPSBjdCArIHN0O1xuXHRcdFx0b3V0W291dFBvcyArIDZdID0gY3QgLSBzdDtcblxuXHRcdFx0dGMyID0gKF9pblsxNl0gLSBfaW5bMTBdKSAqIGN4WzEyICsgNl07XG5cdFx0XHR0czYgPSB0czYgKiBjeFsxMiArIDddICsgX2luWzRdO1xuXHRcdFx0Y3QgPSB0YzEgKiBjeFsxMiArIDBdICsgdGMyICsgdGMzICogY3hbMTIgKyAxXSArIHRjNCAqIGN4WzEyICsgMl07XG5cdFx0XHRzdCA9IC10czUgKiBjeFsxMiArIDRdICsgdHM2IC0gdHM3ICogY3hbMTIgKyA1XSArIHRzOCAqIGN4WzEyICsgM107XG5cdFx0XHRvdXRbb3V0UG9zICsgMV0gPSBjdCArIHN0O1xuXHRcdFx0b3V0W291dFBvcyArIDJdID0gY3QgLSBzdDtcblxuXHRcdFx0Y3QgPSB0YzEgKiBjeFsxMiArIDFdIC0gdGMyIC0gdGMzICogY3hbMTIgKyAyXSArIHRjNCAqIGN4WzEyICsgMF07XG5cdFx0XHRzdCA9IC10czUgKiBjeFsxMiArIDVdICsgdHM2IC0gdHM3ICogY3hbMTIgKyAzXSArIHRzOCAqIGN4WzEyICsgNF07XG5cdFx0XHRvdXRbb3V0UG9zICsgOV0gPSBjdCArIHN0O1xuXHRcdFx0b3V0W291dFBvcyArIDEwXSA9IGN0IC0gc3Q7XG5cblx0XHRcdGN0ID0gdGMxICogY3hbMTIgKyAyXSAtIHRjMiArIHRjMyAqIGN4WzEyICsgMF0gLSB0YzQgKiBjeFsxMiArIDFdO1xuXHRcdFx0c3QgPSB0czUgKiBjeFsxMiArIDNdIC0gdHM2ICsgdHM3ICogY3hbMTIgKyA0XSAtIHRzOCAqIGN4WzEyICsgNV07XG5cdFx0XHRvdXRbb3V0UG9zICsgMTNdID0gY3QgKyBzdDtcblx0XHRcdG91dFtvdXRQb3MgKyAxNF0gPSBjdCAtIHN0O1xuXHRcdH1cblx0XHR7XG5cdFx0XHR2YXIgdHMxLCB0czIsIHRzMywgdHM0LCB0YzUsIHRjNiwgdGM3LCB0Yzg7XG5cblx0XHRcdHRzMSA9IF9pbls4XSAtIF9pblswXTtcblx0XHRcdHRzMyA9IF9pbls2XSAtIF9pblsyXTtcblx0XHRcdHRzNCA9IF9pbls1XSAtIF9pblszXTtcblx0XHRcdHRjNSA9IF9pblsxN10gKyBfaW5bOV07XG5cdFx0XHR0YzYgPSBfaW5bMTZdICsgX2luWzEwXTtcblx0XHRcdHRjNyA9IF9pblsxNV0gKyBfaW5bMTFdO1xuXHRcdFx0dGM4ID0gX2luWzE0XSArIF9pblsxMl07XG5cblx0XHRcdG91dFtvdXRQb3MgKyAwXSA9ICh0YzUgKyB0YzcgKyB0YzgpICsgKHRjNiArIF9pblsxM10pO1xuXHRcdFx0Y3QgPSAodGM1ICsgdGM3ICsgdGM4KSAqIGN4WzEyICsgN10gLSAodGM2ICsgX2luWzEzXSk7XG5cdFx0XHRzdCA9ICh0czEgLSB0czMgKyB0czQpICogY3hbMTIgKyA2XTtcblx0XHRcdG91dFtvdXRQb3MgKyAxMV0gPSBjdCArIHN0O1xuXHRcdFx0b3V0W291dFBvcyArIDEyXSA9IGN0IC0gc3Q7XG5cblx0XHRcdHRzMiA9IChfaW5bN10gLSBfaW5bMV0pICogY3hbMTIgKyA2XTtcblx0XHRcdHRjNiA9IF9pblsxM10gLSB0YzYgKiBjeFsxMiArIDddO1xuXHRcdFx0Y3QgPSB0YzUgKiBjeFsxMiArIDNdIC0gdGM2ICsgdGM3ICogY3hbMTIgKyA0XSArIHRjOCAqIGN4WzEyICsgNV07XG5cdFx0XHRzdCA9IHRzMSAqIGN4WzEyICsgMl0gKyB0czIgKyB0czMgKiBjeFsxMiArIDBdICsgdHM0ICogY3hbMTIgKyAxXTtcblx0XHRcdG91dFtvdXRQb3MgKyAzXSA9IGN0ICsgc3Q7XG5cdFx0XHRvdXRbb3V0UG9zICsgNF0gPSBjdCAtIHN0O1xuXG5cdFx0XHRjdCA9IC10YzUgKiBjeFsxMiArIDVdICsgdGM2IC0gdGM3ICogY3hbMTIgKyAzXSAtIHRjOCAqIGN4WzEyICsgNF07XG5cdFx0XHRzdCA9IHRzMSAqIGN4WzEyICsgMV0gKyB0czIgLSB0czMgKiBjeFsxMiArIDJdIC0gdHM0ICogY3hbMTIgKyAwXTtcblx0XHRcdG91dFtvdXRQb3MgKyA3XSA9IGN0ICsgc3Q7XG5cdFx0XHRvdXRbb3V0UG9zICsgOF0gPSBjdCAtIHN0O1xuXG5cdFx0XHRjdCA9IC10YzUgKiBjeFsxMiArIDRdICsgdGM2IC0gdGM3ICogY3hbMTIgKyA1XSAtIHRjOCAqIGN4WzEyICsgM107XG5cdFx0XHRzdCA9IHRzMSAqIGN4WzEyICsgMF0gLSB0czIgKyB0czMgKiBjeFsxMiArIDFdIC0gdHM0ICogY3hbMTIgKyAyXTtcblx0XHRcdG91dFtvdXRQb3MgKyAxNV0gPSBjdCArIHN0O1xuXHRcdFx0b3V0W291dFBvcyArIDE2XSA9IGN0IC0gc3Q7XG5cdFx0fVxuXHR9XG5cblx0dGhpcy5tZGN0X3N1YjQ4ID0gZnVuY3Rpb24oZ2ZjLCB3MCwgdzEpIHtcblx0XHR2YXIgd2sgPSB3MDtcblx0XHR2YXIgd2tQb3MgPSAyODY7XG5cdFx0LyogdGhpbmtpbmcgY2FjaGUgcGVyZm9ybWFuY2UsIGNoLT5nciBsb29wIGlzIGJldHRlciB0aGFuIGdyLT5jaCBsb29wICovXG5cdFx0Zm9yICh2YXIgY2ggPSAwOyBjaCA8IGdmYy5jaGFubmVsc19vdXQ7IGNoKyspIHtcblx0XHRcdGZvciAodmFyIGdyID0gMDsgZ3IgPCBnZmMubW9kZV9ncjsgZ3IrKykge1xuXHRcdFx0XHR2YXIgYmFuZDtcblx0XHRcdFx0dmFyIGdpID0gKGdmYy5sM19zaWRlLnR0W2dyXVtjaF0pO1xuXHRcdFx0XHR2YXIgbWRjdF9lbmMgPSBnaS54cjtcblx0XHRcdFx0dmFyIG1kY3RfZW5jUG9zID0gMDtcblx0XHRcdFx0dmFyIHNhbXAgPSBnZmMuc2Jfc2FtcGxlW2NoXVsxIC0gZ3JdO1xuXHRcdFx0XHR2YXIgc2FtcFBvcyA9IDA7XG5cblx0XHRcdFx0Zm9yICh2YXIgayA9IDA7IGsgPCAxOCAvIDI7IGsrKykge1xuXHRcdFx0XHRcdHdpbmRvd19zdWJiYW5kKHdrLCB3a1Bvcywgc2FtcFtzYW1wUG9zXSk7XG5cdFx0XHRcdFx0d2luZG93X3N1YmJhbmQod2ssIHdrUG9zICsgMzIsIHNhbXBbc2FtcFBvcyArIDFdKTtcblx0XHRcdFx0XHRzYW1wUG9zICs9IDI7XG5cdFx0XHRcdFx0d2tQb3MgKz0gNjQ7XG5cdFx0XHRcdFx0Lypcblx0XHRcdFx0XHQgKiBDb21wZW5zYXRlIGZvciBpbnZlcnNpb24gaW4gdGhlIGFuYWx5c2lzIGZpbHRlclxuXHRcdFx0XHRcdCAqL1xuXHRcdFx0XHRcdGZvciAoYmFuZCA9IDE7IGJhbmQgPCAzMjsgYmFuZCArPSAyKSB7XG5cdFx0XHRcdFx0XHRzYW1wW3NhbXBQb3MgLSAxXVtiYW5kXSAqPSAtMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKlxuXHRcdFx0XHQgKiBQZXJmb3JtIGltZGN0IG9mIDE4IHByZXZpb3VzIHN1YmJhbmQgc2FtcGxlcyArIDE4IGN1cnJlbnRcblx0XHRcdFx0ICogc3ViYmFuZCBzYW1wbGVzXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRmb3IgKGJhbmQgPSAwOyBiYW5kIDwgMzI7IGJhbmQrKywgbWRjdF9lbmNQb3MgKz0gMTgpIHtcblx0XHRcdFx0XHR2YXIgdHlwZSA9IGdpLmJsb2NrX3R5cGU7XG5cdFx0XHRcdFx0dmFyIGJhbmQwID0gZ2ZjLnNiX3NhbXBsZVtjaF1bZ3JdO1xuXHRcdFx0XHRcdHZhciBiYW5kMSA9IGdmYy5zYl9zYW1wbGVbY2hdWzEgLSBncl07XG5cdFx0XHRcdFx0aWYgKGdpLm1peGVkX2Jsb2NrX2ZsYWcgIT0gMCAmJiBiYW5kIDwgMilcblx0XHRcdFx0XHRcdHR5cGUgPSAwO1xuXHRcdFx0XHRcdGlmIChnZmMuYW1wX2ZpbHRlcltiYW5kXSA8IDFlLTEyKSB7XG5cdFx0XHRcdFx0XHRBcnJheXMuZmlsbChtZGN0X2VuYywgbWRjdF9lbmNQb3MgKyAwLFxuXHRcdFx0XHRcdFx0XHRcdG1kY3RfZW5jUG9zICsgMTgsIDApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAoZ2ZjLmFtcF9maWx0ZXJbYmFuZF0gPCAxLjApIHtcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgayA9IDA7IGsgPCAxODsgaysrKVxuXHRcdFx0XHRcdFx0XHRcdGJhbmQxW2tdW29yZGVyW2JhbmRdXSAqPSBnZmMuYW1wX2ZpbHRlcltiYW5kXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICh0eXBlID09IEVuY29kZXIuU0hPUlRfVFlQRSkge1xuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBrID0gLU5TIC8gNDsgayA8IDA7IGsrKykge1xuXHRcdFx0XHRcdFx0XHRcdHZhciB3ID0gd2luW0VuY29kZXIuU0hPUlRfVFlQRV1bayArIDNdO1xuXHRcdFx0XHRcdFx0XHRcdG1kY3RfZW5jW21kY3RfZW5jUG9zICsgayAqIDMgKyA5XSA9IGJhbmQwWzkgKyBrXVtvcmRlcltiYW5kXV1cblx0XHRcdFx0XHRcdFx0XHRcdFx0KiB3IC0gYmFuZDBbOCAtIGtdW29yZGVyW2JhbmRdXTtcblx0XHRcdFx0XHRcdFx0XHRtZGN0X2VuY1ttZGN0X2VuY1BvcyArIGsgKiAzICsgMThdID0gYmFuZDBbMTQgLSBrXVtvcmRlcltiYW5kXV1cblx0XHRcdFx0XHRcdFx0XHRcdFx0KiB3ICsgYmFuZDBbMTUgKyBrXVtvcmRlcltiYW5kXV07XG5cdFx0XHRcdFx0XHRcdFx0bWRjdF9lbmNbbWRjdF9lbmNQb3MgKyBrICogMyArIDEwXSA9IGJhbmQwWzE1ICsga11bb3JkZXJbYmFuZF1dXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCogdyAtIGJhbmQwWzE0IC0ga11bb3JkZXJbYmFuZF1dO1xuXHRcdFx0XHRcdFx0XHRcdG1kY3RfZW5jW21kY3RfZW5jUG9zICsgayAqIDMgKyAxOV0gPSBiYW5kMVsyIC0ga11bb3JkZXJbYmFuZF1dXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCogdyArIGJhbmQxWzMgKyBrXVtvcmRlcltiYW5kXV07XG5cdFx0XHRcdFx0XHRcdFx0bWRjdF9lbmNbbWRjdF9lbmNQb3MgKyBrICogMyArIDExXSA9IGJhbmQxWzMgKyBrXVtvcmRlcltiYW5kXV1cblx0XHRcdFx0XHRcdFx0XHRcdFx0KiB3IC0gYmFuZDFbMiAtIGtdW29yZGVyW2JhbmRdXTtcblx0XHRcdFx0XHRcdFx0XHRtZGN0X2VuY1ttZGN0X2VuY1BvcyArIGsgKiAzICsgMjBdID0gYmFuZDFbOCAtIGtdW29yZGVyW2JhbmRdXVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQqIHcgKyBiYW5kMVs5ICsga11bb3JkZXJbYmFuZF1dO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdG1kY3Rfc2hvcnQobWRjdF9lbmMsIG1kY3RfZW5jUG9zKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHZhciB3b3JrID0gbmV3X2Zsb2F0KDE4KTtcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgayA9IC1OTCAvIDQ7IGsgPCAwOyBrKyspIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgYSwgYjtcblx0XHRcdFx0XHRcdFx0XHRhID0gd2luW3R5cGVdW2sgKyAyN11cblx0XHRcdFx0XHRcdFx0XHRcdFx0KiBiYW5kMVtrICsgOV1bb3JkZXJbYmFuZF1dXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCsgd2luW3R5cGVdW2sgKyAzNl1cblx0XHRcdFx0XHRcdFx0XHRcdFx0KiBiYW5kMVs4IC0ga11bb3JkZXJbYmFuZF1dO1xuXHRcdFx0XHRcdFx0XHRcdGIgPSB3aW5bdHlwZV1bayArIDldXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCogYmFuZDBbayArIDldW29yZGVyW2JhbmRdXVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQtIHdpblt0eXBlXVtrICsgMThdXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCogYmFuZDBbOCAtIGtdW29yZGVyW2JhbmRdXTtcblx0XHRcdFx0XHRcdFx0XHR3b3JrW2sgKyA5XSA9IGEgLSBiICogdGFudGFiX2xbMyArIGsgKyA5XTtcblx0XHRcdFx0XHRcdFx0XHR3b3JrW2sgKyAxOF0gPSBhICogdGFudGFiX2xbMyArIGsgKyA5XSArIGI7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRtZGN0X2xvbmcobWRjdF9lbmMsIG1kY3RfZW5jUG9zLCB3b3JrKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Lypcblx0XHRcdFx0XHQgKiBQZXJmb3JtIGFsaWFzaW5nIHJlZHVjdGlvbiBidXR0ZXJmbHlcblx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHRpZiAodHlwZSAhPSBFbmNvZGVyLlNIT1JUX1RZUEUgJiYgYmFuZCAhPSAwKSB7XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBrID0gNzsgayA+PSAwOyAtLWspIHtcblx0XHRcdFx0XHRcdFx0dmFyIGJ1LCBiZDtcblx0XHRcdFx0XHRcdFx0YnUgPSBtZGN0X2VuY1ttZGN0X2VuY1BvcyArIGtdICogY2FbMjAgKyBrXVxuXHRcdFx0XHRcdFx0XHRcdFx0KyBtZGN0X2VuY1ttZGN0X2VuY1BvcyArIC0xIC0ga11cblx0XHRcdFx0XHRcdFx0XHRcdCogY3NbMjggKyBrXTtcblx0XHRcdFx0XHRcdFx0YmQgPSBtZGN0X2VuY1ttZGN0X2VuY1BvcyArIGtdICogY3NbMjggKyBrXVxuXHRcdFx0XHRcdFx0XHRcdFx0LSBtZGN0X2VuY1ttZGN0X2VuY1BvcyArIC0xIC0ga11cblx0XHRcdFx0XHRcdFx0XHRcdCogY2FbMjAgKyBrXTtcblxuXHRcdFx0XHRcdFx0XHRtZGN0X2VuY1ttZGN0X2VuY1BvcyArIC0xIC0ga10gPSBidTtcblx0XHRcdFx0XHRcdFx0bWRjdF9lbmNbbWRjdF9lbmNQb3MgKyBrXSA9IGJkO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0d2sgPSB3MTtcblx0XHRcdHdrUG9zID0gMjg2O1xuXHRcdFx0aWYgKGdmYy5tb2RlX2dyID09IDEpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxODsgaSsrKSB7XG5cdFx0XHRcdFx0U3lzdGVtLmFycmF5Y29weShnZmMuc2Jfc2FtcGxlW2NoXVsxXVtpXSwgMCxcblx0XHRcdFx0XHRcdFx0Z2ZjLnNiX3NhbXBsZVtjaF1bMF1baV0sIDAsIDMyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE5ld01EQ1Q7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lamejs/src/js/NewMDCT.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lamejs/src/js/NsPsy.js":
/*!*********************************************!*\
  !*** ./node_modules/lamejs/src/js/NsPsy.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var common = __webpack_require__(/*! ./common.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/common.js\");\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\nvar Encoder = __webpack_require__(/*! ./Encoder.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/Encoder.js\");\n\n//package mp3;\n\n/**\n * Variables used for --nspsytune\n *\n * @author Ken\n *\n */\nfunction NsPsy() {\n    this.last_en_subshort = new_float_n([4, 9]);\n    this.lastAttacks = new_int(4);\n    this.pefirbuf = new_float(19);\n    this.longfact = new_float(Encoder.SBMAX_l);\n    this.shortfact = new_float(Encoder.SBMAX_s);\n\n    /**\n     * short block tuning\n     */\n    this.attackthre = 0.;\n    this.attackthre_s = 0.;\n}\n\nmodule.exports = NsPsy;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL05zUHN5LmpzIiwibWFwcGluZ3MiOiJBQUFBLGFBQWEsbUJBQU8sQ0FBQywrRUFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsbUJBQU8sQ0FBQyxpRkFBYzs7QUFFcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbGFtZWpzL3NyYy9qcy9Oc1BzeS5qcz8wNDE0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbi5qcycpO1xudmFyIFN5c3RlbSA9IGNvbW1vbi5TeXN0ZW07XG52YXIgVmJyTW9kZSA9IGNvbW1vbi5WYnJNb2RlO1xudmFyIEZsb2F0ID0gY29tbW9uLkZsb2F0O1xudmFyIFNob3J0QmxvY2sgPSBjb21tb24uU2hvcnRCbG9jaztcbnZhciBVdGlsID0gY29tbW9uLlV0aWw7XG52YXIgQXJyYXlzID0gY29tbW9uLkFycmF5cztcbnZhciBuZXdfYXJyYXlfbiA9IGNvbW1vbi5uZXdfYXJyYXlfbjtcbnZhciBuZXdfYnl0ZSA9IGNvbW1vbi5uZXdfYnl0ZTtcbnZhciBuZXdfZG91YmxlID0gY29tbW9uLm5ld19kb3VibGU7XG52YXIgbmV3X2Zsb2F0ID0gY29tbW9uLm5ld19mbG9hdDtcbnZhciBuZXdfZmxvYXRfbiA9IGNvbW1vbi5uZXdfZmxvYXRfbjtcbnZhciBuZXdfaW50ID0gY29tbW9uLm5ld19pbnQ7XG52YXIgbmV3X2ludF9uID0gY29tbW9uLm5ld19pbnRfbjtcbnZhciBhc3NlcnQgPSBjb21tb24uYXNzZXJ0O1xuXG52YXIgRW5jb2RlciA9IHJlcXVpcmUoJy4vRW5jb2Rlci5qcycpO1xuXG4vL3BhY2thZ2UgbXAzO1xuXG4vKipcbiAqIFZhcmlhYmxlcyB1c2VkIGZvciAtLW5zcHN5dHVuZVxuICpcbiAqIEBhdXRob3IgS2VuXG4gKlxuICovXG5mdW5jdGlvbiBOc1BzeSgpIHtcbiAgICB0aGlzLmxhc3RfZW5fc3Vic2hvcnQgPSBuZXdfZmxvYXRfbihbNCwgOV0pO1xuICAgIHRoaXMubGFzdEF0dGFja3MgPSBuZXdfaW50KDQpO1xuICAgIHRoaXMucGVmaXJidWYgPSBuZXdfZmxvYXQoMTkpO1xuICAgIHRoaXMubG9uZ2ZhY3QgPSBuZXdfZmxvYXQoRW5jb2Rlci5TQk1BWF9sKTtcbiAgICB0aGlzLnNob3J0ZmFjdCA9IG5ld19mbG9hdChFbmNvZGVyLlNCTUFYX3MpO1xuXG4gICAgLyoqXG4gICAgICogc2hvcnQgYmxvY2sgdHVuaW5nXG4gICAgICovXG4gICAgdGhpcy5hdHRhY2t0aHJlID0gMC47XG4gICAgdGhpcy5hdHRhY2t0aHJlX3MgPSAwLjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBOc1BzeTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lamejs/src/js/NsPsy.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lamejs/src/js/Presets.js":
/*!***********************************************!*\
  !*** ./node_modules/lamejs/src/js/Presets.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var common = __webpack_require__(/*! ./common.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/common.js\");\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\nfunction Presets() {\n    var Lame = __webpack_require__(/*! ./Lame.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/Lame.js\");\n    function VBRPresets(qual, comp, compS,\n                        y, shThreshold, shThresholdS,\n                        adj, adjShort, lower,\n                        curve, sens, inter,\n                        joint, mod, fix) {\n        this.vbr_q = qual;\n        this.quant_comp = comp;\n        this.quant_comp_s = compS;\n        this.expY = y;\n        this.st_lrm = shThreshold;\n        this.st_s = shThresholdS;\n        this.masking_adj = adj;\n        this.masking_adj_short = adjShort;\n        this.ath_lower = lower;\n        this.ath_curve = curve;\n        this.ath_sensitivity = sens;\n        this.interch = inter;\n        this.safejoint = joint;\n        this.sfb21mod = mod;\n        this.msfix = fix;\n    }\n\n    function ABRPresets(kbps, comp, compS,\n                        joint, fix, shThreshold,\n                        shThresholdS, bass, sc,\n                        mask, lower, curve,\n                        interCh, sfScale) {\n        this.quant_comp = comp;\n        this.quant_comp_s = compS;\n        this.safejoint = joint;\n        this.nsmsfix = fix;\n        this.st_lrm = shThreshold;\n        this.st_s = shThresholdS;\n        this.nsbass = bass;\n        this.scale = sc;\n        this.masking_adj = mask;\n        this.ath_lower = lower;\n        this.ath_curve = curve;\n        this.interch = interCh;\n        this.sfscale = sfScale;\n    }\n\n    var lame;\n\n    this.setModules = function (_lame) {\n        lame = _lame;\n    };\n\n    /**\n     * <PRE>\n     * Switch mappings for VBR mode VBR_RH\n     *             vbr_q  qcomp_l  qcomp_s  expY  st_lrm   st_s  mask adj_l  adj_s  ath_lower  ath_curve  ath_sens  interChR  safejoint sfb21mod  msfix\n     * </PRE>\n     */\n    var vbr_old_switch_map = [\n        new VBRPresets(0, 9, 9, 0, 5.20, 125.0, -4.2, -6.3, 4.8, 1, 0, 0, 2, 21, 0.97),\n        new VBRPresets(1, 9, 9, 0, 5.30, 125.0, -3.6, -5.6, 4.5, 1.5, 0, 0, 2, 21, 1.35),\n        new VBRPresets(2, 9, 9, 0, 5.60, 125.0, -2.2, -3.5, 2.8, 2, 0, 0, 2, 21, 1.49),\n        new VBRPresets(3, 9, 9, 1, 5.80, 130.0, -1.8, -2.8, 2.6, 3, -4, 0, 2, 20, 1.64),\n        new VBRPresets(4, 9, 9, 1, 6.00, 135.0, -0.7, -1.1, 1.1, 3.5, -8, 0, 2, 0, 1.79),\n        new VBRPresets(5, 9, 9, 1, 6.40, 140.0, 0.5, 0.4, -7.5, 4, -12, 0.0002, 0, 0, 1.95),\n        new VBRPresets(6, 9, 9, 1, 6.60, 145.0, 0.67, 0.65, -14.7, 6.5, -19, 0.0004, 0, 0, 2.30),\n        new VBRPresets(7, 9, 9, 1, 6.60, 145.0, 0.8, 0.75, -19.7, 8, -22, 0.0006, 0, 0, 2.70),\n        new VBRPresets(8, 9, 9, 1, 6.60, 145.0, 1.2, 1.15, -27.5, 10, -23, 0.0007, 0, 0, 0),\n        new VBRPresets(9, 9, 9, 1, 6.60, 145.0, 1.6, 1.6, -36, 11, -25, 0.0008, 0, 0, 0),\n        new VBRPresets(10, 9, 9, 1, 6.60, 145.0, 2.0, 2.0, -36, 12, -25, 0.0008, 0, 0, 0)\n    ];\n\n    /**\n     * <PRE>\n     *                 vbr_q  qcomp_l  qcomp_s  expY  st_lrm   st_s  mask adj_l  adj_s  ath_lower  ath_curve  ath_sens  interChR  safejoint sfb21mod  msfix\n     * </PRE>\n     */\n    var vbr_psy_switch_map = [\n        new VBRPresets(0, 9, 9, 0, 4.20, 25.0, -7.0, -4.0, 7.5, 1, 0, 0, 2, 26, 0.97),\n        new VBRPresets(1, 9, 9, 0, 4.20, 25.0, -5.6, -3.6, 4.5, 1.5, 0, 0, 2, 21, 1.35),\n        new VBRPresets(2, 9, 9, 0, 4.20, 25.0, -4.4, -1.8, 2, 2, 0, 0, 2, 18, 1.49),\n        new VBRPresets(3, 9, 9, 1, 4.20, 25.0, -3.4, -1.25, 1.1, 3, -4, 0, 2, 15, 1.64),\n        new VBRPresets(4, 9, 9, 1, 4.20, 25.0, -2.2, 0.1, 0, 3.5, -8, 0, 2, 0, 1.79),\n        new VBRPresets(5, 9, 9, 1, 4.20, 25.0, -1.0, 1.65, -7.7, 4, -12, 0.0002, 0, 0, 1.95),\n        new VBRPresets(6, 9, 9, 1, 4.20, 25.0, -0.0, 2.47, -7.7, 6.5, -19, 0.0004, 0, 0, 2),\n        new VBRPresets(7, 9, 9, 1, 4.20, 25.0, 0.5, 2.0, -14.5, 8, -22, 0.0006, 0, 0, 2),\n        new VBRPresets(8, 9, 9, 1, 4.20, 25.0, 1.0, 2.4, -22.0, 10, -23, 0.0007, 0, 0, 2),\n        new VBRPresets(9, 9, 9, 1, 4.20, 25.0, 1.5, 2.95, -30.0, 11, -25, 0.0008, 0, 0, 2),\n        new VBRPresets(10, 9, 9, 1, 4.20, 25.0, 2.0, 2.95, -36.0, 12, -30, 0.0008, 0, 0, 2)\n    ];\n\n    function apply_vbr_preset(gfp, a, enforce) {\n        var vbr_preset = gfp.VBR == VbrMode.vbr_rh ? vbr_old_switch_map\n            : vbr_psy_switch_map;\n\n        var x = gfp.VBR_q_frac;\n        var p = vbr_preset[a];\n        var q = vbr_preset[a + 1];\n        var set = p;\n\n        // NOOP(vbr_q);\n        // NOOP(quant_comp);\n        // NOOP(quant_comp_s);\n        // NOOP(expY);\n        p.st_lrm = p.st_lrm + x * (q.st_lrm - p.st_lrm);\n        // LERP(st_lrm);\n        p.st_s = p.st_s + x * (q.st_s - p.st_s);\n        // LERP(st_s);\n        p.masking_adj = p.masking_adj + x * (q.masking_adj - p.masking_adj);\n        // LERP(masking_adj);\n        p.masking_adj_short = p.masking_adj_short + x\n            * (q.masking_adj_short - p.masking_adj_short);\n        // LERP(masking_adj_short);\n        p.ath_lower = p.ath_lower + x * (q.ath_lower - p.ath_lower);\n        // LERP(ath_lower);\n        p.ath_curve = p.ath_curve + x * (q.ath_curve - p.ath_curve);\n        // LERP(ath_curve);\n        p.ath_sensitivity = p.ath_sensitivity + x\n            * (q.ath_sensitivity - p.ath_sensitivity);\n        // LERP(ath_sensitivity);\n        p.interch = p.interch + x * (q.interch - p.interch);\n        // LERP(interch);\n        // NOOP(safejoint);\n        // NOOP(sfb21mod);\n        p.msfix = p.msfix + x * (q.msfix - p.msfix);\n        // LERP(msfix);\n\n        lame_set_VBR_q(gfp, set.vbr_q);\n\n        if (enforce != 0)\n            gfp.quant_comp = set.quant_comp;\n        else if (!(Math.abs(gfp.quant_comp - -1) > 0))\n            gfp.quant_comp = set.quant_comp;\n        // SET_OPTION(quant_comp, set.quant_comp, -1);\n        if (enforce != 0)\n            gfp.quant_comp_short = set.quant_comp_s;\n        else if (!(Math.abs(gfp.quant_comp_short - -1) > 0))\n            gfp.quant_comp_short = set.quant_comp_s;\n        // SET_OPTION(quant_comp_short, set.quant_comp_s, -1);\n        if (set.expY != 0) {\n            gfp.experimentalY = set.expY != 0;\n        }\n        if (enforce != 0)\n            gfp.internal_flags.nsPsy.attackthre = set.st_lrm;\n        else if (!(Math.abs(gfp.internal_flags.nsPsy.attackthre - -1) > 0))\n            gfp.internal_flags.nsPsy.attackthre = set.st_lrm;\n        // SET_OPTION(short_threshold_lrm, set.st_lrm, -1);\n        if (enforce != 0)\n            gfp.internal_flags.nsPsy.attackthre_s = set.st_s;\n        else if (!(Math.abs(gfp.internal_flags.nsPsy.attackthre_s - -1) > 0))\n            gfp.internal_flags.nsPsy.attackthre_s = set.st_s;\n        // SET_OPTION(short_threshold_s, set.st_s, -1);\n        if (enforce != 0)\n            gfp.maskingadjust = set.masking_adj;\n        else if (!(Math.abs(gfp.maskingadjust - 0) > 0))\n            gfp.maskingadjust = set.masking_adj;\n        // SET_OPTION(maskingadjust, set.masking_adj, 0);\n        if (enforce != 0)\n            gfp.maskingadjust_short = set.masking_adj_short;\n        else if (!(Math.abs(gfp.maskingadjust_short - 0) > 0))\n            gfp.maskingadjust_short = set.masking_adj_short;\n        // SET_OPTION(maskingadjust_short, set.masking_adj_short, 0);\n        if (enforce != 0)\n            gfp.ATHlower = -set.ath_lower / 10.0;\n        else if (!(Math.abs((-gfp.ATHlower * 10.0) - 0) > 0))\n            gfp.ATHlower = -set.ath_lower / 10.0;\n        // SET_OPTION(ATHlower, set.ath_lower, 0);\n        if (enforce != 0)\n            gfp.ATHcurve = set.ath_curve;\n        else if (!(Math.abs(gfp.ATHcurve - -1) > 0))\n            gfp.ATHcurve = set.ath_curve;\n        // SET_OPTION(ATHcurve, set.ath_curve, -1);\n        if (enforce != 0)\n            gfp.athaa_sensitivity = set.ath_sensitivity;\n        else if (!(Math.abs(gfp.athaa_sensitivity - -1) > 0))\n            gfp.athaa_sensitivity = set.ath_sensitivity;\n        // SET_OPTION(athaa_sensitivity, set.ath_sensitivity, 0);\n        if (set.interch > 0) {\n            if (enforce != 0)\n                gfp.interChRatio = set.interch;\n            else if (!(Math.abs(gfp.interChRatio - -1) > 0))\n                gfp.interChRatio = set.interch;\n            // SET_OPTION(interChRatio, set.interch, -1);\n        }\n\n        /* parameters for which there is no proper set/get interface */\n        if (set.safejoint > 0) {\n            gfp.exp_nspsytune = gfp.exp_nspsytune | set.safejoint;\n        }\n        if (set.sfb21mod > 0) {\n            gfp.exp_nspsytune = gfp.exp_nspsytune | (set.sfb21mod << 20);\n        }\n        if (enforce != 0)\n            gfp.msfix = set.msfix;\n        else if (!(Math.abs(gfp.msfix - -1) > 0))\n            gfp.msfix = set.msfix;\n        // SET_OPTION(msfix, set.msfix, -1);\n\n        if (enforce == 0) {\n            gfp.VBR_q = a;\n            gfp.VBR_q_frac = x;\n        }\n    }\n\n    /**\n     * <PRE>\n     *  Switch mappings for ABR mode\n     *\n     *              kbps  quant q_s safejoint nsmsfix st_lrm  st_s  ns-bass scale   msk ath_lwr ath_curve  interch , sfscale\n     * </PRE>\n     */\n    var abr_switch_map = [\n        new ABRPresets(8, 9, 9, 0, 0, 6.60, 145, 0, 0.95, 0, -30.0, 11, 0.0012, 1), /*   8, impossible to use in stereo */\n        new ABRPresets(16, 9, 9, 0, 0, 6.60, 145, 0, 0.95, 0, -25.0, 11, 0.0010, 1), /*  16 */\n        new ABRPresets(24, 9, 9, 0, 0, 6.60, 145, 0, 0.95, 0, -20.0, 11, 0.0010, 1), /*  24 */\n        new ABRPresets(32, 9, 9, 0, 0, 6.60, 145, 0, 0.95, 0, -15.0, 11, 0.0010, 1), /*  32 */\n        new ABRPresets(40, 9, 9, 0, 0, 6.60, 145, 0, 0.95, 0, -10.0, 11, 0.0009, 1), /*  40 */\n        new ABRPresets(48, 9, 9, 0, 0, 6.60, 145, 0, 0.95, 0, -10.0, 11, 0.0009, 1), /*  48 */\n        new ABRPresets(56, 9, 9, 0, 0, 6.60, 145, 0, 0.95, 0, -6.0, 11, 0.0008, 1), /*  56 */\n        new ABRPresets(64, 9, 9, 0, 0, 6.60, 145, 0, 0.95, 0, -2.0, 11, 0.0008, 1), /*  64 */\n        new ABRPresets(80, 9, 9, 0, 0, 6.60, 145, 0, 0.95, 0, .0, 8, 0.0007, 1), /*  80 */\n        new ABRPresets(96, 9, 9, 0, 2.50, 6.60, 145, 0, 0.95, 0, 1.0, 5.5, 0.0006, 1), /*  96 */\n        new ABRPresets(112, 9, 9, 0, 2.25, 6.60, 145, 0, 0.95, 0, 2.0, 4.5, 0.0005, 1), /* 112 */\n        new ABRPresets(128, 9, 9, 0, 1.95, 6.40, 140, 0, 0.95, 0, 3.0, 4, 0.0002, 1), /* 128 */\n        new ABRPresets(160, 9, 9, 1, 1.79, 6.00, 135, 0, 0.95, -2, 5.0, 3.5, 0, 1), /* 160 */\n        new ABRPresets(192, 9, 9, 1, 1.49, 5.60, 125, 0, 0.97, -4, 7.0, 3, 0, 0), /* 192 */\n        new ABRPresets(224, 9, 9, 1, 1.25, 5.20, 125, 0, 0.98, -6, 9.0, 2, 0, 0), /* 224 */\n        new ABRPresets(256, 9, 9, 1, 0.97, 5.20, 125, 0, 1.00, -8, 10.0, 1, 0, 0), /* 256 */\n        new ABRPresets(320, 9, 9, 1, 0.90, 5.20, 125, 0, 1.00, -10, 12.0, 0, 0, 0)  /* 320 */\n    ];\n\n    function apply_abr_preset(gfp, preset, enforce) {\n        /* Variables for the ABR stuff */\n        var actual_bitrate = preset;\n\n        var r = lame.nearestBitrateFullIndex(preset);\n\n        gfp.VBR = VbrMode.vbr_abr;\n        gfp.VBR_mean_bitrate_kbps = actual_bitrate;\n        gfp.VBR_mean_bitrate_kbps = Math.min(gfp.VBR_mean_bitrate_kbps, 320);\n        gfp.VBR_mean_bitrate_kbps = Math.max(gfp.VBR_mean_bitrate_kbps, 8);\n        gfp.brate = gfp.VBR_mean_bitrate_kbps;\n        if (gfp.VBR_mean_bitrate_kbps > 320) {\n            gfp.disable_reservoir = true;\n        }\n\n        /* parameters for which there is no proper set/get interface */\n        if (abr_switch_map[r].safejoint > 0)\n            gfp.exp_nspsytune = gfp.exp_nspsytune | 2;\n        /* safejoint */\n\n        if (abr_switch_map[r].sfscale > 0) {\n            gfp.internal_flags.noise_shaping = 2;\n        }\n        /* ns-bass tweaks */\n        if (Math.abs(abr_switch_map[r].nsbass) > 0) {\n            var k = (int)(abr_switch_map[r].nsbass * 4);\n            if (k < 0)\n                k += 64;\n            gfp.exp_nspsytune = gfp.exp_nspsytune | (k << 2);\n        }\n\n        if (enforce != 0)\n            gfp.quant_comp = abr_switch_map[r].quant_comp;\n        else if (!(Math.abs(gfp.quant_comp - -1) > 0))\n            gfp.quant_comp = abr_switch_map[r].quant_comp;\n        // SET_OPTION(quant_comp, abr_switch_map[r].quant_comp, -1);\n        if (enforce != 0)\n            gfp.quant_comp_short = abr_switch_map[r].quant_comp_s;\n        else if (!(Math.abs(gfp.quant_comp_short - -1) > 0))\n            gfp.quant_comp_short = abr_switch_map[r].quant_comp_s;\n        // SET_OPTION(quant_comp_short, abr_switch_map[r].quant_comp_s, -1);\n\n        if (enforce != 0)\n            gfp.msfix = abr_switch_map[r].nsmsfix;\n        else if (!(Math.abs(gfp.msfix - -1) > 0))\n            gfp.msfix = abr_switch_map[r].nsmsfix;\n        // SET_OPTION(msfix, abr_switch_map[r].nsmsfix, -1);\n\n        if (enforce != 0)\n            gfp.internal_flags.nsPsy.attackthre = abr_switch_map[r].st_lrm;\n        else if (!(Math.abs(gfp.internal_flags.nsPsy.attackthre - -1) > 0))\n            gfp.internal_flags.nsPsy.attackthre = abr_switch_map[r].st_lrm;\n        // SET_OPTION(short_threshold_lrm, abr_switch_map[r].st_lrm, -1);\n        if (enforce != 0)\n            gfp.internal_flags.nsPsy.attackthre_s = abr_switch_map[r].st_s;\n        else if (!(Math.abs(gfp.internal_flags.nsPsy.attackthre_s - -1) > 0))\n            gfp.internal_flags.nsPsy.attackthre_s = abr_switch_map[r].st_s;\n        // SET_OPTION(short_threshold_s, abr_switch_map[r].st_s, -1);\n\n        /*\n         * ABR seems to have big problems with clipping, especially at low\n         * bitrates\n         */\n        /*\n         * so we compensate for that here by using a scale value depending on\n         * bitrate\n         */\n        if (enforce != 0)\n            gfp.scale = abr_switch_map[r].scale;\n        else if (!(Math.abs(gfp.scale - -1) > 0))\n            gfp.scale = abr_switch_map[r].scale;\n        // SET_OPTION(scale, abr_switch_map[r].scale, -1);\n\n        if (enforce != 0)\n            gfp.maskingadjust = abr_switch_map[r].masking_adj;\n        else if (!(Math.abs(gfp.maskingadjust - 0) > 0))\n            gfp.maskingadjust = abr_switch_map[r].masking_adj;\n        // SET_OPTION(maskingadjust, abr_switch_map[r].masking_adj, 0);\n        if (abr_switch_map[r].masking_adj > 0) {\n            if (enforce != 0)\n                gfp.maskingadjust_short = (abr_switch_map[r].masking_adj * .9);\n            else if (!(Math.abs(gfp.maskingadjust_short - 0) > 0))\n                gfp.maskingadjust_short = (abr_switch_map[r].masking_adj * .9);\n            // SET_OPTION(maskingadjust_short, abr_switch_map[r].masking_adj *\n            // .9, 0);\n        } else {\n            if (enforce != 0)\n                gfp.maskingadjust_short = (abr_switch_map[r].masking_adj * 1.1);\n            else if (!(Math.abs(gfp.maskingadjust_short - 0) > 0))\n                gfp.maskingadjust_short = (abr_switch_map[r].masking_adj * 1.1);\n            // SET_OPTION(maskingadjust_short, abr_switch_map[r].masking_adj *\n            // 1.1, 0);\n        }\n\n        if (enforce != 0)\n            gfp.ATHlower = -abr_switch_map[r].ath_lower / 10.;\n        else if (!(Math.abs((-gfp.ATHlower * 10.) - 0) > 0))\n            gfp.ATHlower = -abr_switch_map[r].ath_lower / 10.;\n        // SET_OPTION(ATHlower, abr_switch_map[r].ath_lower, 0);\n        if (enforce != 0)\n            gfp.ATHcurve = abr_switch_map[r].ath_curve;\n        else if (!(Math.abs(gfp.ATHcurve - -1) > 0))\n            gfp.ATHcurve = abr_switch_map[r].ath_curve;\n        // SET_OPTION(ATHcurve, abr_switch_map[r].ath_curve, -1);\n\n        if (enforce != 0)\n            gfp.interChRatio = abr_switch_map[r].interch;\n        else if (!(Math.abs(gfp.interChRatio - -1) > 0))\n            gfp.interChRatio = abr_switch_map[r].interch;\n        // SET_OPTION(interChRatio, abr_switch_map[r].interch, -1);\n\n        return preset;\n    }\n\n    this.apply_preset = function(gfp, preset, enforce) {\n        /* translate legacy presets */\n        switch (preset) {\n            case Lame.R3MIX:\n            {\n                preset = Lame.V3;\n                gfp.VBR = VbrMode.vbr_mtrh;\n                break;\n            }\n            case Lame.MEDIUM:\n            {\n                preset = Lame.V4;\n                gfp.VBR = VbrMode.vbr_rh;\n                break;\n            }\n            case Lame.MEDIUM_FAST:\n            {\n                preset = Lame.V4;\n                gfp.VBR = VbrMode.vbr_mtrh;\n                break;\n            }\n            case Lame.STANDARD:\n            {\n                preset = Lame.V2;\n                gfp.VBR = VbrMode.vbr_rh;\n                break;\n            }\n            case Lame.STANDARD_FAST:\n            {\n                preset = Lame.V2;\n                gfp.VBR = VbrMode.vbr_mtrh;\n                break;\n            }\n            case Lame.EXTREME:\n            {\n                preset = Lame.V0;\n                gfp.VBR = VbrMode.vbr_rh;\n                break;\n            }\n            case Lame.EXTREME_FAST:\n            {\n                preset = Lame.V0;\n                gfp.VBR = VbrMode.vbr_mtrh;\n                break;\n            }\n            case Lame.INSANE:\n            {\n                preset = 320;\n                gfp.preset = preset;\n                apply_abr_preset(gfp, preset, enforce);\n                gfp.VBR = VbrMode.vbr_off;\n                return preset;\n            }\n        }\n\n        gfp.preset = preset;\n        {\n            switch (preset) {\n                case Lame.V9:\n                    apply_vbr_preset(gfp, 9, enforce);\n                    return preset;\n                case Lame.V8:\n                    apply_vbr_preset(gfp, 8, enforce);\n                    return preset;\n                case Lame.V7:\n                    apply_vbr_preset(gfp, 7, enforce);\n                    return preset;\n                case Lame.V6:\n                    apply_vbr_preset(gfp, 6, enforce);\n                    return preset;\n                case Lame.V5:\n                    apply_vbr_preset(gfp, 5, enforce);\n                    return preset;\n                case Lame.V4:\n                    apply_vbr_preset(gfp, 4, enforce);\n                    return preset;\n                case Lame.V3:\n                    apply_vbr_preset(gfp, 3, enforce);\n                    return preset;\n                case Lame.V2:\n                    apply_vbr_preset(gfp, 2, enforce);\n                    return preset;\n                case Lame.V1:\n                    apply_vbr_preset(gfp, 1, enforce);\n                    return preset;\n                case Lame.V0:\n                    apply_vbr_preset(gfp, 0, enforce);\n                    return preset;\n                default:\n                    break;\n            }\n        }\n        if (8 <= preset && preset <= 320) {\n            return apply_abr_preset(gfp, preset, enforce);\n        }\n\n        /* no corresponding preset found */\n        gfp.preset = 0;\n        return preset;\n    }\n\n    // Rest from getset.c:\n\n    /**\n     * VBR quality level.<BR>\n     * 0 = highest<BR>\n     * 9 = lowest\n     */\n    function lame_set_VBR_q(gfp, VBR_q) {\n        var ret = 0;\n\n        if (0 > VBR_q) {\n            /* Unknown VBR quality level! */\n            ret = -1;\n            VBR_q = 0;\n        }\n        if (9 < VBR_q) {\n            ret = -1;\n            VBR_q = 9;\n        }\n\n        gfp.VBR_q = VBR_q;\n        gfp.VBR_q_frac = 0;\n        return ret;\n    }\n\n}\n\nmodule.exports = Presets;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL1ByZXNldHMuanMiLCJtYXBwaW5ncyI6IkFBQUEsYUFBYSxtQkFBTyxDQUFDLCtFQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLG1CQUFPLENBQUMsMkVBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbGFtZWpzL3NyYy9qcy9QcmVzZXRzLmpzP2RmYjgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uLmpzJyk7XG52YXIgU3lzdGVtID0gY29tbW9uLlN5c3RlbTtcbnZhciBWYnJNb2RlID0gY29tbW9uLlZick1vZGU7XG52YXIgRmxvYXQgPSBjb21tb24uRmxvYXQ7XG52YXIgU2hvcnRCbG9jayA9IGNvbW1vbi5TaG9ydEJsb2NrO1xudmFyIFV0aWwgPSBjb21tb24uVXRpbDtcbnZhciBBcnJheXMgPSBjb21tb24uQXJyYXlzO1xudmFyIG5ld19hcnJheV9uID0gY29tbW9uLm5ld19hcnJheV9uO1xudmFyIG5ld19ieXRlID0gY29tbW9uLm5ld19ieXRlO1xudmFyIG5ld19kb3VibGUgPSBjb21tb24ubmV3X2RvdWJsZTtcbnZhciBuZXdfZmxvYXQgPSBjb21tb24ubmV3X2Zsb2F0O1xudmFyIG5ld19mbG9hdF9uID0gY29tbW9uLm5ld19mbG9hdF9uO1xudmFyIG5ld19pbnQgPSBjb21tb24ubmV3X2ludDtcbnZhciBuZXdfaW50X24gPSBjb21tb24ubmV3X2ludF9uO1xudmFyIGFzc2VydCA9IGNvbW1vbi5hc3NlcnQ7XG5cbmZ1bmN0aW9uIFByZXNldHMoKSB7XG4gICAgdmFyIExhbWUgPSByZXF1aXJlKCcuL0xhbWUuanMnKTtcbiAgICBmdW5jdGlvbiBWQlJQcmVzZXRzKHF1YWwsIGNvbXAsIGNvbXBTLFxuICAgICAgICAgICAgICAgICAgICAgICAgeSwgc2hUaHJlc2hvbGQsIHNoVGhyZXNob2xkUyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkaiwgYWRqU2hvcnQsIGxvd2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VydmUsIHNlbnMsIGludGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgam9pbnQsIG1vZCwgZml4KSB7XG4gICAgICAgIHRoaXMudmJyX3EgPSBxdWFsO1xuICAgICAgICB0aGlzLnF1YW50X2NvbXAgPSBjb21wO1xuICAgICAgICB0aGlzLnF1YW50X2NvbXBfcyA9IGNvbXBTO1xuICAgICAgICB0aGlzLmV4cFkgPSB5O1xuICAgICAgICB0aGlzLnN0X2xybSA9IHNoVGhyZXNob2xkO1xuICAgICAgICB0aGlzLnN0X3MgPSBzaFRocmVzaG9sZFM7XG4gICAgICAgIHRoaXMubWFza2luZ19hZGogPSBhZGo7XG4gICAgICAgIHRoaXMubWFza2luZ19hZGpfc2hvcnQgPSBhZGpTaG9ydDtcbiAgICAgICAgdGhpcy5hdGhfbG93ZXIgPSBsb3dlcjtcbiAgICAgICAgdGhpcy5hdGhfY3VydmUgPSBjdXJ2ZTtcbiAgICAgICAgdGhpcy5hdGhfc2Vuc2l0aXZpdHkgPSBzZW5zO1xuICAgICAgICB0aGlzLmludGVyY2ggPSBpbnRlcjtcbiAgICAgICAgdGhpcy5zYWZlam9pbnQgPSBqb2ludDtcbiAgICAgICAgdGhpcy5zZmIyMW1vZCA9IG1vZDtcbiAgICAgICAgdGhpcy5tc2ZpeCA9IGZpeDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBBQlJQcmVzZXRzKGticHMsIGNvbXAsIGNvbXBTLFxuICAgICAgICAgICAgICAgICAgICAgICAgam9pbnQsIGZpeCwgc2hUaHJlc2hvbGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaFRocmVzaG9sZFMsIGJhc3MsIHNjLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFzaywgbG93ZXIsIGN1cnZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJDaCwgc2ZTY2FsZSkge1xuICAgICAgICB0aGlzLnF1YW50X2NvbXAgPSBjb21wO1xuICAgICAgICB0aGlzLnF1YW50X2NvbXBfcyA9IGNvbXBTO1xuICAgICAgICB0aGlzLnNhZmVqb2ludCA9IGpvaW50O1xuICAgICAgICB0aGlzLm5zbXNmaXggPSBmaXg7XG4gICAgICAgIHRoaXMuc3RfbHJtID0gc2hUaHJlc2hvbGQ7XG4gICAgICAgIHRoaXMuc3RfcyA9IHNoVGhyZXNob2xkUztcbiAgICAgICAgdGhpcy5uc2Jhc3MgPSBiYXNzO1xuICAgICAgICB0aGlzLnNjYWxlID0gc2M7XG4gICAgICAgIHRoaXMubWFza2luZ19hZGogPSBtYXNrO1xuICAgICAgICB0aGlzLmF0aF9sb3dlciA9IGxvd2VyO1xuICAgICAgICB0aGlzLmF0aF9jdXJ2ZSA9IGN1cnZlO1xuICAgICAgICB0aGlzLmludGVyY2ggPSBpbnRlckNoO1xuICAgICAgICB0aGlzLnNmc2NhbGUgPSBzZlNjYWxlO1xuICAgIH1cblxuICAgIHZhciBsYW1lO1xuXG4gICAgdGhpcy5zZXRNb2R1bGVzID0gZnVuY3Rpb24gKF9sYW1lKSB7XG4gICAgICAgIGxhbWUgPSBfbGFtZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogPFBSRT5cbiAgICAgKiBTd2l0Y2ggbWFwcGluZ3MgZm9yIFZCUiBtb2RlIFZCUl9SSFxuICAgICAqICAgICAgICAgICAgIHZicl9xICBxY29tcF9sICBxY29tcF9zICBleHBZICBzdF9scm0gICBzdF9zICBtYXNrIGFkal9sICBhZGpfcyAgYXRoX2xvd2VyICBhdGhfY3VydmUgIGF0aF9zZW5zICBpbnRlckNoUiAgc2FmZWpvaW50IHNmYjIxbW9kICBtc2ZpeFxuICAgICAqIDwvUFJFPlxuICAgICAqL1xuICAgIHZhciB2YnJfb2xkX3N3aXRjaF9tYXAgPSBbXG4gICAgICAgIG5ldyBWQlJQcmVzZXRzKDAsIDksIDksIDAsIDUuMjAsIDEyNS4wLCAtNC4yLCAtNi4zLCA0LjgsIDEsIDAsIDAsIDIsIDIxLCAwLjk3KSxcbiAgICAgICAgbmV3IFZCUlByZXNldHMoMSwgOSwgOSwgMCwgNS4zMCwgMTI1LjAsIC0zLjYsIC01LjYsIDQuNSwgMS41LCAwLCAwLCAyLCAyMSwgMS4zNSksXG4gICAgICAgIG5ldyBWQlJQcmVzZXRzKDIsIDksIDksIDAsIDUuNjAsIDEyNS4wLCAtMi4yLCAtMy41LCAyLjgsIDIsIDAsIDAsIDIsIDIxLCAxLjQ5KSxcbiAgICAgICAgbmV3IFZCUlByZXNldHMoMywgOSwgOSwgMSwgNS44MCwgMTMwLjAsIC0xLjgsIC0yLjgsIDIuNiwgMywgLTQsIDAsIDIsIDIwLCAxLjY0KSxcbiAgICAgICAgbmV3IFZCUlByZXNldHMoNCwgOSwgOSwgMSwgNi4wMCwgMTM1LjAsIC0wLjcsIC0xLjEsIDEuMSwgMy41LCAtOCwgMCwgMiwgMCwgMS43OSksXG4gICAgICAgIG5ldyBWQlJQcmVzZXRzKDUsIDksIDksIDEsIDYuNDAsIDE0MC4wLCAwLjUsIDAuNCwgLTcuNSwgNCwgLTEyLCAwLjAwMDIsIDAsIDAsIDEuOTUpLFxuICAgICAgICBuZXcgVkJSUHJlc2V0cyg2LCA5LCA5LCAxLCA2LjYwLCAxNDUuMCwgMC42NywgMC42NSwgLTE0LjcsIDYuNSwgLTE5LCAwLjAwMDQsIDAsIDAsIDIuMzApLFxuICAgICAgICBuZXcgVkJSUHJlc2V0cyg3LCA5LCA5LCAxLCA2LjYwLCAxNDUuMCwgMC44LCAwLjc1LCAtMTkuNywgOCwgLTIyLCAwLjAwMDYsIDAsIDAsIDIuNzApLFxuICAgICAgICBuZXcgVkJSUHJlc2V0cyg4LCA5LCA5LCAxLCA2LjYwLCAxNDUuMCwgMS4yLCAxLjE1LCAtMjcuNSwgMTAsIC0yMywgMC4wMDA3LCAwLCAwLCAwKSxcbiAgICAgICAgbmV3IFZCUlByZXNldHMoOSwgOSwgOSwgMSwgNi42MCwgMTQ1LjAsIDEuNiwgMS42LCAtMzYsIDExLCAtMjUsIDAuMDAwOCwgMCwgMCwgMCksXG4gICAgICAgIG5ldyBWQlJQcmVzZXRzKDEwLCA5LCA5LCAxLCA2LjYwLCAxNDUuMCwgMi4wLCAyLjAsIC0zNiwgMTIsIC0yNSwgMC4wMDA4LCAwLCAwLCAwKVxuICAgIF07XG5cbiAgICAvKipcbiAgICAgKiA8UFJFPlxuICAgICAqICAgICAgICAgICAgICAgICB2YnJfcSAgcWNvbXBfbCAgcWNvbXBfcyAgZXhwWSAgc3RfbHJtICAgc3RfcyAgbWFzayBhZGpfbCAgYWRqX3MgIGF0aF9sb3dlciAgYXRoX2N1cnZlICBhdGhfc2VucyAgaW50ZXJDaFIgIHNhZmVqb2ludCBzZmIyMW1vZCAgbXNmaXhcbiAgICAgKiA8L1BSRT5cbiAgICAgKi9cbiAgICB2YXIgdmJyX3BzeV9zd2l0Y2hfbWFwID0gW1xuICAgICAgICBuZXcgVkJSUHJlc2V0cygwLCA5LCA5LCAwLCA0LjIwLCAyNS4wLCAtNy4wLCAtNC4wLCA3LjUsIDEsIDAsIDAsIDIsIDI2LCAwLjk3KSxcbiAgICAgICAgbmV3IFZCUlByZXNldHMoMSwgOSwgOSwgMCwgNC4yMCwgMjUuMCwgLTUuNiwgLTMuNiwgNC41LCAxLjUsIDAsIDAsIDIsIDIxLCAxLjM1KSxcbiAgICAgICAgbmV3IFZCUlByZXNldHMoMiwgOSwgOSwgMCwgNC4yMCwgMjUuMCwgLTQuNCwgLTEuOCwgMiwgMiwgMCwgMCwgMiwgMTgsIDEuNDkpLFxuICAgICAgICBuZXcgVkJSUHJlc2V0cygzLCA5LCA5LCAxLCA0LjIwLCAyNS4wLCAtMy40LCAtMS4yNSwgMS4xLCAzLCAtNCwgMCwgMiwgMTUsIDEuNjQpLFxuICAgICAgICBuZXcgVkJSUHJlc2V0cyg0LCA5LCA5LCAxLCA0LjIwLCAyNS4wLCAtMi4yLCAwLjEsIDAsIDMuNSwgLTgsIDAsIDIsIDAsIDEuNzkpLFxuICAgICAgICBuZXcgVkJSUHJlc2V0cyg1LCA5LCA5LCAxLCA0LjIwLCAyNS4wLCAtMS4wLCAxLjY1LCAtNy43LCA0LCAtMTIsIDAuMDAwMiwgMCwgMCwgMS45NSksXG4gICAgICAgIG5ldyBWQlJQcmVzZXRzKDYsIDksIDksIDEsIDQuMjAsIDI1LjAsIC0wLjAsIDIuNDcsIC03LjcsIDYuNSwgLTE5LCAwLjAwMDQsIDAsIDAsIDIpLFxuICAgICAgICBuZXcgVkJSUHJlc2V0cyg3LCA5LCA5LCAxLCA0LjIwLCAyNS4wLCAwLjUsIDIuMCwgLTE0LjUsIDgsIC0yMiwgMC4wMDA2LCAwLCAwLCAyKSxcbiAgICAgICAgbmV3IFZCUlByZXNldHMoOCwgOSwgOSwgMSwgNC4yMCwgMjUuMCwgMS4wLCAyLjQsIC0yMi4wLCAxMCwgLTIzLCAwLjAwMDcsIDAsIDAsIDIpLFxuICAgICAgICBuZXcgVkJSUHJlc2V0cyg5LCA5LCA5LCAxLCA0LjIwLCAyNS4wLCAxLjUsIDIuOTUsIC0zMC4wLCAxMSwgLTI1LCAwLjAwMDgsIDAsIDAsIDIpLFxuICAgICAgICBuZXcgVkJSUHJlc2V0cygxMCwgOSwgOSwgMSwgNC4yMCwgMjUuMCwgMi4wLCAyLjk1LCAtMzYuMCwgMTIsIC0zMCwgMC4wMDA4LCAwLCAwLCAyKVxuICAgIF07XG5cbiAgICBmdW5jdGlvbiBhcHBseV92YnJfcHJlc2V0KGdmcCwgYSwgZW5mb3JjZSkge1xuICAgICAgICB2YXIgdmJyX3ByZXNldCA9IGdmcC5WQlIgPT0gVmJyTW9kZS52YnJfcmggPyB2YnJfb2xkX3N3aXRjaF9tYXBcbiAgICAgICAgICAgIDogdmJyX3BzeV9zd2l0Y2hfbWFwO1xuXG4gICAgICAgIHZhciB4ID0gZ2ZwLlZCUl9xX2ZyYWM7XG4gICAgICAgIHZhciBwID0gdmJyX3ByZXNldFthXTtcbiAgICAgICAgdmFyIHEgPSB2YnJfcHJlc2V0W2EgKyAxXTtcbiAgICAgICAgdmFyIHNldCA9IHA7XG5cbiAgICAgICAgLy8gTk9PUCh2YnJfcSk7XG4gICAgICAgIC8vIE5PT1AocXVhbnRfY29tcCk7XG4gICAgICAgIC8vIE5PT1AocXVhbnRfY29tcF9zKTtcbiAgICAgICAgLy8gTk9PUChleHBZKTtcbiAgICAgICAgcC5zdF9scm0gPSBwLnN0X2xybSArIHggKiAocS5zdF9scm0gLSBwLnN0X2xybSk7XG4gICAgICAgIC8vIExFUlAoc3RfbHJtKTtcbiAgICAgICAgcC5zdF9zID0gcC5zdF9zICsgeCAqIChxLnN0X3MgLSBwLnN0X3MpO1xuICAgICAgICAvLyBMRVJQKHN0X3MpO1xuICAgICAgICBwLm1hc2tpbmdfYWRqID0gcC5tYXNraW5nX2FkaiArIHggKiAocS5tYXNraW5nX2FkaiAtIHAubWFza2luZ19hZGopO1xuICAgICAgICAvLyBMRVJQKG1hc2tpbmdfYWRqKTtcbiAgICAgICAgcC5tYXNraW5nX2Fkal9zaG9ydCA9IHAubWFza2luZ19hZGpfc2hvcnQgKyB4XG4gICAgICAgICAgICAqIChxLm1hc2tpbmdfYWRqX3Nob3J0IC0gcC5tYXNraW5nX2Fkal9zaG9ydCk7XG4gICAgICAgIC8vIExFUlAobWFza2luZ19hZGpfc2hvcnQpO1xuICAgICAgICBwLmF0aF9sb3dlciA9IHAuYXRoX2xvd2VyICsgeCAqIChxLmF0aF9sb3dlciAtIHAuYXRoX2xvd2VyKTtcbiAgICAgICAgLy8gTEVSUChhdGhfbG93ZXIpO1xuICAgICAgICBwLmF0aF9jdXJ2ZSA9IHAuYXRoX2N1cnZlICsgeCAqIChxLmF0aF9jdXJ2ZSAtIHAuYXRoX2N1cnZlKTtcbiAgICAgICAgLy8gTEVSUChhdGhfY3VydmUpO1xuICAgICAgICBwLmF0aF9zZW5zaXRpdml0eSA9IHAuYXRoX3NlbnNpdGl2aXR5ICsgeFxuICAgICAgICAgICAgKiAocS5hdGhfc2Vuc2l0aXZpdHkgLSBwLmF0aF9zZW5zaXRpdml0eSk7XG4gICAgICAgIC8vIExFUlAoYXRoX3NlbnNpdGl2aXR5KTtcbiAgICAgICAgcC5pbnRlcmNoID0gcC5pbnRlcmNoICsgeCAqIChxLmludGVyY2ggLSBwLmludGVyY2gpO1xuICAgICAgICAvLyBMRVJQKGludGVyY2gpO1xuICAgICAgICAvLyBOT09QKHNhZmVqb2ludCk7XG4gICAgICAgIC8vIE5PT1Aoc2ZiMjFtb2QpO1xuICAgICAgICBwLm1zZml4ID0gcC5tc2ZpeCArIHggKiAocS5tc2ZpeCAtIHAubXNmaXgpO1xuICAgICAgICAvLyBMRVJQKG1zZml4KTtcblxuICAgICAgICBsYW1lX3NldF9WQlJfcShnZnAsIHNldC52YnJfcSk7XG5cbiAgICAgICAgaWYgKGVuZm9yY2UgIT0gMClcbiAgICAgICAgICAgIGdmcC5xdWFudF9jb21wID0gc2V0LnF1YW50X2NvbXA7XG4gICAgICAgIGVsc2UgaWYgKCEoTWF0aC5hYnMoZ2ZwLnF1YW50X2NvbXAgLSAtMSkgPiAwKSlcbiAgICAgICAgICAgIGdmcC5xdWFudF9jb21wID0gc2V0LnF1YW50X2NvbXA7XG4gICAgICAgIC8vIFNFVF9PUFRJT04ocXVhbnRfY29tcCwgc2V0LnF1YW50X2NvbXAsIC0xKTtcbiAgICAgICAgaWYgKGVuZm9yY2UgIT0gMClcbiAgICAgICAgICAgIGdmcC5xdWFudF9jb21wX3Nob3J0ID0gc2V0LnF1YW50X2NvbXBfcztcbiAgICAgICAgZWxzZSBpZiAoIShNYXRoLmFicyhnZnAucXVhbnRfY29tcF9zaG9ydCAtIC0xKSA+IDApKVxuICAgICAgICAgICAgZ2ZwLnF1YW50X2NvbXBfc2hvcnQgPSBzZXQucXVhbnRfY29tcF9zO1xuICAgICAgICAvLyBTRVRfT1BUSU9OKHF1YW50X2NvbXBfc2hvcnQsIHNldC5xdWFudF9jb21wX3MsIC0xKTtcbiAgICAgICAgaWYgKHNldC5leHBZICE9IDApIHtcbiAgICAgICAgICAgIGdmcC5leHBlcmltZW50YWxZID0gc2V0LmV4cFkgIT0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5mb3JjZSAhPSAwKVxuICAgICAgICAgICAgZ2ZwLmludGVybmFsX2ZsYWdzLm5zUHN5LmF0dGFja3RocmUgPSBzZXQuc3RfbHJtO1xuICAgICAgICBlbHNlIGlmICghKE1hdGguYWJzKGdmcC5pbnRlcm5hbF9mbGFncy5uc1BzeS5hdHRhY2t0aHJlIC0gLTEpID4gMCkpXG4gICAgICAgICAgICBnZnAuaW50ZXJuYWxfZmxhZ3MubnNQc3kuYXR0YWNrdGhyZSA9IHNldC5zdF9scm07XG4gICAgICAgIC8vIFNFVF9PUFRJT04oc2hvcnRfdGhyZXNob2xkX2xybSwgc2V0LnN0X2xybSwgLTEpO1xuICAgICAgICBpZiAoZW5mb3JjZSAhPSAwKVxuICAgICAgICAgICAgZ2ZwLmludGVybmFsX2ZsYWdzLm5zUHN5LmF0dGFja3RocmVfcyA9IHNldC5zdF9zO1xuICAgICAgICBlbHNlIGlmICghKE1hdGguYWJzKGdmcC5pbnRlcm5hbF9mbGFncy5uc1BzeS5hdHRhY2t0aHJlX3MgLSAtMSkgPiAwKSlcbiAgICAgICAgICAgIGdmcC5pbnRlcm5hbF9mbGFncy5uc1BzeS5hdHRhY2t0aHJlX3MgPSBzZXQuc3RfcztcbiAgICAgICAgLy8gU0VUX09QVElPTihzaG9ydF90aHJlc2hvbGRfcywgc2V0LnN0X3MsIC0xKTtcbiAgICAgICAgaWYgKGVuZm9yY2UgIT0gMClcbiAgICAgICAgICAgIGdmcC5tYXNraW5nYWRqdXN0ID0gc2V0Lm1hc2tpbmdfYWRqO1xuICAgICAgICBlbHNlIGlmICghKE1hdGguYWJzKGdmcC5tYXNraW5nYWRqdXN0IC0gMCkgPiAwKSlcbiAgICAgICAgICAgIGdmcC5tYXNraW5nYWRqdXN0ID0gc2V0Lm1hc2tpbmdfYWRqO1xuICAgICAgICAvLyBTRVRfT1BUSU9OKG1hc2tpbmdhZGp1c3QsIHNldC5tYXNraW5nX2FkaiwgMCk7XG4gICAgICAgIGlmIChlbmZvcmNlICE9IDApXG4gICAgICAgICAgICBnZnAubWFza2luZ2FkanVzdF9zaG9ydCA9IHNldC5tYXNraW5nX2Fkal9zaG9ydDtcbiAgICAgICAgZWxzZSBpZiAoIShNYXRoLmFicyhnZnAubWFza2luZ2FkanVzdF9zaG9ydCAtIDApID4gMCkpXG4gICAgICAgICAgICBnZnAubWFza2luZ2FkanVzdF9zaG9ydCA9IHNldC5tYXNraW5nX2Fkal9zaG9ydDtcbiAgICAgICAgLy8gU0VUX09QVElPTihtYXNraW5nYWRqdXN0X3Nob3J0LCBzZXQubWFza2luZ19hZGpfc2hvcnQsIDApO1xuICAgICAgICBpZiAoZW5mb3JjZSAhPSAwKVxuICAgICAgICAgICAgZ2ZwLkFUSGxvd2VyID0gLXNldC5hdGhfbG93ZXIgLyAxMC4wO1xuICAgICAgICBlbHNlIGlmICghKE1hdGguYWJzKCgtZ2ZwLkFUSGxvd2VyICogMTAuMCkgLSAwKSA+IDApKVxuICAgICAgICAgICAgZ2ZwLkFUSGxvd2VyID0gLXNldC5hdGhfbG93ZXIgLyAxMC4wO1xuICAgICAgICAvLyBTRVRfT1BUSU9OKEFUSGxvd2VyLCBzZXQuYXRoX2xvd2VyLCAwKTtcbiAgICAgICAgaWYgKGVuZm9yY2UgIT0gMClcbiAgICAgICAgICAgIGdmcC5BVEhjdXJ2ZSA9IHNldC5hdGhfY3VydmU7XG4gICAgICAgIGVsc2UgaWYgKCEoTWF0aC5hYnMoZ2ZwLkFUSGN1cnZlIC0gLTEpID4gMCkpXG4gICAgICAgICAgICBnZnAuQVRIY3VydmUgPSBzZXQuYXRoX2N1cnZlO1xuICAgICAgICAvLyBTRVRfT1BUSU9OKEFUSGN1cnZlLCBzZXQuYXRoX2N1cnZlLCAtMSk7XG4gICAgICAgIGlmIChlbmZvcmNlICE9IDApXG4gICAgICAgICAgICBnZnAuYXRoYWFfc2Vuc2l0aXZpdHkgPSBzZXQuYXRoX3NlbnNpdGl2aXR5O1xuICAgICAgICBlbHNlIGlmICghKE1hdGguYWJzKGdmcC5hdGhhYV9zZW5zaXRpdml0eSAtIC0xKSA+IDApKVxuICAgICAgICAgICAgZ2ZwLmF0aGFhX3NlbnNpdGl2aXR5ID0gc2V0LmF0aF9zZW5zaXRpdml0eTtcbiAgICAgICAgLy8gU0VUX09QVElPTihhdGhhYV9zZW5zaXRpdml0eSwgc2V0LmF0aF9zZW5zaXRpdml0eSwgMCk7XG4gICAgICAgIGlmIChzZXQuaW50ZXJjaCA+IDApIHtcbiAgICAgICAgICAgIGlmIChlbmZvcmNlICE9IDApXG4gICAgICAgICAgICAgICAgZ2ZwLmludGVyQ2hSYXRpbyA9IHNldC5pbnRlcmNoO1xuICAgICAgICAgICAgZWxzZSBpZiAoIShNYXRoLmFicyhnZnAuaW50ZXJDaFJhdGlvIC0gLTEpID4gMCkpXG4gICAgICAgICAgICAgICAgZ2ZwLmludGVyQ2hSYXRpbyA9IHNldC5pbnRlcmNoO1xuICAgICAgICAgICAgLy8gU0VUX09QVElPTihpbnRlckNoUmF0aW8sIHNldC5pbnRlcmNoLCAtMSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBwYXJhbWV0ZXJzIGZvciB3aGljaCB0aGVyZSBpcyBubyBwcm9wZXIgc2V0L2dldCBpbnRlcmZhY2UgKi9cbiAgICAgICAgaWYgKHNldC5zYWZlam9pbnQgPiAwKSB7XG4gICAgICAgICAgICBnZnAuZXhwX25zcHN5dHVuZSA9IGdmcC5leHBfbnNwc3l0dW5lIHwgc2V0LnNhZmVqb2ludDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0LnNmYjIxbW9kID4gMCkge1xuICAgICAgICAgICAgZ2ZwLmV4cF9uc3BzeXR1bmUgPSBnZnAuZXhwX25zcHN5dHVuZSB8IChzZXQuc2ZiMjFtb2QgPDwgMjApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmZvcmNlICE9IDApXG4gICAgICAgICAgICBnZnAubXNmaXggPSBzZXQubXNmaXg7XG4gICAgICAgIGVsc2UgaWYgKCEoTWF0aC5hYnMoZ2ZwLm1zZml4IC0gLTEpID4gMCkpXG4gICAgICAgICAgICBnZnAubXNmaXggPSBzZXQubXNmaXg7XG4gICAgICAgIC8vIFNFVF9PUFRJT04obXNmaXgsIHNldC5tc2ZpeCwgLTEpO1xuXG4gICAgICAgIGlmIChlbmZvcmNlID09IDApIHtcbiAgICAgICAgICAgIGdmcC5WQlJfcSA9IGE7XG4gICAgICAgICAgICBnZnAuVkJSX3FfZnJhYyA9IHg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiA8UFJFPlxuICAgICAqICBTd2l0Y2ggbWFwcGluZ3MgZm9yIEFCUiBtb2RlXG4gICAgICpcbiAgICAgKiAgICAgICAgICAgICAga2JwcyAgcXVhbnQgcV9zIHNhZmVqb2ludCBuc21zZml4IHN0X2xybSAgc3RfcyAgbnMtYmFzcyBzY2FsZSAgIG1zayBhdGhfbHdyIGF0aF9jdXJ2ZSAgaW50ZXJjaCAsIHNmc2NhbGVcbiAgICAgKiA8L1BSRT5cbiAgICAgKi9cbiAgICB2YXIgYWJyX3N3aXRjaF9tYXAgPSBbXG4gICAgICAgIG5ldyBBQlJQcmVzZXRzKDgsIDksIDksIDAsIDAsIDYuNjAsIDE0NSwgMCwgMC45NSwgMCwgLTMwLjAsIDExLCAwLjAwMTIsIDEpLCAvKiAgIDgsIGltcG9zc2libGUgdG8gdXNlIGluIHN0ZXJlbyAqL1xuICAgICAgICBuZXcgQUJSUHJlc2V0cygxNiwgOSwgOSwgMCwgMCwgNi42MCwgMTQ1LCAwLCAwLjk1LCAwLCAtMjUuMCwgMTEsIDAuMDAxMCwgMSksIC8qICAxNiAqL1xuICAgICAgICBuZXcgQUJSUHJlc2V0cygyNCwgOSwgOSwgMCwgMCwgNi42MCwgMTQ1LCAwLCAwLjk1LCAwLCAtMjAuMCwgMTEsIDAuMDAxMCwgMSksIC8qICAyNCAqL1xuICAgICAgICBuZXcgQUJSUHJlc2V0cygzMiwgOSwgOSwgMCwgMCwgNi42MCwgMTQ1LCAwLCAwLjk1LCAwLCAtMTUuMCwgMTEsIDAuMDAxMCwgMSksIC8qICAzMiAqL1xuICAgICAgICBuZXcgQUJSUHJlc2V0cyg0MCwgOSwgOSwgMCwgMCwgNi42MCwgMTQ1LCAwLCAwLjk1LCAwLCAtMTAuMCwgMTEsIDAuMDAwOSwgMSksIC8qICA0MCAqL1xuICAgICAgICBuZXcgQUJSUHJlc2V0cyg0OCwgOSwgOSwgMCwgMCwgNi42MCwgMTQ1LCAwLCAwLjk1LCAwLCAtMTAuMCwgMTEsIDAuMDAwOSwgMSksIC8qICA0OCAqL1xuICAgICAgICBuZXcgQUJSUHJlc2V0cyg1NiwgOSwgOSwgMCwgMCwgNi42MCwgMTQ1LCAwLCAwLjk1LCAwLCAtNi4wLCAxMSwgMC4wMDA4LCAxKSwgLyogIDU2ICovXG4gICAgICAgIG5ldyBBQlJQcmVzZXRzKDY0LCA5LCA5LCAwLCAwLCA2LjYwLCAxNDUsIDAsIDAuOTUsIDAsIC0yLjAsIDExLCAwLjAwMDgsIDEpLCAvKiAgNjQgKi9cbiAgICAgICAgbmV3IEFCUlByZXNldHMoODAsIDksIDksIDAsIDAsIDYuNjAsIDE0NSwgMCwgMC45NSwgMCwgLjAsIDgsIDAuMDAwNywgMSksIC8qICA4MCAqL1xuICAgICAgICBuZXcgQUJSUHJlc2V0cyg5NiwgOSwgOSwgMCwgMi41MCwgNi42MCwgMTQ1LCAwLCAwLjk1LCAwLCAxLjAsIDUuNSwgMC4wMDA2LCAxKSwgLyogIDk2ICovXG4gICAgICAgIG5ldyBBQlJQcmVzZXRzKDExMiwgOSwgOSwgMCwgMi4yNSwgNi42MCwgMTQ1LCAwLCAwLjk1LCAwLCAyLjAsIDQuNSwgMC4wMDA1LCAxKSwgLyogMTEyICovXG4gICAgICAgIG5ldyBBQlJQcmVzZXRzKDEyOCwgOSwgOSwgMCwgMS45NSwgNi40MCwgMTQwLCAwLCAwLjk1LCAwLCAzLjAsIDQsIDAuMDAwMiwgMSksIC8qIDEyOCAqL1xuICAgICAgICBuZXcgQUJSUHJlc2V0cygxNjAsIDksIDksIDEsIDEuNzksIDYuMDAsIDEzNSwgMCwgMC45NSwgLTIsIDUuMCwgMy41LCAwLCAxKSwgLyogMTYwICovXG4gICAgICAgIG5ldyBBQlJQcmVzZXRzKDE5MiwgOSwgOSwgMSwgMS40OSwgNS42MCwgMTI1LCAwLCAwLjk3LCAtNCwgNy4wLCAzLCAwLCAwKSwgLyogMTkyICovXG4gICAgICAgIG5ldyBBQlJQcmVzZXRzKDIyNCwgOSwgOSwgMSwgMS4yNSwgNS4yMCwgMTI1LCAwLCAwLjk4LCAtNiwgOS4wLCAyLCAwLCAwKSwgLyogMjI0ICovXG4gICAgICAgIG5ldyBBQlJQcmVzZXRzKDI1NiwgOSwgOSwgMSwgMC45NywgNS4yMCwgMTI1LCAwLCAxLjAwLCAtOCwgMTAuMCwgMSwgMCwgMCksIC8qIDI1NiAqL1xuICAgICAgICBuZXcgQUJSUHJlc2V0cygzMjAsIDksIDksIDEsIDAuOTAsIDUuMjAsIDEyNSwgMCwgMS4wMCwgLTEwLCAxMi4wLCAwLCAwLCAwKSAgLyogMzIwICovXG4gICAgXTtcblxuICAgIGZ1bmN0aW9uIGFwcGx5X2Ficl9wcmVzZXQoZ2ZwLCBwcmVzZXQsIGVuZm9yY2UpIHtcbiAgICAgICAgLyogVmFyaWFibGVzIGZvciB0aGUgQUJSIHN0dWZmICovXG4gICAgICAgIHZhciBhY3R1YWxfYml0cmF0ZSA9IHByZXNldDtcblxuICAgICAgICB2YXIgciA9IGxhbWUubmVhcmVzdEJpdHJhdGVGdWxsSW5kZXgocHJlc2V0KTtcblxuICAgICAgICBnZnAuVkJSID0gVmJyTW9kZS52YnJfYWJyO1xuICAgICAgICBnZnAuVkJSX21lYW5fYml0cmF0ZV9rYnBzID0gYWN0dWFsX2JpdHJhdGU7XG4gICAgICAgIGdmcC5WQlJfbWVhbl9iaXRyYXRlX2ticHMgPSBNYXRoLm1pbihnZnAuVkJSX21lYW5fYml0cmF0ZV9rYnBzLCAzMjApO1xuICAgICAgICBnZnAuVkJSX21lYW5fYml0cmF0ZV9rYnBzID0gTWF0aC5tYXgoZ2ZwLlZCUl9tZWFuX2JpdHJhdGVfa2JwcywgOCk7XG4gICAgICAgIGdmcC5icmF0ZSA9IGdmcC5WQlJfbWVhbl9iaXRyYXRlX2ticHM7XG4gICAgICAgIGlmIChnZnAuVkJSX21lYW5fYml0cmF0ZV9rYnBzID4gMzIwKSB7XG4gICAgICAgICAgICBnZnAuZGlzYWJsZV9yZXNlcnZvaXIgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogcGFyYW1ldGVycyBmb3Igd2hpY2ggdGhlcmUgaXMgbm8gcHJvcGVyIHNldC9nZXQgaW50ZXJmYWNlICovXG4gICAgICAgIGlmIChhYnJfc3dpdGNoX21hcFtyXS5zYWZlam9pbnQgPiAwKVxuICAgICAgICAgICAgZ2ZwLmV4cF9uc3BzeXR1bmUgPSBnZnAuZXhwX25zcHN5dHVuZSB8IDI7XG4gICAgICAgIC8qIHNhZmVqb2ludCAqL1xuXG4gICAgICAgIGlmIChhYnJfc3dpdGNoX21hcFtyXS5zZnNjYWxlID4gMCkge1xuICAgICAgICAgICAgZ2ZwLmludGVybmFsX2ZsYWdzLm5vaXNlX3NoYXBpbmcgPSAyO1xuICAgICAgICB9XG4gICAgICAgIC8qIG5zLWJhc3MgdHdlYWtzICovXG4gICAgICAgIGlmIChNYXRoLmFicyhhYnJfc3dpdGNoX21hcFtyXS5uc2Jhc3MpID4gMCkge1xuICAgICAgICAgICAgdmFyIGsgPSAoaW50KShhYnJfc3dpdGNoX21hcFtyXS5uc2Jhc3MgKiA0KTtcbiAgICAgICAgICAgIGlmIChrIDwgMClcbiAgICAgICAgICAgICAgICBrICs9IDY0O1xuICAgICAgICAgICAgZ2ZwLmV4cF9uc3BzeXR1bmUgPSBnZnAuZXhwX25zcHN5dHVuZSB8IChrIDw8IDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZm9yY2UgIT0gMClcbiAgICAgICAgICAgIGdmcC5xdWFudF9jb21wID0gYWJyX3N3aXRjaF9tYXBbcl0ucXVhbnRfY29tcDtcbiAgICAgICAgZWxzZSBpZiAoIShNYXRoLmFicyhnZnAucXVhbnRfY29tcCAtIC0xKSA+IDApKVxuICAgICAgICAgICAgZ2ZwLnF1YW50X2NvbXAgPSBhYnJfc3dpdGNoX21hcFtyXS5xdWFudF9jb21wO1xuICAgICAgICAvLyBTRVRfT1BUSU9OKHF1YW50X2NvbXAsIGFicl9zd2l0Y2hfbWFwW3JdLnF1YW50X2NvbXAsIC0xKTtcbiAgICAgICAgaWYgKGVuZm9yY2UgIT0gMClcbiAgICAgICAgICAgIGdmcC5xdWFudF9jb21wX3Nob3J0ID0gYWJyX3N3aXRjaF9tYXBbcl0ucXVhbnRfY29tcF9zO1xuICAgICAgICBlbHNlIGlmICghKE1hdGguYWJzKGdmcC5xdWFudF9jb21wX3Nob3J0IC0gLTEpID4gMCkpXG4gICAgICAgICAgICBnZnAucXVhbnRfY29tcF9zaG9ydCA9IGFicl9zd2l0Y2hfbWFwW3JdLnF1YW50X2NvbXBfcztcbiAgICAgICAgLy8gU0VUX09QVElPTihxdWFudF9jb21wX3Nob3J0LCBhYnJfc3dpdGNoX21hcFtyXS5xdWFudF9jb21wX3MsIC0xKTtcblxuICAgICAgICBpZiAoZW5mb3JjZSAhPSAwKVxuICAgICAgICAgICAgZ2ZwLm1zZml4ID0gYWJyX3N3aXRjaF9tYXBbcl0ubnNtc2ZpeDtcbiAgICAgICAgZWxzZSBpZiAoIShNYXRoLmFicyhnZnAubXNmaXggLSAtMSkgPiAwKSlcbiAgICAgICAgICAgIGdmcC5tc2ZpeCA9IGFicl9zd2l0Y2hfbWFwW3JdLm5zbXNmaXg7XG4gICAgICAgIC8vIFNFVF9PUFRJT04obXNmaXgsIGFicl9zd2l0Y2hfbWFwW3JdLm5zbXNmaXgsIC0xKTtcblxuICAgICAgICBpZiAoZW5mb3JjZSAhPSAwKVxuICAgICAgICAgICAgZ2ZwLmludGVybmFsX2ZsYWdzLm5zUHN5LmF0dGFja3RocmUgPSBhYnJfc3dpdGNoX21hcFtyXS5zdF9scm07XG4gICAgICAgIGVsc2UgaWYgKCEoTWF0aC5hYnMoZ2ZwLmludGVybmFsX2ZsYWdzLm5zUHN5LmF0dGFja3RocmUgLSAtMSkgPiAwKSlcbiAgICAgICAgICAgIGdmcC5pbnRlcm5hbF9mbGFncy5uc1BzeS5hdHRhY2t0aHJlID0gYWJyX3N3aXRjaF9tYXBbcl0uc3RfbHJtO1xuICAgICAgICAvLyBTRVRfT1BUSU9OKHNob3J0X3RocmVzaG9sZF9scm0sIGFicl9zd2l0Y2hfbWFwW3JdLnN0X2xybSwgLTEpO1xuICAgICAgICBpZiAoZW5mb3JjZSAhPSAwKVxuICAgICAgICAgICAgZ2ZwLmludGVybmFsX2ZsYWdzLm5zUHN5LmF0dGFja3RocmVfcyA9IGFicl9zd2l0Y2hfbWFwW3JdLnN0X3M7XG4gICAgICAgIGVsc2UgaWYgKCEoTWF0aC5hYnMoZ2ZwLmludGVybmFsX2ZsYWdzLm5zUHN5LmF0dGFja3RocmVfcyAtIC0xKSA+IDApKVxuICAgICAgICAgICAgZ2ZwLmludGVybmFsX2ZsYWdzLm5zUHN5LmF0dGFja3RocmVfcyA9IGFicl9zd2l0Y2hfbWFwW3JdLnN0X3M7XG4gICAgICAgIC8vIFNFVF9PUFRJT04oc2hvcnRfdGhyZXNob2xkX3MsIGFicl9zd2l0Y2hfbWFwW3JdLnN0X3MsIC0xKTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBBQlIgc2VlbXMgdG8gaGF2ZSBiaWcgcHJvYmxlbXMgd2l0aCBjbGlwcGluZywgZXNwZWNpYWxseSBhdCBsb3dcbiAgICAgICAgICogYml0cmF0ZXNcbiAgICAgICAgICovXG4gICAgICAgIC8qXG4gICAgICAgICAqIHNvIHdlIGNvbXBlbnNhdGUgZm9yIHRoYXQgaGVyZSBieSB1c2luZyBhIHNjYWxlIHZhbHVlIGRlcGVuZGluZyBvblxuICAgICAgICAgKiBiaXRyYXRlXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoZW5mb3JjZSAhPSAwKVxuICAgICAgICAgICAgZ2ZwLnNjYWxlID0gYWJyX3N3aXRjaF9tYXBbcl0uc2NhbGU7XG4gICAgICAgIGVsc2UgaWYgKCEoTWF0aC5hYnMoZ2ZwLnNjYWxlIC0gLTEpID4gMCkpXG4gICAgICAgICAgICBnZnAuc2NhbGUgPSBhYnJfc3dpdGNoX21hcFtyXS5zY2FsZTtcbiAgICAgICAgLy8gU0VUX09QVElPTihzY2FsZSwgYWJyX3N3aXRjaF9tYXBbcl0uc2NhbGUsIC0xKTtcblxuICAgICAgICBpZiAoZW5mb3JjZSAhPSAwKVxuICAgICAgICAgICAgZ2ZwLm1hc2tpbmdhZGp1c3QgPSBhYnJfc3dpdGNoX21hcFtyXS5tYXNraW5nX2FkajtcbiAgICAgICAgZWxzZSBpZiAoIShNYXRoLmFicyhnZnAubWFza2luZ2FkanVzdCAtIDApID4gMCkpXG4gICAgICAgICAgICBnZnAubWFza2luZ2FkanVzdCA9IGFicl9zd2l0Y2hfbWFwW3JdLm1hc2tpbmdfYWRqO1xuICAgICAgICAvLyBTRVRfT1BUSU9OKG1hc2tpbmdhZGp1c3QsIGFicl9zd2l0Y2hfbWFwW3JdLm1hc2tpbmdfYWRqLCAwKTtcbiAgICAgICAgaWYgKGFicl9zd2l0Y2hfbWFwW3JdLm1hc2tpbmdfYWRqID4gMCkge1xuICAgICAgICAgICAgaWYgKGVuZm9yY2UgIT0gMClcbiAgICAgICAgICAgICAgICBnZnAubWFza2luZ2FkanVzdF9zaG9ydCA9IChhYnJfc3dpdGNoX21hcFtyXS5tYXNraW5nX2FkaiAqIC45KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKCEoTWF0aC5hYnMoZ2ZwLm1hc2tpbmdhZGp1c3Rfc2hvcnQgLSAwKSA+IDApKVxuICAgICAgICAgICAgICAgIGdmcC5tYXNraW5nYWRqdXN0X3Nob3J0ID0gKGFicl9zd2l0Y2hfbWFwW3JdLm1hc2tpbmdfYWRqICogLjkpO1xuICAgICAgICAgICAgLy8gU0VUX09QVElPTihtYXNraW5nYWRqdXN0X3Nob3J0LCBhYnJfc3dpdGNoX21hcFtyXS5tYXNraW5nX2FkaiAqXG4gICAgICAgICAgICAvLyAuOSwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZW5mb3JjZSAhPSAwKVxuICAgICAgICAgICAgICAgIGdmcC5tYXNraW5nYWRqdXN0X3Nob3J0ID0gKGFicl9zd2l0Y2hfbWFwW3JdLm1hc2tpbmdfYWRqICogMS4xKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKCEoTWF0aC5hYnMoZ2ZwLm1hc2tpbmdhZGp1c3Rfc2hvcnQgLSAwKSA+IDApKVxuICAgICAgICAgICAgICAgIGdmcC5tYXNraW5nYWRqdXN0X3Nob3J0ID0gKGFicl9zd2l0Y2hfbWFwW3JdLm1hc2tpbmdfYWRqICogMS4xKTtcbiAgICAgICAgICAgIC8vIFNFVF9PUFRJT04obWFza2luZ2FkanVzdF9zaG9ydCwgYWJyX3N3aXRjaF9tYXBbcl0ubWFza2luZ19hZGogKlxuICAgICAgICAgICAgLy8gMS4xLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbmZvcmNlICE9IDApXG4gICAgICAgICAgICBnZnAuQVRIbG93ZXIgPSAtYWJyX3N3aXRjaF9tYXBbcl0uYXRoX2xvd2VyIC8gMTAuO1xuICAgICAgICBlbHNlIGlmICghKE1hdGguYWJzKCgtZ2ZwLkFUSGxvd2VyICogMTAuKSAtIDApID4gMCkpXG4gICAgICAgICAgICBnZnAuQVRIbG93ZXIgPSAtYWJyX3N3aXRjaF9tYXBbcl0uYXRoX2xvd2VyIC8gMTAuO1xuICAgICAgICAvLyBTRVRfT1BUSU9OKEFUSGxvd2VyLCBhYnJfc3dpdGNoX21hcFtyXS5hdGhfbG93ZXIsIDApO1xuICAgICAgICBpZiAoZW5mb3JjZSAhPSAwKVxuICAgICAgICAgICAgZ2ZwLkFUSGN1cnZlID0gYWJyX3N3aXRjaF9tYXBbcl0uYXRoX2N1cnZlO1xuICAgICAgICBlbHNlIGlmICghKE1hdGguYWJzKGdmcC5BVEhjdXJ2ZSAtIC0xKSA+IDApKVxuICAgICAgICAgICAgZ2ZwLkFUSGN1cnZlID0gYWJyX3N3aXRjaF9tYXBbcl0uYXRoX2N1cnZlO1xuICAgICAgICAvLyBTRVRfT1BUSU9OKEFUSGN1cnZlLCBhYnJfc3dpdGNoX21hcFtyXS5hdGhfY3VydmUsIC0xKTtcblxuICAgICAgICBpZiAoZW5mb3JjZSAhPSAwKVxuICAgICAgICAgICAgZ2ZwLmludGVyQ2hSYXRpbyA9IGFicl9zd2l0Y2hfbWFwW3JdLmludGVyY2g7XG4gICAgICAgIGVsc2UgaWYgKCEoTWF0aC5hYnMoZ2ZwLmludGVyQ2hSYXRpbyAtIC0xKSA+IDApKVxuICAgICAgICAgICAgZ2ZwLmludGVyQ2hSYXRpbyA9IGFicl9zd2l0Y2hfbWFwW3JdLmludGVyY2g7XG4gICAgICAgIC8vIFNFVF9PUFRJT04oaW50ZXJDaFJhdGlvLCBhYnJfc3dpdGNoX21hcFtyXS5pbnRlcmNoLCAtMSk7XG5cbiAgICAgICAgcmV0dXJuIHByZXNldDtcbiAgICB9XG5cbiAgICB0aGlzLmFwcGx5X3ByZXNldCA9IGZ1bmN0aW9uKGdmcCwgcHJlc2V0LCBlbmZvcmNlKSB7XG4gICAgICAgIC8qIHRyYW5zbGF0ZSBsZWdhY3kgcHJlc2V0cyAqL1xuICAgICAgICBzd2l0Y2ggKHByZXNldCkge1xuICAgICAgICAgICAgY2FzZSBMYW1lLlIzTUlYOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByZXNldCA9IExhbWUuVjM7XG4gICAgICAgICAgICAgICAgZ2ZwLlZCUiA9IFZick1vZGUudmJyX210cmg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIExhbWUuTUVESVVNOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByZXNldCA9IExhbWUuVjQ7XG4gICAgICAgICAgICAgICAgZ2ZwLlZCUiA9IFZick1vZGUudmJyX3JoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBMYW1lLk1FRElVTV9GQVNUOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByZXNldCA9IExhbWUuVjQ7XG4gICAgICAgICAgICAgICAgZ2ZwLlZCUiA9IFZick1vZGUudmJyX210cmg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIExhbWUuU1RBTkRBUkQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJlc2V0ID0gTGFtZS5WMjtcbiAgICAgICAgICAgICAgICBnZnAuVkJSID0gVmJyTW9kZS52YnJfcmg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIExhbWUuU1RBTkRBUkRfRkFTVDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcmVzZXQgPSBMYW1lLlYyO1xuICAgICAgICAgICAgICAgIGdmcC5WQlIgPSBWYnJNb2RlLnZicl9tdHJoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBMYW1lLkVYVFJFTUU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJlc2V0ID0gTGFtZS5WMDtcbiAgICAgICAgICAgICAgICBnZnAuVkJSID0gVmJyTW9kZS52YnJfcmg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIExhbWUuRVhUUkVNRV9GQVNUOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByZXNldCA9IExhbWUuVjA7XG4gICAgICAgICAgICAgICAgZ2ZwLlZCUiA9IFZick1vZGUudmJyX210cmg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIExhbWUuSU5TQU5FOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByZXNldCA9IDMyMDtcbiAgICAgICAgICAgICAgICBnZnAucHJlc2V0ID0gcHJlc2V0O1xuICAgICAgICAgICAgICAgIGFwcGx5X2Ficl9wcmVzZXQoZ2ZwLCBwcmVzZXQsIGVuZm9yY2UpO1xuICAgICAgICAgICAgICAgIGdmcC5WQlIgPSBWYnJNb2RlLnZicl9vZmY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdmcC5wcmVzZXQgPSBwcmVzZXQ7XG4gICAgICAgIHtcbiAgICAgICAgICAgIHN3aXRjaCAocHJlc2V0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSBMYW1lLlY5OlxuICAgICAgICAgICAgICAgICAgICBhcHBseV92YnJfcHJlc2V0KGdmcCwgOSwgZW5mb3JjZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVzZXQ7XG4gICAgICAgICAgICAgICAgY2FzZSBMYW1lLlY4OlxuICAgICAgICAgICAgICAgICAgICBhcHBseV92YnJfcHJlc2V0KGdmcCwgOCwgZW5mb3JjZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVzZXQ7XG4gICAgICAgICAgICAgICAgY2FzZSBMYW1lLlY3OlxuICAgICAgICAgICAgICAgICAgICBhcHBseV92YnJfcHJlc2V0KGdmcCwgNywgZW5mb3JjZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVzZXQ7XG4gICAgICAgICAgICAgICAgY2FzZSBMYW1lLlY2OlxuICAgICAgICAgICAgICAgICAgICBhcHBseV92YnJfcHJlc2V0KGdmcCwgNiwgZW5mb3JjZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVzZXQ7XG4gICAgICAgICAgICAgICAgY2FzZSBMYW1lLlY1OlxuICAgICAgICAgICAgICAgICAgICBhcHBseV92YnJfcHJlc2V0KGdmcCwgNSwgZW5mb3JjZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVzZXQ7XG4gICAgICAgICAgICAgICAgY2FzZSBMYW1lLlY0OlxuICAgICAgICAgICAgICAgICAgICBhcHBseV92YnJfcHJlc2V0KGdmcCwgNCwgZW5mb3JjZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVzZXQ7XG4gICAgICAgICAgICAgICAgY2FzZSBMYW1lLlYzOlxuICAgICAgICAgICAgICAgICAgICBhcHBseV92YnJfcHJlc2V0KGdmcCwgMywgZW5mb3JjZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVzZXQ7XG4gICAgICAgICAgICAgICAgY2FzZSBMYW1lLlYyOlxuICAgICAgICAgICAgICAgICAgICBhcHBseV92YnJfcHJlc2V0KGdmcCwgMiwgZW5mb3JjZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVzZXQ7XG4gICAgICAgICAgICAgICAgY2FzZSBMYW1lLlYxOlxuICAgICAgICAgICAgICAgICAgICBhcHBseV92YnJfcHJlc2V0KGdmcCwgMSwgZW5mb3JjZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVzZXQ7XG4gICAgICAgICAgICAgICAgY2FzZSBMYW1lLlYwOlxuICAgICAgICAgICAgICAgICAgICBhcHBseV92YnJfcHJlc2V0KGdmcCwgMCwgZW5mb3JjZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVzZXQ7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKDggPD0gcHJlc2V0ICYmIHByZXNldCA8PSAzMjApIHtcbiAgICAgICAgICAgIHJldHVybiBhcHBseV9hYnJfcHJlc2V0KGdmcCwgcHJlc2V0LCBlbmZvcmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIG5vIGNvcnJlc3BvbmRpbmcgcHJlc2V0IGZvdW5kICovXG4gICAgICAgIGdmcC5wcmVzZXQgPSAwO1xuICAgICAgICByZXR1cm4gcHJlc2V0O1xuICAgIH1cblxuICAgIC8vIFJlc3QgZnJvbSBnZXRzZXQuYzpcblxuICAgIC8qKlxuICAgICAqIFZCUiBxdWFsaXR5IGxldmVsLjxCUj5cbiAgICAgKiAwID0gaGlnaGVzdDxCUj5cbiAgICAgKiA5ID0gbG93ZXN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gbGFtZV9zZXRfVkJSX3EoZ2ZwLCBWQlJfcSkge1xuICAgICAgICB2YXIgcmV0ID0gMDtcblxuICAgICAgICBpZiAoMCA+IFZCUl9xKSB7XG4gICAgICAgICAgICAvKiBVbmtub3duIFZCUiBxdWFsaXR5IGxldmVsISAqL1xuICAgICAgICAgICAgcmV0ID0gLTE7XG4gICAgICAgICAgICBWQlJfcSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKDkgPCBWQlJfcSkge1xuICAgICAgICAgICAgcmV0ID0gLTE7XG4gICAgICAgICAgICBWQlJfcSA9IDk7XG4gICAgICAgIH1cblxuICAgICAgICBnZnAuVkJSX3EgPSBWQlJfcTtcbiAgICAgICAgZ2ZwLlZCUl9xX2ZyYWMgPSAwO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFByZXNldHM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lamejs/src/js/Presets.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lamejs/src/js/PsyModel.js":
/*!************************************************!*\
  !*** ./node_modules/lamejs/src/js/PsyModel.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/*\n *      psymodel.c\n *\n *      Copyright (c) 1999-2000 Mark Taylor\n *      Copyright (c) 2001-2002 Naoki Shibata\n *      Copyright (c) 2000-2003 Takehiro Tominaga\n *      Copyright (c) 2000-2008 Robert Hegemann\n *      Copyright (c) 2000-2005 Gabriel Bouvigne\n *      Copyright (c) 2000-2005 Alexander Leidinger\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */\n\n/* $Id: PsyModel.java,v 1.27 2011/05/24 20:48:06 kenchis Exp $ */\n\n\n/*\n PSYCHO ACOUSTICS\n\n\n This routine computes the psycho acoustics, delayed by one granule.\n\n Input: buffer of PCM data (1024 samples).\n\n This window should be centered over the 576 sample granule window.\n The routine will compute the psycho acoustics for\n this granule, but return the psycho acoustics computed\n for the *previous* granule.  This is because the block\n type of the previous granule can only be determined\n after we have computed the psycho acoustics for the following\n granule.\n\n Output:  maskings and energies for each scalefactor band.\n block type, PE, and some correlation measures.\n The PE is used by CBR modes to determine if extra bits\n from the bit reservoir should be used.  The correlation\n measures are used to determine mid/side or regular stereo.\n */\n/*\n Notation:\n\n barks:  a non-linear frequency scale.  Mapping from frequency to\n barks is given by freq2bark()\n\n scalefactor bands: The spectrum (frequencies) are broken into\n SBMAX \"scalefactor bands\".  Thes bands\n are determined by the MPEG ISO spec.  In\n the noise shaping/quantization code, we allocate\n bits among the partition bands to achieve the\n best possible quality\n\n partition bands:   The spectrum is also broken into about\n 64 \"partition bands\".  Each partition\n band is about .34 barks wide.  There are about 2-5\n partition bands for each scalefactor band.\n\n LAME computes all psycho acoustic information for each partition\n band.  Then at the end of the computations, this information\n is mapped to scalefactor bands.  The energy in each scalefactor\n band is taken as the sum of the energy in all partition bands\n which overlap the scalefactor band.  The maskings can be computed\n in the same way (and thus represent the average masking in that band)\n or by taking the minmum value multiplied by the number of\n partition bands used (which represents a minimum masking in that band).\n */\n/*\n The general outline is as follows:\n\n 1. compute the energy in each partition band\n 2. compute the tonality in each partition band\n 3. compute the strength of each partion band \"masker\"\n 4. compute the masking (via the spreading function applied to each masker)\n 5. Modifications for mid/side masking.\n\n Each partition band is considiered a \"masker\".  The strength\n of the i'th masker in band j is given by:\n\n s3(bark(i)-bark(j))*strength(i)\n\n The strength of the masker is a function of the energy and tonality.\n The more tonal, the less masking.  LAME uses a simple linear formula\n (controlled by NMT and TMN) which says the strength is given by the\n energy divided by a linear function of the tonality.\n */\n/*\n s3() is the \"spreading function\".  It is given by a formula\n determined via listening tests.\n\n The total masking in the j'th partition band is the sum over\n all maskings i.  It is thus given by the convolution of\n the strength with s3(), the \"spreading function.\"\n\n masking(j) = sum_over_i  s3(i-j)*strength(i)  = s3 o strength\n\n where \"o\" = convolution operator.  s3 is given by a formula determined\n via listening tests.  It is normalized so that s3 o 1 = 1.\n\n Note: instead of a simple convolution, LAME also has the\n option of using \"additive masking\"\n\n The most critical part is step 2, computing the tonality of each\n partition band.  LAME has two tonality estimators.  The first\n is based on the ISO spec, and measures how predictiable the\n signal is over time.  The more predictable, the more tonal.\n The second measure is based on looking at the spectrum of\n a single granule.  The more peaky the spectrum, the more\n tonal.  By most indications, the latter approach is better.\n\n Finally, in step 5, the maskings for the mid and side\n channel are possibly increased.  Under certain circumstances,\n noise in the mid & side channels is assumed to also\n be masked by strong maskers in the L or R channels.\n\n\n Other data computed by the psy-model:\n\n ms_ratio        side-channel / mid-channel masking ratio (for previous granule)\n ms_ratio_next   side-channel / mid-channel masking ratio for this granule\n\n percep_entropy[2]     L and R values (prev granule) of PE - A measure of how\n much pre-echo is in the previous granule\n percep_entropy_MS[2]  mid and side channel values (prev granule) of percep_entropy\n energy[4]             L,R,M,S energy in each channel, prev granule\n blocktype_d[2]        block type to use for previous granule\n */\n//package mp3;\n\n//import java.util.Arrays;\nvar common = __webpack_require__(/*! ./common.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/common.js\");\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\nvar FFT = __webpack_require__(/*! ./FFT.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/FFT.js\");\nvar Encoder = __webpack_require__(/*! ./Encoder.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/Encoder.js\");\n\nfunction PsyModel() {\n    var MPEGMode = __webpack_require__(/*! ./MPEGMode.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/MPEGMode.js\");\n    var fft = new FFT();\n\n    var LOG10 = 2.30258509299404568402;\n\n    var rpelev = 2;\n    var rpelev2 = 16;\n    var rpelev_s = 2;\n    var rpelev2_s = 16;\n\n    /* size of each partition band, in barks: */\n    var DELBARK = .34;\n\n    /* tuned for output level (sensitive to energy scale) */\n    var VO_SCALE = (1. / (14752 * 14752) / (Encoder.BLKSIZE / 2));\n\n    var temporalmask_sustain_sec = 0.01;\n\n    var NS_PREECHO_ATT0 = 0.8;\n    var NS_PREECHO_ATT1 = 0.6;\n    var NS_PREECHO_ATT2 = 0.3;\n\n    var NS_MSFIX = 3.5;\n\n    var NSATTACKTHRE = 4.4;\n    var NSATTACKTHRE_S = 25;\n\n    var NSFIRLEN = 21;\n\n    /* size of each partition band, in barks: */\n    var LN_TO_LOG10 = 0.2302585093;\n\n    function NON_LINEAR_SCALE_ENERGY(x) {\n        return x;\n    }\n\n    /**\n     * <PRE>\n     *       L3psycho_anal.  Compute psycho acoustics.\n     *\n     *       Data returned to the calling program must be delayed by one\n     *       granule.\n     *\n     *       This is done in two places.\n     *       If we do not need to know the blocktype, the copying\n     *       can be done here at the top of the program: we copy the data for\n     *       the last granule (computed during the last call) before it is\n     *       overwritten with the new data.  It looks like this:\n     *\n     *       0. static psymodel_data\n     *       1. calling_program_data = psymodel_data\n     *       2. compute psymodel_data\n     *\n     *       For data which needs to know the blocktype, the copying must be\n     *       done at the end of this loop, and the old values must be saved:\n     *\n     *       0. static psymodel_data_old\n     *       1. compute psymodel_data\n     *       2. compute possible block type of this granule\n     *       3. compute final block type of previous granule based on #2.\n     *       4. calling_program_data = psymodel_data_old\n     *       5. psymodel_data_old = psymodel_data\n     *     psycho_loudness_approx\n     *       jd - 2001 mar 12\n     *    in:  energy   - BLKSIZE/2 elements of frequency magnitudes ^ 2\n     *         gfp      - uses out_samplerate, ATHtype (also needed for ATHformula)\n     *    returns: loudness^2 approximation, a positive value roughly tuned for a value\n     *             of 1.0 for signals near clipping.\n     *    notes:   When calibrated, feeding this function binary white noise at sample\n     *             values +32767 or -32768 should return values that approach 3.\n     *             ATHformula is used to approximate an equal loudness curve.\n     *    future:  Data indicates that the shape of the equal loudness curve varies\n     *             with intensity.  This function might be improved by using an equal\n     *             loudness curve shaped for typical playback levels (instead of the\n     *             ATH, that is shaped for the threshold).  A flexible realization might\n     *             simply bend the existing ATH curve to achieve the desired shape.\n     *             However, the potential gain may not be enough to justify an effort.\n     * </PRE>\n     */\n    function psycho_loudness_approx(energy, gfc) {\n        var loudness_power = 0.0;\n        /* apply weights to power in freq. bands */\n        for (var i = 0; i < Encoder.BLKSIZE / 2; ++i)\n            loudness_power += energy[i] * gfc.ATH.eql_w[i];\n        loudness_power *= VO_SCALE;\n\n        return loudness_power;\n    }\n\n    function compute_ffts(gfp, fftenergy, fftenergy_s, wsamp_l, wsamp_lPos, wsamp_s, wsamp_sPos, gr_out, chn, buffer, bufPos) {\n        var gfc = gfp.internal_flags;\n        if (chn < 2) {\n            fft.fft_long(gfc, wsamp_l[wsamp_lPos], chn, buffer, bufPos);\n            fft.fft_short(gfc, wsamp_s[wsamp_sPos], chn, buffer, bufPos);\n        }\n        /* FFT data for mid and side channel is derived from L & R */\n        else if (chn == 2) {\n            for (var j = Encoder.BLKSIZE - 1; j >= 0; --j) {\n                var l = wsamp_l[wsamp_lPos + 0][j];\n                var r = wsamp_l[wsamp_lPos + 1][j];\n                wsamp_l[wsamp_lPos + 0][j] = (l + r) * Util.SQRT2 * 0.5;\n                wsamp_l[wsamp_lPos + 1][j] = (l - r) * Util.SQRT2 * 0.5;\n            }\n            for (var b = 2; b >= 0; --b) {\n                for (var j = Encoder.BLKSIZE_s - 1; j >= 0; --j) {\n                    var l = wsamp_s[wsamp_sPos + 0][b][j];\n                    var r = wsamp_s[wsamp_sPos + 1][b][j];\n                    wsamp_s[wsamp_sPos + 0][b][j] = (l + r) * Util.SQRT2 * 0.5;\n                    wsamp_s[wsamp_sPos + 1][b][j] = (l - r) * Util.SQRT2 * 0.5;\n                }\n            }\n        }\n\n        /*********************************************************************\n         * compute energies\n         *********************************************************************/\n        fftenergy[0] = NON_LINEAR_SCALE_ENERGY(wsamp_l[wsamp_lPos + 0][0]);\n        fftenergy[0] *= fftenergy[0];\n\n        for (var j = Encoder.BLKSIZE / 2 - 1; j >= 0; --j) {\n            var re = (wsamp_l[wsamp_lPos + 0])[Encoder.BLKSIZE / 2 - j];\n            var im = (wsamp_l[wsamp_lPos + 0])[Encoder.BLKSIZE / 2 + j];\n            fftenergy[Encoder.BLKSIZE / 2 - j] = NON_LINEAR_SCALE_ENERGY((re\n                * re + im * im) * 0.5);\n        }\n        for (var b = 2; b >= 0; --b) {\n            fftenergy_s[b][0] = (wsamp_s[wsamp_sPos + 0])[b][0];\n            fftenergy_s[b][0] *= fftenergy_s[b][0];\n            for (var j = Encoder.BLKSIZE_s / 2 - 1; j >= 0; --j) {\n                var re = (wsamp_s[wsamp_sPos + 0])[b][Encoder.BLKSIZE_s\n                / 2 - j];\n                var im = (wsamp_s[wsamp_sPos + 0])[b][Encoder.BLKSIZE_s\n                / 2 + j];\n                fftenergy_s[b][Encoder.BLKSIZE_s / 2 - j] = NON_LINEAR_SCALE_ENERGY((re\n                    * re + im * im) * 0.5);\n            }\n        }\n        /* total energy */\n        {\n            var totalenergy = 0.0;\n            for (var j = 11; j < Encoder.HBLKSIZE; j++)\n                totalenergy += fftenergy[j];\n\n            gfc.tot_ener[chn] = totalenergy;\n        }\n\n        if (gfp.analysis) {\n            for (var j = 0; j < Encoder.HBLKSIZE; j++) {\n                gfc.pinfo.energy[gr_out][chn][j] = gfc.pinfo.energy_save[chn][j];\n                gfc.pinfo.energy_save[chn][j] = fftenergy[j];\n            }\n            gfc.pinfo.pe[gr_out][chn] = gfc.pe[chn];\n        }\n\n        /*********************************************************************\n         * compute loudness approximation (used for ATH auto-level adjustment)\n         *********************************************************************/\n        if (gfp.athaa_loudapprox == 2 && chn < 2) {\n            // no loudness for mid/side ch\n            gfc.loudness_sq[gr_out][chn] = gfc.loudness_sq_save[chn];\n            gfc.loudness_sq_save[chn] = psycho_loudness_approx(fftenergy, gfc);\n        }\n    }\n\n    /* mask_add optimization */\n    /* init the limit values used to avoid computing log in mask_add when it is not necessary */\n\n    /**\n     * <PRE>\n     *  For example, with i = 10*log10(m2/m1)/10*16         (= log10(m2/m1)*16)\n     *\n     * abs(i)>8 is equivalent (as i is an integer) to\n     * abs(i)>=9\n     * i>=9 || i<=-9\n     * equivalent to (as i is the biggest integer smaller than log10(m2/m1)*16\n     * or the smallest integer bigger than log10(m2/m1)*16 depending on the sign of log10(m2/m1)*16)\n     * log10(m2/m1)>=9/16 || log10(m2/m1)<=-9/16\n     * exp10 is strictly increasing thus this is equivalent to\n     * m2/m1 >= 10^(9/16) || m2/m1<=10^(-9/16) which are comparisons to constants\n     * </PRE>\n     */\n\n    /**\n     * as in if(i>8)\n     */\n    var I1LIMIT = 8;\n    /**\n     * as in if(i>24) . changed 23\n     */\n    var I2LIMIT = 23;\n    /**\n     * as in if(m<15)\n     */\n    var MLIMIT = 15;\n\n    var ma_max_i1;\n    var ma_max_i2;\n    var ma_max_m;\n\n    /**\n     * This is the masking table:<BR>\n     * According to tonality, values are going from 0dB (TMN) to 9.3dB (NMT).<BR>\n     * After additive masking computation, 8dB are added, so final values are\n     * going from 8dB to 17.3dB\n     *\n     * pow(10, -0.0..-0.6)\n     */\n    var tab = [1.0, 0.79433, 0.63096, 0.63096,\n        0.63096, 0.63096, 0.63096, 0.25119, 0.11749];\n\n    function init_mask_add_max_values() {\n        ma_max_i1 = Math.pow(10, (I1LIMIT + 1) / 16.0);\n        ma_max_i2 = Math.pow(10, (I2LIMIT + 1) / 16.0);\n        ma_max_m = Math.pow(10, (MLIMIT) / 10.0);\n    }\n\n    var table1 = [3.3246 * 3.3246,\n        3.23837 * 3.23837, 3.15437 * 3.15437, 3.00412 * 3.00412,\n        2.86103 * 2.86103, 2.65407 * 2.65407, 2.46209 * 2.46209,\n        2.284 * 2.284, 2.11879 * 2.11879, 1.96552 * 1.96552,\n        1.82335 * 1.82335, 1.69146 * 1.69146, 1.56911 * 1.56911,\n        1.46658 * 1.46658, 1.37074 * 1.37074, 1.31036 * 1.31036,\n        1.25264 * 1.25264, 1.20648 * 1.20648, 1.16203 * 1.16203,\n        1.12765 * 1.12765, 1.09428 * 1.09428, 1.0659 * 1.0659,\n        1.03826 * 1.03826, 1.01895 * 1.01895, 1];\n\n    var table2 = [1.33352 * 1.33352,\n        1.35879 * 1.35879, 1.38454 * 1.38454, 1.39497 * 1.39497,\n        1.40548 * 1.40548, 1.3537 * 1.3537, 1.30382 * 1.30382,\n        1.22321 * 1.22321, 1.14758 * 1.14758, 1];\n\n    var table3 = [2.35364 * 2.35364,\n        2.29259 * 2.29259, 2.23313 * 2.23313, 2.12675 * 2.12675,\n        2.02545 * 2.02545, 1.87894 * 1.87894, 1.74303 * 1.74303,\n        1.61695 * 1.61695, 1.49999 * 1.49999, 1.39148 * 1.39148,\n        1.29083 * 1.29083, 1.19746 * 1.19746, 1.11084 * 1.11084,\n        1.03826 * 1.03826];\n\n    /**\n     * addition of simultaneous masking Naoki Shibata 2000/7\n     */\n    function mask_add(m1, m2, kk, b, gfc, shortblock) {\n        var ratio;\n\n        if (m2 > m1) {\n            if (m2 < (m1 * ma_max_i2))\n                ratio = m2 / m1;\n            else\n                return (m1 + m2);\n        } else {\n            if (m1 >= (m2 * ma_max_i2))\n                return (m1 + m2);\n            ratio = m1 / m2;\n        }\n\n        /* Should always be true, just checking */\n        assert(m1 >= 0);\n        assert(m2 >= 0);\n\n        m1 += m2;\n        //if (((long)(b + 3) & 0xffffffff) <= 3 + 3) {\n        if ((b + 3) <= 3 + 3) {\n            /* approximately, 1 bark = 3 partitions */\n            /* 65% of the cases */\n            /* originally 'if(i > 8)' */\n            if (ratio >= ma_max_i1) {\n                /* 43% of the total */\n                return m1;\n            }\n\n            /* 22% of the total */\n            var i = 0 | (Util.FAST_LOG10_X(ratio, 16.0));\n            return m1 * table2[i];\n        }\n\n        /**\n         * <PRE>\n         * m<15 equ log10((m1+m2)/gfc.ATH.cb[k])<1.5\n         * equ (m1+m2)/gfc.ATH.cb[k]<10^1.5\n         * equ (m1+m2)<10^1.5 * gfc.ATH.cb[k]\n         * </PRE>\n         */\n        var i = 0 | Util.FAST_LOG10_X(ratio, 16.0);\n        if (shortblock != 0) {\n            m2 = gfc.ATH.cb_s[kk] * gfc.ATH.adjust;\n        } else {\n            m2 = gfc.ATH.cb_l[kk] * gfc.ATH.adjust;\n        }\n        assert(m2 >= 0);\n        if (m1 < ma_max_m * m2) {\n            /* 3% of the total */\n            /* Originally if (m > 0) { */\n            if (m1 > m2) {\n                var f, r;\n\n                f = 1.0;\n                if (i <= 13)\n                    f = table3[i];\n\n                r = Util.FAST_LOG10_X(m1 / m2, 10.0 / 15.0);\n                return m1 * ((table1[i] - f) * r + f);\n            }\n\n            if (i > 13)\n                return m1;\n\n            return m1 * table3[i];\n        }\n\n        /* 10% of total */\n        return m1 * table1[i];\n    }\n\n    var table2_ = [1.33352 * 1.33352,\n        1.35879 * 1.35879, 1.38454 * 1.38454, 1.39497 * 1.39497,\n        1.40548 * 1.40548, 1.3537 * 1.3537, 1.30382 * 1.30382,\n        1.22321 * 1.22321, 1.14758 * 1.14758, 1];\n\n    /**\n     * addition of simultaneous masking Naoki Shibata 2000/7\n     */\n    function vbrpsy_mask_add(m1, m2, b) {\n        var ratio;\n\n        if (m1 < 0) {\n            m1 = 0;\n        }\n        if (m2 < 0) {\n            m2 = 0;\n        }\n        if (m1 <= 0) {\n            return m2;\n        }\n        if (m2 <= 0) {\n            return m1;\n        }\n        if (m2 > m1) {\n            ratio = m2 / m1;\n        } else {\n            ratio = m1 / m2;\n        }\n        if (-2 <= b && b <= 2) {\n            /* approximately, 1 bark = 3 partitions */\n            /* originally 'if(i > 8)' */\n            if (ratio >= ma_max_i1) {\n                return m1 + m2;\n            } else {\n                var i = 0 | (Util.FAST_LOG10_X(ratio, 16.0));\n                return (m1 + m2) * table2_[i];\n            }\n        }\n        if (ratio < ma_max_i2) {\n            return m1 + m2;\n        }\n        if (m1 < m2) {\n            m1 = m2;\n        }\n        return m1;\n    }\n\n    /**\n     * compute interchannel masking effects\n     */\n    function calc_interchannel_masking(gfp, ratio) {\n        var gfc = gfp.internal_flags;\n        if (gfc.channels_out > 1) {\n            for (var sb = 0; sb < Encoder.SBMAX_l; sb++) {\n                var l = gfc.thm[0].l[sb];\n                var r = gfc.thm[1].l[sb];\n                gfc.thm[0].l[sb] += r * ratio;\n                gfc.thm[1].l[sb] += l * ratio;\n            }\n            for (var sb = 0; sb < Encoder.SBMAX_s; sb++) {\n                for (var sblock = 0; sblock < 3; sblock++) {\n                    var l = gfc.thm[0].s[sb][sblock];\n                    var r = gfc.thm[1].s[sb][sblock];\n                    gfc.thm[0].s[sb][sblock] += r * ratio;\n                    gfc.thm[1].s[sb][sblock] += l * ratio;\n                }\n            }\n        }\n    }\n\n    /**\n     * compute M/S thresholds from Johnston & Ferreira 1992 ICASSP paper\n     */\n    function msfix1(gfc) {\n        for (var sb = 0; sb < Encoder.SBMAX_l; sb++) {\n            /* use this fix if L & R masking differs by 2db or less */\n            /* if db = 10*log10(x2/x1) < 2 */\n            /* if (x2 < 1.58*x1) { */\n            if (gfc.thm[0].l[sb] > 1.58 * gfc.thm[1].l[sb]\n                || gfc.thm[1].l[sb] > 1.58 * gfc.thm[0].l[sb])\n                continue;\n            var mld = gfc.mld_l[sb] * gfc.en[3].l[sb];\n            var rmid = Math.max(gfc.thm[2].l[sb],\n                Math.min(gfc.thm[3].l[sb], mld));\n\n            mld = gfc.mld_l[sb] * gfc.en[2].l[sb];\n            var rside = Math.max(gfc.thm[3].l[sb],\n                Math.min(gfc.thm[2].l[sb], mld));\n            gfc.thm[2].l[sb] = rmid;\n            gfc.thm[3].l[sb] = rside;\n        }\n\n        for (var sb = 0; sb < Encoder.SBMAX_s; sb++) {\n            for (var sblock = 0; sblock < 3; sblock++) {\n                if (gfc.thm[0].s[sb][sblock] > 1.58 * gfc.thm[1].s[sb][sblock]\n                    || gfc.thm[1].s[sb][sblock] > 1.58 * gfc.thm[0].s[sb][sblock])\n                    continue;\n                var mld = gfc.mld_s[sb] * gfc.en[3].s[sb][sblock];\n                var rmid = Math.max(gfc.thm[2].s[sb][sblock],\n                    Math.min(gfc.thm[3].s[sb][sblock], mld));\n\n                mld = gfc.mld_s[sb] * gfc.en[2].s[sb][sblock];\n                var rside = Math.max(gfc.thm[3].s[sb][sblock],\n                    Math.min(gfc.thm[2].s[sb][sblock], mld));\n\n                gfc.thm[2].s[sb][sblock] = rmid;\n                gfc.thm[3].s[sb][sblock] = rside;\n            }\n        }\n    }\n\n    /**\n     * Adjust M/S maskings if user set \"msfix\"\n     *\n     * Naoki Shibata 2000\n     */\n    function ns_msfix(gfc, msfix, athadjust) {\n        var msfix2 = msfix;\n        var athlower = Math.pow(10, athadjust);\n\n        msfix *= 2.0;\n        msfix2 *= 2.0;\n        for (var sb = 0; sb < Encoder.SBMAX_l; sb++) {\n            var thmLR, thmM, thmS, ath;\n            ath = (gfc.ATH.cb_l[gfc.bm_l[sb]]) * athlower;\n            thmLR = Math.min(Math.max(gfc.thm[0].l[sb], ath),\n                Math.max(gfc.thm[1].l[sb], ath));\n            thmM = Math.max(gfc.thm[2].l[sb], ath);\n            thmS = Math.max(gfc.thm[3].l[sb], ath);\n            if (thmLR * msfix < thmM + thmS) {\n                var f = thmLR * msfix2 / (thmM + thmS);\n                thmM *= f;\n                thmS *= f;\n                assert(thmM + thmS > 0);\n            }\n            gfc.thm[2].l[sb] = Math.min(thmM, gfc.thm[2].l[sb]);\n            gfc.thm[3].l[sb] = Math.min(thmS, gfc.thm[3].l[sb]);\n        }\n\n        athlower *= ( Encoder.BLKSIZE_s / Encoder.BLKSIZE);\n        for (var sb = 0; sb < Encoder.SBMAX_s; sb++) {\n            for (var sblock = 0; sblock < 3; sblock++) {\n                var thmLR, thmM, thmS, ath;\n                ath = (gfc.ATH.cb_s[gfc.bm_s[sb]]) * athlower;\n                thmLR = Math.min(Math.max(gfc.thm[0].s[sb][sblock], ath),\n                    Math.max(gfc.thm[1].s[sb][sblock], ath));\n                thmM = Math.max(gfc.thm[2].s[sb][sblock], ath);\n                thmS = Math.max(gfc.thm[3].s[sb][sblock], ath);\n\n                if (thmLR * msfix < thmM + thmS) {\n                    var f = thmLR * msfix / (thmM + thmS);\n                    thmM *= f;\n                    thmS *= f;\n                    assert(thmM + thmS > 0);\n                }\n                gfc.thm[2].s[sb][sblock] = Math.min(gfc.thm[2].s[sb][sblock],\n                    thmM);\n                gfc.thm[3].s[sb][sblock] = Math.min(gfc.thm[3].s[sb][sblock],\n                    thmS);\n            }\n        }\n    }\n\n    /**\n     * short block threshold calculation (part 2)\n     *\n     * partition band bo_s[sfb] is at the transition from scalefactor band sfb\n     * to the next one sfb+1; enn and thmm have to be split between them\n     */\n    function convert_partition2scalefac_s(gfc, eb, thr, chn, sblock) {\n        var sb, b;\n        var enn = 0.0;\n        var thmm = 0.0;\n        for (sb = b = 0; sb < Encoder.SBMAX_s; ++b, ++sb) {\n            var bo_s_sb = gfc.bo_s[sb];\n            var npart_s = gfc.npart_s;\n            var b_lim = bo_s_sb < npart_s ? bo_s_sb : npart_s;\n            while (b < b_lim) {\n                assert(eb[b] >= 0);\n                // iff failed, it may indicate some index error elsewhere\n                assert(thr[b] >= 0);\n                enn += eb[b];\n                thmm += thr[b];\n                b++;\n            }\n            gfc.en[chn].s[sb][sblock] = enn;\n            gfc.thm[chn].s[sb][sblock] = thmm;\n\n            if (b >= npart_s) {\n                ++sb;\n                break;\n            }\n            assert(eb[b] >= 0);\n            // iff failed, it may indicate some index error elsewhere\n            assert(thr[b] >= 0);\n            {\n                /* at transition sfb . sfb+1 */\n                var w_curr = gfc.PSY.bo_s_weight[sb];\n                var w_next = 1.0 - w_curr;\n                enn = w_curr * eb[b];\n                thmm = w_curr * thr[b];\n                gfc.en[chn].s[sb][sblock] += enn;\n                gfc.thm[chn].s[sb][sblock] += thmm;\n                enn = w_next * eb[b];\n                thmm = w_next * thr[b];\n            }\n        }\n        /* zero initialize the rest */\n        for (; sb < Encoder.SBMAX_s; ++sb) {\n            gfc.en[chn].s[sb][sblock] = 0;\n            gfc.thm[chn].s[sb][sblock] = 0;\n        }\n    }\n\n    /**\n     * longblock threshold calculation (part 2)\n     */\n    function convert_partition2scalefac_l(gfc, eb, thr, chn) {\n        var sb, b;\n        var enn = 0.0;\n        var thmm = 0.0;\n        for (sb = b = 0; sb < Encoder.SBMAX_l; ++b, ++sb) {\n            var bo_l_sb = gfc.bo_l[sb];\n            var npart_l = gfc.npart_l;\n            var b_lim = bo_l_sb < npart_l ? bo_l_sb : npart_l;\n            while (b < b_lim) {\n                assert(eb[b] >= 0);\n                // iff failed, it may indicate some index error elsewhere\n                assert(thr[b] >= 0);\n                enn += eb[b];\n                thmm += thr[b];\n                b++;\n            }\n            gfc.en[chn].l[sb] = enn;\n            gfc.thm[chn].l[sb] = thmm;\n\n            if (b >= npart_l) {\n                ++sb;\n                break;\n            }\n            assert(eb[b] >= 0);\n            assert(thr[b] >= 0);\n            {\n                /* at transition sfb . sfb+1 */\n                var w_curr = gfc.PSY.bo_l_weight[sb];\n                var w_next = 1.0 - w_curr;\n                enn = w_curr * eb[b];\n                thmm = w_curr * thr[b];\n                gfc.en[chn].l[sb] += enn;\n                gfc.thm[chn].l[sb] += thmm;\n                enn = w_next * eb[b];\n                thmm = w_next * thr[b];\n            }\n        }\n        /* zero initialize the rest */\n        for (; sb < Encoder.SBMAX_l; ++sb) {\n            gfc.en[chn].l[sb] = 0;\n            gfc.thm[chn].l[sb] = 0;\n        }\n    }\n\n    function compute_masking_s(gfp, fftenergy_s, eb, thr, chn, sblock) {\n        var gfc = gfp.internal_flags;\n        var j, b;\n\n        for (b = j = 0; b < gfc.npart_s; ++b) {\n            var ebb = 0, m = 0;\n            var n = gfc.numlines_s[b];\n            for (var i = 0; i < n; ++i, ++j) {\n                var el = fftenergy_s[sblock][j];\n                ebb += el;\n                if (m < el)\n                    m = el;\n            }\n            eb[b] = ebb;\n        }\n        assert(b == gfc.npart_s);\n        assert(j == 129);\n        for (j = b = 0; b < gfc.npart_s; b++) {\n            var kk = gfc.s3ind_s[b][0];\n            var ecb = gfc.s3_ss[j++] * eb[kk];\n            ++kk;\n            while (kk <= gfc.s3ind_s[b][1]) {\n                ecb += gfc.s3_ss[j] * eb[kk];\n                ++j;\n                ++kk;\n            }\n\n            { /* limit calculated threshold by previous granule */\n                var x = rpelev_s * gfc.nb_s1[chn][b];\n                thr[b] = Math.min(ecb, x);\n            }\n            if (gfc.blocktype_old[chn & 1] == Encoder.SHORT_TYPE) {\n                /* limit calculated threshold by even older granule */\n                var x = rpelev2_s * gfc.nb_s2[chn][b];\n                var y = thr[b];\n                thr[b] = Math.min(x, y);\n            }\n\n            gfc.nb_s2[chn][b] = gfc.nb_s1[chn][b];\n            gfc.nb_s1[chn][b] = ecb;\n            assert(thr[b] >= 0);\n        }\n        for (; b <= Encoder.CBANDS; ++b) {\n            eb[b] = 0;\n            thr[b] = 0;\n        }\n    }\n\n    function block_type_set(gfp, uselongblock, blocktype_d, blocktype) {\n        var gfc = gfp.internal_flags;\n\n        if (gfp.short_blocks == ShortBlock.short_block_coupled\n                /* force both channels to use the same block type */\n                /* this is necessary if the frame is to be encoded in ms_stereo. */\n                /* But even without ms_stereo, FhG does this */\n            && !(uselongblock[0] != 0 && uselongblock[1] != 0))\n            uselongblock[0] = uselongblock[1] = 0;\n\n        /*\n         * update the blocktype of the previous granule, since it depends on\n         * what happend in this granule\n         */\n        for (var chn = 0; chn < gfc.channels_out; chn++) {\n            blocktype[chn] = Encoder.NORM_TYPE;\n            /* disable short blocks */\n            if (gfp.short_blocks == ShortBlock.short_block_dispensed)\n                uselongblock[chn] = 1;\n            if (gfp.short_blocks == ShortBlock.short_block_forced)\n                uselongblock[chn] = 0;\n\n            if (uselongblock[chn] != 0) {\n                /* no attack : use long blocks */\n                assert(gfc.blocktype_old[chn] != Encoder.START_TYPE);\n                if (gfc.blocktype_old[chn] == Encoder.SHORT_TYPE)\n                    blocktype[chn] = Encoder.STOP_TYPE;\n            } else {\n                /* attack : use short blocks */\n                blocktype[chn] = Encoder.SHORT_TYPE;\n                if (gfc.blocktype_old[chn] == Encoder.NORM_TYPE) {\n                    gfc.blocktype_old[chn] = Encoder.START_TYPE;\n                }\n                if (gfc.blocktype_old[chn] == Encoder.STOP_TYPE)\n                    gfc.blocktype_old[chn] = Encoder.SHORT_TYPE;\n            }\n\n            blocktype_d[chn] = gfc.blocktype_old[chn];\n            // value returned to calling program\n            gfc.blocktype_old[chn] = blocktype[chn];\n            // save for next call to l3psy_anal\n        }\n    }\n\n    function NS_INTERP(x, y, r) {\n        /* was pow((x),(r))*pow((y),1-(r)) */\n        if (r >= 1.0) {\n            /* 99.7% of the time */\n            return x;\n        }\n        if (r <= 0.0)\n            return y;\n        if (y > 0.0) {\n            /* rest of the time */\n            return (Math.pow(x / y, r) * y);\n        }\n        /* never happens */\n        return 0.0;\n    }\n\n    /**\n     * these values are tuned only for 44.1kHz...\n     */\n    var regcoef_s = [11.8, 13.6, 17.2, 32, 46.5,\n        51.3, 57.5, 67.1, 71.5, 84.6, 97.6, 130,\n        /* 255.8 */\n    ];\n\n    function pecalc_s(mr, masking_lower) {\n        var pe_s = 1236.28 / 4;\n        for (var sb = 0; sb < Encoder.SBMAX_s - 1; sb++) {\n            for (var sblock = 0; sblock < 3; sblock++) {\n                var thm = mr.thm.s[sb][sblock];\n                assert(sb < regcoef_s.length);\n                if (thm > 0.0) {\n                    var x = thm * masking_lower;\n                    var en = mr.en.s[sb][sblock];\n                    if (en > x) {\n                        if (en > x * 1e10) {\n                            pe_s += regcoef_s[sb] * (10.0 * LOG10);\n                        } else {\n                            assert(x > 0);\n                            pe_s += regcoef_s[sb] * Util.FAST_LOG10(en / x);\n                        }\n                    }\n                }\n            }\n        }\n\n        return pe_s;\n    }\n\n    /**\n     * these values are tuned only for 44.1kHz...\n     */\n    var regcoef_l = [6.8, 5.8, 5.8, 6.4, 6.5, 9.9,\n        12.1, 14.4, 15, 18.9, 21.6, 26.9, 34.2, 40.2, 46.8, 56.5,\n        60.7, 73.9, 85.7, 93.4, 126.1,\n        /* 241.3 */\n    ];\n\n    function pecalc_l(mr, masking_lower) {\n        var pe_l = 1124.23 / 4;\n        for (var sb = 0; sb < Encoder.SBMAX_l - 1; sb++) {\n            var thm = mr.thm.l[sb];\n            assert(sb < regcoef_l.length);\n            if (thm > 0.0) {\n                var x = thm * masking_lower;\n                var en = mr.en.l[sb];\n                if (en > x) {\n                    if (en > x * 1e10) {\n                        pe_l += regcoef_l[sb] * (10.0 * LOG10);\n                    } else {\n                        assert(x > 0);\n                        pe_l += regcoef_l[sb] * Util.FAST_LOG10(en / x);\n                    }\n                }\n            }\n        }\n        return pe_l;\n    }\n\n    function calc_energy(gfc, fftenergy, eb, max, avg) {\n        var b, j;\n\n        for (b = j = 0; b < gfc.npart_l; ++b) {\n            var ebb = 0, m = 0;\n            var i;\n            for (i = 0; i < gfc.numlines_l[b]; ++i, ++j) {\n                var el = fftenergy[j];\n                assert(el >= 0);\n                ebb += el;\n                if (m < el)\n                    m = el;\n            }\n            eb[b] = ebb;\n            max[b] = m;\n            avg[b] = ebb * gfc.rnumlines_l[b];\n            assert(gfc.rnumlines_l[b] >= 0);\n            assert(ebb >= 0);\n            assert(eb[b] >= 0);\n            assert(max[b] >= 0);\n            assert(avg[b] >= 0);\n        }\n    }\n\n    function calc_mask_index_l(gfc, max, avg, mask_idx) {\n        var last_tab_entry = tab.length - 1;\n        var b = 0;\n        var a = avg[b] + avg[b + 1];\n        assert(a >= 0);\n        if (a > 0.0) {\n            var m = max[b];\n            if (m < max[b + 1])\n                m = max[b + 1];\n            assert((gfc.numlines_l[b] + gfc.numlines_l[b + 1] - 1) > 0);\n            a = 20.0 * (m * 2.0 - a)\n                / (a * (gfc.numlines_l[b] + gfc.numlines_l[b + 1] - 1));\n            var k = 0 | a;\n            if (k > last_tab_entry)\n                k = last_tab_entry;\n            mask_idx[b] = k;\n        } else {\n            mask_idx[b] = 0;\n        }\n\n        for (b = 1; b < gfc.npart_l - 1; b++) {\n            a = avg[b - 1] + avg[b] + avg[b + 1];\n            assert(a >= 0);\n            if (a > 0.0) {\n                var m = max[b - 1];\n                if (m < max[b])\n                    m = max[b];\n                if (m < max[b + 1])\n                    m = max[b + 1];\n                assert((gfc.numlines_l[b - 1] + gfc.numlines_l[b] + gfc.numlines_l[b + 1] - 1) > 0);\n                a = 20.0\n                    * (m * 3.0 - a)\n                    / (a * (gfc.numlines_l[b - 1] + gfc.numlines_l[b]\n                    + gfc.numlines_l[b + 1] - 1));\n                var k = 0 | a;\n                if (k > last_tab_entry)\n                    k = last_tab_entry;\n                mask_idx[b] = k;\n            } else {\n                mask_idx[b] = 0;\n            }\n        }\n        assert(b > 0);\n        assert(b == gfc.npart_l - 1);\n\n        a = avg[b - 1] + avg[b];\n        assert(a >= 0);\n        if (a > 0.0) {\n            var m = max[b - 1];\n            if (m < max[b])\n                m = max[b];\n            assert((gfc.numlines_l[b - 1] + gfc.numlines_l[b] - 1) > 0);\n            a = 20.0 * (m * 2.0 - a)\n                / (a * (gfc.numlines_l[b - 1] + gfc.numlines_l[b] - 1));\n            var k = 0 | a;\n            if (k > last_tab_entry)\n                k = last_tab_entry;\n            mask_idx[b] = k;\n        } else {\n            mask_idx[b] = 0;\n        }\n        assert(b == (gfc.npart_l - 1));\n    }\n\n    var fircoef = [\n        -8.65163e-18 * 2, -0.00851586 * 2, -6.74764e-18 * 2, 0.0209036 * 2,\n        -3.36639e-17 * 2, -0.0438162 * 2, -1.54175e-17 * 2, 0.0931738 * 2,\n        -5.52212e-17 * 2, -0.313819 * 2\n    ];\n\n    this.L3psycho_anal_ns = function (gfp, buffer, bufPos, gr_out, masking_ratio, masking_MS_ratio, percep_entropy, percep_MS_entropy, energy, blocktype_d) {\n        /*\n         * to get a good cache performance, one has to think about the sequence,\n         * in which the variables are used.\n         */\n        var gfc = gfp.internal_flags;\n\n        /* fft and energy calculation */\n        var wsamp_L = new_float_n([2, Encoder.BLKSIZE]);\n        var wsamp_S = new_float_n([2, 3, Encoder.BLKSIZE_s]);\n\n        /* convolution */\n        var eb_l = new_float(Encoder.CBANDS + 1);\n        var eb_s = new_float(Encoder.CBANDS + 1);\n        var thr = new_float(Encoder.CBANDS + 2);\n\n        /* block type */\n        var blocktype = new_int(2), uselongblock = new_int(2);\n\n        /* usual variables like loop indices, etc.. */\n        var numchn, chn;\n        var b, i, j, k;\n        var sb, sblock;\n\n        /* variables used for --nspsytune */\n        var ns_hpfsmpl = new_float_n([2, 576]);\n        var pcfact;\n        var mask_idx_l = new_int(Encoder.CBANDS + 2), mask_idx_s = new_int(Encoder.CBANDS + 2);\n\n        Arrays.fill(mask_idx_s, 0);\n\n        numchn = gfc.channels_out;\n        /* chn=2 and 3 = Mid and Side channels */\n        if (gfp.mode == MPEGMode.JOINT_STEREO)\n            numchn = 4;\n\n        if (gfp.VBR == VbrMode.vbr_off)\n            pcfact = gfc.ResvMax == 0 ? 0 : ( gfc.ResvSize)\n            / gfc.ResvMax * 0.5;\n        else if (gfp.VBR == VbrMode.vbr_rh || gfp.VBR == VbrMode.vbr_mtrh\n            || gfp.VBR == VbrMode.vbr_mt) {\n            pcfact = 0.6;\n        } else\n            pcfact = 1.0;\n\n        /**********************************************************************\n         * Apply HPF of fs/4 to the input signal. This is used for attack\n         * detection / handling.\n         **********************************************************************/\n        /* Don't copy the input buffer into a temporary buffer */\n        /* unroll the loop 2 times */\n        for (chn = 0; chn < gfc.channels_out; chn++) {\n            /* apply high pass filter of fs/4 */\n            var firbuf = buffer[chn];\n            var firbufPos = bufPos + 576 - 350 - NSFIRLEN + 192;\n            assert(fircoef.length == ((NSFIRLEN - 1) / 2));\n            for (i = 0; i < 576; i++) {\n                var sum1, sum2;\n                sum1 = firbuf[firbufPos + i + 10];\n                sum2 = 0.0;\n                for (j = 0; j < ((NSFIRLEN - 1) / 2) - 1; j += 2) {\n                    sum1 += fircoef[j]\n                        * (firbuf[firbufPos + i + j] + firbuf[firbufPos + i\n                        + NSFIRLEN - j]);\n                    sum2 += fircoef[j + 1]\n                        * (firbuf[firbufPos + i + j + 1] + firbuf[firbufPos\n                        + i + NSFIRLEN - j - 1]);\n                }\n                ns_hpfsmpl[chn][i] = sum1 + sum2;\n            }\n            masking_ratio[gr_out][chn].en.assign(gfc.en[chn]);\n            masking_ratio[gr_out][chn].thm.assign(gfc.thm[chn]);\n            if (numchn > 2) {\n                /* MS maskings */\n                /* percep_MS_entropy [chn-2] = gfc . pe [chn]; */\n                masking_MS_ratio[gr_out][chn].en.assign(gfc.en[chn + 2]);\n                masking_MS_ratio[gr_out][chn].thm.assign(gfc.thm[chn + 2]);\n            }\n        }\n\n        for (chn = 0; chn < numchn; chn++) {\n            var wsamp_l;\n            var wsamp_s;\n            var en_subshort = new_float(12);\n            var en_short = [0, 0, 0, 0];\n            var attack_intensity = new_float(12);\n            var ns_uselongblock = 1;\n            var attackThreshold;\n            var max = new_float(Encoder.CBANDS), avg = new_float(Encoder.CBANDS);\n            var ns_attacks = [0, 0, 0, 0];\n            var fftenergy = new_float(Encoder.HBLKSIZE);\n            var fftenergy_s = new_float_n([3, Encoder.HBLKSIZE_s]);\n\n            /*\n             * rh 20040301: the following loops do access one off the limits so\n             * I increase the array dimensions by one and initialize the\n             * accessed values to zero\n             */\n            assert(gfc.npart_s <= Encoder.CBANDS);\n            assert(gfc.npart_l <= Encoder.CBANDS);\n\n            /***************************************************************\n             * determine the block type (window type)\n             ***************************************************************/\n            /* calculate energies of each sub-shortblocks */\n            for (i = 0; i < 3; i++) {\n                en_subshort[i] = gfc.nsPsy.last_en_subshort[chn][i + 6];\n                assert(gfc.nsPsy.last_en_subshort[chn][i + 4] > 0);\n                attack_intensity[i] = en_subshort[i]\n                    / gfc.nsPsy.last_en_subshort[chn][i + 4];\n                en_short[0] += en_subshort[i];\n            }\n\n            if (chn == 2) {\n                for (i = 0; i < 576; i++) {\n                    var l, r;\n                    l = ns_hpfsmpl[0][i];\n                    r = ns_hpfsmpl[1][i];\n                    ns_hpfsmpl[0][i] = l + r;\n                    ns_hpfsmpl[1][i] = l - r;\n                }\n            }\n            {\n                var pf = ns_hpfsmpl[chn & 1];\n                var pfPos = 0;\n                for (i = 0; i < 9; i++) {\n                    var pfe = pfPos + 576 / 9;\n                    var p = 1.;\n                    for (; pfPos < pfe; pfPos++)\n                        if (p < Math.abs(pf[pfPos]))\n                            p = Math.abs(pf[pfPos]);\n\n                    gfc.nsPsy.last_en_subshort[chn][i] = en_subshort[i + 3] = p;\n                    en_short[1 + i / 3] += p;\n                    if (p > en_subshort[i + 3 - 2]) {\n                        assert(en_subshort[i + 3 - 2] > 0);\n                        p = p / en_subshort[i + 3 - 2];\n                    } else if (en_subshort[i + 3 - 2] > p * 10.0) {\n                        assert(p > 0);\n                        p = en_subshort[i + 3 - 2] / (p * 10.0);\n                    } else\n                        p = 0.0;\n                    attack_intensity[i + 3] = p;\n                }\n            }\n\n            if (gfp.analysis) {\n                var x = attack_intensity[0];\n                for (i = 1; i < 12; i++)\n                    if (x < attack_intensity[i])\n                        x = attack_intensity[i];\n                gfc.pinfo.ers[gr_out][chn] = gfc.pinfo.ers_save[chn];\n                gfc.pinfo.ers_save[chn] = x;\n            }\n\n            /* compare energies between sub-shortblocks */\n            attackThreshold = (chn == 3) ? gfc.nsPsy.attackthre_s\n                : gfc.nsPsy.attackthre;\n            for (i = 0; i < 12; i++)\n                if (0 == ns_attacks[i / 3]\n                    && attack_intensity[i] > attackThreshold)\n                    ns_attacks[i / 3] = (i % 3) + 1;\n\n            /*\n             * should have energy change between short blocks, in order to avoid\n             * periodic signals\n             */\n            for (i = 1; i < 4; i++) {\n                var ratio;\n                if (en_short[i - 1] > en_short[i]) {\n                    assert(en_short[i] > 0);\n                    ratio = en_short[i - 1] / en_short[i];\n                } else {\n                    assert(en_short[i - 1] > 0);\n                    ratio = en_short[i] / en_short[i - 1];\n                }\n                if (ratio < 1.7) {\n                    ns_attacks[i] = 0;\n                    if (i == 1)\n                        ns_attacks[0] = 0;\n                }\n            }\n\n            if (ns_attacks[0] != 0 && gfc.nsPsy.lastAttacks[chn] != 0)\n                ns_attacks[0] = 0;\n\n            if (gfc.nsPsy.lastAttacks[chn] == 3\n                || (ns_attacks[0] + ns_attacks[1] + ns_attacks[2] + ns_attacks[3]) != 0) {\n                ns_uselongblock = 0;\n\n                if (ns_attacks[1] != 0 && ns_attacks[0] != 0)\n                    ns_attacks[1] = 0;\n                if (ns_attacks[2] != 0 && ns_attacks[1] != 0)\n                    ns_attacks[2] = 0;\n                if (ns_attacks[3] != 0 && ns_attacks[2] != 0)\n                    ns_attacks[3] = 0;\n            }\n\n            if (chn < 2) {\n                uselongblock[chn] = ns_uselongblock;\n            } else {\n                if (ns_uselongblock == 0) {\n                    uselongblock[0] = uselongblock[1] = 0;\n                }\n            }\n\n            /*\n             * there is a one granule delay. Copy maskings computed last call\n             * into masking_ratio to return to calling program.\n             */\n            energy[chn] = gfc.tot_ener[chn];\n\n            /*********************************************************************\n             * compute FFTs\n             *********************************************************************/\n            wsamp_s = wsamp_S;\n            wsamp_l = wsamp_L;\n            compute_ffts(gfp, fftenergy, fftenergy_s, wsamp_l, (chn & 1),\n                wsamp_s, (chn & 1), gr_out, chn, buffer, bufPos);\n\n            /*********************************************************************\n             * Calculate the energy and the tonality of each partition.\n             *********************************************************************/\n            calc_energy(gfc, fftenergy, eb_l, max, avg);\n            calc_mask_index_l(gfc, max, avg, mask_idx_l);\n            /* compute masking thresholds for short blocks */\n            for (sblock = 0; sblock < 3; sblock++) {\n                var enn, thmm;\n                compute_masking_s(gfp, fftenergy_s, eb_s, thr, chn, sblock);\n                convert_partition2scalefac_s(gfc, eb_s, thr, chn, sblock);\n                /**** short block pre-echo control ****/\n                for (sb = 0; sb < Encoder.SBMAX_s; sb++) {\n                    thmm = gfc.thm[chn].s[sb][sblock];\n\n                    thmm *= NS_PREECHO_ATT0;\n                    if (ns_attacks[sblock] >= 2 || ns_attacks[sblock + 1] == 1) {\n                        var idx = (sblock != 0) ? sblock - 1 : 2;\n                        var p = NS_INTERP(gfc.thm[chn].s[sb][idx], thmm,\n                            NS_PREECHO_ATT1 * pcfact);\n                        thmm = Math.min(thmm, p);\n                    }\n\n                    if (ns_attacks[sblock] == 1) {\n                        var idx = (sblock != 0) ? sblock - 1 : 2;\n                        var p = NS_INTERP(gfc.thm[chn].s[sb][idx], thmm,\n                            NS_PREECHO_ATT2 * pcfact);\n                        thmm = Math.min(thmm, p);\n                    } else if ((sblock != 0 && ns_attacks[sblock - 1] == 3)\n                        || (sblock == 0 && gfc.nsPsy.lastAttacks[chn] == 3)) {\n                        var idx = (sblock != 2) ? sblock + 1 : 0;\n                        var p = NS_INTERP(gfc.thm[chn].s[sb][idx], thmm,\n                            NS_PREECHO_ATT2 * pcfact);\n                        thmm = Math.min(thmm, p);\n                    }\n\n                    /* pulse like signal detection for fatboy.wav and so on */\n                    enn = en_subshort[sblock * 3 + 3]\n                        + en_subshort[sblock * 3 + 4]\n                        + en_subshort[sblock * 3 + 5];\n                    if (en_subshort[sblock * 3 + 5] * 6 < enn) {\n                        thmm *= 0.5;\n                        if (en_subshort[sblock * 3 + 4] * 6 < enn)\n                            thmm *= 0.5;\n                    }\n\n                    gfc.thm[chn].s[sb][sblock] = thmm;\n                }\n            }\n            gfc.nsPsy.lastAttacks[chn] = ns_attacks[2];\n\n            /*********************************************************************\n             * convolve the partitioned energy and unpredictability with the\n             * spreading function, s3_l[b][k]\n             ********************************************************************/\n            k = 0;\n            {\n                for (b = 0; b < gfc.npart_l; b++) {\n                    /*\n                     * convolve the partitioned energy with the spreading\n                     * function\n                     */\n                    var kk = gfc.s3ind[b][0];\n                    var eb2 = eb_l[kk] * tab[mask_idx_l[kk]];\n                    var ecb = gfc.s3_ll[k++] * eb2;\n                    while (++kk <= gfc.s3ind[b][1]) {\n                        eb2 = eb_l[kk] * tab[mask_idx_l[kk]];\n                        ecb = mask_add(ecb, gfc.s3_ll[k++] * eb2, kk, kk - b,\n                            gfc, 0);\n                    }\n                    ecb *= 0.158489319246111;\n                    /* pow(10,-0.8) */\n\n                    /**** long block pre-echo control ****/\n                    /**\n                     * <PRE>\n                     * dont use long block pre-echo control if previous granule was\n                     * a short block.  This is to avoid the situation:\n                     * frame0:  quiet (very low masking)\n                     * frame1:  surge  (triggers short blocks)\n                     * frame2:  regular frame.  looks like pre-echo when compared to\n                     *          frame0, but all pre-echo was in frame1.\n                     * </PRE>\n                     */\n                    /*\n                     * chn=0,1 L and R channels\n                     *\n                     * chn=2,3 S and M channels.\n                     */\n\n                    if (gfc.blocktype_old[chn & 1] == Encoder.SHORT_TYPE)\n                        thr[b] = ecb;\n                    else\n                        thr[b] = NS_INTERP(\n                            Math.min(ecb, Math.min(rpelev\n                                * gfc.nb_1[chn][b], rpelev2\n                                * gfc.nb_2[chn][b])), ecb, pcfact);\n\n                    gfc.nb_2[chn][b] = gfc.nb_1[chn][b];\n                    gfc.nb_1[chn][b] = ecb;\n                }\n            }\n            for (; b <= Encoder.CBANDS; ++b) {\n                eb_l[b] = 0;\n                thr[b] = 0;\n            }\n            /* compute masking thresholds for long blocks */\n            convert_partition2scalefac_l(gfc, eb_l, thr, chn);\n        }\n        /* end loop over chn */\n\n        if (gfp.mode == MPEGMode.STEREO || gfp.mode == MPEGMode.JOINT_STEREO) {\n            if (gfp.interChRatio > 0.0) {\n                calc_interchannel_masking(gfp, gfp.interChRatio);\n            }\n        }\n\n        if (gfp.mode == MPEGMode.JOINT_STEREO) {\n            var msfix;\n            msfix1(gfc);\n            msfix = gfp.msfix;\n            if (Math.abs(msfix) > 0.0)\n                ns_msfix(gfc, msfix, gfp.ATHlower * gfc.ATH.adjust);\n        }\n\n        /***************************************************************\n         * determine final block type\n         ***************************************************************/\n        block_type_set(gfp, uselongblock, blocktype_d, blocktype);\n\n        /*********************************************************************\n         * compute the value of PE to return ... no delay and advance\n         *********************************************************************/\n        for (chn = 0; chn < numchn; chn++) {\n            var ppe;\n            var ppePos = 0;\n            var type;\n            var mr;\n\n            if (chn > 1) {\n                ppe = percep_MS_entropy;\n                ppePos = -2;\n                type = Encoder.NORM_TYPE;\n                if (blocktype_d[0] == Encoder.SHORT_TYPE\n                    || blocktype_d[1] == Encoder.SHORT_TYPE)\n                    type = Encoder.SHORT_TYPE;\n                mr = masking_MS_ratio[gr_out][chn - 2];\n            } else {\n                ppe = percep_entropy;\n                ppePos = 0;\n                type = blocktype_d[chn];\n                mr = masking_ratio[gr_out][chn];\n            }\n\n            if (type == Encoder.SHORT_TYPE)\n                ppe[ppePos + chn] = pecalc_s(mr, gfc.masking_lower);\n            else\n                ppe[ppePos + chn] = pecalc_l(mr, gfc.masking_lower);\n\n            if (gfp.analysis)\n                gfc.pinfo.pe[gr_out][chn] = ppe[ppePos + chn];\n\n        }\n        return 0;\n    }\n\n    function vbrpsy_compute_fft_l(gfp, buffer, bufPos, chn, gr_out, fftenergy, wsamp_l, wsamp_lPos) {\n        var gfc = gfp.internal_flags;\n        if (chn < 2) {\n            fft.fft_long(gfc, wsamp_l[wsamp_lPos], chn, buffer, bufPos);\n        } else if (chn == 2) {\n            /* FFT data for mid and side channel is derived from L & R */\n            for (var j = Encoder.BLKSIZE - 1; j >= 0; --j) {\n                var l = wsamp_l[wsamp_lPos + 0][j];\n                var r = wsamp_l[wsamp_lPos + 1][j];\n                wsamp_l[wsamp_lPos + 0][j] = (l + r) * Util.SQRT2 * 0.5;\n                wsamp_l[wsamp_lPos + 1][j] = (l - r) * Util.SQRT2 * 0.5;\n            }\n        }\n\n        /*********************************************************************\n         * compute energies\n         *********************************************************************/\n        fftenergy[0] = NON_LINEAR_SCALE_ENERGY(wsamp_l[wsamp_lPos + 0][0]);\n        fftenergy[0] *= fftenergy[0];\n\n        for (var j = Encoder.BLKSIZE / 2 - 1; j >= 0; --j) {\n            var re = wsamp_l[wsamp_lPos + 0][Encoder.BLKSIZE / 2 - j];\n            var im = wsamp_l[wsamp_lPos + 0][Encoder.BLKSIZE / 2 + j];\n            fftenergy[Encoder.BLKSIZE / 2 - j] = NON_LINEAR_SCALE_ENERGY((re\n                * re + im * im) * 0.5);\n        }\n        /* total energy */\n        {\n            var totalenergy = 0.0;\n            for (var j = 11; j < Encoder.HBLKSIZE; j++)\n                totalenergy += fftenergy[j];\n\n            gfc.tot_ener[chn] = totalenergy;\n        }\n\n        if (gfp.analysis) {\n            for (var j = 0; j < Encoder.HBLKSIZE; j++) {\n                gfc.pinfo.energy[gr_out][chn][j] = gfc.pinfo.energy_save[chn][j];\n                gfc.pinfo.energy_save[chn][j] = fftenergy[j];\n            }\n            gfc.pinfo.pe[gr_out][chn] = gfc.pe[chn];\n        }\n    }\n\n    function vbrpsy_compute_fft_s(gfp, buffer, bufPos, chn, sblock, fftenergy_s, wsamp_s, wsamp_sPos) {\n        var gfc = gfp.internal_flags;\n\n        if (sblock == 0 && chn < 2) {\n            fft.fft_short(gfc, wsamp_s[wsamp_sPos], chn, buffer, bufPos);\n        }\n        if (chn == 2) {\n            /* FFT data for mid and side channel is derived from L & R */\n            for (var j = Encoder.BLKSIZE_s - 1; j >= 0; --j) {\n                var l = wsamp_s[wsamp_sPos + 0][sblock][j];\n                var r = wsamp_s[wsamp_sPos + 1][sblock][j];\n                wsamp_s[wsamp_sPos + 0][sblock][j] = (l + r) * Util.SQRT2 * 0.5;\n                wsamp_s[wsamp_sPos + 1][sblock][j] = (l - r) * Util.SQRT2 * 0.5;\n            }\n        }\n\n        /*********************************************************************\n         * compute energies\n         *********************************************************************/\n        fftenergy_s[sblock][0] = wsamp_s[wsamp_sPos + 0][sblock][0];\n        fftenergy_s[sblock][0] *= fftenergy_s[sblock][0];\n        for (var j = Encoder.BLKSIZE_s / 2 - 1; j >= 0; --j) {\n            var re = wsamp_s[wsamp_sPos + 0][sblock][Encoder.BLKSIZE_s / 2 - j];\n            var im = wsamp_s[wsamp_sPos + 0][sblock][Encoder.BLKSIZE_s / 2 + j];\n            fftenergy_s[sblock][Encoder.BLKSIZE_s / 2 - j] = NON_LINEAR_SCALE_ENERGY((re\n                * re + im * im) * 0.5);\n        }\n    }\n\n    /**\n     * compute loudness approximation (used for ATH auto-level adjustment)\n     */\n    function vbrpsy_compute_loudness_approximation_l(gfp, gr_out, chn, fftenergy) {\n        var gfc = gfp.internal_flags;\n        if (gfp.athaa_loudapprox == 2 && chn < 2) {\n            // no loudness for mid/side ch\n            gfc.loudness_sq[gr_out][chn] = gfc.loudness_sq_save[chn];\n            gfc.loudness_sq_save[chn] = psycho_loudness_approx(fftenergy, gfc);\n        }\n    }\n\n    var fircoef_ = [-8.65163e-18 * 2,\n        -0.00851586 * 2, -6.74764e-18 * 2, 0.0209036 * 2,\n        -3.36639e-17 * 2, -0.0438162 * 2, -1.54175e-17 * 2,\n        0.0931738 * 2, -5.52212e-17 * 2, -0.313819 * 2];\n\n    /**\n     * Apply HPF of fs/4 to the input signal. This is used for attack detection\n     * / handling.\n     */\n    function vbrpsy_attack_detection(gfp, buffer, bufPos, gr_out, masking_ratio, masking_MS_ratio, energy, sub_short_factor, ns_attacks, uselongblock) {\n        var ns_hpfsmpl = new_float_n([2, 576]);\n        var gfc = gfp.internal_flags;\n        var n_chn_out = gfc.channels_out;\n        /* chn=2 and 3 = Mid and Side channels */\n        var n_chn_psy = (gfp.mode == MPEGMode.JOINT_STEREO) ? 4 : n_chn_out;\n        /* Don't copy the input buffer into a temporary buffer */\n        /* unroll the loop 2 times */\n        for (var chn = 0; chn < n_chn_out; chn++) {\n            /* apply high pass filter of fs/4 */\n            firbuf = buffer[chn];\n            var firbufPos = bufPos + 576 - 350 - NSFIRLEN + 192;\n            assert(fircoef_.length == ((NSFIRLEN - 1) / 2));\n            for (var i = 0; i < 576; i++) {\n                var sum1, sum2;\n                sum1 = firbuf[firbufPos + i + 10];\n                sum2 = 0.0;\n                for (var j = 0; j < ((NSFIRLEN - 1) / 2) - 1; j += 2) {\n                    sum1 += fircoef_[j]\n                        * (firbuf[firbufPos + i + j] + firbuf[firbufPos + i\n                        + NSFIRLEN - j]);\n                    sum2 += fircoef_[j + 1]\n                        * (firbuf[firbufPos + i + j + 1] + firbuf[firbufPos\n                        + i + NSFIRLEN - j - 1]);\n                }\n                ns_hpfsmpl[chn][i] = sum1 + sum2;\n            }\n            masking_ratio[gr_out][chn].en.assign(gfc.en[chn]);\n            masking_ratio[gr_out][chn].thm.assign(gfc.thm[chn]);\n            if (n_chn_psy > 2) {\n                /* MS maskings */\n                /* percep_MS_entropy [chn-2] = gfc . pe [chn]; */\n                masking_MS_ratio[gr_out][chn].en.assign(gfc.en[chn + 2]);\n                masking_MS_ratio[gr_out][chn].thm.assign(gfc.thm[chn + 2]);\n            }\n        }\n        for (var chn = 0; chn < n_chn_psy; chn++) {\n            var attack_intensity = new_float(12);\n            var en_subshort = new_float(12);\n            var en_short = [0, 0, 0, 0];\n            var pf = ns_hpfsmpl[chn & 1];\n            var pfPos = 0;\n            var attackThreshold = (chn == 3) ? gfc.nsPsy.attackthre_s\n                : gfc.nsPsy.attackthre;\n            var ns_uselongblock = 1;\n\n            if (chn == 2) {\n                for (var i = 0, j = 576; j > 0; ++i, --j) {\n                    var l = ns_hpfsmpl[0][i];\n                    var r = ns_hpfsmpl[1][i];\n                    ns_hpfsmpl[0][i] = l + r;\n                    ns_hpfsmpl[1][i] = l - r;\n                }\n            }\n            /***************************************************************\n             * determine the block type (window type)\n             ***************************************************************/\n            /* calculate energies of each sub-shortblocks */\n            for (var i = 0; i < 3; i++) {\n                en_subshort[i] = gfc.nsPsy.last_en_subshort[chn][i + 6];\n                assert(gfc.nsPsy.last_en_subshort[chn][i + 4] > 0);\n                attack_intensity[i] = en_subshort[i]\n                    / gfc.nsPsy.last_en_subshort[chn][i + 4];\n                en_short[0] += en_subshort[i];\n            }\n\n            for (var i = 0; i < 9; i++) {\n                var pfe = pfPos + 576 / 9;\n                var p = 1.;\n                for (; pfPos < pfe; pfPos++)\n                    if (p < Math.abs(pf[pfPos]))\n                        p = Math.abs(pf[pfPos]);\n\n                gfc.nsPsy.last_en_subshort[chn][i] = en_subshort[i + 3] = p;\n                en_short[1 + i / 3] += p;\n                if (p > en_subshort[i + 3 - 2]) {\n                    assert(en_subshort[i + 3 - 2] > 0);\n                    p = p / en_subshort[i + 3 - 2];\n                } else if (en_subshort[i + 3 - 2] > p * 10.0) {\n                    assert(p > 0);\n                    p = en_subshort[i + 3 - 2] / (p * 10.0);\n                } else {\n                    p = 0.0;\n                }\n                attack_intensity[i + 3] = p;\n            }\n            /* pulse like signal detection for fatboy.wav and so on */\n            for (var i = 0; i < 3; ++i) {\n                var enn = en_subshort[i * 3 + 3]\n                    + en_subshort[i * 3 + 4] + en_subshort[i * 3 + 5];\n                var factor = 1.;\n                if (en_subshort[i * 3 + 5] * 6 < enn) {\n                    factor *= 0.5;\n                    if (en_subshort[i * 3 + 4] * 6 < enn) {\n                        factor *= 0.5;\n                    }\n                }\n                sub_short_factor[chn][i] = factor;\n            }\n\n            if (gfp.analysis) {\n                var x = attack_intensity[0];\n                for (var i = 1; i < 12; i++) {\n                    if (x < attack_intensity[i]) {\n                        x = attack_intensity[i];\n                    }\n                }\n                gfc.pinfo.ers[gr_out][chn] = gfc.pinfo.ers_save[chn];\n                gfc.pinfo.ers_save[chn] = x;\n            }\n\n            /* compare energies between sub-shortblocks */\n            for (var i = 0; i < 12; i++) {\n                if (0 == ns_attacks[chn][i / 3]\n                    && attack_intensity[i] > attackThreshold) {\n                    ns_attacks[chn][i / 3] = (i % 3) + 1;\n                }\n            }\n\n            /*\n             * should have energy change between short blocks, in order to avoid\n             * periodic signals\n             */\n            /* Good samples to show the effect are Trumpet test songs */\n            /*\n             * GB: tuned (1) to avoid too many short blocks for test sample\n             * TRUMPET\n             */\n            /*\n             * RH: tuned (2) to let enough short blocks through for test sample\n             * FSOL and SNAPS\n             */\n            for (var i = 1; i < 4; i++) {\n                var u = en_short[i - 1];\n                var v = en_short[i];\n                var m = Math.max(u, v);\n                if (m < 40000) { /* (2) */\n                    if (u < 1.7 * v && v < 1.7 * u) { /* (1) */\n                        if (i == 1 && ns_attacks[chn][0] <= ns_attacks[chn][i]) {\n                            ns_attacks[chn][0] = 0;\n                        }\n                        ns_attacks[chn][i] = 0;\n                    }\n                }\n            }\n\n            if (ns_attacks[chn][0] <= gfc.nsPsy.lastAttacks[chn]) {\n                ns_attacks[chn][0] = 0;\n            }\n\n            if (gfc.nsPsy.lastAttacks[chn] == 3\n                || (ns_attacks[chn][0] + ns_attacks[chn][1]\n                + ns_attacks[chn][2] + ns_attacks[chn][3]) != 0) {\n                ns_uselongblock = 0;\n\n                if (ns_attacks[chn][1] != 0 && ns_attacks[chn][0] != 0) {\n                    ns_attacks[chn][1] = 0;\n                }\n                if (ns_attacks[chn][2] != 0 && ns_attacks[chn][1] != 0) {\n                    ns_attacks[chn][2] = 0;\n                }\n                if (ns_attacks[chn][3] != 0 && ns_attacks[chn][2] != 0) {\n                    ns_attacks[chn][3] = 0;\n                }\n            }\n            if (chn < 2) {\n                uselongblock[chn] = ns_uselongblock;\n            } else {\n                if (ns_uselongblock == 0) {\n                    uselongblock[0] = uselongblock[1] = 0;\n                }\n            }\n\n            /*\n             * there is a one granule delay. Copy maskings computed last call\n             * into masking_ratio to return to calling program.\n             */\n            energy[chn] = gfc.tot_ener[chn];\n        }\n    }\n\n    function vbrpsy_skip_masking_s(gfc, chn, sblock) {\n        if (sblock == 0) {\n            for (var b = 0; b < gfc.npart_s; b++) {\n                gfc.nb_s2[chn][b] = gfc.nb_s1[chn][b];\n                gfc.nb_s1[chn][b] = 0;\n            }\n        }\n    }\n\n    function vbrpsy_skip_masking_l(gfc, chn) {\n        for (var b = 0; b < gfc.npart_l; b++) {\n            gfc.nb_2[chn][b] = gfc.nb_1[chn][b];\n            gfc.nb_1[chn][b] = 0;\n        }\n    }\n\n    function psyvbr_calc_mask_index_s(gfc, max, avg, mask_idx) {\n        var last_tab_entry = tab.length - 1;\n        var b = 0;\n        var a = avg[b] + avg[b + 1];\n        assert(a >= 0);\n        if (a > 0.0) {\n            var m = max[b];\n            if (m < max[b + 1])\n                m = max[b + 1];\n            assert((gfc.numlines_s[b] + gfc.numlines_s[b + 1] - 1) > 0);\n            a = 20.0 * (m * 2.0 - a)\n                / (a * (gfc.numlines_s[b] + gfc.numlines_s[b + 1] - 1));\n            var k = 0 | a;\n            if (k > last_tab_entry)\n                k = last_tab_entry;\n            mask_idx[b] = k;\n        } else {\n            mask_idx[b] = 0;\n        }\n\n        for (b = 1; b < gfc.npart_s - 1; b++) {\n            a = avg[b - 1] + avg[b] + avg[b + 1];\n            assert(b + 1 < gfc.npart_s);\n            assert(a >= 0);\n            if (a > 0.0) {\n                var m = max[b - 1];\n                if (m < max[b])\n                    m = max[b];\n                if (m < max[b + 1])\n                    m = max[b + 1];\n                assert((gfc.numlines_s[b - 1] + gfc.numlines_s[b] + gfc.numlines_s[b + 1] - 1) > 0);\n                a = 20.0\n                    * (m * 3.0 - a)\n                    / (a * (gfc.numlines_s[b - 1] + gfc.numlines_s[b]\n                    + gfc.numlines_s[b + 1] - 1));\n                var k = 0 | a;\n                if (k > last_tab_entry)\n                    k = last_tab_entry;\n                mask_idx[b] = k;\n            } else {\n                mask_idx[b] = 0;\n            }\n        }\n        assert(b > 0);\n        assert(b == gfc.npart_s - 1);\n\n        a = avg[b - 1] + avg[b];\n        assert(a >= 0);\n        if (a > 0.0) {\n            var m = max[b - 1];\n            if (m < max[b])\n                m = max[b];\n            assert((gfc.numlines_s[b - 1] + gfc.numlines_s[b] - 1) > 0);\n            a = 20.0 * (m * 2.0 - a)\n                / (a * (gfc.numlines_s[b - 1] + gfc.numlines_s[b] - 1));\n            var k = 0 | a;\n            if (k > last_tab_entry)\n                k = last_tab_entry;\n            mask_idx[b] = k;\n        } else {\n            mask_idx[b] = 0;\n        }\n        assert(b == (gfc.npart_s - 1));\n    }\n\n    function vbrpsy_compute_masking_s(gfp, fftenergy_s, eb, thr, chn, sblock) {\n        var gfc = gfp.internal_flags;\n        var max = new float[Encoder.CBANDS], avg = new_float(Encoder.CBANDS);\n        var i, j, b;\n        var mask_idx_s = new int[Encoder.CBANDS];\n\n        for (b = j = 0; b < gfc.npart_s; ++b) {\n            var ebb = 0, m = 0;\n            var n = gfc.numlines_s[b];\n            for (i = 0; i < n; ++i, ++j) {\n                var el = fftenergy_s[sblock][j];\n                ebb += el;\n                if (m < el)\n                    m = el;\n            }\n            eb[b] = ebb;\n            assert(ebb >= 0);\n            max[b] = m;\n            assert(n > 0);\n            avg[b] = ebb / n;\n            assert(avg[b] >= 0);\n        }\n        assert(b == gfc.npart_s);\n        assert(j == 129);\n        for (; b < Encoder.CBANDS; ++b) {\n            max[b] = 0;\n            avg[b] = 0;\n        }\n        psyvbr_calc_mask_index_s(gfc, max, avg, mask_idx_s);\n        for (j = b = 0; b < gfc.npart_s; b++) {\n            var kk = gfc.s3ind_s[b][0];\n            var last = gfc.s3ind_s[b][1];\n            var dd, dd_n;\n            var x, ecb, avg_mask;\n            dd = mask_idx_s[kk];\n            dd_n = 1;\n            ecb = gfc.s3_ss[j] * eb[kk] * tab[mask_idx_s[kk]];\n            ++j;\n            ++kk;\n            while (kk <= last) {\n                dd += mask_idx_s[kk];\n                dd_n += 1;\n                x = gfc.s3_ss[j] * eb[kk] * tab[mask_idx_s[kk]];\n                ecb = vbrpsy_mask_add(ecb, x, kk - b);\n                ++j;\n                ++kk;\n            }\n            dd = (1 + 2 * dd) / (2 * dd_n);\n            avg_mask = tab[dd] * 0.5;\n            ecb *= avg_mask;\n            thr[b] = ecb;\n            gfc.nb_s2[chn][b] = gfc.nb_s1[chn][b];\n            gfc.nb_s1[chn][b] = ecb;\n            {\n                /*\n                 * if THR exceeds EB, the quantization routines will take the\n                 * difference from other bands. in case of strong tonal samples\n                 * (tonaltest.wav) this leads to heavy distortions. that's why\n                 * we limit THR here.\n                 */\n                x = max[b];\n                x *= gfc.minval_s[b];\n                x *= avg_mask;\n                if (thr[b] > x) {\n                    thr[b] = x;\n                }\n            }\n            if (gfc.masking_lower > 1) {\n                thr[b] *= gfc.masking_lower;\n            }\n            if (thr[b] > eb[b]) {\n                thr[b] = eb[b];\n            }\n            if (gfc.masking_lower < 1) {\n                thr[b] *= gfc.masking_lower;\n            }\n\n            assert(thr[b] >= 0);\n        }\n        for (; b < Encoder.CBANDS; ++b) {\n            eb[b] = 0;\n            thr[b] = 0;\n        }\n    }\n\n    function vbrpsy_compute_masking_l(gfc, fftenergy, eb_l, thr, chn) {\n        var max = new_float(Encoder.CBANDS), avg = new_float(Encoder.CBANDS);\n        var mask_idx_l = new_int(Encoder.CBANDS + 2);\n        var b;\n\n        /*********************************************************************\n         * Calculate the energy and the tonality of each partition.\n         *********************************************************************/\n        calc_energy(gfc, fftenergy, eb_l, max, avg);\n        calc_mask_index_l(gfc, max, avg, mask_idx_l);\n\n        /*********************************************************************\n         * convolve the partitioned energy and unpredictability with the\n         * spreading function, s3_l[b][k]\n         ********************************************************************/\n        var k = 0;\n        for (b = 0; b < gfc.npart_l; b++) {\n            var x, ecb, avg_mask, t;\n            /* convolve the partitioned energy with the spreading function */\n            var kk = gfc.s3ind[b][0];\n            var last = gfc.s3ind[b][1];\n            var dd = 0, dd_n = 0;\n            dd = mask_idx_l[kk];\n            dd_n += 1;\n            ecb = gfc.s3_ll[k] * eb_l[kk] * tab[mask_idx_l[kk]];\n            ++k;\n            ++kk;\n            while (kk <= last) {\n                dd += mask_idx_l[kk];\n                dd_n += 1;\n                x = gfc.s3_ll[k] * eb_l[kk] * tab[mask_idx_l[kk]];\n                t = vbrpsy_mask_add(ecb, x, kk - b);\n                ecb = t;\n                ++k;\n                ++kk;\n            }\n            dd = (1 + 2 * dd) / (2 * dd_n);\n            avg_mask = tab[dd] * 0.5;\n            ecb *= avg_mask;\n\n            /**** long block pre-echo control ****/\n            /**\n             * <PRE>\n             * dont use long block pre-echo control if previous granule was\n             * a short block.  This is to avoid the situation:\n             * frame0:  quiet (very low masking)\n             * frame1:  surge  (triggers short blocks)\n             * frame2:  regular frame.  looks like pre-echo when compared to\n             *          frame0, but all pre-echo was in frame1.\n             * </PRE>\n             */\n            /*\n             * chn=0,1 L and R channels chn=2,3 S and M channels.\n             */\n            if (gfc.blocktype_old[chn & 0x01] == Encoder.SHORT_TYPE) {\n                var ecb_limit = rpelev * gfc.nb_1[chn][b];\n                if (ecb_limit > 0) {\n                    thr[b] = Math.min(ecb, ecb_limit);\n                } else {\n                    /**\n                     * <PRE>\n                     * Robert 071209:\n                     * Because we don't calculate long block psy when we know a granule\n                     * should be of short blocks, we don't have any clue how the granule\n                     * before would have looked like as a long block. So we have to guess\n                     * a little bit for this END_TYPE block.\n                     * Most of the time we get away with this sloppyness. (fingers crossed :)\n                     * The speed increase is worth it.\n                     * </PRE>\n                     */\n                    thr[b] = Math.min(ecb, eb_l[b] * NS_PREECHO_ATT2);\n                }\n            } else {\n                var ecb_limit_2 = rpelev2 * gfc.nb_2[chn][b];\n                var ecb_limit_1 = rpelev * gfc.nb_1[chn][b];\n                var ecb_limit;\n                if (ecb_limit_2 <= 0) {\n                    ecb_limit_2 = ecb;\n                }\n                if (ecb_limit_1 <= 0) {\n                    ecb_limit_1 = ecb;\n                }\n                if (gfc.blocktype_old[chn & 0x01] == Encoder.NORM_TYPE) {\n                    ecb_limit = Math.min(ecb_limit_1, ecb_limit_2);\n                } else {\n                    ecb_limit = ecb_limit_1;\n                }\n                thr[b] = Math.min(ecb, ecb_limit);\n            }\n            gfc.nb_2[chn][b] = gfc.nb_1[chn][b];\n            gfc.nb_1[chn][b] = ecb;\n            {\n                /*\n                 * if THR exceeds EB, the quantization routines will take the\n                 * difference from other bands. in case of strong tonal samples\n                 * (tonaltest.wav) this leads to heavy distortions. that's why\n                 * we limit THR here.\n                 */\n                x = max[b];\n                x *= gfc.minval_l[b];\n                x *= avg_mask;\n                if (thr[b] > x) {\n                    thr[b] = x;\n                }\n            }\n            if (gfc.masking_lower > 1) {\n                thr[b] *= gfc.masking_lower;\n            }\n            if (thr[b] > eb_l[b]) {\n                thr[b] = eb_l[b];\n            }\n            if (gfc.masking_lower < 1) {\n                thr[b] *= gfc.masking_lower;\n            }\n            assert(thr[b] >= 0);\n        }\n        for (; b < Encoder.CBANDS; ++b) {\n            eb_l[b] = 0;\n            thr[b] = 0;\n        }\n    }\n\n    function vbrpsy_compute_block_type(gfp, uselongblock) {\n        var gfc = gfp.internal_flags;\n\n        if (gfp.short_blocks == ShortBlock.short_block_coupled\n                /* force both channels to use the same block type */\n                /* this is necessary if the frame is to be encoded in ms_stereo. */\n                /* But even without ms_stereo, FhG does this */\n            && !(uselongblock[0] != 0 && uselongblock[1] != 0))\n            uselongblock[0] = uselongblock[1] = 0;\n\n        for (var chn = 0; chn < gfc.channels_out; chn++) {\n            /* disable short blocks */\n            if (gfp.short_blocks == ShortBlock.short_block_dispensed) {\n                uselongblock[chn] = 1;\n            }\n            if (gfp.short_blocks == ShortBlock.short_block_forced) {\n                uselongblock[chn] = 0;\n            }\n        }\n    }\n\n    function vbrpsy_apply_block_type(gfp, uselongblock, blocktype_d) {\n        var gfc = gfp.internal_flags;\n\n        /*\n         * update the blocktype of the previous granule, since it depends on\n         * what happend in this granule\n         */\n        for (var chn = 0; chn < gfc.channels_out; chn++) {\n            var blocktype = Encoder.NORM_TYPE;\n            /* disable short blocks */\n\n            if (uselongblock[chn] != 0) {\n                /* no attack : use long blocks */\n                assert(gfc.blocktype_old[chn] != Encoder.START_TYPE);\n                if (gfc.blocktype_old[chn] == Encoder.SHORT_TYPE)\n                    blocktype = Encoder.STOP_TYPE;\n            } else {\n                /* attack : use short blocks */\n                blocktype = Encoder.SHORT_TYPE;\n                if (gfc.blocktype_old[chn] == Encoder.NORM_TYPE) {\n                    gfc.blocktype_old[chn] = Encoder.START_TYPE;\n                }\n                if (gfc.blocktype_old[chn] == Encoder.STOP_TYPE)\n                    gfc.blocktype_old[chn] = Encoder.SHORT_TYPE;\n            }\n\n            blocktype_d[chn] = gfc.blocktype_old[chn];\n            // value returned to calling program\n            gfc.blocktype_old[chn] = blocktype;\n            // save for next call to l3psy_anal\n        }\n    }\n\n    /**\n     * compute M/S thresholds from Johnston & Ferreira 1992 ICASSP paper\n     */\n    function vbrpsy_compute_MS_thresholds(eb, thr, cb_mld, ath_cb, athadjust, msfix, n) {\n        var msfix2 = msfix * 2;\n        var athlower = msfix > 0 ? Math.pow(10, athadjust) : 1;\n        var rside, rmid;\n        for (var b = 0; b < n; ++b) {\n            var ebM = eb[2][b];\n            var ebS = eb[3][b];\n            var thmL = thr[0][b];\n            var thmR = thr[1][b];\n            var thmM = thr[2][b];\n            var thmS = thr[3][b];\n\n            /* use this fix if L & R masking differs by 2db or less */\n            if (thmL <= 1.58 * thmR && thmR <= 1.58 * thmL) {\n                var mld_m = cb_mld[b] * ebS;\n                var mld_s = cb_mld[b] * ebM;\n                rmid = Math.max(thmM, Math.min(thmS, mld_m));\n                rside = Math.max(thmS, Math.min(thmM, mld_s));\n            } else {\n                rmid = thmM;\n                rside = thmS;\n            }\n            if (msfix > 0) {\n                /***************************************************************/\n                /* Adjust M/S maskings if user set \"msfix\" */\n                /***************************************************************/\n                /* Naoki Shibata 2000 */\n                var thmLR, thmMS;\n                var ath = ath_cb[b] * athlower;\n                thmLR = Math.min(Math.max(thmL, ath), Math.max(thmR, ath));\n                thmM = Math.max(rmid, ath);\n                thmS = Math.max(rside, ath);\n                thmMS = thmM + thmS;\n                if (thmMS > 0 && (thmLR * msfix2) < thmMS) {\n                    var f = thmLR * msfix2 / thmMS;\n                    thmM *= f;\n                    thmS *= f;\n                    assert(thmMS > 0);\n                }\n                rmid = Math.min(thmM, rmid);\n                rside = Math.min(thmS, rside);\n            }\n            if (rmid > ebM) {\n                rmid = ebM;\n            }\n            if (rside > ebS) {\n                rside = ebS;\n            }\n            thr[2][b] = rmid;\n            thr[3][b] = rside;\n        }\n    }\n\n    this.L3psycho_anal_vbr = function (gfp, buffer, bufPos, gr_out, masking_ratio, masking_MS_ratio, percep_entropy, percep_MS_entropy, energy, blocktype_d) {\n        var gfc = gfp.internal_flags;\n\n        /* fft and energy calculation */\n        var wsamp_l;\n        var wsamp_s;\n        var fftenergy = new_float(Encoder.HBLKSIZE);\n        var fftenergy_s = new_float_n([3, Encoder.HBLKSIZE_s]);\n        var wsamp_L = new_float_n([2, Encoder.BLKSIZE]);\n        var wsamp_S = new_float_n([2, 3, Encoder.BLKSIZE_s]);\n        var eb = new_float_n([4, Encoder.CBANDS]), thr = new_float_n([4, Encoder.CBANDS]);\n        var sub_short_factor = new_float_n([4, 3]);\n        var pcfact = 0.6;\n\n        /* block type */\n        var ns_attacks = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0],\n            [0, 0, 0, 0]];\n        var uselongblock = new_int(2);\n\n        /* usual variables like loop indices, etc.. */\n\n        /* chn=2 and 3 = Mid and Side channels */\n        var n_chn_psy = (gfp.mode == MPEGMode.JOINT_STEREO) ? 4\n            : gfc.channels_out;\n\n        vbrpsy_attack_detection(gfp, buffer, bufPos, gr_out, masking_ratio,\n            masking_MS_ratio, energy, sub_short_factor, ns_attacks,\n            uselongblock);\n\n        vbrpsy_compute_block_type(gfp, uselongblock);\n\n        /* LONG BLOCK CASE */\n        {\n            for (var chn = 0; chn < n_chn_psy; chn++) {\n                var ch01 = chn & 0x01;\n                wsamp_l = wsamp_L;\n                vbrpsy_compute_fft_l(gfp, buffer, bufPos, chn, gr_out,\n                    fftenergy, wsamp_l, ch01);\n\n                vbrpsy_compute_loudness_approximation_l(gfp, gr_out, chn,\n                    fftenergy);\n\n                if (uselongblock[ch01] != 0) {\n                    vbrpsy_compute_masking_l(gfc, fftenergy, eb[chn], thr[chn],\n                        chn);\n                } else {\n                    vbrpsy_skip_masking_l(gfc, chn);\n                }\n            }\n            if ((uselongblock[0] + uselongblock[1]) == 2) {\n                /* M/S channel */\n                if (gfp.mode == MPEGMode.JOINT_STEREO) {\n                    vbrpsy_compute_MS_thresholds(eb, thr, gfc.mld_cb_l,\n                        gfc.ATH.cb_l, gfp.ATHlower * gfc.ATH.adjust,\n                        gfp.msfix, gfc.npart_l);\n                }\n            }\n            /* TODO: apply adaptive ATH masking here ?? */\n            for (var chn = 0; chn < n_chn_psy; chn++) {\n                var ch01 = chn & 0x01;\n                if (uselongblock[ch01] != 0) {\n                    convert_partition2scalefac_l(gfc, eb[chn], thr[chn], chn);\n                }\n            }\n        }\n\n        /* SHORT BLOCKS CASE */\n        {\n            for (var sblock = 0; sblock < 3; sblock++) {\n                for (var chn = 0; chn < n_chn_psy; ++chn) {\n                    var ch01 = chn & 0x01;\n\n                    if (uselongblock[ch01] != 0) {\n                        vbrpsy_skip_masking_s(gfc, chn, sblock);\n                    } else {\n                        /* compute masking thresholds for short blocks */\n                        wsamp_s = wsamp_S;\n                        vbrpsy_compute_fft_s(gfp, buffer, bufPos, chn, sblock,\n                            fftenergy_s, wsamp_s, ch01);\n                        vbrpsy_compute_masking_s(gfp, fftenergy_s, eb[chn],\n                            thr[chn], chn, sblock);\n                    }\n                }\n                if ((uselongblock[0] + uselongblock[1]) == 0) {\n                    /* M/S channel */\n                    if (gfp.mode == MPEGMode.JOINT_STEREO) {\n                        vbrpsy_compute_MS_thresholds(eb, thr, gfc.mld_cb_s,\n                            gfc.ATH.cb_s, gfp.ATHlower * gfc.ATH.adjust,\n                            gfp.msfix, gfc.npart_s);\n                    }\n                    /* L/R channel */\n                }\n                /* TODO: apply adaptive ATH masking here ?? */\n                for (var chn = 0; chn < n_chn_psy; ++chn) {\n                    var ch01 = chn & 0x01;\n                    if (0 == uselongblock[ch01]) {\n                        convert_partition2scalefac_s(gfc, eb[chn], thr[chn],\n                            chn, sblock);\n                    }\n                }\n            }\n\n            /**** short block pre-echo control ****/\n            for (var chn = 0; chn < n_chn_psy; chn++) {\n                var ch01 = chn & 0x01;\n\n                if (uselongblock[ch01] != 0) {\n                    continue;\n                }\n                for (var sb = 0; sb < Encoder.SBMAX_s; sb++) {\n                    var new_thmm = new_float(3);\n                    for (var sblock = 0; sblock < 3; sblock++) {\n                        var thmm = gfc.thm[chn].s[sb][sblock];\n                        thmm *= NS_PREECHO_ATT0;\n\n                        if (ns_attacks[chn][sblock] >= 2\n                            || ns_attacks[chn][sblock + 1] == 1) {\n                            var idx = (sblock != 0) ? sblock - 1 : 2;\n                            var p = NS_INTERP(gfc.thm[chn].s[sb][idx], thmm,\n                                NS_PREECHO_ATT1 * pcfact);\n                            thmm = Math.min(thmm, p);\n                        } else if (ns_attacks[chn][sblock] == 1) {\n                            var idx = (sblock != 0) ? sblock - 1 : 2;\n                            var p = NS_INTERP(gfc.thm[chn].s[sb][idx], thmm,\n                                NS_PREECHO_ATT2 * pcfact);\n                            thmm = Math.min(thmm, p);\n                        } else if ((sblock != 0 && ns_attacks[chn][sblock - 1] == 3)\n                            || (sblock == 0 && gfc.nsPsy.lastAttacks[chn] == 3)) {\n                            var idx = (sblock != 2) ? sblock + 1 : 0;\n                            var p = NS_INTERP(gfc.thm[chn].s[sb][idx], thmm,\n                                NS_PREECHO_ATT2 * pcfact);\n                            thmm = Math.min(thmm, p);\n                        }\n\n                        /* pulse like signal detection for fatboy.wav and so on */\n                        thmm *= sub_short_factor[chn][sblock];\n\n                        new_thmm[sblock] = thmm;\n                    }\n                    for (var sblock = 0; sblock < 3; sblock++) {\n                        gfc.thm[chn].s[sb][sblock] = new_thmm[sblock];\n                    }\n                }\n            }\n        }\n        for (var chn = 0; chn < n_chn_psy; chn++) {\n            gfc.nsPsy.lastAttacks[chn] = ns_attacks[chn][2];\n        }\n\n        /***************************************************************\n         * determine final block type\n         ***************************************************************/\n        vbrpsy_apply_block_type(gfp, uselongblock, blocktype_d);\n\n        /*********************************************************************\n         * compute the value of PE to return ... no delay and advance\n         *********************************************************************/\n        for (var chn = 0; chn < n_chn_psy; chn++) {\n            var ppe;\n            var ppePos;\n            var type;\n            var mr;\n\n            if (chn > 1) {\n                ppe = percep_MS_entropy;\n                ppePos = -2;\n                type = Encoder.NORM_TYPE;\n                if (blocktype_d[0] == Encoder.SHORT_TYPE\n                    || blocktype_d[1] == Encoder.SHORT_TYPE)\n                    type = Encoder.SHORT_TYPE;\n                mr = masking_MS_ratio[gr_out][chn - 2];\n            } else {\n                ppe = percep_entropy;\n                ppePos = 0;\n                type = blocktype_d[chn];\n                mr = masking_ratio[gr_out][chn];\n            }\n\n            if (type == Encoder.SHORT_TYPE) {\n                ppe[ppePos + chn] = pecalc_s(mr, gfc.masking_lower);\n            } else {\n                ppe[ppePos + chn] = pecalc_l(mr, gfc.masking_lower);\n            }\n\n            if (gfp.analysis) {\n                gfc.pinfo.pe[gr_out][chn] = ppe[ppePos + chn];\n            }\n        }\n        return 0;\n    }\n\n    function s3_func_x(bark, hf_slope) {\n        var tempx = bark, tempy;\n\n        if (tempx >= 0) {\n            tempy = -tempx * 27;\n        } else {\n            tempy = tempx * hf_slope;\n        }\n        if (tempy <= -72.0) {\n            return 0;\n        }\n        return Math.exp(tempy * LN_TO_LOG10);\n    }\n\n    function norm_s3_func_x(hf_slope) {\n        var lim_a = 0, lim_b = 0;\n        {\n            var x = 0, l, h;\n            for (x = 0; s3_func_x(x, hf_slope) > 1e-20; x -= 1)\n                ;\n            l = x;\n            h = 0;\n            while (Math.abs(h - l) > 1e-12) {\n                x = (h + l) / 2;\n                if (s3_func_x(x, hf_slope) > 0) {\n                    h = x;\n                } else {\n                    l = x;\n                }\n            }\n            lim_a = l;\n        }\n        {\n            var x = 0, l, h;\n            for (x = 0; s3_func_x(x, hf_slope) > 1e-20; x += 1)\n                ;\n            l = 0;\n            h = x;\n            while (Math.abs(h - l) > 1e-12) {\n                x = (h + l) / 2;\n                if (s3_func_x(x, hf_slope) > 0) {\n                    l = x;\n                } else {\n                    h = x;\n                }\n            }\n            lim_b = h;\n        }\n        {\n            var sum = 0;\n            var m = 1000;\n            var i;\n            for (i = 0; i <= m; ++i) {\n                var x = lim_a + i * (lim_b - lim_a) / m;\n                var y = s3_func_x(x, hf_slope);\n                sum += y;\n            }\n            {\n                var norm = (m + 1) / (sum * (lim_b - lim_a));\n                /* printf( \"norm = %lf\\n\",norm); */\n                return norm;\n            }\n        }\n    }\n\n    /**\n     *   The spreading function.  Values returned in units of energy\n     */\n    function s3_func(bark) {\n        var tempx, x, tempy, temp;\n        tempx = bark;\n        if (tempx >= 0)\n            tempx *= 3;\n        else\n            tempx *= 1.5;\n\n        if (tempx >= 0.5 && tempx <= 2.5) {\n            temp = tempx - 0.5;\n            x = 8.0 * (temp * temp - 2.0 * temp);\n        } else\n            x = 0.0;\n        tempx += 0.474;\n        tempy = 15.811389 + 7.5 * tempx - 17.5\n            * Math.sqrt(1.0 + tempx * tempx);\n\n        if (tempy <= -60.0)\n            return 0.0;\n\n        tempx = Math.exp((x + tempy) * LN_TO_LOG10);\n\n        /**\n         * <PRE>\n         * Normalization.  The spreading function should be normalized so that:\n         * +inf\n         * /\n         * |  s3 [ bark ]  d(bark)   =  1\n         * /\n         * -inf\n         * </PRE>\n         */\n        tempx /= .6609193;\n        return tempx;\n    }\n\n    /**\n     * see for example \"Zwicker: Psychoakustik, 1982; ISBN 3-540-11401-7\n     */\n    function freq2bark(freq) {\n        /* input: freq in hz output: barks */\n        if (freq < 0)\n            freq = 0;\n        freq = freq * 0.001;\n        return 13.0 * Math.atan(.76 * freq) + 3.5\n            * Math.atan(freq * freq / (7.5 * 7.5));\n    }\n\n    function init_numline(numlines, bo, bm, bval, bval_width, mld, bo_w, sfreq, blksize, scalepos, deltafreq, sbmax) {\n        var b_frq = new_float(Encoder.CBANDS + 1);\n        var sample_freq_frac = sfreq / (sbmax > 15 ? 2 * 576 : 2 * 192);\n        var partition = new_int(Encoder.HBLKSIZE);\n        var i;\n        sfreq /= blksize;\n        var j = 0;\n        var ni = 0;\n        /* compute numlines, the number of spectral lines in each partition band */\n        /* each partition band should be about DELBARK wide. */\n        for (i = 0; i < Encoder.CBANDS; i++) {\n            var bark1;\n            var j2;\n            bark1 = freq2bark(sfreq * j);\n\n            b_frq[i] = sfreq * j;\n\n            for (j2 = j; freq2bark(sfreq * j2) - bark1 < DELBARK\n            && j2 <= blksize / 2; j2++)\n                ;\n\n            numlines[i] = j2 - j;\n            ni = i + 1;\n\n            while (j < j2) {\n                assert(j < Encoder.HBLKSIZE);\n                partition[j++] = i;\n            }\n            if (j > blksize / 2) {\n                j = blksize / 2;\n                ++i;\n                break;\n            }\n        }\n        assert(i < Encoder.CBANDS);\n        b_frq[i] = sfreq * j;\n\n        for (var sfb = 0; sfb < sbmax; sfb++) {\n            var i1, i2, start, end;\n            var arg;\n            start = scalepos[sfb];\n            end = scalepos[sfb + 1];\n\n            i1 = 0 | Math.floor(.5 + deltafreq * (start - .5));\n            if (i1 < 0)\n                i1 = 0;\n            i2 = 0 | Math.floor(.5 + deltafreq * (end - .5));\n\n            if (i2 > blksize / 2)\n                i2 = blksize / 2;\n\n            bm[sfb] = (partition[i1] + partition[i2]) / 2;\n            bo[sfb] = partition[i2];\n            var f_tmp = sample_freq_frac * end;\n            /*\n             * calculate how much of this band belongs to current scalefactor\n             * band\n             */\n            bo_w[sfb] = (f_tmp - b_frq[bo[sfb]])\n                / (b_frq[bo[sfb] + 1] - b_frq[bo[sfb]]);\n            if (bo_w[sfb] < 0) {\n                bo_w[sfb] = 0;\n            } else {\n                if (bo_w[sfb] > 1) {\n                    bo_w[sfb] = 1;\n                }\n            }\n            /* setup stereo demasking thresholds */\n            /* formula reverse enginerred from plot in paper */\n            arg = freq2bark(sfreq * scalepos[sfb] * deltafreq);\n            arg = ( Math.min(arg, 15.5) / 15.5);\n\n            mld[sfb] = Math.pow(10.0,\n                1.25 * (1 - Math.cos(Math.PI * arg)) - 2.5);\n        }\n\n        /* compute bark values of each critical band */\n        j = 0;\n        for (var k = 0; k < ni; k++) {\n            var w = numlines[k];\n            var bark1, bark2;\n\n            bark1 = freq2bark(sfreq * (j));\n            bark2 = freq2bark(sfreq * (j + w - 1));\n            bval[k] = .5 * (bark1 + bark2);\n\n            bark1 = freq2bark(sfreq * (j - .5));\n            bark2 = freq2bark(sfreq * (j + w - .5));\n            bval_width[k] = bark2 - bark1;\n            j += w;\n        }\n\n        return ni;\n    }\n\n    function init_s3_values(s3ind, npart, bval, bval_width, norm, use_old_s3) {\n        var s3 = new_float_n([Encoder.CBANDS, Encoder.CBANDS]);\n        /*\n         * The s3 array is not linear in the bark scale.\n         *\n         * bval[x] should be used to get the bark value.\n         */\n        var j;\n        var numberOfNoneZero = 0;\n\n        /**\n         * <PRE>\n         * s[i][j], the value of the spreading function,\n         * centered at band j (masker), for band i (maskee)\n         *\n         * i.e.: sum over j to spread into signal barkval=i\n         * NOTE: i and j are used opposite as in the ISO docs\n         * </PRE>\n         */\n        if (use_old_s3) {\n            for (var i = 0; i < npart; i++) {\n                for (j = 0; j < npart; j++) {\n                    var v = s3_func(bval[i] - bval[j]) * bval_width[j];\n                    s3[i][j] = v * norm[i];\n                }\n            }\n        } else {\n            for (j = 0; j < npart; j++) {\n                var hf_slope = 15 + Math.min(21 / bval[j], 12);\n                var s3_x_norm = norm_s3_func_x(hf_slope);\n                for (var i = 0; i < npart; i++) {\n                    var v = s3_x_norm\n                        * s3_func_x(bval[i] - bval[j], hf_slope)\n                        * bval_width[j];\n                    s3[i][j] = v * norm[i];\n                }\n            }\n        }\n        for (var i = 0; i < npart; i++) {\n            for (j = 0; j < npart; j++) {\n                if (s3[i][j] > 0.0)\n                    break;\n            }\n            s3ind[i][0] = j;\n\n            for (j = npart - 1; j > 0; j--) {\n                if (s3[i][j] > 0.0)\n                    break;\n            }\n            s3ind[i][1] = j;\n            numberOfNoneZero += (s3ind[i][1] - s3ind[i][0] + 1);\n        }\n\n        var p = new_float(numberOfNoneZero);\n        var k = 0;\n        for (var i = 0; i < npart; i++)\n            for (j = s3ind[i][0]; j <= s3ind[i][1]; j++)\n                p[k++] = s3[i][j];\n\n        return p;\n    }\n\n    function stereo_demask(f) {\n        /* setup stereo demasking thresholds */\n        /* formula reverse enginerred from plot in paper */\n        var arg = freq2bark(f);\n        arg = (Math.min(arg, 15.5) / 15.5);\n\n        return Math.pow(10.0,\n            1.25 * (1 - Math.cos(Math.PI * arg)) - 2.5);\n    }\n\n    /**\n     * NOTE: the bitrate reduction from the inter-channel masking effect is low\n     * compared to the chance of getting annyoing artefacts. L3psycho_anal_vbr\n     * does not use this feature. (Robert 071216)\n     */\n    this.psymodel_init = function (gfp) {\n        var gfc = gfp.internal_flags;\n        var i;\n        var useOldS3 = true;\n        var bvl_a = 13, bvl_b = 24;\n        var snr_l_a = 0, snr_l_b = 0;\n        var snr_s_a = -8.25, snr_s_b = -4.5;\n        var bval = new_float(Encoder.CBANDS);\n        var bval_width = new_float(Encoder.CBANDS);\n        var norm = new_float(Encoder.CBANDS);\n        var sfreq = gfp.out_samplerate;\n\n        switch (gfp.experimentalZ) {\n            default:\n            case 0:\n                useOldS3 = true;\n                break;\n            case 1:\n                useOldS3 = (gfp.VBR == VbrMode.vbr_mtrh || gfp.VBR == VbrMode.vbr_mt) ? false\n                    : true;\n                break;\n            case 2:\n                useOldS3 = false;\n                break;\n            case 3:\n                bvl_a = 8;\n                snr_l_a = -1.75;\n                snr_l_b = -0.0125;\n                snr_s_a = -8.25;\n                snr_s_b = -2.25;\n                break;\n        }\n        gfc.ms_ener_ratio_old = .25;\n        gfc.blocktype_old[0] = gfc.blocktype_old[1] = Encoder.NORM_TYPE;\n        // the vbr header is long blocks\n\n        for (i = 0; i < 4; ++i) {\n            for (var j = 0; j < Encoder.CBANDS; ++j) {\n                gfc.nb_1[i][j] = 1e20;\n                gfc.nb_2[i][j] = 1e20;\n                gfc.nb_s1[i][j] = gfc.nb_s2[i][j] = 1.0;\n            }\n            for (var sb = 0; sb < Encoder.SBMAX_l; sb++) {\n                gfc.en[i].l[sb] = 1e20;\n                gfc.thm[i].l[sb] = 1e20;\n            }\n            for (var j = 0; j < 3; ++j) {\n                for (var sb = 0; sb < Encoder.SBMAX_s; sb++) {\n                    gfc.en[i].s[sb][j] = 1e20;\n                    gfc.thm[i].s[sb][j] = 1e20;\n                }\n                gfc.nsPsy.lastAttacks[i] = 0;\n            }\n            for (var j = 0; j < 9; j++)\n                gfc.nsPsy.last_en_subshort[i][j] = 10.;\n        }\n\n        /* init. for loudness approx. -jd 2001 mar 27 */\n        gfc.loudness_sq_save[0] = gfc.loudness_sq_save[1] = 0.0;\n\n        /*************************************************************************\n         * now compute the psychoacoustic model specific constants\n         ************************************************************************/\n        /* compute numlines, bo, bm, bval, bval_width, mld */\n\n        gfc.npart_l = init_numline(gfc.numlines_l, gfc.bo_l, gfc.bm_l, bval,\n            bval_width, gfc.mld_l, gfc.PSY.bo_l_weight, sfreq,\n            Encoder.BLKSIZE, gfc.scalefac_band.l, Encoder.BLKSIZE\n            / (2.0 * 576), Encoder.SBMAX_l);\n        assert(gfc.npart_l < Encoder.CBANDS);\n        /* compute the spreading function */\n        for (i = 0; i < gfc.npart_l; i++) {\n            var snr = snr_l_a;\n            if (bval[i] >= bvl_a) {\n                snr = snr_l_b * (bval[i] - bvl_a) / (bvl_b - bvl_a) + snr_l_a\n                    * (bvl_b - bval[i]) / (bvl_b - bvl_a);\n            }\n            norm[i] = Math.pow(10.0, snr / 10.0);\n            if (gfc.numlines_l[i] > 0) {\n                gfc.rnumlines_l[i] = 1.0 / gfc.numlines_l[i];\n            } else {\n                gfc.rnumlines_l[i] = 0;\n            }\n        }\n        gfc.s3_ll = init_s3_values(gfc.s3ind, gfc.npart_l, bval, bval_width,\n            norm, useOldS3);\n\n        /* compute long block specific values, ATH and MINVAL */\n        var j = 0;\n        for (i = 0; i < gfc.npart_l; i++) {\n            var x;\n\n            /* ATH */\n            x = Float.MAX_VALUE;\n            for (var k = 0; k < gfc.numlines_l[i]; k++, j++) {\n                var freq = sfreq * j / (1000.0 * Encoder.BLKSIZE);\n                var level;\n                /*\n                 * ATH below 100 Hz constant, not further climbing\n                 */\n                level = this.ATHformula(freq * 1000, gfp) - 20;\n                // scale to FFT units; returned value is in dB\n                level = Math.pow(10., 0.1 * level);\n                // convert from dB . energy\n                level *= gfc.numlines_l[i];\n                if (x > level)\n                    x = level;\n            }\n            gfc.ATH.cb_l[i] = x;\n\n            /*\n             * MINVAL. For low freq, the strength of the masking is limited by\n             * minval this is an ISO MPEG1 thing, dont know if it is really\n             * needed\n             */\n            /*\n             * FIXME: it does work to reduce low-freq problems in S53-Wind-Sax\n             * and lead-voice samples, but introduces some 3 kbps bit bloat too.\n             * TODO: Further refinement of the shape of this hack.\n             */\n            x = -20 + bval[i] * 20 / 10;\n            if (x > 6) {\n                x = 100;\n            }\n            if (x < -15) {\n                x = -15;\n            }\n            x -= 8.;\n            gfc.minval_l[i] = (Math.pow(10.0, x / 10.) * gfc.numlines_l[i]);\n        }\n\n        /************************************************************************\n         * do the same things for short blocks\n         ************************************************************************/\n        gfc.npart_s = init_numline(gfc.numlines_s, gfc.bo_s, gfc.bm_s, bval,\n            bval_width, gfc.mld_s, gfc.PSY.bo_s_weight, sfreq,\n            Encoder.BLKSIZE_s, gfc.scalefac_band.s, Encoder.BLKSIZE_s\n            / (2.0 * 192), Encoder.SBMAX_s);\n        assert(gfc.npart_s < Encoder.CBANDS);\n\n        /* SNR formula. short block is normalized by SNR. is it still right ? */\n        j = 0;\n        for (i = 0; i < gfc.npart_s; i++) {\n            var x;\n            var snr = snr_s_a;\n            if (bval[i] >= bvl_a) {\n                snr = snr_s_b * (bval[i] - bvl_a) / (bvl_b - bvl_a) + snr_s_a\n                    * (bvl_b - bval[i]) / (bvl_b - bvl_a);\n            }\n            norm[i] = Math.pow(10.0, snr / 10.0);\n\n            /* ATH */\n            x = Float.MAX_VALUE;\n            for (var k = 0; k < gfc.numlines_s[i]; k++, j++) {\n                var freq = sfreq * j / (1000.0 * Encoder.BLKSIZE_s);\n                var level;\n                /* freq = Min(.1,freq); */\n                /*\n                 * ATH below 100 Hz constant, not\n                 * further climbing\n                 */\n                level = this.ATHformula(freq * 1000, gfp) - 20;\n                // scale to FFT units; returned value is in dB\n                level = Math.pow(10., 0.1 * level);\n                // convert from dB . energy\n                level *= gfc.numlines_s[i];\n                if (x > level)\n                    x = level;\n            }\n            gfc.ATH.cb_s[i] = x;\n\n            /*\n             * MINVAL. For low freq, the strength of the masking is limited by\n             * minval this is an ISO MPEG1 thing, dont know if it is really\n             * needed\n             */\n            x = (-7.0 + bval[i] * 7.0 / 12.0);\n            if (bval[i] > 12) {\n                x *= 1 + Math.log(1 + x) * 3.1;\n            }\n            if (bval[i] < 12) {\n                x *= 1 + Math.log(1 - x) * 2.3;\n            }\n            if (x < -15) {\n                x = -15;\n            }\n            x -= 8;\n            gfc.minval_s[i] = Math.pow(10.0, x / 10)\n                * gfc.numlines_s[i];\n        }\n\n        gfc.s3_ss = init_s3_values(gfc.s3ind_s, gfc.npart_s, bval, bval_width,\n            norm, useOldS3);\n\n        init_mask_add_max_values();\n        fft.init_fft(gfc);\n\n        /* setup temporal masking */\n        gfc.decay = Math.exp(-1.0 * LOG10\n            / (temporalmask_sustain_sec * sfreq / 192.0));\n\n        {\n            var msfix;\n            msfix = NS_MSFIX;\n            if ((gfp.exp_nspsytune & 2) != 0)\n                msfix = 1.0;\n            if (Math.abs(gfp.msfix) > 0.0)\n                msfix = gfp.msfix;\n            gfp.msfix = msfix;\n\n            /*\n             * spread only from npart_l bands. Normally, we use the spreading\n             * function to convolve from npart_l down to npart_l bands\n             */\n            for (var b = 0; b < gfc.npart_l; b++)\n                if (gfc.s3ind[b][1] > gfc.npart_l - 1)\n                    gfc.s3ind[b][1] = gfc.npart_l - 1;\n        }\n\n        /*\n         * prepare for ATH auto adjustment: we want to decrease the ATH by 12 dB\n         * per second\n         */\n        var frame_duration = (576. * gfc.mode_gr / sfreq);\n        gfc.ATH.decay = Math.pow(10., -12. / 10. * frame_duration);\n        gfc.ATH.adjust = 0.01;\n        /* minimum, for leading low loudness */\n        gfc.ATH.adjustLimit = 1.0;\n        /* on lead, allow adjust up to maximum */\n\n        assert(gfc.bo_l[Encoder.SBMAX_l - 1] <= gfc.npart_l);\n        assert(gfc.bo_s[Encoder.SBMAX_s - 1] <= gfc.npart_s);\n\n        if (gfp.ATHtype != -1) {\n            /* compute equal loudness weights (eql_w) */\n            var freq;\n            var freq_inc = gfp.out_samplerate\n                / (Encoder.BLKSIZE);\n            var eql_balance = 0.0;\n            freq = 0.0;\n            for (i = 0; i < Encoder.BLKSIZE / 2; ++i) {\n                /* convert ATH dB to relative power (not dB) */\n                /* to determine eql_w */\n                freq += freq_inc;\n                gfc.ATH.eql_w[i] = 1. / Math.pow(10, this.ATHformula(freq, gfp) / 10);\n                eql_balance += gfc.ATH.eql_w[i];\n            }\n            eql_balance = 1.0 / eql_balance;\n            for (i = Encoder.BLKSIZE / 2; --i >= 0;) { /* scale weights */\n                gfc.ATH.eql_w[i] *= eql_balance;\n            }\n        }\n        {\n            for (var b = j = 0; b < gfc.npart_s; ++b) {\n                for (i = 0; i < gfc.numlines_s[b]; ++i) {\n                    ++j;\n                }\n            }\n            assert(j == 129);\n            for (var b = j = 0; b < gfc.npart_l; ++b) {\n                for (i = 0; i < gfc.numlines_l[b]; ++i) {\n                    ++j;\n                }\n            }\n            assert(j == 513);\n        }\n        j = 0;\n        for (i = 0; i < gfc.npart_l; i++) {\n            var freq = sfreq * (j + gfc.numlines_l[i] / 2) / (1.0 * Encoder.BLKSIZE);\n            gfc.mld_cb_l[i] = stereo_demask(freq);\n            j += gfc.numlines_l[i];\n        }\n        for (; i < Encoder.CBANDS; ++i) {\n            gfc.mld_cb_l[i] = 1;\n        }\n        j = 0;\n        for (i = 0; i < gfc.npart_s; i++) {\n            var freq = sfreq * (j + gfc.numlines_s[i] / 2) / (1.0 * Encoder.BLKSIZE_s);\n            gfc.mld_cb_s[i] = stereo_demask(freq);\n            j += gfc.numlines_s[i];\n        }\n        for (; i < Encoder.CBANDS; ++i) {\n            gfc.mld_cb_s[i] = 1;\n        }\n        return 0;\n    }\n\n    /**\n     * Those ATH formulas are returning their minimum value for input = -1\n     */\n    function ATHformula_GB(f, value) {\n        /**\n         * <PRE>\n         *  from Painter & Spanias\n         *           modified by Gabriel Bouvigne to better fit the reality\n         *           ath =    3.640 * pow(f,-0.8)\n         *           - 6.800 * exp(-0.6*pow(f-3.4,2.0))\n         *           + 6.000 * exp(-0.15*pow(f-8.7,2.0))\n         *           + 0.6* 0.001 * pow(f,4.0);\n         *\n         *\n         *           In the past LAME was using the Painter &Spanias formula.\n         *           But we had some recurrent problems with HF content.\n         *           We measured real ATH values, and found the older formula\n         *           to be inaccurate in the higher part. So we made this new\n         *           formula and this solved most of HF problematic test cases.\n         *           The tradeoff is that in VBR mode it increases a lot the\n         *           bitrate.\n         * </PRE>\n         */\n\n        /*\n         * This curve can be adjusted according to the VBR scale: it adjusts\n         * from something close to Painter & Spanias on V9 up to Bouvigne's\n         * formula for V0. This way the VBR bitrate is more balanced according\n         * to the -V value.\n         */\n\n        // the following Hack allows to ask for the lowest value\n        if (f < -.3)\n            f = 3410;\n\n        // convert to khz\n        f /= 1000;\n        f = Math.max(0.1, f);\n        var ath = 3.640 * Math.pow(f, -0.8) - 6.800\n            * Math.exp(-0.6 * Math.pow(f - 3.4, 2.0)) + 6.000\n            * Math.exp(-0.15 * Math.pow(f - 8.7, 2.0))\n            + (0.6 + 0.04 * value) * 0.001 * Math.pow(f, 4.0);\n        return ath;\n    }\n\n    this.ATHformula = function (f, gfp) {\n        var ath;\n        switch (gfp.ATHtype) {\n            case 0:\n                ath = ATHformula_GB(f, 9);\n                break;\n            case 1:\n                // over sensitive, should probably be removed\n                ath = ATHformula_GB(f, -1);\n                break;\n            case 2:\n                ath = ATHformula_GB(f, 0);\n                break;\n            case 3:\n                // modification of GB formula by Roel\n                ath = ATHformula_GB(f, 1) + 6;\n                break;\n            case 4:\n                ath = ATHformula_GB(f, gfp.ATHcurve);\n                break;\n            default:\n                ath = ATHformula_GB(f, 0);\n                break;\n        }\n        return ath;\n    }\n\n}\n\nmodule.exports = PsyModel;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL1BzeU1vZGVsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLCtFQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxtQkFBTyxDQUFDLHlFQUFVO0FBQzVCLGNBQWMsbUJBQU8sQ0FBQyxpRkFBYzs7QUFFcEM7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyxtRkFBZTtBQUMxQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDLG9EQUFvRCxRQUFRO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQSxvREFBb0QsUUFBUTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNCQUFzQjtBQUNuRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNCQUFzQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNCQUFzQjtBQUNuRCxxQ0FBcUMsWUFBWTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNCQUFzQjtBQUMvQztBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLHNCQUFzQjtBQUMvQyxpQ0FBaUMsWUFBWTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLHNCQUFzQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsc0JBQXNCO0FBQy9DLGlDQUFpQyxZQUFZO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNCQUFzQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0JBQXNCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0JBQXdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLDBCQUEwQjtBQUNuRCxpQ0FBaUMsWUFBWTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLDBCQUEwQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUEsb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsOEJBQThCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixZQUFZO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNCQUFzQjtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0JBQXNCO0FBQ25EOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsOEJBQThCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQix3QkFBd0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0JBQXdCO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLGlCQUFpQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaUJBQWlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLFlBQVk7QUFDN0Msa0NBQWtDLGlCQUFpQjtBQUNuRDs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsaUJBQWlCO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxzQkFBc0I7QUFDdkQ7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDLFlBQVk7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUJBQWlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQ0FBZ0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0NBQWdDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx5QkFBeUI7QUFDekIsa0NBQWtDO0FBQ2xDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixhQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkMsa0NBQWtDLGtCQUFrQjtBQUNwRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLE9BQU87QUFDM0IsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixzQkFBc0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkMsaUNBQWlDLHNCQUFzQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVMsSUFBSTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpQkFBaUI7QUFDakQsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpQkFBaUI7QUFDakQsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbGFtZWpzL3NyYy9qcy9Qc3lNb2RlbC5qcz80Mjg0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiAgICAgIHBzeW1vZGVsLmNcbiAqXG4gKiAgICAgIENvcHlyaWdodCAoYykgMTk5OS0yMDAwIE1hcmsgVGF5bG9yXG4gKiAgICAgIENvcHlyaWdodCAoYykgMjAwMS0yMDAyIE5hb2tpIFNoaWJhdGFcbiAqICAgICAgQ29weXJpZ2h0IChjKSAyMDAwLTIwMDMgVGFrZWhpcm8gVG9taW5hZ2FcbiAqICAgICAgQ29weXJpZ2h0IChjKSAyMDAwLTIwMDggUm9iZXJ0IEhlZ2VtYW5uXG4gKiAgICAgIENvcHlyaWdodCAoYykgMjAwMC0yMDA1IEdhYnJpZWwgQm91dmlnbmVcbiAqICAgICAgQ29weXJpZ2h0IChjKSAyMDAwLTIwMDUgQWxleGFuZGVyIExlaWRpbmdlclxuICpcbiAqIFRoaXMgbGlicmFyeSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAqIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcbiAqIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb247IGVpdGhlclxuICogdmVyc2lvbiAyIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuICpcbiAqIFRoaXMgbGlicmFyeSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGUgR05VXG4gKiBMaWJyYXJ5IEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG4gKiBMaWNlbnNlIGFsb25nIHdpdGggdGhpcyBsaWJyYXJ5OyBpZiBub3QsIHdyaXRlIHRvIHRoZVxuICogRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsXG4gKiBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cbiAqL1xuXG4vKiAkSWQ6IFBzeU1vZGVsLmphdmEsdiAxLjI3IDIwMTEvMDUvMjQgMjA6NDg6MDYga2VuY2hpcyBFeHAgJCAqL1xuXG5cbi8qXG4gUFNZQ0hPIEFDT1VTVElDU1xuXG5cbiBUaGlzIHJvdXRpbmUgY29tcHV0ZXMgdGhlIHBzeWNobyBhY291c3RpY3MsIGRlbGF5ZWQgYnkgb25lIGdyYW51bGUuXG5cbiBJbnB1dDogYnVmZmVyIG9mIFBDTSBkYXRhICgxMDI0IHNhbXBsZXMpLlxuXG4gVGhpcyB3aW5kb3cgc2hvdWxkIGJlIGNlbnRlcmVkIG92ZXIgdGhlIDU3NiBzYW1wbGUgZ3JhbnVsZSB3aW5kb3cuXG4gVGhlIHJvdXRpbmUgd2lsbCBjb21wdXRlIHRoZSBwc3ljaG8gYWNvdXN0aWNzIGZvclxuIHRoaXMgZ3JhbnVsZSwgYnV0IHJldHVybiB0aGUgcHN5Y2hvIGFjb3VzdGljcyBjb21wdXRlZFxuIGZvciB0aGUgKnByZXZpb3VzKiBncmFudWxlLiAgVGhpcyBpcyBiZWNhdXNlIHRoZSBibG9ja1xuIHR5cGUgb2YgdGhlIHByZXZpb3VzIGdyYW51bGUgY2FuIG9ubHkgYmUgZGV0ZXJtaW5lZFxuIGFmdGVyIHdlIGhhdmUgY29tcHV0ZWQgdGhlIHBzeWNobyBhY291c3RpY3MgZm9yIHRoZSBmb2xsb3dpbmdcbiBncmFudWxlLlxuXG4gT3V0cHV0OiAgbWFza2luZ3MgYW5kIGVuZXJnaWVzIGZvciBlYWNoIHNjYWxlZmFjdG9yIGJhbmQuXG4gYmxvY2sgdHlwZSwgUEUsIGFuZCBzb21lIGNvcnJlbGF0aW9uIG1lYXN1cmVzLlxuIFRoZSBQRSBpcyB1c2VkIGJ5IENCUiBtb2RlcyB0byBkZXRlcm1pbmUgaWYgZXh0cmEgYml0c1xuIGZyb20gdGhlIGJpdCByZXNlcnZvaXIgc2hvdWxkIGJlIHVzZWQuICBUaGUgY29ycmVsYXRpb25cbiBtZWFzdXJlcyBhcmUgdXNlZCB0byBkZXRlcm1pbmUgbWlkL3NpZGUgb3IgcmVndWxhciBzdGVyZW8uXG4gKi9cbi8qXG4gTm90YXRpb246XG5cbiBiYXJrczogIGEgbm9uLWxpbmVhciBmcmVxdWVuY3kgc2NhbGUuICBNYXBwaW5nIGZyb20gZnJlcXVlbmN5IHRvXG4gYmFya3MgaXMgZ2l2ZW4gYnkgZnJlcTJiYXJrKClcblxuIHNjYWxlZmFjdG9yIGJhbmRzOiBUaGUgc3BlY3RydW0gKGZyZXF1ZW5jaWVzKSBhcmUgYnJva2VuIGludG9cbiBTQk1BWCBcInNjYWxlZmFjdG9yIGJhbmRzXCIuICBUaGVzIGJhbmRzXG4gYXJlIGRldGVybWluZWQgYnkgdGhlIE1QRUcgSVNPIHNwZWMuICBJblxuIHRoZSBub2lzZSBzaGFwaW5nL3F1YW50aXphdGlvbiBjb2RlLCB3ZSBhbGxvY2F0ZVxuIGJpdHMgYW1vbmcgdGhlIHBhcnRpdGlvbiBiYW5kcyB0byBhY2hpZXZlIHRoZVxuIGJlc3QgcG9zc2libGUgcXVhbGl0eVxuXG4gcGFydGl0aW9uIGJhbmRzOiAgIFRoZSBzcGVjdHJ1bSBpcyBhbHNvIGJyb2tlbiBpbnRvIGFib3V0XG4gNjQgXCJwYXJ0aXRpb24gYmFuZHNcIi4gIEVhY2ggcGFydGl0aW9uXG4gYmFuZCBpcyBhYm91dCAuMzQgYmFya3Mgd2lkZS4gIFRoZXJlIGFyZSBhYm91dCAyLTVcbiBwYXJ0aXRpb24gYmFuZHMgZm9yIGVhY2ggc2NhbGVmYWN0b3IgYmFuZC5cblxuIExBTUUgY29tcHV0ZXMgYWxsIHBzeWNobyBhY291c3RpYyBpbmZvcm1hdGlvbiBmb3IgZWFjaCBwYXJ0aXRpb25cbiBiYW5kLiAgVGhlbiBhdCB0aGUgZW5kIG9mIHRoZSBjb21wdXRhdGlvbnMsIHRoaXMgaW5mb3JtYXRpb25cbiBpcyBtYXBwZWQgdG8gc2NhbGVmYWN0b3IgYmFuZHMuICBUaGUgZW5lcmd5IGluIGVhY2ggc2NhbGVmYWN0b3JcbiBiYW5kIGlzIHRha2VuIGFzIHRoZSBzdW0gb2YgdGhlIGVuZXJneSBpbiBhbGwgcGFydGl0aW9uIGJhbmRzXG4gd2hpY2ggb3ZlcmxhcCB0aGUgc2NhbGVmYWN0b3IgYmFuZC4gIFRoZSBtYXNraW5ncyBjYW4gYmUgY29tcHV0ZWRcbiBpbiB0aGUgc2FtZSB3YXkgKGFuZCB0aHVzIHJlcHJlc2VudCB0aGUgYXZlcmFnZSBtYXNraW5nIGluIHRoYXQgYmFuZClcbiBvciBieSB0YWtpbmcgdGhlIG1pbm11bSB2YWx1ZSBtdWx0aXBsaWVkIGJ5IHRoZSBudW1iZXIgb2ZcbiBwYXJ0aXRpb24gYmFuZHMgdXNlZCAod2hpY2ggcmVwcmVzZW50cyBhIG1pbmltdW0gbWFza2luZyBpbiB0aGF0IGJhbmQpLlxuICovXG4vKlxuIFRoZSBnZW5lcmFsIG91dGxpbmUgaXMgYXMgZm9sbG93czpcblxuIDEuIGNvbXB1dGUgdGhlIGVuZXJneSBpbiBlYWNoIHBhcnRpdGlvbiBiYW5kXG4gMi4gY29tcHV0ZSB0aGUgdG9uYWxpdHkgaW4gZWFjaCBwYXJ0aXRpb24gYmFuZFxuIDMuIGNvbXB1dGUgdGhlIHN0cmVuZ3RoIG9mIGVhY2ggcGFydGlvbiBiYW5kIFwibWFza2VyXCJcbiA0LiBjb21wdXRlIHRoZSBtYXNraW5nICh2aWEgdGhlIHNwcmVhZGluZyBmdW5jdGlvbiBhcHBsaWVkIHRvIGVhY2ggbWFza2VyKVxuIDUuIE1vZGlmaWNhdGlvbnMgZm9yIG1pZC9zaWRlIG1hc2tpbmcuXG5cbiBFYWNoIHBhcnRpdGlvbiBiYW5kIGlzIGNvbnNpZGllcmVkIGEgXCJtYXNrZXJcIi4gIFRoZSBzdHJlbmd0aFxuIG9mIHRoZSBpJ3RoIG1hc2tlciBpbiBiYW5kIGogaXMgZ2l2ZW4gYnk6XG5cbiBzMyhiYXJrKGkpLWJhcmsoaikpKnN0cmVuZ3RoKGkpXG5cbiBUaGUgc3RyZW5ndGggb2YgdGhlIG1hc2tlciBpcyBhIGZ1bmN0aW9uIG9mIHRoZSBlbmVyZ3kgYW5kIHRvbmFsaXR5LlxuIFRoZSBtb3JlIHRvbmFsLCB0aGUgbGVzcyBtYXNraW5nLiAgTEFNRSB1c2VzIGEgc2ltcGxlIGxpbmVhciBmb3JtdWxhXG4gKGNvbnRyb2xsZWQgYnkgTk1UIGFuZCBUTU4pIHdoaWNoIHNheXMgdGhlIHN0cmVuZ3RoIGlzIGdpdmVuIGJ5IHRoZVxuIGVuZXJneSBkaXZpZGVkIGJ5IGEgbGluZWFyIGZ1bmN0aW9uIG9mIHRoZSB0b25hbGl0eS5cbiAqL1xuLypcbiBzMygpIGlzIHRoZSBcInNwcmVhZGluZyBmdW5jdGlvblwiLiAgSXQgaXMgZ2l2ZW4gYnkgYSBmb3JtdWxhXG4gZGV0ZXJtaW5lZCB2aWEgbGlzdGVuaW5nIHRlc3RzLlxuXG4gVGhlIHRvdGFsIG1hc2tpbmcgaW4gdGhlIGondGggcGFydGl0aW9uIGJhbmQgaXMgdGhlIHN1bSBvdmVyXG4gYWxsIG1hc2tpbmdzIGkuICBJdCBpcyB0aHVzIGdpdmVuIGJ5IHRoZSBjb252b2x1dGlvbiBvZlxuIHRoZSBzdHJlbmd0aCB3aXRoIHMzKCksIHRoZSBcInNwcmVhZGluZyBmdW5jdGlvbi5cIlxuXG4gbWFza2luZyhqKSA9IHN1bV9vdmVyX2kgIHMzKGktaikqc3RyZW5ndGgoaSkgID0gczMgbyBzdHJlbmd0aFxuXG4gd2hlcmUgXCJvXCIgPSBjb252b2x1dGlvbiBvcGVyYXRvci4gIHMzIGlzIGdpdmVuIGJ5IGEgZm9ybXVsYSBkZXRlcm1pbmVkXG4gdmlhIGxpc3RlbmluZyB0ZXN0cy4gIEl0IGlzIG5vcm1hbGl6ZWQgc28gdGhhdCBzMyBvIDEgPSAxLlxuXG4gTm90ZTogaW5zdGVhZCBvZiBhIHNpbXBsZSBjb252b2x1dGlvbiwgTEFNRSBhbHNvIGhhcyB0aGVcbiBvcHRpb24gb2YgdXNpbmcgXCJhZGRpdGl2ZSBtYXNraW5nXCJcblxuIFRoZSBtb3N0IGNyaXRpY2FsIHBhcnQgaXMgc3RlcCAyLCBjb21wdXRpbmcgdGhlIHRvbmFsaXR5IG9mIGVhY2hcbiBwYXJ0aXRpb24gYmFuZC4gIExBTUUgaGFzIHR3byB0b25hbGl0eSBlc3RpbWF0b3JzLiAgVGhlIGZpcnN0XG4gaXMgYmFzZWQgb24gdGhlIElTTyBzcGVjLCBhbmQgbWVhc3VyZXMgaG93IHByZWRpY3RpYWJsZSB0aGVcbiBzaWduYWwgaXMgb3ZlciB0aW1lLiAgVGhlIG1vcmUgcHJlZGljdGFibGUsIHRoZSBtb3JlIHRvbmFsLlxuIFRoZSBzZWNvbmQgbWVhc3VyZSBpcyBiYXNlZCBvbiBsb29raW5nIGF0IHRoZSBzcGVjdHJ1bSBvZlxuIGEgc2luZ2xlIGdyYW51bGUuICBUaGUgbW9yZSBwZWFreSB0aGUgc3BlY3RydW0sIHRoZSBtb3JlXG4gdG9uYWwuICBCeSBtb3N0IGluZGljYXRpb25zLCB0aGUgbGF0dGVyIGFwcHJvYWNoIGlzIGJldHRlci5cblxuIEZpbmFsbHksIGluIHN0ZXAgNSwgdGhlIG1hc2tpbmdzIGZvciB0aGUgbWlkIGFuZCBzaWRlXG4gY2hhbm5lbCBhcmUgcG9zc2libHkgaW5jcmVhc2VkLiAgVW5kZXIgY2VydGFpbiBjaXJjdW1zdGFuY2VzLFxuIG5vaXNlIGluIHRoZSBtaWQgJiBzaWRlIGNoYW5uZWxzIGlzIGFzc3VtZWQgdG8gYWxzb1xuIGJlIG1hc2tlZCBieSBzdHJvbmcgbWFza2VycyBpbiB0aGUgTCBvciBSIGNoYW5uZWxzLlxuXG5cbiBPdGhlciBkYXRhIGNvbXB1dGVkIGJ5IHRoZSBwc3ktbW9kZWw6XG5cbiBtc19yYXRpbyAgICAgICAgc2lkZS1jaGFubmVsIC8gbWlkLWNoYW5uZWwgbWFza2luZyByYXRpbyAoZm9yIHByZXZpb3VzIGdyYW51bGUpXG4gbXNfcmF0aW9fbmV4dCAgIHNpZGUtY2hhbm5lbCAvIG1pZC1jaGFubmVsIG1hc2tpbmcgcmF0aW8gZm9yIHRoaXMgZ3JhbnVsZVxuXG4gcGVyY2VwX2VudHJvcHlbMl0gICAgIEwgYW5kIFIgdmFsdWVzIChwcmV2IGdyYW51bGUpIG9mIFBFIC0gQSBtZWFzdXJlIG9mIGhvd1xuIG11Y2ggcHJlLWVjaG8gaXMgaW4gdGhlIHByZXZpb3VzIGdyYW51bGVcbiBwZXJjZXBfZW50cm9weV9NU1syXSAgbWlkIGFuZCBzaWRlIGNoYW5uZWwgdmFsdWVzIChwcmV2IGdyYW51bGUpIG9mIHBlcmNlcF9lbnRyb3B5XG4gZW5lcmd5WzRdICAgICAgICAgICAgIEwsUixNLFMgZW5lcmd5IGluIGVhY2ggY2hhbm5lbCwgcHJldiBncmFudWxlXG4gYmxvY2t0eXBlX2RbMl0gICAgICAgIGJsb2NrIHR5cGUgdG8gdXNlIGZvciBwcmV2aW91cyBncmFudWxlXG4gKi9cbi8vcGFja2FnZSBtcDM7XG5cbi8vaW1wb3J0IGphdmEudXRpbC5BcnJheXM7XG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24uanMnKTtcbnZhciBTeXN0ZW0gPSBjb21tb24uU3lzdGVtO1xudmFyIFZick1vZGUgPSBjb21tb24uVmJyTW9kZTtcbnZhciBGbG9hdCA9IGNvbW1vbi5GbG9hdDtcbnZhciBTaG9ydEJsb2NrID0gY29tbW9uLlNob3J0QmxvY2s7XG52YXIgVXRpbCA9IGNvbW1vbi5VdGlsO1xudmFyIEFycmF5cyA9IGNvbW1vbi5BcnJheXM7XG52YXIgbmV3X2FycmF5X24gPSBjb21tb24ubmV3X2FycmF5X247XG52YXIgbmV3X2J5dGUgPSBjb21tb24ubmV3X2J5dGU7XG52YXIgbmV3X2RvdWJsZSA9IGNvbW1vbi5uZXdfZG91YmxlO1xudmFyIG5ld19mbG9hdCA9IGNvbW1vbi5uZXdfZmxvYXQ7XG52YXIgbmV3X2Zsb2F0X24gPSBjb21tb24ubmV3X2Zsb2F0X247XG52YXIgbmV3X2ludCA9IGNvbW1vbi5uZXdfaW50O1xudmFyIG5ld19pbnRfbiA9IGNvbW1vbi5uZXdfaW50X247XG52YXIgYXNzZXJ0ID0gY29tbW9uLmFzc2VydDtcblxudmFyIEZGVCA9IHJlcXVpcmUoXCIuL0ZGVC5qc1wiKTtcbnZhciBFbmNvZGVyID0gcmVxdWlyZShcIi4vRW5jb2Rlci5qc1wiKTtcblxuZnVuY3Rpb24gUHN5TW9kZWwoKSB7XG4gICAgdmFyIE1QRUdNb2RlID0gcmVxdWlyZSgnLi9NUEVHTW9kZS5qcycpO1xuICAgIHZhciBmZnQgPSBuZXcgRkZUKCk7XG5cbiAgICB2YXIgTE9HMTAgPSAyLjMwMjU4NTA5Mjk5NDA0NTY4NDAyO1xuXG4gICAgdmFyIHJwZWxldiA9IDI7XG4gICAgdmFyIHJwZWxldjIgPSAxNjtcbiAgICB2YXIgcnBlbGV2X3MgPSAyO1xuICAgIHZhciBycGVsZXYyX3MgPSAxNjtcblxuICAgIC8qIHNpemUgb2YgZWFjaCBwYXJ0aXRpb24gYmFuZCwgaW4gYmFya3M6ICovXG4gICAgdmFyIERFTEJBUksgPSAuMzQ7XG5cbiAgICAvKiB0dW5lZCBmb3Igb3V0cHV0IGxldmVsIChzZW5zaXRpdmUgdG8gZW5lcmd5IHNjYWxlKSAqL1xuICAgIHZhciBWT19TQ0FMRSA9ICgxLiAvICgxNDc1MiAqIDE0NzUyKSAvIChFbmNvZGVyLkJMS1NJWkUgLyAyKSk7XG5cbiAgICB2YXIgdGVtcG9yYWxtYXNrX3N1c3RhaW5fc2VjID0gMC4wMTtcblxuICAgIHZhciBOU19QUkVFQ0hPX0FUVDAgPSAwLjg7XG4gICAgdmFyIE5TX1BSRUVDSE9fQVRUMSA9IDAuNjtcbiAgICB2YXIgTlNfUFJFRUNIT19BVFQyID0gMC4zO1xuXG4gICAgdmFyIE5TX01TRklYID0gMy41O1xuXG4gICAgdmFyIE5TQVRUQUNLVEhSRSA9IDQuNDtcbiAgICB2YXIgTlNBVFRBQ0tUSFJFX1MgPSAyNTtcblxuICAgIHZhciBOU0ZJUkxFTiA9IDIxO1xuXG4gICAgLyogc2l6ZSBvZiBlYWNoIHBhcnRpdGlvbiBiYW5kLCBpbiBiYXJrczogKi9cbiAgICB2YXIgTE5fVE9fTE9HMTAgPSAwLjIzMDI1ODUwOTM7XG5cbiAgICBmdW5jdGlvbiBOT05fTElORUFSX1NDQUxFX0VORVJHWSh4KSB7XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIDxQUkU+XG4gICAgICogICAgICAgTDNwc3ljaG9fYW5hbC4gIENvbXB1dGUgcHN5Y2hvIGFjb3VzdGljcy5cbiAgICAgKlxuICAgICAqICAgICAgIERhdGEgcmV0dXJuZWQgdG8gdGhlIGNhbGxpbmcgcHJvZ3JhbSBtdXN0IGJlIGRlbGF5ZWQgYnkgb25lXG4gICAgICogICAgICAgZ3JhbnVsZS5cbiAgICAgKlxuICAgICAqICAgICAgIFRoaXMgaXMgZG9uZSBpbiB0d28gcGxhY2VzLlxuICAgICAqICAgICAgIElmIHdlIGRvIG5vdCBuZWVkIHRvIGtub3cgdGhlIGJsb2NrdHlwZSwgdGhlIGNvcHlpbmdcbiAgICAgKiAgICAgICBjYW4gYmUgZG9uZSBoZXJlIGF0IHRoZSB0b3Agb2YgdGhlIHByb2dyYW06IHdlIGNvcHkgdGhlIGRhdGEgZm9yXG4gICAgICogICAgICAgdGhlIGxhc3QgZ3JhbnVsZSAoY29tcHV0ZWQgZHVyaW5nIHRoZSBsYXN0IGNhbGwpIGJlZm9yZSBpdCBpc1xuICAgICAqICAgICAgIG92ZXJ3cml0dGVuIHdpdGggdGhlIG5ldyBkYXRhLiAgSXQgbG9va3MgbGlrZSB0aGlzOlxuICAgICAqXG4gICAgICogICAgICAgMC4gc3RhdGljIHBzeW1vZGVsX2RhdGFcbiAgICAgKiAgICAgICAxLiBjYWxsaW5nX3Byb2dyYW1fZGF0YSA9IHBzeW1vZGVsX2RhdGFcbiAgICAgKiAgICAgICAyLiBjb21wdXRlIHBzeW1vZGVsX2RhdGFcbiAgICAgKlxuICAgICAqICAgICAgIEZvciBkYXRhIHdoaWNoIG5lZWRzIHRvIGtub3cgdGhlIGJsb2NrdHlwZSwgdGhlIGNvcHlpbmcgbXVzdCBiZVxuICAgICAqICAgICAgIGRvbmUgYXQgdGhlIGVuZCBvZiB0aGlzIGxvb3AsIGFuZCB0aGUgb2xkIHZhbHVlcyBtdXN0IGJlIHNhdmVkOlxuICAgICAqXG4gICAgICogICAgICAgMC4gc3RhdGljIHBzeW1vZGVsX2RhdGFfb2xkXG4gICAgICogICAgICAgMS4gY29tcHV0ZSBwc3ltb2RlbF9kYXRhXG4gICAgICogICAgICAgMi4gY29tcHV0ZSBwb3NzaWJsZSBibG9jayB0eXBlIG9mIHRoaXMgZ3JhbnVsZVxuICAgICAqICAgICAgIDMuIGNvbXB1dGUgZmluYWwgYmxvY2sgdHlwZSBvZiBwcmV2aW91cyBncmFudWxlIGJhc2VkIG9uICMyLlxuICAgICAqICAgICAgIDQuIGNhbGxpbmdfcHJvZ3JhbV9kYXRhID0gcHN5bW9kZWxfZGF0YV9vbGRcbiAgICAgKiAgICAgICA1LiBwc3ltb2RlbF9kYXRhX29sZCA9IHBzeW1vZGVsX2RhdGFcbiAgICAgKiAgICAgcHN5Y2hvX2xvdWRuZXNzX2FwcHJveFxuICAgICAqICAgICAgIGpkIC0gMjAwMSBtYXIgMTJcbiAgICAgKiAgICBpbjogIGVuZXJneSAgIC0gQkxLU0laRS8yIGVsZW1lbnRzIG9mIGZyZXF1ZW5jeSBtYWduaXR1ZGVzIF4gMlxuICAgICAqICAgICAgICAgZ2ZwICAgICAgLSB1c2VzIG91dF9zYW1wbGVyYXRlLCBBVEh0eXBlIChhbHNvIG5lZWRlZCBmb3IgQVRIZm9ybXVsYSlcbiAgICAgKiAgICByZXR1cm5zOiBsb3VkbmVzc14yIGFwcHJveGltYXRpb24sIGEgcG9zaXRpdmUgdmFsdWUgcm91Z2hseSB0dW5lZCBmb3IgYSB2YWx1ZVxuICAgICAqICAgICAgICAgICAgIG9mIDEuMCBmb3Igc2lnbmFscyBuZWFyIGNsaXBwaW5nLlxuICAgICAqICAgIG5vdGVzOiAgIFdoZW4gY2FsaWJyYXRlZCwgZmVlZGluZyB0aGlzIGZ1bmN0aW9uIGJpbmFyeSB3aGl0ZSBub2lzZSBhdCBzYW1wbGVcbiAgICAgKiAgICAgICAgICAgICB2YWx1ZXMgKzMyNzY3IG9yIC0zMjc2OCBzaG91bGQgcmV0dXJuIHZhbHVlcyB0aGF0IGFwcHJvYWNoIDMuXG4gICAgICogICAgICAgICAgICAgQVRIZm9ybXVsYSBpcyB1c2VkIHRvIGFwcHJveGltYXRlIGFuIGVxdWFsIGxvdWRuZXNzIGN1cnZlLlxuICAgICAqICAgIGZ1dHVyZTogIERhdGEgaW5kaWNhdGVzIHRoYXQgdGhlIHNoYXBlIG9mIHRoZSBlcXVhbCBsb3VkbmVzcyBjdXJ2ZSB2YXJpZXNcbiAgICAgKiAgICAgICAgICAgICB3aXRoIGludGVuc2l0eS4gIFRoaXMgZnVuY3Rpb24gbWlnaHQgYmUgaW1wcm92ZWQgYnkgdXNpbmcgYW4gZXF1YWxcbiAgICAgKiAgICAgICAgICAgICBsb3VkbmVzcyBjdXJ2ZSBzaGFwZWQgZm9yIHR5cGljYWwgcGxheWJhY2sgbGV2ZWxzIChpbnN0ZWFkIG9mIHRoZVxuICAgICAqICAgICAgICAgICAgIEFUSCwgdGhhdCBpcyBzaGFwZWQgZm9yIHRoZSB0aHJlc2hvbGQpLiAgQSBmbGV4aWJsZSByZWFsaXphdGlvbiBtaWdodFxuICAgICAqICAgICAgICAgICAgIHNpbXBseSBiZW5kIHRoZSBleGlzdGluZyBBVEggY3VydmUgdG8gYWNoaWV2ZSB0aGUgZGVzaXJlZCBzaGFwZS5cbiAgICAgKiAgICAgICAgICAgICBIb3dldmVyLCB0aGUgcG90ZW50aWFsIGdhaW4gbWF5IG5vdCBiZSBlbm91Z2ggdG8ganVzdGlmeSBhbiBlZmZvcnQuXG4gICAgICogPC9QUkU+XG4gICAgICovXG4gICAgZnVuY3Rpb24gcHN5Y2hvX2xvdWRuZXNzX2FwcHJveChlbmVyZ3ksIGdmYykge1xuICAgICAgICB2YXIgbG91ZG5lc3NfcG93ZXIgPSAwLjA7XG4gICAgICAgIC8qIGFwcGx5IHdlaWdodHMgdG8gcG93ZXIgaW4gZnJlcS4gYmFuZHMgKi9cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBFbmNvZGVyLkJMS1NJWkUgLyAyOyArK2kpXG4gICAgICAgICAgICBsb3VkbmVzc19wb3dlciArPSBlbmVyZ3lbaV0gKiBnZmMuQVRILmVxbF93W2ldO1xuICAgICAgICBsb3VkbmVzc19wb3dlciAqPSBWT19TQ0FMRTtcblxuICAgICAgICByZXR1cm4gbG91ZG5lc3NfcG93ZXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZV9mZnRzKGdmcCwgZmZ0ZW5lcmd5LCBmZnRlbmVyZ3lfcywgd3NhbXBfbCwgd3NhbXBfbFBvcywgd3NhbXBfcywgd3NhbXBfc1BvcywgZ3Jfb3V0LCBjaG4sIGJ1ZmZlciwgYnVmUG9zKSB7XG4gICAgICAgIHZhciBnZmMgPSBnZnAuaW50ZXJuYWxfZmxhZ3M7XG4gICAgICAgIGlmIChjaG4gPCAyKSB7XG4gICAgICAgICAgICBmZnQuZmZ0X2xvbmcoZ2ZjLCB3c2FtcF9sW3dzYW1wX2xQb3NdLCBjaG4sIGJ1ZmZlciwgYnVmUG9zKTtcbiAgICAgICAgICAgIGZmdC5mZnRfc2hvcnQoZ2ZjLCB3c2FtcF9zW3dzYW1wX3NQb3NdLCBjaG4sIGJ1ZmZlciwgYnVmUG9zKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBGRlQgZGF0YSBmb3IgbWlkIGFuZCBzaWRlIGNoYW5uZWwgaXMgZGVyaXZlZCBmcm9tIEwgJiBSICovXG4gICAgICAgIGVsc2UgaWYgKGNobiA9PSAyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gRW5jb2Rlci5CTEtTSVpFIC0gMTsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgICAgICAgICB2YXIgbCA9IHdzYW1wX2xbd3NhbXBfbFBvcyArIDBdW2pdO1xuICAgICAgICAgICAgICAgIHZhciByID0gd3NhbXBfbFt3c2FtcF9sUG9zICsgMV1bal07XG4gICAgICAgICAgICAgICAgd3NhbXBfbFt3c2FtcF9sUG9zICsgMF1bal0gPSAobCArIHIpICogVXRpbC5TUVJUMiAqIDAuNTtcbiAgICAgICAgICAgICAgICB3c2FtcF9sW3dzYW1wX2xQb3MgKyAxXVtqXSA9IChsIC0gcikgKiBVdGlsLlNRUlQyICogMC41O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgYiA9IDI7IGIgPj0gMDsgLS1iKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IEVuY29kZXIuQkxLU0laRV9zIC0gMTsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSB3c2FtcF9zW3dzYW1wX3NQb3MgKyAwXVtiXVtqXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSB3c2FtcF9zW3dzYW1wX3NQb3MgKyAxXVtiXVtqXTtcbiAgICAgICAgICAgICAgICAgICAgd3NhbXBfc1t3c2FtcF9zUG9zICsgMF1bYl1bal0gPSAobCArIHIpICogVXRpbC5TUVJUMiAqIDAuNTtcbiAgICAgICAgICAgICAgICAgICAgd3NhbXBfc1t3c2FtcF9zUG9zICsgMV1bYl1bal0gPSAobCAtIHIpICogVXRpbC5TUVJUMiAqIDAuNTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICAqIGNvbXB1dGUgZW5lcmdpZXNcbiAgICAgICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgZmZ0ZW5lcmd5WzBdID0gTk9OX0xJTkVBUl9TQ0FMRV9FTkVSR1kod3NhbXBfbFt3c2FtcF9sUG9zICsgMF1bMF0pO1xuICAgICAgICBmZnRlbmVyZ3lbMF0gKj0gZmZ0ZW5lcmd5WzBdO1xuXG4gICAgICAgIGZvciAodmFyIGogPSBFbmNvZGVyLkJMS1NJWkUgLyAyIC0gMTsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgICAgIHZhciByZSA9ICh3c2FtcF9sW3dzYW1wX2xQb3MgKyAwXSlbRW5jb2Rlci5CTEtTSVpFIC8gMiAtIGpdO1xuICAgICAgICAgICAgdmFyIGltID0gKHdzYW1wX2xbd3NhbXBfbFBvcyArIDBdKVtFbmNvZGVyLkJMS1NJWkUgLyAyICsgal07XG4gICAgICAgICAgICBmZnRlbmVyZ3lbRW5jb2Rlci5CTEtTSVpFIC8gMiAtIGpdID0gTk9OX0xJTkVBUl9TQ0FMRV9FTkVSR1koKHJlXG4gICAgICAgICAgICAgICAgKiByZSArIGltICogaW0pICogMC41KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBiID0gMjsgYiA+PSAwOyAtLWIpIHtcbiAgICAgICAgICAgIGZmdGVuZXJneV9zW2JdWzBdID0gKHdzYW1wX3Nbd3NhbXBfc1BvcyArIDBdKVtiXVswXTtcbiAgICAgICAgICAgIGZmdGVuZXJneV9zW2JdWzBdICo9IGZmdGVuZXJneV9zW2JdWzBdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IEVuY29kZXIuQkxLU0laRV9zIC8gMiAtIDE7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlID0gKHdzYW1wX3Nbd3NhbXBfc1BvcyArIDBdKVtiXVtFbmNvZGVyLkJMS1NJWkVfc1xuICAgICAgICAgICAgICAgIC8gMiAtIGpdO1xuICAgICAgICAgICAgICAgIHZhciBpbSA9ICh3c2FtcF9zW3dzYW1wX3NQb3MgKyAwXSlbYl1bRW5jb2Rlci5CTEtTSVpFX3NcbiAgICAgICAgICAgICAgICAvIDIgKyBqXTtcbiAgICAgICAgICAgICAgICBmZnRlbmVyZ3lfc1tiXVtFbmNvZGVyLkJMS1NJWkVfcyAvIDIgLSBqXSA9IE5PTl9MSU5FQVJfU0NBTEVfRU5FUkdZKChyZVxuICAgICAgICAgICAgICAgICAgICAqIHJlICsgaW0gKiBpbSkgKiAwLjUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qIHRvdGFsIGVuZXJneSAqL1xuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgdG90YWxlbmVyZ3kgPSAwLjA7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMTE7IGogPCBFbmNvZGVyLkhCTEtTSVpFOyBqKyspXG4gICAgICAgICAgICAgICAgdG90YWxlbmVyZ3kgKz0gZmZ0ZW5lcmd5W2pdO1xuXG4gICAgICAgICAgICBnZmMudG90X2VuZXJbY2huXSA9IHRvdGFsZW5lcmd5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdmcC5hbmFseXNpcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBFbmNvZGVyLkhCTEtTSVpFOyBqKyspIHtcbiAgICAgICAgICAgICAgICBnZmMucGluZm8uZW5lcmd5W2dyX291dF1bY2huXVtqXSA9IGdmYy5waW5mby5lbmVyZ3lfc2F2ZVtjaG5dW2pdO1xuICAgICAgICAgICAgICAgIGdmYy5waW5mby5lbmVyZ3lfc2F2ZVtjaG5dW2pdID0gZmZ0ZW5lcmd5W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2ZjLnBpbmZvLnBlW2dyX291dF1bY2huXSA9IGdmYy5wZVtjaG5dO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAgKiBjb21wdXRlIGxvdWRuZXNzIGFwcHJveGltYXRpb24gKHVzZWQgZm9yIEFUSCBhdXRvLWxldmVsIGFkanVzdG1lbnQpXG4gICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIGlmIChnZnAuYXRoYWFfbG91ZGFwcHJveCA9PSAyICYmIGNobiA8IDIpIHtcbiAgICAgICAgICAgIC8vIG5vIGxvdWRuZXNzIGZvciBtaWQvc2lkZSBjaFxuICAgICAgICAgICAgZ2ZjLmxvdWRuZXNzX3NxW2dyX291dF1bY2huXSA9IGdmYy5sb3VkbmVzc19zcV9zYXZlW2Nobl07XG4gICAgICAgICAgICBnZmMubG91ZG5lc3Nfc3Ffc2F2ZVtjaG5dID0gcHN5Y2hvX2xvdWRuZXNzX2FwcHJveChmZnRlbmVyZ3ksIGdmYyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBtYXNrX2FkZCBvcHRpbWl6YXRpb24gKi9cbiAgICAvKiBpbml0IHRoZSBsaW1pdCB2YWx1ZXMgdXNlZCB0byBhdm9pZCBjb21wdXRpbmcgbG9nIGluIG1hc2tfYWRkIHdoZW4gaXQgaXMgbm90IG5lY2Vzc2FyeSAqL1xuXG4gICAgLyoqXG4gICAgICogPFBSRT5cbiAgICAgKiAgRm9yIGV4YW1wbGUsIHdpdGggaSA9IDEwKmxvZzEwKG0yL20xKS8xMCoxNiAgICAgICAgICg9IGxvZzEwKG0yL20xKSoxNilcbiAgICAgKlxuICAgICAqIGFicyhpKT44IGlzIGVxdWl2YWxlbnQgKGFzIGkgaXMgYW4gaW50ZWdlcikgdG9cbiAgICAgKiBhYnMoaSk+PTlcbiAgICAgKiBpPj05IHx8IGk8PS05XG4gICAgICogZXF1aXZhbGVudCB0byAoYXMgaSBpcyB0aGUgYmlnZ2VzdCBpbnRlZ2VyIHNtYWxsZXIgdGhhbiBsb2cxMChtMi9tMSkqMTZcbiAgICAgKiBvciB0aGUgc21hbGxlc3QgaW50ZWdlciBiaWdnZXIgdGhhbiBsb2cxMChtMi9tMSkqMTYgZGVwZW5kaW5nIG9uIHRoZSBzaWduIG9mIGxvZzEwKG0yL20xKSoxNilcbiAgICAgKiBsb2cxMChtMi9tMSk+PTkvMTYgfHwgbG9nMTAobTIvbTEpPD0tOS8xNlxuICAgICAqIGV4cDEwIGlzIHN0cmljdGx5IGluY3JlYXNpbmcgdGh1cyB0aGlzIGlzIGVxdWl2YWxlbnQgdG9cbiAgICAgKiBtMi9tMSA+PSAxMF4oOS8xNikgfHwgbTIvbTE8PTEwXigtOS8xNikgd2hpY2ggYXJlIGNvbXBhcmlzb25zIHRvIGNvbnN0YW50c1xuICAgICAqIDwvUFJFPlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogYXMgaW4gaWYoaT44KVxuICAgICAqL1xuICAgIHZhciBJMUxJTUlUID0gODtcbiAgICAvKipcbiAgICAgKiBhcyBpbiBpZihpPjI0KSAuIGNoYW5nZWQgMjNcbiAgICAgKi9cbiAgICB2YXIgSTJMSU1JVCA9IDIzO1xuICAgIC8qKlxuICAgICAqIGFzIGluIGlmKG08MTUpXG4gICAgICovXG4gICAgdmFyIE1MSU1JVCA9IDE1O1xuXG4gICAgdmFyIG1hX21heF9pMTtcbiAgICB2YXIgbWFfbWF4X2kyO1xuICAgIHZhciBtYV9tYXhfbTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIG1hc2tpbmcgdGFibGU6PEJSPlxuICAgICAqIEFjY29yZGluZyB0byB0b25hbGl0eSwgdmFsdWVzIGFyZSBnb2luZyBmcm9tIDBkQiAoVE1OKSB0byA5LjNkQiAoTk1UKS48QlI+XG4gICAgICogQWZ0ZXIgYWRkaXRpdmUgbWFza2luZyBjb21wdXRhdGlvbiwgOGRCIGFyZSBhZGRlZCwgc28gZmluYWwgdmFsdWVzIGFyZVxuICAgICAqIGdvaW5nIGZyb20gOGRCIHRvIDE3LjNkQlxuICAgICAqXG4gICAgICogcG93KDEwLCAtMC4wLi4tMC42KVxuICAgICAqL1xuICAgIHZhciB0YWIgPSBbMS4wLCAwLjc5NDMzLCAwLjYzMDk2LCAwLjYzMDk2LFxuICAgICAgICAwLjYzMDk2LCAwLjYzMDk2LCAwLjYzMDk2LCAwLjI1MTE5LCAwLjExNzQ5XTtcblxuICAgIGZ1bmN0aW9uIGluaXRfbWFza19hZGRfbWF4X3ZhbHVlcygpIHtcbiAgICAgICAgbWFfbWF4X2kxID0gTWF0aC5wb3coMTAsIChJMUxJTUlUICsgMSkgLyAxNi4wKTtcbiAgICAgICAgbWFfbWF4X2kyID0gTWF0aC5wb3coMTAsIChJMkxJTUlUICsgMSkgLyAxNi4wKTtcbiAgICAgICAgbWFfbWF4X20gPSBNYXRoLnBvdygxMCwgKE1MSU1JVCkgLyAxMC4wKTtcbiAgICB9XG5cbiAgICB2YXIgdGFibGUxID0gWzMuMzI0NiAqIDMuMzI0NixcbiAgICAgICAgMy4yMzgzNyAqIDMuMjM4MzcsIDMuMTU0MzcgKiAzLjE1NDM3LCAzLjAwNDEyICogMy4wMDQxMixcbiAgICAgICAgMi44NjEwMyAqIDIuODYxMDMsIDIuNjU0MDcgKiAyLjY1NDA3LCAyLjQ2MjA5ICogMi40NjIwOSxcbiAgICAgICAgMi4yODQgKiAyLjI4NCwgMi4xMTg3OSAqIDIuMTE4NzksIDEuOTY1NTIgKiAxLjk2NTUyLFxuICAgICAgICAxLjgyMzM1ICogMS44MjMzNSwgMS42OTE0NiAqIDEuNjkxNDYsIDEuNTY5MTEgKiAxLjU2OTExLFxuICAgICAgICAxLjQ2NjU4ICogMS40NjY1OCwgMS4zNzA3NCAqIDEuMzcwNzQsIDEuMzEwMzYgKiAxLjMxMDM2LFxuICAgICAgICAxLjI1MjY0ICogMS4yNTI2NCwgMS4yMDY0OCAqIDEuMjA2NDgsIDEuMTYyMDMgKiAxLjE2MjAzLFxuICAgICAgICAxLjEyNzY1ICogMS4xMjc2NSwgMS4wOTQyOCAqIDEuMDk0MjgsIDEuMDY1OSAqIDEuMDY1OSxcbiAgICAgICAgMS4wMzgyNiAqIDEuMDM4MjYsIDEuMDE4OTUgKiAxLjAxODk1LCAxXTtcblxuICAgIHZhciB0YWJsZTIgPSBbMS4zMzM1MiAqIDEuMzMzNTIsXG4gICAgICAgIDEuMzU4NzkgKiAxLjM1ODc5LCAxLjM4NDU0ICogMS4zODQ1NCwgMS4zOTQ5NyAqIDEuMzk0OTcsXG4gICAgICAgIDEuNDA1NDggKiAxLjQwNTQ4LCAxLjM1MzcgKiAxLjM1MzcsIDEuMzAzODIgKiAxLjMwMzgyLFxuICAgICAgICAxLjIyMzIxICogMS4yMjMyMSwgMS4xNDc1OCAqIDEuMTQ3NTgsIDFdO1xuXG4gICAgdmFyIHRhYmxlMyA9IFsyLjM1MzY0ICogMi4zNTM2NCxcbiAgICAgICAgMi4yOTI1OSAqIDIuMjkyNTksIDIuMjMzMTMgKiAyLjIzMzEzLCAyLjEyNjc1ICogMi4xMjY3NSxcbiAgICAgICAgMi4wMjU0NSAqIDIuMDI1NDUsIDEuODc4OTQgKiAxLjg3ODk0LCAxLjc0MzAzICogMS43NDMwMyxcbiAgICAgICAgMS42MTY5NSAqIDEuNjE2OTUsIDEuNDk5OTkgKiAxLjQ5OTk5LCAxLjM5MTQ4ICogMS4zOTE0OCxcbiAgICAgICAgMS4yOTA4MyAqIDEuMjkwODMsIDEuMTk3NDYgKiAxLjE5NzQ2LCAxLjExMDg0ICogMS4xMTA4NCxcbiAgICAgICAgMS4wMzgyNiAqIDEuMDM4MjZdO1xuXG4gICAgLyoqXG4gICAgICogYWRkaXRpb24gb2Ygc2ltdWx0YW5lb3VzIG1hc2tpbmcgTmFva2kgU2hpYmF0YSAyMDAwLzdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXNrX2FkZChtMSwgbTIsIGtrLCBiLCBnZmMsIHNob3J0YmxvY2spIHtcbiAgICAgICAgdmFyIHJhdGlvO1xuXG4gICAgICAgIGlmIChtMiA+IG0xKSB7XG4gICAgICAgICAgICBpZiAobTIgPCAobTEgKiBtYV9tYXhfaTIpKVxuICAgICAgICAgICAgICAgIHJhdGlvID0gbTIgLyBtMTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gKG0xICsgbTIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG0xID49IChtMiAqIG1hX21heF9pMikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIChtMSArIG0yKTtcbiAgICAgICAgICAgIHJhdGlvID0gbTEgLyBtMjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIFNob3VsZCBhbHdheXMgYmUgdHJ1ZSwganVzdCBjaGVja2luZyAqL1xuICAgICAgICBhc3NlcnQobTEgPj0gMCk7XG4gICAgICAgIGFzc2VydChtMiA+PSAwKTtcblxuICAgICAgICBtMSArPSBtMjtcbiAgICAgICAgLy9pZiAoKChsb25nKShiICsgMykgJiAweGZmZmZmZmZmKSA8PSAzICsgMykge1xuICAgICAgICBpZiAoKGIgKyAzKSA8PSAzICsgMykge1xuICAgICAgICAgICAgLyogYXBwcm94aW1hdGVseSwgMSBiYXJrID0gMyBwYXJ0aXRpb25zICovXG4gICAgICAgICAgICAvKiA2NSUgb2YgdGhlIGNhc2VzICovXG4gICAgICAgICAgICAvKiBvcmlnaW5hbGx5ICdpZihpID4gOCknICovXG4gICAgICAgICAgICBpZiAocmF0aW8gPj0gbWFfbWF4X2kxKSB7XG4gICAgICAgICAgICAgICAgLyogNDMlIG9mIHRoZSB0b3RhbCAqL1xuICAgICAgICAgICAgICAgIHJldHVybiBtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyogMjIlIG9mIHRoZSB0b3RhbCAqL1xuICAgICAgICAgICAgdmFyIGkgPSAwIHwgKFV0aWwuRkFTVF9MT0cxMF9YKHJhdGlvLCAxNi4wKSk7XG4gICAgICAgICAgICByZXR1cm4gbTEgKiB0YWJsZTJbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogPFBSRT5cbiAgICAgICAgICogbTwxNSBlcXUgbG9nMTAoKG0xK20yKS9nZmMuQVRILmNiW2tdKTwxLjVcbiAgICAgICAgICogZXF1IChtMSttMikvZ2ZjLkFUSC5jYltrXTwxMF4xLjVcbiAgICAgICAgICogZXF1IChtMSttMik8MTBeMS41ICogZ2ZjLkFUSC5jYltrXVxuICAgICAgICAgKiA8L1BSRT5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBpID0gMCB8IFV0aWwuRkFTVF9MT0cxMF9YKHJhdGlvLCAxNi4wKTtcbiAgICAgICAgaWYgKHNob3J0YmxvY2sgIT0gMCkge1xuICAgICAgICAgICAgbTIgPSBnZmMuQVRILmNiX3Nba2tdICogZ2ZjLkFUSC5hZGp1c3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtMiA9IGdmYy5BVEguY2JfbFtra10gKiBnZmMuQVRILmFkanVzdDtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQobTIgPj0gMCk7XG4gICAgICAgIGlmIChtMSA8IG1hX21heF9tICogbTIpIHtcbiAgICAgICAgICAgIC8qIDMlIG9mIHRoZSB0b3RhbCAqL1xuICAgICAgICAgICAgLyogT3JpZ2luYWxseSBpZiAobSA+IDApIHsgKi9cbiAgICAgICAgICAgIGlmIChtMSA+IG0yKSB7XG4gICAgICAgICAgICAgICAgdmFyIGYsIHI7XG5cbiAgICAgICAgICAgICAgICBmID0gMS4wO1xuICAgICAgICAgICAgICAgIGlmIChpIDw9IDEzKVxuICAgICAgICAgICAgICAgICAgICBmID0gdGFibGUzW2ldO1xuXG4gICAgICAgICAgICAgICAgciA9IFV0aWwuRkFTVF9MT0cxMF9YKG0xIC8gbTIsIDEwLjAgLyAxNS4wKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbTEgKiAoKHRhYmxlMVtpXSAtIGYpICogciArIGYpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaSA+IDEzKVxuICAgICAgICAgICAgICAgIHJldHVybiBtMTtcblxuICAgICAgICAgICAgcmV0dXJuIG0xICogdGFibGUzW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogMTAlIG9mIHRvdGFsICovXG4gICAgICAgIHJldHVybiBtMSAqIHRhYmxlMVtpXTtcbiAgICB9XG5cbiAgICB2YXIgdGFibGUyXyA9IFsxLjMzMzUyICogMS4zMzM1MixcbiAgICAgICAgMS4zNTg3OSAqIDEuMzU4NzksIDEuMzg0NTQgKiAxLjM4NDU0LCAxLjM5NDk3ICogMS4zOTQ5NyxcbiAgICAgICAgMS40MDU0OCAqIDEuNDA1NDgsIDEuMzUzNyAqIDEuMzUzNywgMS4zMDM4MiAqIDEuMzAzODIsXG4gICAgICAgIDEuMjIzMjEgKiAxLjIyMzIxLCAxLjE0NzU4ICogMS4xNDc1OCwgMV07XG5cbiAgICAvKipcbiAgICAgKiBhZGRpdGlvbiBvZiBzaW11bHRhbmVvdXMgbWFza2luZyBOYW9raSBTaGliYXRhIDIwMDAvN1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZicnBzeV9tYXNrX2FkZChtMSwgbTIsIGIpIHtcbiAgICAgICAgdmFyIHJhdGlvO1xuXG4gICAgICAgIGlmIChtMSA8IDApIHtcbiAgICAgICAgICAgIG0xID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobTIgPCAwKSB7XG4gICAgICAgICAgICBtMiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG0xIDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiBtMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobTIgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG0xO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtMiA+IG0xKSB7XG4gICAgICAgICAgICByYXRpbyA9IG0yIC8gbTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByYXRpbyA9IG0xIC8gbTI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKC0yIDw9IGIgJiYgYiA8PSAyKSB7XG4gICAgICAgICAgICAvKiBhcHByb3hpbWF0ZWx5LCAxIGJhcmsgPSAzIHBhcnRpdGlvbnMgKi9cbiAgICAgICAgICAgIC8qIG9yaWdpbmFsbHkgJ2lmKGkgPiA4KScgKi9cbiAgICAgICAgICAgIGlmIChyYXRpbyA+PSBtYV9tYXhfaTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbTEgKyBtMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwIHwgKFV0aWwuRkFTVF9MT0cxMF9YKHJhdGlvLCAxNi4wKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChtMSArIG0yKSAqIHRhYmxlMl9baV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJhdGlvIDwgbWFfbWF4X2kyKSB7XG4gICAgICAgICAgICByZXR1cm4gbTEgKyBtMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobTEgPCBtMikge1xuICAgICAgICAgICAgbTEgPSBtMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY29tcHV0ZSBpbnRlcmNoYW5uZWwgbWFza2luZyBlZmZlY3RzXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FsY19pbnRlcmNoYW5uZWxfbWFza2luZyhnZnAsIHJhdGlvKSB7XG4gICAgICAgIHZhciBnZmMgPSBnZnAuaW50ZXJuYWxfZmxhZ3M7XG4gICAgICAgIGlmIChnZmMuY2hhbm5lbHNfb3V0ID4gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgc2IgPSAwOyBzYiA8IEVuY29kZXIuU0JNQVhfbDsgc2IrKykge1xuICAgICAgICAgICAgICAgIHZhciBsID0gZ2ZjLnRobVswXS5sW3NiXTtcbiAgICAgICAgICAgICAgICB2YXIgciA9IGdmYy50aG1bMV0ubFtzYl07XG4gICAgICAgICAgICAgICAgZ2ZjLnRobVswXS5sW3NiXSArPSByICogcmF0aW87XG4gICAgICAgICAgICAgICAgZ2ZjLnRobVsxXS5sW3NiXSArPSBsICogcmF0aW87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBzYiA9IDA7IHNiIDwgRW5jb2Rlci5TQk1BWF9zOyBzYisrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgc2Jsb2NrID0gMDsgc2Jsb2NrIDwgMzsgc2Jsb2NrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBnZmMudGhtWzBdLnNbc2JdW3NibG9ja107XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gZ2ZjLnRobVsxXS5zW3NiXVtzYmxvY2tdO1xuICAgICAgICAgICAgICAgICAgICBnZmMudGhtWzBdLnNbc2JdW3NibG9ja10gKz0gciAqIHJhdGlvO1xuICAgICAgICAgICAgICAgICAgICBnZmMudGhtWzFdLnNbc2JdW3NibG9ja10gKz0gbCAqIHJhdGlvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNvbXB1dGUgTS9TIHRocmVzaG9sZHMgZnJvbSBKb2huc3RvbiAmIEZlcnJlaXJhIDE5OTIgSUNBU1NQIHBhcGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gbXNmaXgxKGdmYykge1xuICAgICAgICBmb3IgKHZhciBzYiA9IDA7IHNiIDwgRW5jb2Rlci5TQk1BWF9sOyBzYisrKSB7XG4gICAgICAgICAgICAvKiB1c2UgdGhpcyBmaXggaWYgTCAmIFIgbWFza2luZyBkaWZmZXJzIGJ5IDJkYiBvciBsZXNzICovXG4gICAgICAgICAgICAvKiBpZiBkYiA9IDEwKmxvZzEwKHgyL3gxKSA8IDIgKi9cbiAgICAgICAgICAgIC8qIGlmICh4MiA8IDEuNTgqeDEpIHsgKi9cbiAgICAgICAgICAgIGlmIChnZmMudGhtWzBdLmxbc2JdID4gMS41OCAqIGdmYy50aG1bMV0ubFtzYl1cbiAgICAgICAgICAgICAgICB8fCBnZmMudGhtWzFdLmxbc2JdID4gMS41OCAqIGdmYy50aG1bMF0ubFtzYl0pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB2YXIgbWxkID0gZ2ZjLm1sZF9sW3NiXSAqIGdmYy5lblszXS5sW3NiXTtcbiAgICAgICAgICAgIHZhciBybWlkID0gTWF0aC5tYXgoZ2ZjLnRobVsyXS5sW3NiXSxcbiAgICAgICAgICAgICAgICBNYXRoLm1pbihnZmMudGhtWzNdLmxbc2JdLCBtbGQpKTtcblxuICAgICAgICAgICAgbWxkID0gZ2ZjLm1sZF9sW3NiXSAqIGdmYy5lblsyXS5sW3NiXTtcbiAgICAgICAgICAgIHZhciByc2lkZSA9IE1hdGgubWF4KGdmYy50aG1bM10ubFtzYl0sXG4gICAgICAgICAgICAgICAgTWF0aC5taW4oZ2ZjLnRobVsyXS5sW3NiXSwgbWxkKSk7XG4gICAgICAgICAgICBnZmMudGhtWzJdLmxbc2JdID0gcm1pZDtcbiAgICAgICAgICAgIGdmYy50aG1bM10ubFtzYl0gPSByc2lkZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIHNiID0gMDsgc2IgPCBFbmNvZGVyLlNCTUFYX3M7IHNiKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIHNibG9jayA9IDA7IHNibG9jayA8IDM7IHNibG9jaysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdmYy50aG1bMF0uc1tzYl1bc2Jsb2NrXSA+IDEuNTggKiBnZmMudGhtWzFdLnNbc2JdW3NibG9ja11cbiAgICAgICAgICAgICAgICAgICAgfHwgZ2ZjLnRobVsxXS5zW3NiXVtzYmxvY2tdID4gMS41OCAqIGdmYy50aG1bMF0uc1tzYl1bc2Jsb2NrXSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgdmFyIG1sZCA9IGdmYy5tbGRfc1tzYl0gKiBnZmMuZW5bM10uc1tzYl1bc2Jsb2NrXTtcbiAgICAgICAgICAgICAgICB2YXIgcm1pZCA9IE1hdGgubWF4KGdmYy50aG1bMl0uc1tzYl1bc2Jsb2NrXSxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oZ2ZjLnRobVszXS5zW3NiXVtzYmxvY2tdLCBtbGQpKTtcblxuICAgICAgICAgICAgICAgIG1sZCA9IGdmYy5tbGRfc1tzYl0gKiBnZmMuZW5bMl0uc1tzYl1bc2Jsb2NrXTtcbiAgICAgICAgICAgICAgICB2YXIgcnNpZGUgPSBNYXRoLm1heChnZmMudGhtWzNdLnNbc2JdW3NibG9ja10sXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWluKGdmYy50aG1bMl0uc1tzYl1bc2Jsb2NrXSwgbWxkKSk7XG5cbiAgICAgICAgICAgICAgICBnZmMudGhtWzJdLnNbc2JdW3NibG9ja10gPSBybWlkO1xuICAgICAgICAgICAgICAgIGdmYy50aG1bM10uc1tzYl1bc2Jsb2NrXSA9IHJzaWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRqdXN0IE0vUyBtYXNraW5ncyBpZiB1c2VyIHNldCBcIm1zZml4XCJcbiAgICAgKlxuICAgICAqIE5hb2tpIFNoaWJhdGEgMjAwMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5zX21zZml4KGdmYywgbXNmaXgsIGF0aGFkanVzdCkge1xuICAgICAgICB2YXIgbXNmaXgyID0gbXNmaXg7XG4gICAgICAgIHZhciBhdGhsb3dlciA9IE1hdGgucG93KDEwLCBhdGhhZGp1c3QpO1xuXG4gICAgICAgIG1zZml4ICo9IDIuMDtcbiAgICAgICAgbXNmaXgyICo9IDIuMDtcbiAgICAgICAgZm9yICh2YXIgc2IgPSAwOyBzYiA8IEVuY29kZXIuU0JNQVhfbDsgc2IrKykge1xuICAgICAgICAgICAgdmFyIHRobUxSLCB0aG1NLCB0aG1TLCBhdGg7XG4gICAgICAgICAgICBhdGggPSAoZ2ZjLkFUSC5jYl9sW2dmYy5ibV9sW3NiXV0pICogYXRobG93ZXI7XG4gICAgICAgICAgICB0aG1MUiA9IE1hdGgubWluKE1hdGgubWF4KGdmYy50aG1bMF0ubFtzYl0sIGF0aCksXG4gICAgICAgICAgICAgICAgTWF0aC5tYXgoZ2ZjLnRobVsxXS5sW3NiXSwgYXRoKSk7XG4gICAgICAgICAgICB0aG1NID0gTWF0aC5tYXgoZ2ZjLnRobVsyXS5sW3NiXSwgYXRoKTtcbiAgICAgICAgICAgIHRobVMgPSBNYXRoLm1heChnZmMudGhtWzNdLmxbc2JdLCBhdGgpO1xuICAgICAgICAgICAgaWYgKHRobUxSICogbXNmaXggPCB0aG1NICsgdGhtUykge1xuICAgICAgICAgICAgICAgIHZhciBmID0gdGhtTFIgKiBtc2ZpeDIgLyAodGhtTSArIHRobVMpO1xuICAgICAgICAgICAgICAgIHRobU0gKj0gZjtcbiAgICAgICAgICAgICAgICB0aG1TICo9IGY7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KHRobU0gKyB0aG1TID4gMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZmMudGhtWzJdLmxbc2JdID0gTWF0aC5taW4odGhtTSwgZ2ZjLnRobVsyXS5sW3NiXSk7XG4gICAgICAgICAgICBnZmMudGhtWzNdLmxbc2JdID0gTWF0aC5taW4odGhtUywgZ2ZjLnRobVszXS5sW3NiXSk7XG4gICAgICAgIH1cblxuICAgICAgICBhdGhsb3dlciAqPSAoIEVuY29kZXIuQkxLU0laRV9zIC8gRW5jb2Rlci5CTEtTSVpFKTtcbiAgICAgICAgZm9yICh2YXIgc2IgPSAwOyBzYiA8IEVuY29kZXIuU0JNQVhfczsgc2IrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgc2Jsb2NrID0gMDsgc2Jsb2NrIDwgMzsgc2Jsb2NrKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdGhtTFIsIHRobU0sIHRobVMsIGF0aDtcbiAgICAgICAgICAgICAgICBhdGggPSAoZ2ZjLkFUSC5jYl9zW2dmYy5ibV9zW3NiXV0pICogYXRobG93ZXI7XG4gICAgICAgICAgICAgICAgdGhtTFIgPSBNYXRoLm1pbihNYXRoLm1heChnZmMudGhtWzBdLnNbc2JdW3NibG9ja10sIGF0aCksXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KGdmYy50aG1bMV0uc1tzYl1bc2Jsb2NrXSwgYXRoKSk7XG4gICAgICAgICAgICAgICAgdGhtTSA9IE1hdGgubWF4KGdmYy50aG1bMl0uc1tzYl1bc2Jsb2NrXSwgYXRoKTtcbiAgICAgICAgICAgICAgICB0aG1TID0gTWF0aC5tYXgoZ2ZjLnRobVszXS5zW3NiXVtzYmxvY2tdLCBhdGgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRobUxSICogbXNmaXggPCB0aG1NICsgdGhtUykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IHRobUxSICogbXNmaXggLyAodGhtTSArIHRobVMpO1xuICAgICAgICAgICAgICAgICAgICB0aG1NICo9IGY7XG4gICAgICAgICAgICAgICAgICAgIHRobVMgKj0gZjtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KHRobU0gKyB0aG1TID4gMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdmYy50aG1bMl0uc1tzYl1bc2Jsb2NrXSA9IE1hdGgubWluKGdmYy50aG1bMl0uc1tzYl1bc2Jsb2NrXSxcbiAgICAgICAgICAgICAgICAgICAgdGhtTSk7XG4gICAgICAgICAgICAgICAgZ2ZjLnRobVszXS5zW3NiXVtzYmxvY2tdID0gTWF0aC5taW4oZ2ZjLnRobVszXS5zW3NiXVtzYmxvY2tdLFxuICAgICAgICAgICAgICAgICAgICB0aG1TKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNob3J0IGJsb2NrIHRocmVzaG9sZCBjYWxjdWxhdGlvbiAocGFydCAyKVxuICAgICAqXG4gICAgICogcGFydGl0aW9uIGJhbmQgYm9fc1tzZmJdIGlzIGF0IHRoZSB0cmFuc2l0aW9uIGZyb20gc2NhbGVmYWN0b3IgYmFuZCBzZmJcbiAgICAgKiB0byB0aGUgbmV4dCBvbmUgc2ZiKzE7IGVubiBhbmQgdGhtbSBoYXZlIHRvIGJlIHNwbGl0IGJldHdlZW4gdGhlbVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnZlcnRfcGFydGl0aW9uMnNjYWxlZmFjX3MoZ2ZjLCBlYiwgdGhyLCBjaG4sIHNibG9jaykge1xuICAgICAgICB2YXIgc2IsIGI7XG4gICAgICAgIHZhciBlbm4gPSAwLjA7XG4gICAgICAgIHZhciB0aG1tID0gMC4wO1xuICAgICAgICBmb3IgKHNiID0gYiA9IDA7IHNiIDwgRW5jb2Rlci5TQk1BWF9zOyArK2IsICsrc2IpIHtcbiAgICAgICAgICAgIHZhciBib19zX3NiID0gZ2ZjLmJvX3Nbc2JdO1xuICAgICAgICAgICAgdmFyIG5wYXJ0X3MgPSBnZmMubnBhcnRfcztcbiAgICAgICAgICAgIHZhciBiX2xpbSA9IGJvX3Nfc2IgPCBucGFydF9zID8gYm9fc19zYiA6IG5wYXJ0X3M7XG4gICAgICAgICAgICB3aGlsZSAoYiA8IGJfbGltKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGViW2JdID49IDApO1xuICAgICAgICAgICAgICAgIC8vIGlmZiBmYWlsZWQsIGl0IG1heSBpbmRpY2F0ZSBzb21lIGluZGV4IGVycm9yIGVsc2V3aGVyZVxuICAgICAgICAgICAgICAgIGFzc2VydCh0aHJbYl0gPj0gMCk7XG4gICAgICAgICAgICAgICAgZW5uICs9IGViW2JdO1xuICAgICAgICAgICAgICAgIHRobW0gKz0gdGhyW2JdO1xuICAgICAgICAgICAgICAgIGIrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdmYy5lbltjaG5dLnNbc2JdW3NibG9ja10gPSBlbm47XG4gICAgICAgICAgICBnZmMudGhtW2Nobl0uc1tzYl1bc2Jsb2NrXSA9IHRobW07XG5cbiAgICAgICAgICAgIGlmIChiID49IG5wYXJ0X3MpIHtcbiAgICAgICAgICAgICAgICArK3NiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0KGViW2JdID49IDApO1xuICAgICAgICAgICAgLy8gaWZmIGZhaWxlZCwgaXQgbWF5IGluZGljYXRlIHNvbWUgaW5kZXggZXJyb3IgZWxzZXdoZXJlXG4gICAgICAgICAgICBhc3NlcnQodGhyW2JdID49IDApO1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8qIGF0IHRyYW5zaXRpb24gc2ZiIC4gc2ZiKzEgKi9cbiAgICAgICAgICAgICAgICB2YXIgd19jdXJyID0gZ2ZjLlBTWS5ib19zX3dlaWdodFtzYl07XG4gICAgICAgICAgICAgICAgdmFyIHdfbmV4dCA9IDEuMCAtIHdfY3VycjtcbiAgICAgICAgICAgICAgICBlbm4gPSB3X2N1cnIgKiBlYltiXTtcbiAgICAgICAgICAgICAgICB0aG1tID0gd19jdXJyICogdGhyW2JdO1xuICAgICAgICAgICAgICAgIGdmYy5lbltjaG5dLnNbc2JdW3NibG9ja10gKz0gZW5uO1xuICAgICAgICAgICAgICAgIGdmYy50aG1bY2huXS5zW3NiXVtzYmxvY2tdICs9IHRobW07XG4gICAgICAgICAgICAgICAgZW5uID0gd19uZXh0ICogZWJbYl07XG4gICAgICAgICAgICAgICAgdGhtbSA9IHdfbmV4dCAqIHRocltiXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKiB6ZXJvIGluaXRpYWxpemUgdGhlIHJlc3QgKi9cbiAgICAgICAgZm9yICg7IHNiIDwgRW5jb2Rlci5TQk1BWF9zOyArK3NiKSB7XG4gICAgICAgICAgICBnZmMuZW5bY2huXS5zW3NiXVtzYmxvY2tdID0gMDtcbiAgICAgICAgICAgIGdmYy50aG1bY2huXS5zW3NiXVtzYmxvY2tdID0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGxvbmdibG9jayB0aHJlc2hvbGQgY2FsY3VsYXRpb24gKHBhcnQgMilcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb252ZXJ0X3BhcnRpdGlvbjJzY2FsZWZhY19sKGdmYywgZWIsIHRociwgY2huKSB7XG4gICAgICAgIHZhciBzYiwgYjtcbiAgICAgICAgdmFyIGVubiA9IDAuMDtcbiAgICAgICAgdmFyIHRobW0gPSAwLjA7XG4gICAgICAgIGZvciAoc2IgPSBiID0gMDsgc2IgPCBFbmNvZGVyLlNCTUFYX2w7ICsrYiwgKytzYikge1xuICAgICAgICAgICAgdmFyIGJvX2xfc2IgPSBnZmMuYm9fbFtzYl07XG4gICAgICAgICAgICB2YXIgbnBhcnRfbCA9IGdmYy5ucGFydF9sO1xuICAgICAgICAgICAgdmFyIGJfbGltID0gYm9fbF9zYiA8IG5wYXJ0X2wgPyBib19sX3NiIDogbnBhcnRfbDtcbiAgICAgICAgICAgIHdoaWxlIChiIDwgYl9saW0pIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQoZWJbYl0gPj0gMCk7XG4gICAgICAgICAgICAgICAgLy8gaWZmIGZhaWxlZCwgaXQgbWF5IGluZGljYXRlIHNvbWUgaW5kZXggZXJyb3IgZWxzZXdoZXJlXG4gICAgICAgICAgICAgICAgYXNzZXJ0KHRocltiXSA+PSAwKTtcbiAgICAgICAgICAgICAgICBlbm4gKz0gZWJbYl07XG4gICAgICAgICAgICAgICAgdGhtbSArPSB0aHJbYl07XG4gICAgICAgICAgICAgICAgYisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2ZjLmVuW2Nobl0ubFtzYl0gPSBlbm47XG4gICAgICAgICAgICBnZmMudGhtW2Nobl0ubFtzYl0gPSB0aG1tO1xuXG4gICAgICAgICAgICBpZiAoYiA+PSBucGFydF9sKSB7XG4gICAgICAgICAgICAgICAgKytzYjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydChlYltiXSA+PSAwKTtcbiAgICAgICAgICAgIGFzc2VydCh0aHJbYl0gPj0gMCk7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLyogYXQgdHJhbnNpdGlvbiBzZmIgLiBzZmIrMSAqL1xuICAgICAgICAgICAgICAgIHZhciB3X2N1cnIgPSBnZmMuUFNZLmJvX2xfd2VpZ2h0W3NiXTtcbiAgICAgICAgICAgICAgICB2YXIgd19uZXh0ID0gMS4wIC0gd19jdXJyO1xuICAgICAgICAgICAgICAgIGVubiA9IHdfY3VyciAqIGViW2JdO1xuICAgICAgICAgICAgICAgIHRobW0gPSB3X2N1cnIgKiB0aHJbYl07XG4gICAgICAgICAgICAgICAgZ2ZjLmVuW2Nobl0ubFtzYl0gKz0gZW5uO1xuICAgICAgICAgICAgICAgIGdmYy50aG1bY2huXS5sW3NiXSArPSB0aG1tO1xuICAgICAgICAgICAgICAgIGVubiA9IHdfbmV4dCAqIGViW2JdO1xuICAgICAgICAgICAgICAgIHRobW0gPSB3X25leHQgKiB0aHJbYl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyogemVybyBpbml0aWFsaXplIHRoZSByZXN0ICovXG4gICAgICAgIGZvciAoOyBzYiA8IEVuY29kZXIuU0JNQVhfbDsgKytzYikge1xuICAgICAgICAgICAgZ2ZjLmVuW2Nobl0ubFtzYl0gPSAwO1xuICAgICAgICAgICAgZ2ZjLnRobVtjaG5dLmxbc2JdID0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVfbWFza2luZ19zKGdmcCwgZmZ0ZW5lcmd5X3MsIGViLCB0aHIsIGNobiwgc2Jsb2NrKSB7XG4gICAgICAgIHZhciBnZmMgPSBnZnAuaW50ZXJuYWxfZmxhZ3M7XG4gICAgICAgIHZhciBqLCBiO1xuXG4gICAgICAgIGZvciAoYiA9IGogPSAwOyBiIDwgZ2ZjLm5wYXJ0X3M7ICsrYikge1xuICAgICAgICAgICAgdmFyIGViYiA9IDAsIG0gPSAwO1xuICAgICAgICAgICAgdmFyIG4gPSBnZmMubnVtbGluZXNfc1tiXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpLCArK2opIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBmZnRlbmVyZ3lfc1tzYmxvY2tdW2pdO1xuICAgICAgICAgICAgICAgIGViYiArPSBlbDtcbiAgICAgICAgICAgICAgICBpZiAobSA8IGVsKVxuICAgICAgICAgICAgICAgICAgICBtID0gZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlYltiXSA9IGViYjtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoYiA9PSBnZmMubnBhcnRfcyk7XG4gICAgICAgIGFzc2VydChqID09IDEyOSk7XG4gICAgICAgIGZvciAoaiA9IGIgPSAwOyBiIDwgZ2ZjLm5wYXJ0X3M7IGIrKykge1xuICAgICAgICAgICAgdmFyIGtrID0gZ2ZjLnMzaW5kX3NbYl1bMF07XG4gICAgICAgICAgICB2YXIgZWNiID0gZ2ZjLnMzX3NzW2orK10gKiBlYltra107XG4gICAgICAgICAgICArK2trO1xuICAgICAgICAgICAgd2hpbGUgKGtrIDw9IGdmYy5zM2luZF9zW2JdWzFdKSB7XG4gICAgICAgICAgICAgICAgZWNiICs9IGdmYy5zM19zc1tqXSAqIGViW2trXTtcbiAgICAgICAgICAgICAgICArK2o7XG4gICAgICAgICAgICAgICAgKytraztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeyAvKiBsaW1pdCBjYWxjdWxhdGVkIHRocmVzaG9sZCBieSBwcmV2aW91cyBncmFudWxlICovXG4gICAgICAgICAgICAgICAgdmFyIHggPSBycGVsZXZfcyAqIGdmYy5uYl9zMVtjaG5dW2JdO1xuICAgICAgICAgICAgICAgIHRocltiXSA9IE1hdGgubWluKGVjYiwgeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2ZjLmJsb2NrdHlwZV9vbGRbY2huICYgMV0gPT0gRW5jb2Rlci5TSE9SVF9UWVBFKSB7XG4gICAgICAgICAgICAgICAgLyogbGltaXQgY2FsY3VsYXRlZCB0aHJlc2hvbGQgYnkgZXZlbiBvbGRlciBncmFudWxlICovXG4gICAgICAgICAgICAgICAgdmFyIHggPSBycGVsZXYyX3MgKiBnZmMubmJfczJbY2huXVtiXTtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHRocltiXTtcbiAgICAgICAgICAgICAgICB0aHJbYl0gPSBNYXRoLm1pbih4LCB5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2ZjLm5iX3MyW2Nobl1bYl0gPSBnZmMubmJfczFbY2huXVtiXTtcbiAgICAgICAgICAgIGdmYy5uYl9zMVtjaG5dW2JdID0gZWNiO1xuICAgICAgICAgICAgYXNzZXJ0KHRocltiXSA+PSAwKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgYiA8PSBFbmNvZGVyLkNCQU5EUzsgKytiKSB7XG4gICAgICAgICAgICBlYltiXSA9IDA7XG4gICAgICAgICAgICB0aHJbYl0gPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYmxvY2tfdHlwZV9zZXQoZ2ZwLCB1c2Vsb25nYmxvY2ssIGJsb2NrdHlwZV9kLCBibG9ja3R5cGUpIHtcbiAgICAgICAgdmFyIGdmYyA9IGdmcC5pbnRlcm5hbF9mbGFncztcblxuICAgICAgICBpZiAoZ2ZwLnNob3J0X2Jsb2NrcyA9PSBTaG9ydEJsb2NrLnNob3J0X2Jsb2NrX2NvdXBsZWRcbiAgICAgICAgICAgICAgICAvKiBmb3JjZSBib3RoIGNoYW5uZWxzIHRvIHVzZSB0aGUgc2FtZSBibG9jayB0eXBlICovXG4gICAgICAgICAgICAgICAgLyogdGhpcyBpcyBuZWNlc3NhcnkgaWYgdGhlIGZyYW1lIGlzIHRvIGJlIGVuY29kZWQgaW4gbXNfc3RlcmVvLiAqL1xuICAgICAgICAgICAgICAgIC8qIEJ1dCBldmVuIHdpdGhvdXQgbXNfc3RlcmVvLCBGaEcgZG9lcyB0aGlzICovXG4gICAgICAgICAgICAmJiAhKHVzZWxvbmdibG9ja1swXSAhPSAwICYmIHVzZWxvbmdibG9ja1sxXSAhPSAwKSlcbiAgICAgICAgICAgIHVzZWxvbmdibG9ja1swXSA9IHVzZWxvbmdibG9ja1sxXSA9IDA7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogdXBkYXRlIHRoZSBibG9ja3R5cGUgb2YgdGhlIHByZXZpb3VzIGdyYW51bGUsIHNpbmNlIGl0IGRlcGVuZHMgb25cbiAgICAgICAgICogd2hhdCBoYXBwZW5kIGluIHRoaXMgZ3JhbnVsZVxuICAgICAgICAgKi9cbiAgICAgICAgZm9yICh2YXIgY2huID0gMDsgY2huIDwgZ2ZjLmNoYW5uZWxzX291dDsgY2huKyspIHtcbiAgICAgICAgICAgIGJsb2NrdHlwZVtjaG5dID0gRW5jb2Rlci5OT1JNX1RZUEU7XG4gICAgICAgICAgICAvKiBkaXNhYmxlIHNob3J0IGJsb2NrcyAqL1xuICAgICAgICAgICAgaWYgKGdmcC5zaG9ydF9ibG9ja3MgPT0gU2hvcnRCbG9jay5zaG9ydF9ibG9ja19kaXNwZW5zZWQpXG4gICAgICAgICAgICAgICAgdXNlbG9uZ2Jsb2NrW2Nobl0gPSAxO1xuICAgICAgICAgICAgaWYgKGdmcC5zaG9ydF9ibG9ja3MgPT0gU2hvcnRCbG9jay5zaG9ydF9ibG9ja19mb3JjZWQpXG4gICAgICAgICAgICAgICAgdXNlbG9uZ2Jsb2NrW2Nobl0gPSAwO1xuXG4gICAgICAgICAgICBpZiAodXNlbG9uZ2Jsb2NrW2Nobl0gIT0gMCkge1xuICAgICAgICAgICAgICAgIC8qIG5vIGF0dGFjayA6IHVzZSBsb25nIGJsb2NrcyAqL1xuICAgICAgICAgICAgICAgIGFzc2VydChnZmMuYmxvY2t0eXBlX29sZFtjaG5dICE9IEVuY29kZXIuU1RBUlRfVFlQRSk7XG4gICAgICAgICAgICAgICAgaWYgKGdmYy5ibG9ja3R5cGVfb2xkW2Nobl0gPT0gRW5jb2Rlci5TSE9SVF9UWVBFKVxuICAgICAgICAgICAgICAgICAgICBibG9ja3R5cGVbY2huXSA9IEVuY29kZXIuU1RPUF9UWVBFO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKiBhdHRhY2sgOiB1c2Ugc2hvcnQgYmxvY2tzICovXG4gICAgICAgICAgICAgICAgYmxvY2t0eXBlW2Nobl0gPSBFbmNvZGVyLlNIT1JUX1RZUEU7XG4gICAgICAgICAgICAgICAgaWYgKGdmYy5ibG9ja3R5cGVfb2xkW2Nobl0gPT0gRW5jb2Rlci5OT1JNX1RZUEUpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2ZjLmJsb2NrdHlwZV9vbGRbY2huXSA9IEVuY29kZXIuU1RBUlRfVFlQRTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGdmYy5ibG9ja3R5cGVfb2xkW2Nobl0gPT0gRW5jb2Rlci5TVE9QX1RZUEUpXG4gICAgICAgICAgICAgICAgICAgIGdmYy5ibG9ja3R5cGVfb2xkW2Nobl0gPSBFbmNvZGVyLlNIT1JUX1RZUEU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJsb2NrdHlwZV9kW2Nobl0gPSBnZmMuYmxvY2t0eXBlX29sZFtjaG5dO1xuICAgICAgICAgICAgLy8gdmFsdWUgcmV0dXJuZWQgdG8gY2FsbGluZyBwcm9ncmFtXG4gICAgICAgICAgICBnZmMuYmxvY2t0eXBlX29sZFtjaG5dID0gYmxvY2t0eXBlW2Nobl07XG4gICAgICAgICAgICAvLyBzYXZlIGZvciBuZXh0IGNhbGwgdG8gbDNwc3lfYW5hbFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTlNfSU5URVJQKHgsIHksIHIpIHtcbiAgICAgICAgLyogd2FzIHBvdygoeCksKHIpKSpwb3coKHkpLDEtKHIpKSAqL1xuICAgICAgICBpZiAociA+PSAxLjApIHtcbiAgICAgICAgICAgIC8qIDk5LjclIG9mIHRoZSB0aW1lICovXG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfVxuICAgICAgICBpZiAociA8PSAwLjApXG4gICAgICAgICAgICByZXR1cm4geTtcbiAgICAgICAgaWYgKHkgPiAwLjApIHtcbiAgICAgICAgICAgIC8qIHJlc3Qgb2YgdGhlIHRpbWUgKi9cbiAgICAgICAgICAgIHJldHVybiAoTWF0aC5wb3coeCAvIHksIHIpICogeSk7XG4gICAgICAgIH1cbiAgICAgICAgLyogbmV2ZXIgaGFwcGVucyAqL1xuICAgICAgICByZXR1cm4gMC4wO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRoZXNlIHZhbHVlcyBhcmUgdHVuZWQgb25seSBmb3IgNDQuMWtIei4uLlxuICAgICAqL1xuICAgIHZhciByZWdjb2VmX3MgPSBbMTEuOCwgMTMuNiwgMTcuMiwgMzIsIDQ2LjUsXG4gICAgICAgIDUxLjMsIDU3LjUsIDY3LjEsIDcxLjUsIDg0LjYsIDk3LjYsIDEzMCxcbiAgICAgICAgLyogMjU1LjggKi9cbiAgICBdO1xuXG4gICAgZnVuY3Rpb24gcGVjYWxjX3MobXIsIG1hc2tpbmdfbG93ZXIpIHtcbiAgICAgICAgdmFyIHBlX3MgPSAxMjM2LjI4IC8gNDtcbiAgICAgICAgZm9yICh2YXIgc2IgPSAwOyBzYiA8IEVuY29kZXIuU0JNQVhfcyAtIDE7IHNiKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIHNibG9jayA9IDA7IHNibG9jayA8IDM7IHNibG9jaysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRobSA9IG1yLnRobS5zW3NiXVtzYmxvY2tdO1xuICAgICAgICAgICAgICAgIGFzc2VydChzYiA8IHJlZ2NvZWZfcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmICh0aG0gPiAwLjApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSB0aG0gKiBtYXNraW5nX2xvd2VyO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW4gPSBtci5lbi5zW3NiXVtzYmxvY2tdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW4gPiB4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW4gPiB4ICogMWUxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlX3MgKz0gcmVnY29lZl9zW3NiXSAqICgxMC4wICogTE9HMTApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQoeCA+IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlX3MgKz0gcmVnY29lZl9zW3NiXSAqIFV0aWwuRkFTVF9MT0cxMChlbiAvIHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBlX3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdGhlc2UgdmFsdWVzIGFyZSB0dW5lZCBvbmx5IGZvciA0NC4xa0h6Li4uXG4gICAgICovXG4gICAgdmFyIHJlZ2NvZWZfbCA9IFs2LjgsIDUuOCwgNS44LCA2LjQsIDYuNSwgOS45LFxuICAgICAgICAxMi4xLCAxNC40LCAxNSwgMTguOSwgMjEuNiwgMjYuOSwgMzQuMiwgNDAuMiwgNDYuOCwgNTYuNSxcbiAgICAgICAgNjAuNywgNzMuOSwgODUuNywgOTMuNCwgMTI2LjEsXG4gICAgICAgIC8qIDI0MS4zICovXG4gICAgXTtcblxuICAgIGZ1bmN0aW9uIHBlY2FsY19sKG1yLCBtYXNraW5nX2xvd2VyKSB7XG4gICAgICAgIHZhciBwZV9sID0gMTEyNC4yMyAvIDQ7XG4gICAgICAgIGZvciAodmFyIHNiID0gMDsgc2IgPCBFbmNvZGVyLlNCTUFYX2wgLSAxOyBzYisrKSB7XG4gICAgICAgICAgICB2YXIgdGhtID0gbXIudGhtLmxbc2JdO1xuICAgICAgICAgICAgYXNzZXJ0KHNiIDwgcmVnY29lZl9sLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAodGhtID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgdmFyIHggPSB0aG0gKiBtYXNraW5nX2xvd2VyO1xuICAgICAgICAgICAgICAgIHZhciBlbiA9IG1yLmVuLmxbc2JdO1xuICAgICAgICAgICAgICAgIGlmIChlbiA+IHgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuID4geCAqIDFlMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlX2wgKz0gcmVnY29lZl9sW3NiXSAqICgxMC4wICogTE9HMTApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KHggPiAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlX2wgKz0gcmVnY29lZl9sW3NiXSAqIFV0aWwuRkFTVF9MT0cxMChlbiAvIHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwZV9sO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGNfZW5lcmd5KGdmYywgZmZ0ZW5lcmd5LCBlYiwgbWF4LCBhdmcpIHtcbiAgICAgICAgdmFyIGIsIGo7XG5cbiAgICAgICAgZm9yIChiID0gaiA9IDA7IGIgPCBnZmMubnBhcnRfbDsgKytiKSB7XG4gICAgICAgICAgICB2YXIgZWJiID0gMCwgbSA9IDA7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBnZmMubnVtbGluZXNfbFtiXTsgKytpLCArK2opIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBmZnRlbmVyZ3lbal07XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGVsID49IDApO1xuICAgICAgICAgICAgICAgIGViYiArPSBlbDtcbiAgICAgICAgICAgICAgICBpZiAobSA8IGVsKVxuICAgICAgICAgICAgICAgICAgICBtID0gZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlYltiXSA9IGViYjtcbiAgICAgICAgICAgIG1heFtiXSA9IG07XG4gICAgICAgICAgICBhdmdbYl0gPSBlYmIgKiBnZmMucm51bWxpbmVzX2xbYl07XG4gICAgICAgICAgICBhc3NlcnQoZ2ZjLnJudW1saW5lc19sW2JdID49IDApO1xuICAgICAgICAgICAgYXNzZXJ0KGViYiA+PSAwKTtcbiAgICAgICAgICAgIGFzc2VydChlYltiXSA+PSAwKTtcbiAgICAgICAgICAgIGFzc2VydChtYXhbYl0gPj0gMCk7XG4gICAgICAgICAgICBhc3NlcnQoYXZnW2JdID49IDApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsY19tYXNrX2luZGV4X2woZ2ZjLCBtYXgsIGF2ZywgbWFza19pZHgpIHtcbiAgICAgICAgdmFyIGxhc3RfdGFiX2VudHJ5ID0gdGFiLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBiID0gMDtcbiAgICAgICAgdmFyIGEgPSBhdmdbYl0gKyBhdmdbYiArIDFdO1xuICAgICAgICBhc3NlcnQoYSA+PSAwKTtcbiAgICAgICAgaWYgKGEgPiAwLjApIHtcbiAgICAgICAgICAgIHZhciBtID0gbWF4W2JdO1xuICAgICAgICAgICAgaWYgKG0gPCBtYXhbYiArIDFdKVxuICAgICAgICAgICAgICAgIG0gPSBtYXhbYiArIDFdO1xuICAgICAgICAgICAgYXNzZXJ0KChnZmMubnVtbGluZXNfbFtiXSArIGdmYy5udW1saW5lc19sW2IgKyAxXSAtIDEpID4gMCk7XG4gICAgICAgICAgICBhID0gMjAuMCAqIChtICogMi4wIC0gYSlcbiAgICAgICAgICAgICAgICAvIChhICogKGdmYy5udW1saW5lc19sW2JdICsgZ2ZjLm51bWxpbmVzX2xbYiArIDFdIC0gMSkpO1xuICAgICAgICAgICAgdmFyIGsgPSAwIHwgYTtcbiAgICAgICAgICAgIGlmIChrID4gbGFzdF90YWJfZW50cnkpXG4gICAgICAgICAgICAgICAgayA9IGxhc3RfdGFiX2VudHJ5O1xuICAgICAgICAgICAgbWFza19pZHhbYl0gPSBrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFza19pZHhbYl0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChiID0gMTsgYiA8IGdmYy5ucGFydF9sIC0gMTsgYisrKSB7XG4gICAgICAgICAgICBhID0gYXZnW2IgLSAxXSArIGF2Z1tiXSArIGF2Z1tiICsgMV07XG4gICAgICAgICAgICBhc3NlcnQoYSA+PSAwKTtcbiAgICAgICAgICAgIGlmIChhID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgdmFyIG0gPSBtYXhbYiAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChtIDwgbWF4W2JdKVxuICAgICAgICAgICAgICAgICAgICBtID0gbWF4W2JdO1xuICAgICAgICAgICAgICAgIGlmIChtIDwgbWF4W2IgKyAxXSlcbiAgICAgICAgICAgICAgICAgICAgbSA9IG1heFtiICsgMV07XG4gICAgICAgICAgICAgICAgYXNzZXJ0KChnZmMubnVtbGluZXNfbFtiIC0gMV0gKyBnZmMubnVtbGluZXNfbFtiXSArIGdmYy5udW1saW5lc19sW2IgKyAxXSAtIDEpID4gMCk7XG4gICAgICAgICAgICAgICAgYSA9IDIwLjBcbiAgICAgICAgICAgICAgICAgICAgKiAobSAqIDMuMCAtIGEpXG4gICAgICAgICAgICAgICAgICAgIC8gKGEgKiAoZ2ZjLm51bWxpbmVzX2xbYiAtIDFdICsgZ2ZjLm51bWxpbmVzX2xbYl1cbiAgICAgICAgICAgICAgICAgICAgKyBnZmMubnVtbGluZXNfbFtiICsgMV0gLSAxKSk7XG4gICAgICAgICAgICAgICAgdmFyIGsgPSAwIHwgYTtcbiAgICAgICAgICAgICAgICBpZiAoayA+IGxhc3RfdGFiX2VudHJ5KVxuICAgICAgICAgICAgICAgICAgICBrID0gbGFzdF90YWJfZW50cnk7XG4gICAgICAgICAgICAgICAgbWFza19pZHhbYl0gPSBrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXNrX2lkeFtiXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KGIgPiAwKTtcbiAgICAgICAgYXNzZXJ0KGIgPT0gZ2ZjLm5wYXJ0X2wgLSAxKTtcblxuICAgICAgICBhID0gYXZnW2IgLSAxXSArIGF2Z1tiXTtcbiAgICAgICAgYXNzZXJ0KGEgPj0gMCk7XG4gICAgICAgIGlmIChhID4gMC4wKSB7XG4gICAgICAgICAgICB2YXIgbSA9IG1heFtiIC0gMV07XG4gICAgICAgICAgICBpZiAobSA8IG1heFtiXSlcbiAgICAgICAgICAgICAgICBtID0gbWF4W2JdO1xuICAgICAgICAgICAgYXNzZXJ0KChnZmMubnVtbGluZXNfbFtiIC0gMV0gKyBnZmMubnVtbGluZXNfbFtiXSAtIDEpID4gMCk7XG4gICAgICAgICAgICBhID0gMjAuMCAqIChtICogMi4wIC0gYSlcbiAgICAgICAgICAgICAgICAvIChhICogKGdmYy5udW1saW5lc19sW2IgLSAxXSArIGdmYy5udW1saW5lc19sW2JdIC0gMSkpO1xuICAgICAgICAgICAgdmFyIGsgPSAwIHwgYTtcbiAgICAgICAgICAgIGlmIChrID4gbGFzdF90YWJfZW50cnkpXG4gICAgICAgICAgICAgICAgayA9IGxhc3RfdGFiX2VudHJ5O1xuICAgICAgICAgICAgbWFza19pZHhbYl0gPSBrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFza19pZHhbYl0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChiID09IChnZmMubnBhcnRfbCAtIDEpKTtcbiAgICB9XG5cbiAgICB2YXIgZmlyY29lZiA9IFtcbiAgICAgICAgLTguNjUxNjNlLTE4ICogMiwgLTAuMDA4NTE1ODYgKiAyLCAtNi43NDc2NGUtMTggKiAyLCAwLjAyMDkwMzYgKiAyLFxuICAgICAgICAtMy4zNjYzOWUtMTcgKiAyLCAtMC4wNDM4MTYyICogMiwgLTEuNTQxNzVlLTE3ICogMiwgMC4wOTMxNzM4ICogMixcbiAgICAgICAgLTUuNTIyMTJlLTE3ICogMiwgLTAuMzEzODE5ICogMlxuICAgIF07XG5cbiAgICB0aGlzLkwzcHN5Y2hvX2FuYWxfbnMgPSBmdW5jdGlvbiAoZ2ZwLCBidWZmZXIsIGJ1ZlBvcywgZ3Jfb3V0LCBtYXNraW5nX3JhdGlvLCBtYXNraW5nX01TX3JhdGlvLCBwZXJjZXBfZW50cm9weSwgcGVyY2VwX01TX2VudHJvcHksIGVuZXJneSwgYmxvY2t0eXBlX2QpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogdG8gZ2V0IGEgZ29vZCBjYWNoZSBwZXJmb3JtYW5jZSwgb25lIGhhcyB0byB0aGluayBhYm91dCB0aGUgc2VxdWVuY2UsXG4gICAgICAgICAqIGluIHdoaWNoIHRoZSB2YXJpYWJsZXMgYXJlIHVzZWQuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgZ2ZjID0gZ2ZwLmludGVybmFsX2ZsYWdzO1xuXG4gICAgICAgIC8qIGZmdCBhbmQgZW5lcmd5IGNhbGN1bGF0aW9uICovXG4gICAgICAgIHZhciB3c2FtcF9MID0gbmV3X2Zsb2F0X24oWzIsIEVuY29kZXIuQkxLU0laRV0pO1xuICAgICAgICB2YXIgd3NhbXBfUyA9IG5ld19mbG9hdF9uKFsyLCAzLCBFbmNvZGVyLkJMS1NJWkVfc10pO1xuXG4gICAgICAgIC8qIGNvbnZvbHV0aW9uICovXG4gICAgICAgIHZhciBlYl9sID0gbmV3X2Zsb2F0KEVuY29kZXIuQ0JBTkRTICsgMSk7XG4gICAgICAgIHZhciBlYl9zID0gbmV3X2Zsb2F0KEVuY29kZXIuQ0JBTkRTICsgMSk7XG4gICAgICAgIHZhciB0aHIgPSBuZXdfZmxvYXQoRW5jb2Rlci5DQkFORFMgKyAyKTtcblxuICAgICAgICAvKiBibG9jayB0eXBlICovXG4gICAgICAgIHZhciBibG9ja3R5cGUgPSBuZXdfaW50KDIpLCB1c2Vsb25nYmxvY2sgPSBuZXdfaW50KDIpO1xuXG4gICAgICAgIC8qIHVzdWFsIHZhcmlhYmxlcyBsaWtlIGxvb3AgaW5kaWNlcywgZXRjLi4gKi9cbiAgICAgICAgdmFyIG51bWNobiwgY2huO1xuICAgICAgICB2YXIgYiwgaSwgaiwgaztcbiAgICAgICAgdmFyIHNiLCBzYmxvY2s7XG5cbiAgICAgICAgLyogdmFyaWFibGVzIHVzZWQgZm9yIC0tbnNwc3l0dW5lICovXG4gICAgICAgIHZhciBuc19ocGZzbXBsID0gbmV3X2Zsb2F0X24oWzIsIDU3Nl0pO1xuICAgICAgICB2YXIgcGNmYWN0O1xuICAgICAgICB2YXIgbWFza19pZHhfbCA9IG5ld19pbnQoRW5jb2Rlci5DQkFORFMgKyAyKSwgbWFza19pZHhfcyA9IG5ld19pbnQoRW5jb2Rlci5DQkFORFMgKyAyKTtcblxuICAgICAgICBBcnJheXMuZmlsbChtYXNrX2lkeF9zLCAwKTtcblxuICAgICAgICBudW1jaG4gPSBnZmMuY2hhbm5lbHNfb3V0O1xuICAgICAgICAvKiBjaG49MiBhbmQgMyA9IE1pZCBhbmQgU2lkZSBjaGFubmVscyAqL1xuICAgICAgICBpZiAoZ2ZwLm1vZGUgPT0gTVBFR01vZGUuSk9JTlRfU1RFUkVPKVxuICAgICAgICAgICAgbnVtY2huID0gNDtcblxuICAgICAgICBpZiAoZ2ZwLlZCUiA9PSBWYnJNb2RlLnZicl9vZmYpXG4gICAgICAgICAgICBwY2ZhY3QgPSBnZmMuUmVzdk1heCA9PSAwID8gMCA6ICggZ2ZjLlJlc3ZTaXplKVxuICAgICAgICAgICAgLyBnZmMuUmVzdk1heCAqIDAuNTtcbiAgICAgICAgZWxzZSBpZiAoZ2ZwLlZCUiA9PSBWYnJNb2RlLnZicl9yaCB8fCBnZnAuVkJSID09IFZick1vZGUudmJyX210cmhcbiAgICAgICAgICAgIHx8IGdmcC5WQlIgPT0gVmJyTW9kZS52YnJfbXQpIHtcbiAgICAgICAgICAgIHBjZmFjdCA9IDAuNjtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBwY2ZhY3QgPSAxLjA7XG5cbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgICogQXBwbHkgSFBGIG9mIGZzLzQgdG8gdGhlIGlucHV0IHNpZ25hbC4gVGhpcyBpcyB1c2VkIGZvciBhdHRhY2tcbiAgICAgICAgICogZGV0ZWN0aW9uIC8gaGFuZGxpbmcuXG4gICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKiBEb24ndCBjb3B5IHRoZSBpbnB1dCBidWZmZXIgaW50byBhIHRlbXBvcmFyeSBidWZmZXIgKi9cbiAgICAgICAgLyogdW5yb2xsIHRoZSBsb29wIDIgdGltZXMgKi9cbiAgICAgICAgZm9yIChjaG4gPSAwOyBjaG4gPCBnZmMuY2hhbm5lbHNfb3V0OyBjaG4rKykge1xuICAgICAgICAgICAgLyogYXBwbHkgaGlnaCBwYXNzIGZpbHRlciBvZiBmcy80ICovXG4gICAgICAgICAgICB2YXIgZmlyYnVmID0gYnVmZmVyW2Nobl07XG4gICAgICAgICAgICB2YXIgZmlyYnVmUG9zID0gYnVmUG9zICsgNTc2IC0gMzUwIC0gTlNGSVJMRU4gKyAxOTI7XG4gICAgICAgICAgICBhc3NlcnQoZmlyY29lZi5sZW5ndGggPT0gKChOU0ZJUkxFTiAtIDEpIC8gMikpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDU3NjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1bTEsIHN1bTI7XG4gICAgICAgICAgICAgICAgc3VtMSA9IGZpcmJ1ZltmaXJidWZQb3MgKyBpICsgMTBdO1xuICAgICAgICAgICAgICAgIHN1bTIgPSAwLjA7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8ICgoTlNGSVJMRU4gLSAxKSAvIDIpIC0gMTsgaiArPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bTEgKz0gZmlyY29lZltqXVxuICAgICAgICAgICAgICAgICAgICAgICAgKiAoZmlyYnVmW2ZpcmJ1ZlBvcyArIGkgKyBqXSArIGZpcmJ1ZltmaXJidWZQb3MgKyBpXG4gICAgICAgICAgICAgICAgICAgICAgICArIE5TRklSTEVOIC0gal0pO1xuICAgICAgICAgICAgICAgICAgICBzdW0yICs9IGZpcmNvZWZbaiArIDFdXG4gICAgICAgICAgICAgICAgICAgICAgICAqIChmaXJidWZbZmlyYnVmUG9zICsgaSArIGogKyAxXSArIGZpcmJ1ZltmaXJidWZQb3NcbiAgICAgICAgICAgICAgICAgICAgICAgICsgaSArIE5TRklSTEVOIC0gaiAtIDFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbnNfaHBmc21wbFtjaG5dW2ldID0gc3VtMSArIHN1bTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXNraW5nX3JhdGlvW2dyX291dF1bY2huXS5lbi5hc3NpZ24oZ2ZjLmVuW2Nobl0pO1xuICAgICAgICAgICAgbWFza2luZ19yYXRpb1tncl9vdXRdW2Nobl0udGhtLmFzc2lnbihnZmMudGhtW2Nobl0pO1xuICAgICAgICAgICAgaWYgKG51bWNobiA+IDIpIHtcbiAgICAgICAgICAgICAgICAvKiBNUyBtYXNraW5ncyAqL1xuICAgICAgICAgICAgICAgIC8qIHBlcmNlcF9NU19lbnRyb3B5IFtjaG4tMl0gPSBnZmMgLiBwZSBbY2huXTsgKi9cbiAgICAgICAgICAgICAgICBtYXNraW5nX01TX3JhdGlvW2dyX291dF1bY2huXS5lbi5hc3NpZ24oZ2ZjLmVuW2NobiArIDJdKTtcbiAgICAgICAgICAgICAgICBtYXNraW5nX01TX3JhdGlvW2dyX291dF1bY2huXS50aG0uYXNzaWduKGdmYy50aG1bY2huICsgMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjaG4gPSAwOyBjaG4gPCBudW1jaG47IGNobisrKSB7XG4gICAgICAgICAgICB2YXIgd3NhbXBfbDtcbiAgICAgICAgICAgIHZhciB3c2FtcF9zO1xuICAgICAgICAgICAgdmFyIGVuX3N1YnNob3J0ID0gbmV3X2Zsb2F0KDEyKTtcbiAgICAgICAgICAgIHZhciBlbl9zaG9ydCA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgICAgIHZhciBhdHRhY2tfaW50ZW5zaXR5ID0gbmV3X2Zsb2F0KDEyKTtcbiAgICAgICAgICAgIHZhciBuc191c2Vsb25nYmxvY2sgPSAxO1xuICAgICAgICAgICAgdmFyIGF0dGFja1RocmVzaG9sZDtcbiAgICAgICAgICAgIHZhciBtYXggPSBuZXdfZmxvYXQoRW5jb2Rlci5DQkFORFMpLCBhdmcgPSBuZXdfZmxvYXQoRW5jb2Rlci5DQkFORFMpO1xuICAgICAgICAgICAgdmFyIG5zX2F0dGFja3MgPSBbMCwgMCwgMCwgMF07XG4gICAgICAgICAgICB2YXIgZmZ0ZW5lcmd5ID0gbmV3X2Zsb2F0KEVuY29kZXIuSEJMS1NJWkUpO1xuICAgICAgICAgICAgdmFyIGZmdGVuZXJneV9zID0gbmV3X2Zsb2F0X24oWzMsIEVuY29kZXIuSEJMS1NJWkVfc10pO1xuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogcmggMjAwNDAzMDE6IHRoZSBmb2xsb3dpbmcgbG9vcHMgZG8gYWNjZXNzIG9uZSBvZmYgdGhlIGxpbWl0cyBzb1xuICAgICAgICAgICAgICogSSBpbmNyZWFzZSB0aGUgYXJyYXkgZGltZW5zaW9ucyBieSBvbmUgYW5kIGluaXRpYWxpemUgdGhlXG4gICAgICAgICAgICAgKiBhY2Nlc3NlZCB2YWx1ZXMgdG8gemVyb1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBhc3NlcnQoZ2ZjLm5wYXJ0X3MgPD0gRW5jb2Rlci5DQkFORFMpO1xuICAgICAgICAgICAgYXNzZXJ0KGdmYy5ucGFydF9sIDw9IEVuY29kZXIuQ0JBTkRTKTtcblxuICAgICAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAgICAgICogZGV0ZXJtaW5lIHRoZSBibG9jayB0eXBlICh3aW5kb3cgdHlwZSlcbiAgICAgICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgICAgICAvKiBjYWxjdWxhdGUgZW5lcmdpZXMgb2YgZWFjaCBzdWItc2hvcnRibG9ja3MgKi9cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBlbl9zdWJzaG9ydFtpXSA9IGdmYy5uc1BzeS5sYXN0X2VuX3N1YnNob3J0W2Nobl1baSArIDZdO1xuICAgICAgICAgICAgICAgIGFzc2VydChnZmMubnNQc3kubGFzdF9lbl9zdWJzaG9ydFtjaG5dW2kgKyA0XSA+IDApO1xuICAgICAgICAgICAgICAgIGF0dGFja19pbnRlbnNpdHlbaV0gPSBlbl9zdWJzaG9ydFtpXVxuICAgICAgICAgICAgICAgICAgICAvIGdmYy5uc1BzeS5sYXN0X2VuX3N1YnNob3J0W2Nobl1baSArIDRdO1xuICAgICAgICAgICAgICAgIGVuX3Nob3J0WzBdICs9IGVuX3N1YnNob3J0W2ldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2huID09IDIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNTc2OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGwsIHI7XG4gICAgICAgICAgICAgICAgICAgIGwgPSBuc19ocGZzbXBsWzBdW2ldO1xuICAgICAgICAgICAgICAgICAgICByID0gbnNfaHBmc21wbFsxXVtpXTtcbiAgICAgICAgICAgICAgICAgICAgbnNfaHBmc21wbFswXVtpXSA9IGwgKyByO1xuICAgICAgICAgICAgICAgICAgICBuc19ocGZzbXBsWzFdW2ldID0gbCAtIHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBwZiA9IG5zX2hwZnNtcGxbY2huICYgMV07XG4gICAgICAgICAgICAgICAgdmFyIHBmUG9zID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgOTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwZmUgPSBwZlBvcyArIDU3NiAvIDk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gMS47XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBwZlBvcyA8IHBmZTsgcGZQb3MrKylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwIDwgTWF0aC5hYnMocGZbcGZQb3NdKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gTWF0aC5hYnMocGZbcGZQb3NdKTtcblxuICAgICAgICAgICAgICAgICAgICBnZmMubnNQc3kubGFzdF9lbl9zdWJzaG9ydFtjaG5dW2ldID0gZW5fc3Vic2hvcnRbaSArIDNdID0gcDtcbiAgICAgICAgICAgICAgICAgICAgZW5fc2hvcnRbMSArIGkgLyAzXSArPSBwO1xuICAgICAgICAgICAgICAgICAgICBpZiAocCA+IGVuX3N1YnNob3J0W2kgKyAzIC0gMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydChlbl9zdWJzaG9ydFtpICsgMyAtIDJdID4gMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwID0gcCAvIGVuX3N1YnNob3J0W2kgKyAzIC0gMl07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZW5fc3Vic2hvcnRbaSArIDMgLSAyXSA+IHAgKiAxMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQocCA+IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IGVuX3N1YnNob3J0W2kgKyAzIC0gMl0gLyAocCAqIDEwLjApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSAwLjA7XG4gICAgICAgICAgICAgICAgICAgIGF0dGFja19pbnRlbnNpdHlbaSArIDNdID0gcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChnZnAuYW5hbHlzaXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IGF0dGFja19pbnRlbnNpdHlbMF07XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IDEyOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGlmICh4IDwgYXR0YWNrX2ludGVuc2l0eVtpXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBhdHRhY2tfaW50ZW5zaXR5W2ldO1xuICAgICAgICAgICAgICAgIGdmYy5waW5mby5lcnNbZ3Jfb3V0XVtjaG5dID0gZ2ZjLnBpbmZvLmVyc19zYXZlW2Nobl07XG4gICAgICAgICAgICAgICAgZ2ZjLnBpbmZvLmVyc19zYXZlW2Nobl0gPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKiBjb21wYXJlIGVuZXJnaWVzIGJldHdlZW4gc3ViLXNob3J0YmxvY2tzICovXG4gICAgICAgICAgICBhdHRhY2tUaHJlc2hvbGQgPSAoY2huID09IDMpID8gZ2ZjLm5zUHN5LmF0dGFja3RocmVfc1xuICAgICAgICAgICAgICAgIDogZ2ZjLm5zUHN5LmF0dGFja3RocmU7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAoMCA9PSBuc19hdHRhY2tzW2kgLyAzXVxuICAgICAgICAgICAgICAgICAgICAmJiBhdHRhY2tfaW50ZW5zaXR5W2ldID4gYXR0YWNrVGhyZXNob2xkKVxuICAgICAgICAgICAgICAgICAgICBuc19hdHRhY2tzW2kgLyAzXSA9IChpICUgMykgKyAxO1xuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogc2hvdWxkIGhhdmUgZW5lcmd5IGNoYW5nZSBiZXR3ZWVuIHNob3J0IGJsb2NrcywgaW4gb3JkZXIgdG8gYXZvaWRcbiAgICAgICAgICAgICAqIHBlcmlvZGljIHNpZ25hbHNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciByYXRpbztcbiAgICAgICAgICAgICAgICBpZiAoZW5fc2hvcnRbaSAtIDFdID4gZW5fc2hvcnRbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGVuX3Nob3J0W2ldID4gMCk7XG4gICAgICAgICAgICAgICAgICAgIHJhdGlvID0gZW5fc2hvcnRbaSAtIDFdIC8gZW5fc2hvcnRbaV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGVuX3Nob3J0W2kgLSAxXSA+IDApO1xuICAgICAgICAgICAgICAgICAgICByYXRpbyA9IGVuX3Nob3J0W2ldIC8gZW5fc2hvcnRbaSAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmF0aW8gPCAxLjcpIHtcbiAgICAgICAgICAgICAgICAgICAgbnNfYXR0YWNrc1tpXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09IDEpXG4gICAgICAgICAgICAgICAgICAgICAgICBuc19hdHRhY2tzWzBdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuc19hdHRhY2tzWzBdICE9IDAgJiYgZ2ZjLm5zUHN5Lmxhc3RBdHRhY2tzW2Nobl0gIT0gMClcbiAgICAgICAgICAgICAgICBuc19hdHRhY2tzWzBdID0gMDtcblxuICAgICAgICAgICAgaWYgKGdmYy5uc1BzeS5sYXN0QXR0YWNrc1tjaG5dID09IDNcbiAgICAgICAgICAgICAgICB8fCAobnNfYXR0YWNrc1swXSArIG5zX2F0dGFja3NbMV0gKyBuc19hdHRhY2tzWzJdICsgbnNfYXR0YWNrc1szXSkgIT0gMCkge1xuICAgICAgICAgICAgICAgIG5zX3VzZWxvbmdibG9jayA9IDA7XG5cbiAgICAgICAgICAgICAgICBpZiAobnNfYXR0YWNrc1sxXSAhPSAwICYmIG5zX2F0dGFja3NbMF0gIT0gMClcbiAgICAgICAgICAgICAgICAgICAgbnNfYXR0YWNrc1sxXSA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKG5zX2F0dGFja3NbMl0gIT0gMCAmJiBuc19hdHRhY2tzWzFdICE9IDApXG4gICAgICAgICAgICAgICAgICAgIG5zX2F0dGFja3NbMl0gPSAwO1xuICAgICAgICAgICAgICAgIGlmIChuc19hdHRhY2tzWzNdICE9IDAgJiYgbnNfYXR0YWNrc1syXSAhPSAwKVxuICAgICAgICAgICAgICAgICAgICBuc19hdHRhY2tzWzNdID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNobiA8IDIpIHtcbiAgICAgICAgICAgICAgICB1c2Vsb25nYmxvY2tbY2huXSA9IG5zX3VzZWxvbmdibG9jaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG5zX3VzZWxvbmdibG9jayA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZWxvbmdibG9ja1swXSA9IHVzZWxvbmdibG9ja1sxXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogdGhlcmUgaXMgYSBvbmUgZ3JhbnVsZSBkZWxheS4gQ29weSBtYXNraW5ncyBjb21wdXRlZCBsYXN0IGNhbGxcbiAgICAgICAgICAgICAqIGludG8gbWFza2luZ19yYXRpbyB0byByZXR1cm4gdG8gY2FsbGluZyBwcm9ncmFtLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBlbmVyZ3lbY2huXSA9IGdmYy50b3RfZW5lcltjaG5dO1xuXG4gICAgICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICAgICAgKiBjb21wdXRlIEZGVHNcbiAgICAgICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgICAgICB3c2FtcF9zID0gd3NhbXBfUztcbiAgICAgICAgICAgIHdzYW1wX2wgPSB3c2FtcF9MO1xuICAgICAgICAgICAgY29tcHV0ZV9mZnRzKGdmcCwgZmZ0ZW5lcmd5LCBmZnRlbmVyZ3lfcywgd3NhbXBfbCwgKGNobiAmIDEpLFxuICAgICAgICAgICAgICAgIHdzYW1wX3MsIChjaG4gJiAxKSwgZ3Jfb3V0LCBjaG4sIGJ1ZmZlciwgYnVmUG9zKTtcblxuICAgICAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAgICAgICogQ2FsY3VsYXRlIHRoZSBlbmVyZ3kgYW5kIHRoZSB0b25hbGl0eSBvZiBlYWNoIHBhcnRpdGlvbi5cbiAgICAgICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgICAgICBjYWxjX2VuZXJneShnZmMsIGZmdGVuZXJneSwgZWJfbCwgbWF4LCBhdmcpO1xuICAgICAgICAgICAgY2FsY19tYXNrX2luZGV4X2woZ2ZjLCBtYXgsIGF2ZywgbWFza19pZHhfbCk7XG4gICAgICAgICAgICAvKiBjb21wdXRlIG1hc2tpbmcgdGhyZXNob2xkcyBmb3Igc2hvcnQgYmxvY2tzICovXG4gICAgICAgICAgICBmb3IgKHNibG9jayA9IDA7IHNibG9jayA8IDM7IHNibG9jaysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVubiwgdGhtbTtcbiAgICAgICAgICAgICAgICBjb21wdXRlX21hc2tpbmdfcyhnZnAsIGZmdGVuZXJneV9zLCBlYl9zLCB0aHIsIGNobiwgc2Jsb2NrKTtcbiAgICAgICAgICAgICAgICBjb252ZXJ0X3BhcnRpdGlvbjJzY2FsZWZhY19zKGdmYywgZWJfcywgdGhyLCBjaG4sIHNibG9jayk7XG4gICAgICAgICAgICAgICAgLyoqKiogc2hvcnQgYmxvY2sgcHJlLWVjaG8gY29udHJvbCAqKioqL1xuICAgICAgICAgICAgICAgIGZvciAoc2IgPSAwOyBzYiA8IEVuY29kZXIuU0JNQVhfczsgc2IrKykge1xuICAgICAgICAgICAgICAgICAgICB0aG1tID0gZ2ZjLnRobVtjaG5dLnNbc2JdW3NibG9ja107XG5cbiAgICAgICAgICAgICAgICAgICAgdGhtbSAqPSBOU19QUkVFQ0hPX0FUVDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuc19hdHRhY2tzW3NibG9ja10gPj0gMiB8fCBuc19hdHRhY2tzW3NibG9jayArIDFdID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSAoc2Jsb2NrICE9IDApID8gc2Jsb2NrIC0gMSA6IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IE5TX0lOVEVSUChnZmMudGhtW2Nobl0uc1tzYl1baWR4XSwgdGhtbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBOU19QUkVFQ0hPX0FUVDEgKiBwY2ZhY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhtbSA9IE1hdGgubWluKHRobW0sIHApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5zX2F0dGFja3Nbc2Jsb2NrXSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gKHNibG9jayAhPSAwKSA/IHNibG9jayAtIDEgOiAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBOU19JTlRFUlAoZ2ZjLnRobVtjaG5dLnNbc2JdW2lkeF0sIHRobW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTlNfUFJFRUNIT19BVFQyICogcGNmYWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRobW0gPSBNYXRoLm1pbih0aG1tLCBwKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgoc2Jsb2NrICE9IDAgJiYgbnNfYXR0YWNrc1tzYmxvY2sgLSAxXSA9PSAzKVxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgKHNibG9jayA9PSAwICYmIGdmYy5uc1BzeS5sYXN0QXR0YWNrc1tjaG5dID09IDMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gKHNibG9jayAhPSAyKSA/IHNibG9jayArIDEgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBOU19JTlRFUlAoZ2ZjLnRobVtjaG5dLnNbc2JdW2lkeF0sIHRobW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTlNfUFJFRUNIT19BVFQyICogcGNmYWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRobW0gPSBNYXRoLm1pbih0aG1tLCBwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qIHB1bHNlIGxpa2Ugc2lnbmFsIGRldGVjdGlvbiBmb3IgZmF0Ym95LndhdiBhbmQgc28gb24gKi9cbiAgICAgICAgICAgICAgICAgICAgZW5uID0gZW5fc3Vic2hvcnRbc2Jsb2NrICogMyArIDNdXG4gICAgICAgICAgICAgICAgICAgICAgICArIGVuX3N1YnNob3J0W3NibG9jayAqIDMgKyA0XVxuICAgICAgICAgICAgICAgICAgICAgICAgKyBlbl9zdWJzaG9ydFtzYmxvY2sgKiAzICsgNV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbl9zdWJzaG9ydFtzYmxvY2sgKiAzICsgNV0gKiA2IDwgZW5uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aG1tICo9IDAuNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbl9zdWJzaG9ydFtzYmxvY2sgKiAzICsgNF0gKiA2IDwgZW5uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRobW0gKj0gMC41O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZ2ZjLnRobVtjaG5dLnNbc2JdW3NibG9ja10gPSB0aG1tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdmYy5uc1BzeS5sYXN0QXR0YWNrc1tjaG5dID0gbnNfYXR0YWNrc1syXTtcblxuICAgICAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAgICAgICogY29udm9sdmUgdGhlIHBhcnRpdGlvbmVkIGVuZXJneSBhbmQgdW5wcmVkaWN0YWJpbGl0eSB3aXRoIHRoZVxuICAgICAgICAgICAgICogc3ByZWFkaW5nIGZ1bmN0aW9uLCBzM19sW2JdW2tdXG4gICAgICAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgICAgICBrID0gMDtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmb3IgKGIgPSAwOyBiIDwgZ2ZjLm5wYXJ0X2w7IGIrKykge1xuICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgKiBjb252b2x2ZSB0aGUgcGFydGl0aW9uZWQgZW5lcmd5IHdpdGggdGhlIHNwcmVhZGluZ1xuICAgICAgICAgICAgICAgICAgICAgKiBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdmFyIGtrID0gZ2ZjLnMzaW5kW2JdWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWIyID0gZWJfbFtra10gKiB0YWJbbWFza19pZHhfbFtra11dO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWNiID0gZ2ZjLnMzX2xsW2srK10gKiBlYjI7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgrK2trIDw9IGdmYy5zM2luZFtiXVsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWIyID0gZWJfbFtra10gKiB0YWJbbWFza19pZHhfbFtra11dO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWNiID0gbWFza19hZGQoZWNiLCBnZmMuczNfbGxbaysrXSAqIGViMiwga2ssIGtrIC0gYixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZmMsIDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVjYiAqPSAwLjE1ODQ4OTMxOTI0NjExMTtcbiAgICAgICAgICAgICAgICAgICAgLyogcG93KDEwLC0wLjgpICovXG5cbiAgICAgICAgICAgICAgICAgICAgLyoqKiogbG9uZyBibG9jayBwcmUtZWNobyBjb250cm9sICoqKiovXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiA8UFJFPlxuICAgICAgICAgICAgICAgICAgICAgKiBkb250IHVzZSBsb25nIGJsb2NrIHByZS1lY2hvIGNvbnRyb2wgaWYgcHJldmlvdXMgZ3JhbnVsZSB3YXNcbiAgICAgICAgICAgICAgICAgICAgICogYSBzaG9ydCBibG9jay4gIFRoaXMgaXMgdG8gYXZvaWQgdGhlIHNpdHVhdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICogZnJhbWUwOiAgcXVpZXQgKHZlcnkgbG93IG1hc2tpbmcpXG4gICAgICAgICAgICAgICAgICAgICAqIGZyYW1lMTogIHN1cmdlICAodHJpZ2dlcnMgc2hvcnQgYmxvY2tzKVxuICAgICAgICAgICAgICAgICAgICAgKiBmcmFtZTI6ICByZWd1bGFyIGZyYW1lLiAgbG9va3MgbGlrZSBwcmUtZWNobyB3aGVuIGNvbXBhcmVkIHRvXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIGZyYW1lMCwgYnV0IGFsbCBwcmUtZWNobyB3YXMgaW4gZnJhbWUxLlxuICAgICAgICAgICAgICAgICAgICAgKiA8L1BSRT5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAqIGNobj0wLDEgTCBhbmQgUiBjaGFubmVsc1xuICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgKiBjaG49MiwzIFMgYW5kIE0gY2hhbm5lbHMuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChnZmMuYmxvY2t0eXBlX29sZFtjaG4gJiAxXSA9PSBFbmNvZGVyLlNIT1JUX1RZUEUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJbYl0gPSBlY2I7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocltiXSA9IE5TX0lOVEVSUChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihlY2IsIE1hdGgubWluKHJwZWxldlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGdmYy5uYl8xW2Nobl1bYl0sIHJwZWxldjJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBnZmMubmJfMltjaG5dW2JdKSksIGVjYiwgcGNmYWN0KTtcblxuICAgICAgICAgICAgICAgICAgICBnZmMubmJfMltjaG5dW2JdID0gZ2ZjLm5iXzFbY2huXVtiXTtcbiAgICAgICAgICAgICAgICAgICAgZ2ZjLm5iXzFbY2huXVtiXSA9IGVjYjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKDsgYiA8PSBFbmNvZGVyLkNCQU5EUzsgKytiKSB7XG4gICAgICAgICAgICAgICAgZWJfbFtiXSA9IDA7XG4gICAgICAgICAgICAgICAgdGhyW2JdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGNvbXB1dGUgbWFza2luZyB0aHJlc2hvbGRzIGZvciBsb25nIGJsb2NrcyAqL1xuICAgICAgICAgICAgY29udmVydF9wYXJ0aXRpb24yc2NhbGVmYWNfbChnZmMsIGViX2wsIHRociwgY2huKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBlbmQgbG9vcCBvdmVyIGNobiAqL1xuXG4gICAgICAgIGlmIChnZnAubW9kZSA9PSBNUEVHTW9kZS5TVEVSRU8gfHwgZ2ZwLm1vZGUgPT0gTVBFR01vZGUuSk9JTlRfU1RFUkVPKSB7XG4gICAgICAgICAgICBpZiAoZ2ZwLmludGVyQ2hSYXRpbyA+IDAuMCkge1xuICAgICAgICAgICAgICAgIGNhbGNfaW50ZXJjaGFubmVsX21hc2tpbmcoZ2ZwLCBnZnAuaW50ZXJDaFJhdGlvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnZnAubW9kZSA9PSBNUEVHTW9kZS5KT0lOVF9TVEVSRU8pIHtcbiAgICAgICAgICAgIHZhciBtc2ZpeDtcbiAgICAgICAgICAgIG1zZml4MShnZmMpO1xuICAgICAgICAgICAgbXNmaXggPSBnZnAubXNmaXg7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMobXNmaXgpID4gMC4wKVxuICAgICAgICAgICAgICAgIG5zX21zZml4KGdmYywgbXNmaXgsIGdmcC5BVEhsb3dlciAqIGdmYy5BVEguYWRqdXN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgICogZGV0ZXJtaW5lIGZpbmFsIGJsb2NrIHR5cGVcbiAgICAgICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgYmxvY2tfdHlwZV9zZXQoZ2ZwLCB1c2Vsb25nYmxvY2ssIGJsb2NrdHlwZV9kLCBibG9ja3R5cGUpO1xuXG4gICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgICogY29tcHV0ZSB0aGUgdmFsdWUgb2YgUEUgdG8gcmV0dXJuIC4uLiBubyBkZWxheSBhbmQgYWR2YW5jZVxuICAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICBmb3IgKGNobiA9IDA7IGNobiA8IG51bWNobjsgY2huKyspIHtcbiAgICAgICAgICAgIHZhciBwcGU7XG4gICAgICAgICAgICB2YXIgcHBlUG9zID0gMDtcbiAgICAgICAgICAgIHZhciB0eXBlO1xuICAgICAgICAgICAgdmFyIG1yO1xuXG4gICAgICAgICAgICBpZiAoY2huID4gMSkge1xuICAgICAgICAgICAgICAgIHBwZSA9IHBlcmNlcF9NU19lbnRyb3B5O1xuICAgICAgICAgICAgICAgIHBwZVBvcyA9IC0yO1xuICAgICAgICAgICAgICAgIHR5cGUgPSBFbmNvZGVyLk5PUk1fVFlQRTtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2t0eXBlX2RbMF0gPT0gRW5jb2Rlci5TSE9SVF9UWVBFXG4gICAgICAgICAgICAgICAgICAgIHx8IGJsb2NrdHlwZV9kWzFdID09IEVuY29kZXIuU0hPUlRfVFlQRSlcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IEVuY29kZXIuU0hPUlRfVFlQRTtcbiAgICAgICAgICAgICAgICBtciA9IG1hc2tpbmdfTVNfcmF0aW9bZ3Jfb3V0XVtjaG4gLSAyXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHBlID0gcGVyY2VwX2VudHJvcHk7XG4gICAgICAgICAgICAgICAgcHBlUG9zID0gMDtcbiAgICAgICAgICAgICAgICB0eXBlID0gYmxvY2t0eXBlX2RbY2huXTtcbiAgICAgICAgICAgICAgICBtciA9IG1hc2tpbmdfcmF0aW9bZ3Jfb3V0XVtjaG5dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZSA9PSBFbmNvZGVyLlNIT1JUX1RZUEUpXG4gICAgICAgICAgICAgICAgcHBlW3BwZVBvcyArIGNobl0gPSBwZWNhbGNfcyhtciwgZ2ZjLm1hc2tpbmdfbG93ZXIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHBwZVtwcGVQb3MgKyBjaG5dID0gcGVjYWxjX2wobXIsIGdmYy5tYXNraW5nX2xvd2VyKTtcblxuICAgICAgICAgICAgaWYgKGdmcC5hbmFseXNpcylcbiAgICAgICAgICAgICAgICBnZmMucGluZm8ucGVbZ3Jfb3V0XVtjaG5dID0gcHBlW3BwZVBvcyArIGNobl07XG5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YnJwc3lfY29tcHV0ZV9mZnRfbChnZnAsIGJ1ZmZlciwgYnVmUG9zLCBjaG4sIGdyX291dCwgZmZ0ZW5lcmd5LCB3c2FtcF9sLCB3c2FtcF9sUG9zKSB7XG4gICAgICAgIHZhciBnZmMgPSBnZnAuaW50ZXJuYWxfZmxhZ3M7XG4gICAgICAgIGlmIChjaG4gPCAyKSB7XG4gICAgICAgICAgICBmZnQuZmZ0X2xvbmcoZ2ZjLCB3c2FtcF9sW3dzYW1wX2xQb3NdLCBjaG4sIGJ1ZmZlciwgYnVmUG9zKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaG4gPT0gMikge1xuICAgICAgICAgICAgLyogRkZUIGRhdGEgZm9yIG1pZCBhbmQgc2lkZSBjaGFubmVsIGlzIGRlcml2ZWQgZnJvbSBMICYgUiAqL1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IEVuY29kZXIuQkxLU0laRSAtIDE7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgICAgICAgICAgdmFyIGwgPSB3c2FtcF9sW3dzYW1wX2xQb3MgKyAwXVtqXTtcbiAgICAgICAgICAgICAgICB2YXIgciA9IHdzYW1wX2xbd3NhbXBfbFBvcyArIDFdW2pdO1xuICAgICAgICAgICAgICAgIHdzYW1wX2xbd3NhbXBfbFBvcyArIDBdW2pdID0gKGwgKyByKSAqIFV0aWwuU1FSVDIgKiAwLjU7XG4gICAgICAgICAgICAgICAgd3NhbXBfbFt3c2FtcF9sUG9zICsgMV1bal0gPSAobCAtIHIpICogVXRpbC5TUVJUMiAqIDAuNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgICogY29tcHV0ZSBlbmVyZ2llc1xuICAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICBmZnRlbmVyZ3lbMF0gPSBOT05fTElORUFSX1NDQUxFX0VORVJHWSh3c2FtcF9sW3dzYW1wX2xQb3MgKyAwXVswXSk7XG4gICAgICAgIGZmdGVuZXJneVswXSAqPSBmZnRlbmVyZ3lbMF07XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IEVuY29kZXIuQkxLU0laRSAvIDIgLSAxOyBqID49IDA7IC0taikge1xuICAgICAgICAgICAgdmFyIHJlID0gd3NhbXBfbFt3c2FtcF9sUG9zICsgMF1bRW5jb2Rlci5CTEtTSVpFIC8gMiAtIGpdO1xuICAgICAgICAgICAgdmFyIGltID0gd3NhbXBfbFt3c2FtcF9sUG9zICsgMF1bRW5jb2Rlci5CTEtTSVpFIC8gMiArIGpdO1xuICAgICAgICAgICAgZmZ0ZW5lcmd5W0VuY29kZXIuQkxLU0laRSAvIDIgLSBqXSA9IE5PTl9MSU5FQVJfU0NBTEVfRU5FUkdZKChyZVxuICAgICAgICAgICAgICAgICogcmUgKyBpbSAqIGltKSAqIDAuNSk7XG4gICAgICAgIH1cbiAgICAgICAgLyogdG90YWwgZW5lcmd5ICovXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB0b3RhbGVuZXJneSA9IDAuMDtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAxMTsgaiA8IEVuY29kZXIuSEJMS1NJWkU7IGorKylcbiAgICAgICAgICAgICAgICB0b3RhbGVuZXJneSArPSBmZnRlbmVyZ3lbal07XG5cbiAgICAgICAgICAgIGdmYy50b3RfZW5lcltjaG5dID0gdG90YWxlbmVyZ3k7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2ZwLmFuYWx5c2lzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IEVuY29kZXIuSEJMS1NJWkU7IGorKykge1xuICAgICAgICAgICAgICAgIGdmYy5waW5mby5lbmVyZ3lbZ3Jfb3V0XVtjaG5dW2pdID0gZ2ZjLnBpbmZvLmVuZXJneV9zYXZlW2Nobl1bal07XG4gICAgICAgICAgICAgICAgZ2ZjLnBpbmZvLmVuZXJneV9zYXZlW2Nobl1bal0gPSBmZnRlbmVyZ3lbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZmMucGluZm8ucGVbZ3Jfb3V0XVtjaG5dID0gZ2ZjLnBlW2Nobl07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YnJwc3lfY29tcHV0ZV9mZnRfcyhnZnAsIGJ1ZmZlciwgYnVmUG9zLCBjaG4sIHNibG9jaywgZmZ0ZW5lcmd5X3MsIHdzYW1wX3MsIHdzYW1wX3NQb3MpIHtcbiAgICAgICAgdmFyIGdmYyA9IGdmcC5pbnRlcm5hbF9mbGFncztcblxuICAgICAgICBpZiAoc2Jsb2NrID09IDAgJiYgY2huIDwgMikge1xuICAgICAgICAgICAgZmZ0LmZmdF9zaG9ydChnZmMsIHdzYW1wX3Nbd3NhbXBfc1Bvc10sIGNobiwgYnVmZmVyLCBidWZQb3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaG4gPT0gMikge1xuICAgICAgICAgICAgLyogRkZUIGRhdGEgZm9yIG1pZCBhbmQgc2lkZSBjaGFubmVsIGlzIGRlcml2ZWQgZnJvbSBMICYgUiAqL1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IEVuY29kZXIuQkxLU0laRV9zIC0gMTsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgICAgICAgICB2YXIgbCA9IHdzYW1wX3Nbd3NhbXBfc1BvcyArIDBdW3NibG9ja11bal07XG4gICAgICAgICAgICAgICAgdmFyIHIgPSB3c2FtcF9zW3dzYW1wX3NQb3MgKyAxXVtzYmxvY2tdW2pdO1xuICAgICAgICAgICAgICAgIHdzYW1wX3Nbd3NhbXBfc1BvcyArIDBdW3NibG9ja11bal0gPSAobCArIHIpICogVXRpbC5TUVJUMiAqIDAuNTtcbiAgICAgICAgICAgICAgICB3c2FtcF9zW3dzYW1wX3NQb3MgKyAxXVtzYmxvY2tdW2pdID0gKGwgLSByKSAqIFV0aWwuU1FSVDIgKiAwLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICAqIGNvbXB1dGUgZW5lcmdpZXNcbiAgICAgICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgZmZ0ZW5lcmd5X3Nbc2Jsb2NrXVswXSA9IHdzYW1wX3Nbd3NhbXBfc1BvcyArIDBdW3NibG9ja11bMF07XG4gICAgICAgIGZmdGVuZXJneV9zW3NibG9ja11bMF0gKj0gZmZ0ZW5lcmd5X3Nbc2Jsb2NrXVswXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IEVuY29kZXIuQkxLU0laRV9zIC8gMiAtIDE7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgICAgICB2YXIgcmUgPSB3c2FtcF9zW3dzYW1wX3NQb3MgKyAwXVtzYmxvY2tdW0VuY29kZXIuQkxLU0laRV9zIC8gMiAtIGpdO1xuICAgICAgICAgICAgdmFyIGltID0gd3NhbXBfc1t3c2FtcF9zUG9zICsgMF1bc2Jsb2NrXVtFbmNvZGVyLkJMS1NJWkVfcyAvIDIgKyBqXTtcbiAgICAgICAgICAgIGZmdGVuZXJneV9zW3NibG9ja11bRW5jb2Rlci5CTEtTSVpFX3MgLyAyIC0gal0gPSBOT05fTElORUFSX1NDQUxFX0VORVJHWSgocmVcbiAgICAgICAgICAgICAgICAqIHJlICsgaW0gKiBpbSkgKiAwLjUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY29tcHV0ZSBsb3VkbmVzcyBhcHByb3hpbWF0aW9uICh1c2VkIGZvciBBVEggYXV0by1sZXZlbCBhZGp1c3RtZW50KVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZicnBzeV9jb21wdXRlX2xvdWRuZXNzX2FwcHJveGltYXRpb25fbChnZnAsIGdyX291dCwgY2huLCBmZnRlbmVyZ3kpIHtcbiAgICAgICAgdmFyIGdmYyA9IGdmcC5pbnRlcm5hbF9mbGFncztcbiAgICAgICAgaWYgKGdmcC5hdGhhYV9sb3VkYXBwcm94ID09IDIgJiYgY2huIDwgMikge1xuICAgICAgICAgICAgLy8gbm8gbG91ZG5lc3MgZm9yIG1pZC9zaWRlIGNoXG4gICAgICAgICAgICBnZmMubG91ZG5lc3Nfc3FbZ3Jfb3V0XVtjaG5dID0gZ2ZjLmxvdWRuZXNzX3NxX3NhdmVbY2huXTtcbiAgICAgICAgICAgIGdmYy5sb3VkbmVzc19zcV9zYXZlW2Nobl0gPSBwc3ljaG9fbG91ZG5lc3NfYXBwcm94KGZmdGVuZXJneSwgZ2ZjKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmaXJjb2VmXyA9IFstOC42NTE2M2UtMTggKiAyLFxuICAgICAgICAtMC4wMDg1MTU4NiAqIDIsIC02Ljc0NzY0ZS0xOCAqIDIsIDAuMDIwOTAzNiAqIDIsXG4gICAgICAgIC0zLjM2NjM5ZS0xNyAqIDIsIC0wLjA0MzgxNjIgKiAyLCAtMS41NDE3NWUtMTcgKiAyLFxuICAgICAgICAwLjA5MzE3MzggKiAyLCAtNS41MjIxMmUtMTcgKiAyLCAtMC4zMTM4MTkgKiAyXTtcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IEhQRiBvZiBmcy80IHRvIHRoZSBpbnB1dCBzaWduYWwuIFRoaXMgaXMgdXNlZCBmb3IgYXR0YWNrIGRldGVjdGlvblxuICAgICAqIC8gaGFuZGxpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmJycHN5X2F0dGFja19kZXRlY3Rpb24oZ2ZwLCBidWZmZXIsIGJ1ZlBvcywgZ3Jfb3V0LCBtYXNraW5nX3JhdGlvLCBtYXNraW5nX01TX3JhdGlvLCBlbmVyZ3ksIHN1Yl9zaG9ydF9mYWN0b3IsIG5zX2F0dGFja3MsIHVzZWxvbmdibG9jaykge1xuICAgICAgICB2YXIgbnNfaHBmc21wbCA9IG5ld19mbG9hdF9uKFsyLCA1NzZdKTtcbiAgICAgICAgdmFyIGdmYyA9IGdmcC5pbnRlcm5hbF9mbGFncztcbiAgICAgICAgdmFyIG5fY2huX291dCA9IGdmYy5jaGFubmVsc19vdXQ7XG4gICAgICAgIC8qIGNobj0yIGFuZCAzID0gTWlkIGFuZCBTaWRlIGNoYW5uZWxzICovXG4gICAgICAgIHZhciBuX2Nobl9wc3kgPSAoZ2ZwLm1vZGUgPT0gTVBFR01vZGUuSk9JTlRfU1RFUkVPKSA/IDQgOiBuX2Nobl9vdXQ7XG4gICAgICAgIC8qIERvbid0IGNvcHkgdGhlIGlucHV0IGJ1ZmZlciBpbnRvIGEgdGVtcG9yYXJ5IGJ1ZmZlciAqL1xuICAgICAgICAvKiB1bnJvbGwgdGhlIGxvb3AgMiB0aW1lcyAqL1xuICAgICAgICBmb3IgKHZhciBjaG4gPSAwOyBjaG4gPCBuX2Nobl9vdXQ7IGNobisrKSB7XG4gICAgICAgICAgICAvKiBhcHBseSBoaWdoIHBhc3MgZmlsdGVyIG9mIGZzLzQgKi9cbiAgICAgICAgICAgIGZpcmJ1ZiA9IGJ1ZmZlcltjaG5dO1xuICAgICAgICAgICAgdmFyIGZpcmJ1ZlBvcyA9IGJ1ZlBvcyArIDU3NiAtIDM1MCAtIE5TRklSTEVOICsgMTkyO1xuICAgICAgICAgICAgYXNzZXJ0KGZpcmNvZWZfLmxlbmd0aCA9PSAoKE5TRklSTEVOIC0gMSkgLyAyKSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDU3NjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1bTEsIHN1bTI7XG4gICAgICAgICAgICAgICAgc3VtMSA9IGZpcmJ1ZltmaXJidWZQb3MgKyBpICsgMTBdO1xuICAgICAgICAgICAgICAgIHN1bTIgPSAwLjA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAoKE5TRklSTEVOIC0gMSkgLyAyKSAtIDE7IGogKz0gMikge1xuICAgICAgICAgICAgICAgICAgICBzdW0xICs9IGZpcmNvZWZfW2pdXG4gICAgICAgICAgICAgICAgICAgICAgICAqIChmaXJidWZbZmlyYnVmUG9zICsgaSArIGpdICsgZmlyYnVmW2ZpcmJ1ZlBvcyArIGlcbiAgICAgICAgICAgICAgICAgICAgICAgICsgTlNGSVJMRU4gLSBqXSk7XG4gICAgICAgICAgICAgICAgICAgIHN1bTIgKz0gZmlyY29lZl9baiArIDFdXG4gICAgICAgICAgICAgICAgICAgICAgICAqIChmaXJidWZbZmlyYnVmUG9zICsgaSArIGogKyAxXSArIGZpcmJ1ZltmaXJidWZQb3NcbiAgICAgICAgICAgICAgICAgICAgICAgICsgaSArIE5TRklSTEVOIC0gaiAtIDFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbnNfaHBmc21wbFtjaG5dW2ldID0gc3VtMSArIHN1bTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXNraW5nX3JhdGlvW2dyX291dF1bY2huXS5lbi5hc3NpZ24oZ2ZjLmVuW2Nobl0pO1xuICAgICAgICAgICAgbWFza2luZ19yYXRpb1tncl9vdXRdW2Nobl0udGhtLmFzc2lnbihnZmMudGhtW2Nobl0pO1xuICAgICAgICAgICAgaWYgKG5fY2huX3BzeSA+IDIpIHtcbiAgICAgICAgICAgICAgICAvKiBNUyBtYXNraW5ncyAqL1xuICAgICAgICAgICAgICAgIC8qIHBlcmNlcF9NU19lbnRyb3B5IFtjaG4tMl0gPSBnZmMgLiBwZSBbY2huXTsgKi9cbiAgICAgICAgICAgICAgICBtYXNraW5nX01TX3JhdGlvW2dyX291dF1bY2huXS5lbi5hc3NpZ24oZ2ZjLmVuW2NobiArIDJdKTtcbiAgICAgICAgICAgICAgICBtYXNraW5nX01TX3JhdGlvW2dyX291dF1bY2huXS50aG0uYXNzaWduKGdmYy50aG1bY2huICsgMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGNobiA9IDA7IGNobiA8IG5fY2huX3BzeTsgY2huKyspIHtcbiAgICAgICAgICAgIHZhciBhdHRhY2tfaW50ZW5zaXR5ID0gbmV3X2Zsb2F0KDEyKTtcbiAgICAgICAgICAgIHZhciBlbl9zdWJzaG9ydCA9IG5ld19mbG9hdCgxMik7XG4gICAgICAgICAgICB2YXIgZW5fc2hvcnQgPSBbMCwgMCwgMCwgMF07XG4gICAgICAgICAgICB2YXIgcGYgPSBuc19ocGZzbXBsW2NobiAmIDFdO1xuICAgICAgICAgICAgdmFyIHBmUG9zID0gMDtcbiAgICAgICAgICAgIHZhciBhdHRhY2tUaHJlc2hvbGQgPSAoY2huID09IDMpID8gZ2ZjLm5zUHN5LmF0dGFja3RocmVfc1xuICAgICAgICAgICAgICAgIDogZ2ZjLm5zUHN5LmF0dGFja3RocmU7XG4gICAgICAgICAgICB2YXIgbnNfdXNlbG9uZ2Jsb2NrID0gMTtcblxuICAgICAgICAgICAgaWYgKGNobiA9PSAyKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSA1NzY7IGogPiAwOyArK2ksIC0taikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IG5zX2hwZnNtcGxbMF1baV07XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gbnNfaHBmc21wbFsxXVtpXTtcbiAgICAgICAgICAgICAgICAgICAgbnNfaHBmc21wbFswXVtpXSA9IGwgKyByO1xuICAgICAgICAgICAgICAgICAgICBuc19ocGZzbXBsWzFdW2ldID0gbCAtIHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAgICAgICogZGV0ZXJtaW5lIHRoZSBibG9jayB0eXBlICh3aW5kb3cgdHlwZSlcbiAgICAgICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgICAgICAvKiBjYWxjdWxhdGUgZW5lcmdpZXMgb2YgZWFjaCBzdWItc2hvcnRibG9ja3MgKi9cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZW5fc3Vic2hvcnRbaV0gPSBnZmMubnNQc3kubGFzdF9lbl9zdWJzaG9ydFtjaG5dW2kgKyA2XTtcbiAgICAgICAgICAgICAgICBhc3NlcnQoZ2ZjLm5zUHN5Lmxhc3RfZW5fc3Vic2hvcnRbY2huXVtpICsgNF0gPiAwKTtcbiAgICAgICAgICAgICAgICBhdHRhY2tfaW50ZW5zaXR5W2ldID0gZW5fc3Vic2hvcnRbaV1cbiAgICAgICAgICAgICAgICAgICAgLyBnZmMubnNQc3kubGFzdF9lbl9zdWJzaG9ydFtjaG5dW2kgKyA0XTtcbiAgICAgICAgICAgICAgICBlbl9zaG9ydFswXSArPSBlbl9zdWJzaG9ydFtpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA5OyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGZlID0gcGZQb3MgKyA1NzYgLyA5O1xuICAgICAgICAgICAgICAgIHZhciBwID0gMS47XG4gICAgICAgICAgICAgICAgZm9yICg7IHBmUG9zIDwgcGZlOyBwZlBvcysrKVxuICAgICAgICAgICAgICAgICAgICBpZiAocCA8IE1hdGguYWJzKHBmW3BmUG9zXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBwID0gTWF0aC5hYnMocGZbcGZQb3NdKTtcblxuICAgICAgICAgICAgICAgIGdmYy5uc1BzeS5sYXN0X2VuX3N1YnNob3J0W2Nobl1baV0gPSBlbl9zdWJzaG9ydFtpICsgM10gPSBwO1xuICAgICAgICAgICAgICAgIGVuX3Nob3J0WzEgKyBpIC8gM10gKz0gcDtcbiAgICAgICAgICAgICAgICBpZiAocCA+IGVuX3N1YnNob3J0W2kgKyAzIC0gMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGVuX3N1YnNob3J0W2kgKyAzIC0gMl0gPiAwKTtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAgLyBlbl9zdWJzaG9ydFtpICsgMyAtIDJdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZW5fc3Vic2hvcnRbaSArIDMgLSAyXSA+IHAgKiAxMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydChwID4gMCk7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBlbl9zdWJzaG9ydFtpICsgMyAtIDJdIC8gKHAgKiAxMC4wKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwID0gMC4wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhdHRhY2tfaW50ZW5zaXR5W2kgKyAzXSA9IHA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBwdWxzZSBsaWtlIHNpZ25hbCBkZXRlY3Rpb24gZm9yIGZhdGJveS53YXYgYW5kIHNvIG9uICovXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBlbm4gPSBlbl9zdWJzaG9ydFtpICogMyArIDNdXG4gICAgICAgICAgICAgICAgICAgICsgZW5fc3Vic2hvcnRbaSAqIDMgKyA0XSArIGVuX3N1YnNob3J0W2kgKiAzICsgNV07XG4gICAgICAgICAgICAgICAgdmFyIGZhY3RvciA9IDEuO1xuICAgICAgICAgICAgICAgIGlmIChlbl9zdWJzaG9ydFtpICogMyArIDVdICogNiA8IGVubikge1xuICAgICAgICAgICAgICAgICAgICBmYWN0b3IgKj0gMC41O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5fc3Vic2hvcnRbaSAqIDMgKyA0XSAqIDYgPCBlbm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvciAqPSAwLjU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3ViX3Nob3J0X2ZhY3RvcltjaG5dW2ldID0gZmFjdG9yO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZ2ZwLmFuYWx5c2lzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHggPSBhdHRhY2tfaW50ZW5zaXR5WzBdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoeCA8IGF0dGFja19pbnRlbnNpdHlbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBhdHRhY2tfaW50ZW5zaXR5W2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdmYy5waW5mby5lcnNbZ3Jfb3V0XVtjaG5dID0gZ2ZjLnBpbmZvLmVyc19zYXZlW2Nobl07XG4gICAgICAgICAgICAgICAgZ2ZjLnBpbmZvLmVyc19zYXZlW2Nobl0gPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKiBjb21wYXJlIGVuZXJnaWVzIGJldHdlZW4gc3ViLXNob3J0YmxvY2tzICovXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoMCA9PSBuc19hdHRhY2tzW2Nobl1baSAvIDNdXG4gICAgICAgICAgICAgICAgICAgICYmIGF0dGFja19pbnRlbnNpdHlbaV0gPiBhdHRhY2tUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgbnNfYXR0YWNrc1tjaG5dW2kgLyAzXSA9IChpICUgMykgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIHNob3VsZCBoYXZlIGVuZXJneSBjaGFuZ2UgYmV0d2VlbiBzaG9ydCBibG9ja3MsIGluIG9yZGVyIHRvIGF2b2lkXG4gICAgICAgICAgICAgKiBwZXJpb2RpYyBzaWduYWxzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qIEdvb2Qgc2FtcGxlcyB0byBzaG93IHRoZSBlZmZlY3QgYXJlIFRydW1wZXQgdGVzdCBzb25ncyAqL1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIEdCOiB0dW5lZCAoMSkgdG8gYXZvaWQgdG9vIG1hbnkgc2hvcnQgYmxvY2tzIGZvciB0ZXN0IHNhbXBsZVxuICAgICAgICAgICAgICogVFJVTVBFVFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogUkg6IHR1bmVkICgyKSB0byBsZXQgZW5vdWdoIHNob3J0IGJsb2NrcyB0aHJvdWdoIGZvciB0ZXN0IHNhbXBsZVxuICAgICAgICAgICAgICogRlNPTCBhbmQgU05BUFNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdSA9IGVuX3Nob3J0W2kgLSAxXTtcbiAgICAgICAgICAgICAgICB2YXIgdiA9IGVuX3Nob3J0W2ldO1xuICAgICAgICAgICAgICAgIHZhciBtID0gTWF0aC5tYXgodSwgdik7XG4gICAgICAgICAgICAgICAgaWYgKG0gPCA0MDAwMCkgeyAvKiAoMikgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPCAxLjcgKiB2ICYmIHYgPCAxLjcgKiB1KSB7IC8qICgxKSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gMSAmJiBuc19hdHRhY2tzW2Nobl1bMF0gPD0gbnNfYXR0YWNrc1tjaG5dW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnNfYXR0YWNrc1tjaG5dWzBdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5zX2F0dGFja3NbY2huXVtpXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuc19hdHRhY2tzW2Nobl1bMF0gPD0gZ2ZjLm5zUHN5Lmxhc3RBdHRhY2tzW2Nobl0pIHtcbiAgICAgICAgICAgICAgICBuc19hdHRhY2tzW2Nobl1bMF0gPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZ2ZjLm5zUHN5Lmxhc3RBdHRhY2tzW2Nobl0gPT0gM1xuICAgICAgICAgICAgICAgIHx8IChuc19hdHRhY2tzW2Nobl1bMF0gKyBuc19hdHRhY2tzW2Nobl1bMV1cbiAgICAgICAgICAgICAgICArIG5zX2F0dGFja3NbY2huXVsyXSArIG5zX2F0dGFja3NbY2huXVszXSkgIT0gMCkge1xuICAgICAgICAgICAgICAgIG5zX3VzZWxvbmdibG9jayA9IDA7XG5cbiAgICAgICAgICAgICAgICBpZiAobnNfYXR0YWNrc1tjaG5dWzFdICE9IDAgJiYgbnNfYXR0YWNrc1tjaG5dWzBdICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbnNfYXR0YWNrc1tjaG5dWzFdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5zX2F0dGFja3NbY2huXVsyXSAhPSAwICYmIG5zX2F0dGFja3NbY2huXVsxXSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5zX2F0dGFja3NbY2huXVsyXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuc19hdHRhY2tzW2Nobl1bM10gIT0gMCAmJiBuc19hdHRhY2tzW2Nobl1bMl0gIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBuc19hdHRhY2tzW2Nobl1bM10gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaG4gPCAyKSB7XG4gICAgICAgICAgICAgICAgdXNlbG9uZ2Jsb2NrW2Nobl0gPSBuc191c2Vsb25nYmxvY2s7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChuc191c2Vsb25nYmxvY2sgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB1c2Vsb25nYmxvY2tbMF0gPSB1c2Vsb25nYmxvY2tbMV0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIHRoZXJlIGlzIGEgb25lIGdyYW51bGUgZGVsYXkuIENvcHkgbWFza2luZ3MgY29tcHV0ZWQgbGFzdCBjYWxsXG4gICAgICAgICAgICAgKiBpbnRvIG1hc2tpbmdfcmF0aW8gdG8gcmV0dXJuIHRvIGNhbGxpbmcgcHJvZ3JhbS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZW5lcmd5W2Nobl0gPSBnZmMudG90X2VuZXJbY2huXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZicnBzeV9za2lwX21hc2tpbmdfcyhnZmMsIGNobiwgc2Jsb2NrKSB7XG4gICAgICAgIGlmIChzYmxvY2sgPT0gMCkge1xuICAgICAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBnZmMubnBhcnRfczsgYisrKSB7XG4gICAgICAgICAgICAgICAgZ2ZjLm5iX3MyW2Nobl1bYl0gPSBnZmMubmJfczFbY2huXVtiXTtcbiAgICAgICAgICAgICAgICBnZmMubmJfczFbY2huXVtiXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YnJwc3lfc2tpcF9tYXNraW5nX2woZ2ZjLCBjaG4pIHtcbiAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBnZmMubnBhcnRfbDsgYisrKSB7XG4gICAgICAgICAgICBnZmMubmJfMltjaG5dW2JdID0gZ2ZjLm5iXzFbY2huXVtiXTtcbiAgICAgICAgICAgIGdmYy5uYl8xW2Nobl1bYl0gPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHN5dmJyX2NhbGNfbWFza19pbmRleF9zKGdmYywgbWF4LCBhdmcsIG1hc2tfaWR4KSB7XG4gICAgICAgIHZhciBsYXN0X3RhYl9lbnRyeSA9IHRhYi5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgYiA9IDA7XG4gICAgICAgIHZhciBhID0gYXZnW2JdICsgYXZnW2IgKyAxXTtcbiAgICAgICAgYXNzZXJ0KGEgPj0gMCk7XG4gICAgICAgIGlmIChhID4gMC4wKSB7XG4gICAgICAgICAgICB2YXIgbSA9IG1heFtiXTtcbiAgICAgICAgICAgIGlmIChtIDwgbWF4W2IgKyAxXSlcbiAgICAgICAgICAgICAgICBtID0gbWF4W2IgKyAxXTtcbiAgICAgICAgICAgIGFzc2VydCgoZ2ZjLm51bWxpbmVzX3NbYl0gKyBnZmMubnVtbGluZXNfc1tiICsgMV0gLSAxKSA+IDApO1xuICAgICAgICAgICAgYSA9IDIwLjAgKiAobSAqIDIuMCAtIGEpXG4gICAgICAgICAgICAgICAgLyAoYSAqIChnZmMubnVtbGluZXNfc1tiXSArIGdmYy5udW1saW5lc19zW2IgKyAxXSAtIDEpKTtcbiAgICAgICAgICAgIHZhciBrID0gMCB8IGE7XG4gICAgICAgICAgICBpZiAoayA+IGxhc3RfdGFiX2VudHJ5KVxuICAgICAgICAgICAgICAgIGsgPSBsYXN0X3RhYl9lbnRyeTtcbiAgICAgICAgICAgIG1hc2tfaWR4W2JdID0gaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hc2tfaWR4W2JdID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoYiA9IDE7IGIgPCBnZmMubnBhcnRfcyAtIDE7IGIrKykge1xuICAgICAgICAgICAgYSA9IGF2Z1tiIC0gMV0gKyBhdmdbYl0gKyBhdmdbYiArIDFdO1xuICAgICAgICAgICAgYXNzZXJ0KGIgKyAxIDwgZ2ZjLm5wYXJ0X3MpO1xuICAgICAgICAgICAgYXNzZXJ0KGEgPj0gMCk7XG4gICAgICAgICAgICBpZiAoYSA+IDAuMCkge1xuICAgICAgICAgICAgICAgIHZhciBtID0gbWF4W2IgLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobSA8IG1heFtiXSlcbiAgICAgICAgICAgICAgICAgICAgbSA9IG1heFtiXTtcbiAgICAgICAgICAgICAgICBpZiAobSA8IG1heFtiICsgMV0pXG4gICAgICAgICAgICAgICAgICAgIG0gPSBtYXhbYiArIDFdO1xuICAgICAgICAgICAgICAgIGFzc2VydCgoZ2ZjLm51bWxpbmVzX3NbYiAtIDFdICsgZ2ZjLm51bWxpbmVzX3NbYl0gKyBnZmMubnVtbGluZXNfc1tiICsgMV0gLSAxKSA+IDApO1xuICAgICAgICAgICAgICAgIGEgPSAyMC4wXG4gICAgICAgICAgICAgICAgICAgICogKG0gKiAzLjAgLSBhKVxuICAgICAgICAgICAgICAgICAgICAvIChhICogKGdmYy5udW1saW5lc19zW2IgLSAxXSArIGdmYy5udW1saW5lc19zW2JdXG4gICAgICAgICAgICAgICAgICAgICsgZ2ZjLm51bWxpbmVzX3NbYiArIDFdIC0gMSkpO1xuICAgICAgICAgICAgICAgIHZhciBrID0gMCB8IGE7XG4gICAgICAgICAgICAgICAgaWYgKGsgPiBsYXN0X3RhYl9lbnRyeSlcbiAgICAgICAgICAgICAgICAgICAgayA9IGxhc3RfdGFiX2VudHJ5O1xuICAgICAgICAgICAgICAgIG1hc2tfaWR4W2JdID0gaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFza19pZHhbYl0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzc2VydChiID4gMCk7XG4gICAgICAgIGFzc2VydChiID09IGdmYy5ucGFydF9zIC0gMSk7XG5cbiAgICAgICAgYSA9IGF2Z1tiIC0gMV0gKyBhdmdbYl07XG4gICAgICAgIGFzc2VydChhID49IDApO1xuICAgICAgICBpZiAoYSA+IDAuMCkge1xuICAgICAgICAgICAgdmFyIG0gPSBtYXhbYiAtIDFdO1xuICAgICAgICAgICAgaWYgKG0gPCBtYXhbYl0pXG4gICAgICAgICAgICAgICAgbSA9IG1heFtiXTtcbiAgICAgICAgICAgIGFzc2VydCgoZ2ZjLm51bWxpbmVzX3NbYiAtIDFdICsgZ2ZjLm51bWxpbmVzX3NbYl0gLSAxKSA+IDApO1xuICAgICAgICAgICAgYSA9IDIwLjAgKiAobSAqIDIuMCAtIGEpXG4gICAgICAgICAgICAgICAgLyAoYSAqIChnZmMubnVtbGluZXNfc1tiIC0gMV0gKyBnZmMubnVtbGluZXNfc1tiXSAtIDEpKTtcbiAgICAgICAgICAgIHZhciBrID0gMCB8IGE7XG4gICAgICAgICAgICBpZiAoayA+IGxhc3RfdGFiX2VudHJ5KVxuICAgICAgICAgICAgICAgIGsgPSBsYXN0X3RhYl9lbnRyeTtcbiAgICAgICAgICAgIG1hc2tfaWR4W2JdID0gaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hc2tfaWR4W2JdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoYiA9PSAoZ2ZjLm5wYXJ0X3MgLSAxKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmJycHN5X2NvbXB1dGVfbWFza2luZ19zKGdmcCwgZmZ0ZW5lcmd5X3MsIGViLCB0aHIsIGNobiwgc2Jsb2NrKSB7XG4gICAgICAgIHZhciBnZmMgPSBnZnAuaW50ZXJuYWxfZmxhZ3M7XG4gICAgICAgIHZhciBtYXggPSBuZXcgZmxvYXRbRW5jb2Rlci5DQkFORFNdLCBhdmcgPSBuZXdfZmxvYXQoRW5jb2Rlci5DQkFORFMpO1xuICAgICAgICB2YXIgaSwgaiwgYjtcbiAgICAgICAgdmFyIG1hc2tfaWR4X3MgPSBuZXcgaW50W0VuY29kZXIuQ0JBTkRTXTtcblxuICAgICAgICBmb3IgKGIgPSBqID0gMDsgYiA8IGdmYy5ucGFydF9zOyArK2IpIHtcbiAgICAgICAgICAgIHZhciBlYmIgPSAwLCBtID0gMDtcbiAgICAgICAgICAgIHZhciBuID0gZ2ZjLm51bWxpbmVzX3NbYl07XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpLCArK2opIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBmZnRlbmVyZ3lfc1tzYmxvY2tdW2pdO1xuICAgICAgICAgICAgICAgIGViYiArPSBlbDtcbiAgICAgICAgICAgICAgICBpZiAobSA8IGVsKVxuICAgICAgICAgICAgICAgICAgICBtID0gZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlYltiXSA9IGViYjtcbiAgICAgICAgICAgIGFzc2VydChlYmIgPj0gMCk7XG4gICAgICAgICAgICBtYXhbYl0gPSBtO1xuICAgICAgICAgICAgYXNzZXJ0KG4gPiAwKTtcbiAgICAgICAgICAgIGF2Z1tiXSA9IGViYiAvIG47XG4gICAgICAgICAgICBhc3NlcnQoYXZnW2JdID49IDApO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChiID09IGdmYy5ucGFydF9zKTtcbiAgICAgICAgYXNzZXJ0KGogPT0gMTI5KTtcbiAgICAgICAgZm9yICg7IGIgPCBFbmNvZGVyLkNCQU5EUzsgKytiKSB7XG4gICAgICAgICAgICBtYXhbYl0gPSAwO1xuICAgICAgICAgICAgYXZnW2JdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwc3l2YnJfY2FsY19tYXNrX2luZGV4X3MoZ2ZjLCBtYXgsIGF2ZywgbWFza19pZHhfcyk7XG4gICAgICAgIGZvciAoaiA9IGIgPSAwOyBiIDwgZ2ZjLm5wYXJ0X3M7IGIrKykge1xuICAgICAgICAgICAgdmFyIGtrID0gZ2ZjLnMzaW5kX3NbYl1bMF07XG4gICAgICAgICAgICB2YXIgbGFzdCA9IGdmYy5zM2luZF9zW2JdWzFdO1xuICAgICAgICAgICAgdmFyIGRkLCBkZF9uO1xuICAgICAgICAgICAgdmFyIHgsIGVjYiwgYXZnX21hc2s7XG4gICAgICAgICAgICBkZCA9IG1hc2tfaWR4X3Nba2tdO1xuICAgICAgICAgICAgZGRfbiA9IDE7XG4gICAgICAgICAgICBlY2IgPSBnZmMuczNfc3Nbal0gKiBlYltra10gKiB0YWJbbWFza19pZHhfc1tra11dO1xuICAgICAgICAgICAgKytqO1xuICAgICAgICAgICAgKytraztcbiAgICAgICAgICAgIHdoaWxlIChrayA8PSBsYXN0KSB7XG4gICAgICAgICAgICAgICAgZGQgKz0gbWFza19pZHhfc1tra107XG4gICAgICAgICAgICAgICAgZGRfbiArPSAxO1xuICAgICAgICAgICAgICAgIHggPSBnZmMuczNfc3Nbal0gKiBlYltra10gKiB0YWJbbWFza19pZHhfc1tra11dO1xuICAgICAgICAgICAgICAgIGVjYiA9IHZicnBzeV9tYXNrX2FkZChlY2IsIHgsIGtrIC0gYik7XG4gICAgICAgICAgICAgICAgKytqO1xuICAgICAgICAgICAgICAgICsra2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZCA9ICgxICsgMiAqIGRkKSAvICgyICogZGRfbik7XG4gICAgICAgICAgICBhdmdfbWFzayA9IHRhYltkZF0gKiAwLjU7XG4gICAgICAgICAgICBlY2IgKj0gYXZnX21hc2s7XG4gICAgICAgICAgICB0aHJbYl0gPSBlY2I7XG4gICAgICAgICAgICBnZmMubmJfczJbY2huXVtiXSA9IGdmYy5uYl9zMVtjaG5dW2JdO1xuICAgICAgICAgICAgZ2ZjLm5iX3MxW2Nobl1bYl0gPSBlY2I7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBpZiBUSFIgZXhjZWVkcyBFQiwgdGhlIHF1YW50aXphdGlvbiByb3V0aW5lcyB3aWxsIHRha2UgdGhlXG4gICAgICAgICAgICAgICAgICogZGlmZmVyZW5jZSBmcm9tIG90aGVyIGJhbmRzLiBpbiBjYXNlIG9mIHN0cm9uZyB0b25hbCBzYW1wbGVzXG4gICAgICAgICAgICAgICAgICogKHRvbmFsdGVzdC53YXYpIHRoaXMgbGVhZHMgdG8gaGVhdnkgZGlzdG9ydGlvbnMuIHRoYXQncyB3aHlcbiAgICAgICAgICAgICAgICAgKiB3ZSBsaW1pdCBUSFIgaGVyZS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB4ID0gbWF4W2JdO1xuICAgICAgICAgICAgICAgIHggKj0gZ2ZjLm1pbnZhbF9zW2JdO1xuICAgICAgICAgICAgICAgIHggKj0gYXZnX21hc2s7XG4gICAgICAgICAgICAgICAgaWYgKHRocltiXSA+IHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyW2JdID0geDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2ZjLm1hc2tpbmdfbG93ZXIgPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhyW2JdICo9IGdmYy5tYXNraW5nX2xvd2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRocltiXSA+IGViW2JdKSB7XG4gICAgICAgICAgICAgICAgdGhyW2JdID0gZWJbYl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2ZjLm1hc2tpbmdfbG93ZXIgPCAxKSB7XG4gICAgICAgICAgICAgICAgdGhyW2JdICo9IGdmYy5tYXNraW5nX2xvd2VyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhc3NlcnQodGhyW2JdID49IDApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyBiIDwgRW5jb2Rlci5DQkFORFM7ICsrYikge1xuICAgICAgICAgICAgZWJbYl0gPSAwO1xuICAgICAgICAgICAgdGhyW2JdID0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZicnBzeV9jb21wdXRlX21hc2tpbmdfbChnZmMsIGZmdGVuZXJneSwgZWJfbCwgdGhyLCBjaG4pIHtcbiAgICAgICAgdmFyIG1heCA9IG5ld19mbG9hdChFbmNvZGVyLkNCQU5EUyksIGF2ZyA9IG5ld19mbG9hdChFbmNvZGVyLkNCQU5EUyk7XG4gICAgICAgIHZhciBtYXNrX2lkeF9sID0gbmV3X2ludChFbmNvZGVyLkNCQU5EUyArIDIpO1xuICAgICAgICB2YXIgYjtcblxuICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICAqIENhbGN1bGF0ZSB0aGUgZW5lcmd5IGFuZCB0aGUgdG9uYWxpdHkgb2YgZWFjaCBwYXJ0aXRpb24uXG4gICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIGNhbGNfZW5lcmd5KGdmYywgZmZ0ZW5lcmd5LCBlYl9sLCBtYXgsIGF2Zyk7XG4gICAgICAgIGNhbGNfbWFza19pbmRleF9sKGdmYywgbWF4LCBhdmcsIG1hc2tfaWR4X2wpO1xuXG4gICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgICogY29udm9sdmUgdGhlIHBhcnRpdGlvbmVkIGVuZXJneSBhbmQgdW5wcmVkaWN0YWJpbGl0eSB3aXRoIHRoZVxuICAgICAgICAgKiBzcHJlYWRpbmcgZnVuY3Rpb24sIHMzX2xbYl1ba11cbiAgICAgICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgIGZvciAoYiA9IDA7IGIgPCBnZmMubnBhcnRfbDsgYisrKSB7XG4gICAgICAgICAgICB2YXIgeCwgZWNiLCBhdmdfbWFzaywgdDtcbiAgICAgICAgICAgIC8qIGNvbnZvbHZlIHRoZSBwYXJ0aXRpb25lZCBlbmVyZ3kgd2l0aCB0aGUgc3ByZWFkaW5nIGZ1bmN0aW9uICovXG4gICAgICAgICAgICB2YXIga2sgPSBnZmMuczNpbmRbYl1bMF07XG4gICAgICAgICAgICB2YXIgbGFzdCA9IGdmYy5zM2luZFtiXVsxXTtcbiAgICAgICAgICAgIHZhciBkZCA9IDAsIGRkX24gPSAwO1xuICAgICAgICAgICAgZGQgPSBtYXNrX2lkeF9sW2trXTtcbiAgICAgICAgICAgIGRkX24gKz0gMTtcbiAgICAgICAgICAgIGVjYiA9IGdmYy5zM19sbFtrXSAqIGViX2xba2tdICogdGFiW21hc2tfaWR4X2xba2tdXTtcbiAgICAgICAgICAgICsraztcbiAgICAgICAgICAgICsra2s7XG4gICAgICAgICAgICB3aGlsZSAoa2sgPD0gbGFzdCkge1xuICAgICAgICAgICAgICAgIGRkICs9IG1hc2tfaWR4X2xba2tdO1xuICAgICAgICAgICAgICAgIGRkX24gKz0gMTtcbiAgICAgICAgICAgICAgICB4ID0gZ2ZjLnMzX2xsW2tdICogZWJfbFtra10gKiB0YWJbbWFza19pZHhfbFtra11dO1xuICAgICAgICAgICAgICAgIHQgPSB2YnJwc3lfbWFza19hZGQoZWNiLCB4LCBrayAtIGIpO1xuICAgICAgICAgICAgICAgIGVjYiA9IHQ7XG4gICAgICAgICAgICAgICAgKytrO1xuICAgICAgICAgICAgICAgICsra2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZCA9ICgxICsgMiAqIGRkKSAvICgyICogZGRfbik7XG4gICAgICAgICAgICBhdmdfbWFzayA9IHRhYltkZF0gKiAwLjU7XG4gICAgICAgICAgICBlY2IgKj0gYXZnX21hc2s7XG5cbiAgICAgICAgICAgIC8qKioqIGxvbmcgYmxvY2sgcHJlLWVjaG8gY29udHJvbCAqKioqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiA8UFJFPlxuICAgICAgICAgICAgICogZG9udCB1c2UgbG9uZyBibG9jayBwcmUtZWNobyBjb250cm9sIGlmIHByZXZpb3VzIGdyYW51bGUgd2FzXG4gICAgICAgICAgICAgKiBhIHNob3J0IGJsb2NrLiAgVGhpcyBpcyB0byBhdm9pZCB0aGUgc2l0dWF0aW9uOlxuICAgICAgICAgICAgICogZnJhbWUwOiAgcXVpZXQgKHZlcnkgbG93IG1hc2tpbmcpXG4gICAgICAgICAgICAgKiBmcmFtZTE6ICBzdXJnZSAgKHRyaWdnZXJzIHNob3J0IGJsb2NrcylcbiAgICAgICAgICAgICAqIGZyYW1lMjogIHJlZ3VsYXIgZnJhbWUuICBsb29rcyBsaWtlIHByZS1lY2hvIHdoZW4gY29tcGFyZWQgdG9cbiAgICAgICAgICAgICAqICAgICAgICAgIGZyYW1lMCwgYnV0IGFsbCBwcmUtZWNobyB3YXMgaW4gZnJhbWUxLlxuICAgICAgICAgICAgICogPC9QUkU+XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBjaG49MCwxIEwgYW5kIFIgY2hhbm5lbHMgY2huPTIsMyBTIGFuZCBNIGNoYW5uZWxzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoZ2ZjLmJsb2NrdHlwZV9vbGRbY2huICYgMHgwMV0gPT0gRW5jb2Rlci5TSE9SVF9UWVBFKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVjYl9saW1pdCA9IHJwZWxldiAqIGdmYy5uYl8xW2Nobl1bYl07XG4gICAgICAgICAgICAgICAgaWYgKGVjYl9saW1pdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyW2JdID0gTWF0aC5taW4oZWNiLCBlY2JfbGltaXQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiA8UFJFPlxuICAgICAgICAgICAgICAgICAgICAgKiBSb2JlcnQgMDcxMjA5OlxuICAgICAgICAgICAgICAgICAgICAgKiBCZWNhdXNlIHdlIGRvbid0IGNhbGN1bGF0ZSBsb25nIGJsb2NrIHBzeSB3aGVuIHdlIGtub3cgYSBncmFudWxlXG4gICAgICAgICAgICAgICAgICAgICAqIHNob3VsZCBiZSBvZiBzaG9ydCBibG9ja3MsIHdlIGRvbid0IGhhdmUgYW55IGNsdWUgaG93IHRoZSBncmFudWxlXG4gICAgICAgICAgICAgICAgICAgICAqIGJlZm9yZSB3b3VsZCBoYXZlIGxvb2tlZCBsaWtlIGFzIGEgbG9uZyBibG9jay4gU28gd2UgaGF2ZSB0byBndWVzc1xuICAgICAgICAgICAgICAgICAgICAgKiBhIGxpdHRsZSBiaXQgZm9yIHRoaXMgRU5EX1RZUEUgYmxvY2suXG4gICAgICAgICAgICAgICAgICAgICAqIE1vc3Qgb2YgdGhlIHRpbWUgd2UgZ2V0IGF3YXkgd2l0aCB0aGlzIHNsb3BweW5lc3MuIChmaW5nZXJzIGNyb3NzZWQgOilcbiAgICAgICAgICAgICAgICAgICAgICogVGhlIHNwZWVkIGluY3JlYXNlIGlzIHdvcnRoIGl0LlxuICAgICAgICAgICAgICAgICAgICAgKiA8L1BSRT5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHRocltiXSA9IE1hdGgubWluKGVjYiwgZWJfbFtiXSAqIE5TX1BSRUVDSE9fQVRUMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZWNiX2xpbWl0XzIgPSBycGVsZXYyICogZ2ZjLm5iXzJbY2huXVtiXTtcbiAgICAgICAgICAgICAgICB2YXIgZWNiX2xpbWl0XzEgPSBycGVsZXYgKiBnZmMubmJfMVtjaG5dW2JdO1xuICAgICAgICAgICAgICAgIHZhciBlY2JfbGltaXQ7XG4gICAgICAgICAgICAgICAgaWYgKGVjYl9saW1pdF8yIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZWNiX2xpbWl0XzIgPSBlY2I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlY2JfbGltaXRfMSA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVjYl9saW1pdF8xID0gZWNiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZ2ZjLmJsb2NrdHlwZV9vbGRbY2huICYgMHgwMV0gPT0gRW5jb2Rlci5OT1JNX1RZUEUpIHtcbiAgICAgICAgICAgICAgICAgICAgZWNiX2xpbWl0ID0gTWF0aC5taW4oZWNiX2xpbWl0XzEsIGVjYl9saW1pdF8yKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlY2JfbGltaXQgPSBlY2JfbGltaXRfMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyW2JdID0gTWF0aC5taW4oZWNiLCBlY2JfbGltaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2ZjLm5iXzJbY2huXVtiXSA9IGdmYy5uYl8xW2Nobl1bYl07XG4gICAgICAgICAgICBnZmMubmJfMVtjaG5dW2JdID0gZWNiO1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogaWYgVEhSIGV4Y2VlZHMgRUIsIHRoZSBxdWFudGl6YXRpb24gcm91dGluZXMgd2lsbCB0YWtlIHRoZVxuICAgICAgICAgICAgICAgICAqIGRpZmZlcmVuY2UgZnJvbSBvdGhlciBiYW5kcy4gaW4gY2FzZSBvZiBzdHJvbmcgdG9uYWwgc2FtcGxlc1xuICAgICAgICAgICAgICAgICAqICh0b25hbHRlc3Qud2F2KSB0aGlzIGxlYWRzIHRvIGhlYXZ5IGRpc3RvcnRpb25zLiB0aGF0J3Mgd2h5XG4gICAgICAgICAgICAgICAgICogd2UgbGltaXQgVEhSIGhlcmUuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgeCA9IG1heFtiXTtcbiAgICAgICAgICAgICAgICB4ICo9IGdmYy5taW52YWxfbFtiXTtcbiAgICAgICAgICAgICAgICB4ICo9IGF2Z19tYXNrO1xuICAgICAgICAgICAgICAgIGlmICh0aHJbYl0gPiB4KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocltiXSA9IHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdmYy5tYXNraW5nX2xvd2VyID4gMSkge1xuICAgICAgICAgICAgICAgIHRocltiXSAqPSBnZmMubWFza2luZ19sb3dlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aHJbYl0gPiBlYl9sW2JdKSB7XG4gICAgICAgICAgICAgICAgdGhyW2JdID0gZWJfbFtiXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZmMubWFza2luZ19sb3dlciA8IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJbYl0gKj0gZ2ZjLm1hc2tpbmdfbG93ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnQodGhyW2JdID49IDApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyBiIDwgRW5jb2Rlci5DQkFORFM7ICsrYikge1xuICAgICAgICAgICAgZWJfbFtiXSA9IDA7XG4gICAgICAgICAgICB0aHJbYl0gPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmJycHN5X2NvbXB1dGVfYmxvY2tfdHlwZShnZnAsIHVzZWxvbmdibG9jaykge1xuICAgICAgICB2YXIgZ2ZjID0gZ2ZwLmludGVybmFsX2ZsYWdzO1xuXG4gICAgICAgIGlmIChnZnAuc2hvcnRfYmxvY2tzID09IFNob3J0QmxvY2suc2hvcnRfYmxvY2tfY291cGxlZFxuICAgICAgICAgICAgICAgIC8qIGZvcmNlIGJvdGggY2hhbm5lbHMgdG8gdXNlIHRoZSBzYW1lIGJsb2NrIHR5cGUgKi9cbiAgICAgICAgICAgICAgICAvKiB0aGlzIGlzIG5lY2Vzc2FyeSBpZiB0aGUgZnJhbWUgaXMgdG8gYmUgZW5jb2RlZCBpbiBtc19zdGVyZW8uICovXG4gICAgICAgICAgICAgICAgLyogQnV0IGV2ZW4gd2l0aG91dCBtc19zdGVyZW8sIEZoRyBkb2VzIHRoaXMgKi9cbiAgICAgICAgICAgICYmICEodXNlbG9uZ2Jsb2NrWzBdICE9IDAgJiYgdXNlbG9uZ2Jsb2NrWzFdICE9IDApKVxuICAgICAgICAgICAgdXNlbG9uZ2Jsb2NrWzBdID0gdXNlbG9uZ2Jsb2NrWzFdID0gMDtcblxuICAgICAgICBmb3IgKHZhciBjaG4gPSAwOyBjaG4gPCBnZmMuY2hhbm5lbHNfb3V0OyBjaG4rKykge1xuICAgICAgICAgICAgLyogZGlzYWJsZSBzaG9ydCBibG9ja3MgKi9cbiAgICAgICAgICAgIGlmIChnZnAuc2hvcnRfYmxvY2tzID09IFNob3J0QmxvY2suc2hvcnRfYmxvY2tfZGlzcGVuc2VkKSB7XG4gICAgICAgICAgICAgICAgdXNlbG9uZ2Jsb2NrW2Nobl0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdmcC5zaG9ydF9ibG9ja3MgPT0gU2hvcnRCbG9jay5zaG9ydF9ibG9ja19mb3JjZWQpIHtcbiAgICAgICAgICAgICAgICB1c2Vsb25nYmxvY2tbY2huXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YnJwc3lfYXBwbHlfYmxvY2tfdHlwZShnZnAsIHVzZWxvbmdibG9jaywgYmxvY2t0eXBlX2QpIHtcbiAgICAgICAgdmFyIGdmYyA9IGdmcC5pbnRlcm5hbF9mbGFncztcblxuICAgICAgICAvKlxuICAgICAgICAgKiB1cGRhdGUgdGhlIGJsb2NrdHlwZSBvZiB0aGUgcHJldmlvdXMgZ3JhbnVsZSwgc2luY2UgaXQgZGVwZW5kcyBvblxuICAgICAgICAgKiB3aGF0IGhhcHBlbmQgaW4gdGhpcyBncmFudWxlXG4gICAgICAgICAqL1xuICAgICAgICBmb3IgKHZhciBjaG4gPSAwOyBjaG4gPCBnZmMuY2hhbm5lbHNfb3V0OyBjaG4rKykge1xuICAgICAgICAgICAgdmFyIGJsb2NrdHlwZSA9IEVuY29kZXIuTk9STV9UWVBFO1xuICAgICAgICAgICAgLyogZGlzYWJsZSBzaG9ydCBibG9ja3MgKi9cblxuICAgICAgICAgICAgaWYgKHVzZWxvbmdibG9ja1tjaG5dICE9IDApIHtcbiAgICAgICAgICAgICAgICAvKiBubyBhdHRhY2sgOiB1c2UgbG9uZyBibG9ja3MgKi9cbiAgICAgICAgICAgICAgICBhc3NlcnQoZ2ZjLmJsb2NrdHlwZV9vbGRbY2huXSAhPSBFbmNvZGVyLlNUQVJUX1RZUEUpO1xuICAgICAgICAgICAgICAgIGlmIChnZmMuYmxvY2t0eXBlX29sZFtjaG5dID09IEVuY29kZXIuU0hPUlRfVFlQRSlcbiAgICAgICAgICAgICAgICAgICAgYmxvY2t0eXBlID0gRW5jb2Rlci5TVE9QX1RZUEU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8qIGF0dGFjayA6IHVzZSBzaG9ydCBibG9ja3MgKi9cbiAgICAgICAgICAgICAgICBibG9ja3R5cGUgPSBFbmNvZGVyLlNIT1JUX1RZUEU7XG4gICAgICAgICAgICAgICAgaWYgKGdmYy5ibG9ja3R5cGVfb2xkW2Nobl0gPT0gRW5jb2Rlci5OT1JNX1RZUEUpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2ZjLmJsb2NrdHlwZV9vbGRbY2huXSA9IEVuY29kZXIuU1RBUlRfVFlQRTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGdmYy5ibG9ja3R5cGVfb2xkW2Nobl0gPT0gRW5jb2Rlci5TVE9QX1RZUEUpXG4gICAgICAgICAgICAgICAgICAgIGdmYy5ibG9ja3R5cGVfb2xkW2Nobl0gPSBFbmNvZGVyLlNIT1JUX1RZUEU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJsb2NrdHlwZV9kW2Nobl0gPSBnZmMuYmxvY2t0eXBlX29sZFtjaG5dO1xuICAgICAgICAgICAgLy8gdmFsdWUgcmV0dXJuZWQgdG8gY2FsbGluZyBwcm9ncmFtXG4gICAgICAgICAgICBnZmMuYmxvY2t0eXBlX29sZFtjaG5dID0gYmxvY2t0eXBlO1xuICAgICAgICAgICAgLy8gc2F2ZSBmb3IgbmV4dCBjYWxsIHRvIGwzcHN5X2FuYWxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNvbXB1dGUgTS9TIHRocmVzaG9sZHMgZnJvbSBKb2huc3RvbiAmIEZlcnJlaXJhIDE5OTIgSUNBU1NQIHBhcGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmJycHN5X2NvbXB1dGVfTVNfdGhyZXNob2xkcyhlYiwgdGhyLCBjYl9tbGQsIGF0aF9jYiwgYXRoYWRqdXN0LCBtc2ZpeCwgbikge1xuICAgICAgICB2YXIgbXNmaXgyID0gbXNmaXggKiAyO1xuICAgICAgICB2YXIgYXRobG93ZXIgPSBtc2ZpeCA+IDAgPyBNYXRoLnBvdygxMCwgYXRoYWRqdXN0KSA6IDE7XG4gICAgICAgIHZhciByc2lkZSwgcm1pZDtcbiAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBuOyArK2IpIHtcbiAgICAgICAgICAgIHZhciBlYk0gPSBlYlsyXVtiXTtcbiAgICAgICAgICAgIHZhciBlYlMgPSBlYlszXVtiXTtcbiAgICAgICAgICAgIHZhciB0aG1MID0gdGhyWzBdW2JdO1xuICAgICAgICAgICAgdmFyIHRobVIgPSB0aHJbMV1bYl07XG4gICAgICAgICAgICB2YXIgdGhtTSA9IHRoclsyXVtiXTtcbiAgICAgICAgICAgIHZhciB0aG1TID0gdGhyWzNdW2JdO1xuXG4gICAgICAgICAgICAvKiB1c2UgdGhpcyBmaXggaWYgTCAmIFIgbWFza2luZyBkaWZmZXJzIGJ5IDJkYiBvciBsZXNzICovXG4gICAgICAgICAgICBpZiAodGhtTCA8PSAxLjU4ICogdGhtUiAmJiB0aG1SIDw9IDEuNTggKiB0aG1MKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1sZF9tID0gY2JfbWxkW2JdICogZWJTO1xuICAgICAgICAgICAgICAgIHZhciBtbGRfcyA9IGNiX21sZFtiXSAqIGViTTtcbiAgICAgICAgICAgICAgICBybWlkID0gTWF0aC5tYXgodGhtTSwgTWF0aC5taW4odGhtUywgbWxkX20pKTtcbiAgICAgICAgICAgICAgICByc2lkZSA9IE1hdGgubWF4KHRobVMsIE1hdGgubWluKHRobU0sIG1sZF9zKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJtaWQgPSB0aG1NO1xuICAgICAgICAgICAgICAgIHJzaWRlID0gdGhtUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtc2ZpeCA+IDApIHtcbiAgICAgICAgICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAgICAgICAgIC8qIEFkanVzdCBNL1MgbWFza2luZ3MgaWYgdXNlciBzZXQgXCJtc2ZpeFwiICovXG4gICAgICAgICAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgICAgICAgICAvKiBOYW9raSBTaGliYXRhIDIwMDAgKi9cbiAgICAgICAgICAgICAgICB2YXIgdGhtTFIsIHRobU1TO1xuICAgICAgICAgICAgICAgIHZhciBhdGggPSBhdGhfY2JbYl0gKiBhdGhsb3dlcjtcbiAgICAgICAgICAgICAgICB0aG1MUiA9IE1hdGgubWluKE1hdGgubWF4KHRobUwsIGF0aCksIE1hdGgubWF4KHRobVIsIGF0aCkpO1xuICAgICAgICAgICAgICAgIHRobU0gPSBNYXRoLm1heChybWlkLCBhdGgpO1xuICAgICAgICAgICAgICAgIHRobVMgPSBNYXRoLm1heChyc2lkZSwgYXRoKTtcbiAgICAgICAgICAgICAgICB0aG1NUyA9IHRobU0gKyB0aG1TO1xuICAgICAgICAgICAgICAgIGlmICh0aG1NUyA+IDAgJiYgKHRobUxSICogbXNmaXgyKSA8IHRobU1TKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmID0gdGhtTFIgKiBtc2ZpeDIgLyB0aG1NUztcbiAgICAgICAgICAgICAgICAgICAgdGhtTSAqPSBmO1xuICAgICAgICAgICAgICAgICAgICB0aG1TICo9IGY7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydCh0aG1NUyA+IDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBybWlkID0gTWF0aC5taW4odGhtTSwgcm1pZCk7XG4gICAgICAgICAgICAgICAgcnNpZGUgPSBNYXRoLm1pbih0aG1TLCByc2lkZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocm1pZCA+IGViTSkge1xuICAgICAgICAgICAgICAgIHJtaWQgPSBlYk07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocnNpZGUgPiBlYlMpIHtcbiAgICAgICAgICAgICAgICByc2lkZSA9IGViUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoclsyXVtiXSA9IHJtaWQ7XG4gICAgICAgICAgICB0aHJbM11bYl0gPSByc2lkZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuTDNwc3ljaG9fYW5hbF92YnIgPSBmdW5jdGlvbiAoZ2ZwLCBidWZmZXIsIGJ1ZlBvcywgZ3Jfb3V0LCBtYXNraW5nX3JhdGlvLCBtYXNraW5nX01TX3JhdGlvLCBwZXJjZXBfZW50cm9weSwgcGVyY2VwX01TX2VudHJvcHksIGVuZXJneSwgYmxvY2t0eXBlX2QpIHtcbiAgICAgICAgdmFyIGdmYyA9IGdmcC5pbnRlcm5hbF9mbGFncztcblxuICAgICAgICAvKiBmZnQgYW5kIGVuZXJneSBjYWxjdWxhdGlvbiAqL1xuICAgICAgICB2YXIgd3NhbXBfbDtcbiAgICAgICAgdmFyIHdzYW1wX3M7XG4gICAgICAgIHZhciBmZnRlbmVyZ3kgPSBuZXdfZmxvYXQoRW5jb2Rlci5IQkxLU0laRSk7XG4gICAgICAgIHZhciBmZnRlbmVyZ3lfcyA9IG5ld19mbG9hdF9uKFszLCBFbmNvZGVyLkhCTEtTSVpFX3NdKTtcbiAgICAgICAgdmFyIHdzYW1wX0wgPSBuZXdfZmxvYXRfbihbMiwgRW5jb2Rlci5CTEtTSVpFXSk7XG4gICAgICAgIHZhciB3c2FtcF9TID0gbmV3X2Zsb2F0X24oWzIsIDMsIEVuY29kZXIuQkxLU0laRV9zXSk7XG4gICAgICAgIHZhciBlYiA9IG5ld19mbG9hdF9uKFs0LCBFbmNvZGVyLkNCQU5EU10pLCB0aHIgPSBuZXdfZmxvYXRfbihbNCwgRW5jb2Rlci5DQkFORFNdKTtcbiAgICAgICAgdmFyIHN1Yl9zaG9ydF9mYWN0b3IgPSBuZXdfZmxvYXRfbihbNCwgM10pO1xuICAgICAgICB2YXIgcGNmYWN0ID0gMC42O1xuXG4gICAgICAgIC8qIGJsb2NrIHR5cGUgKi9cbiAgICAgICAgdmFyIG5zX2F0dGFja3MgPSBbWzAsIDAsIDAsIDBdLCBbMCwgMCwgMCwgMF0sIFswLCAwLCAwLCAwXSxcbiAgICAgICAgICAgIFswLCAwLCAwLCAwXV07XG4gICAgICAgIHZhciB1c2Vsb25nYmxvY2sgPSBuZXdfaW50KDIpO1xuXG4gICAgICAgIC8qIHVzdWFsIHZhcmlhYmxlcyBsaWtlIGxvb3AgaW5kaWNlcywgZXRjLi4gKi9cblxuICAgICAgICAvKiBjaG49MiBhbmQgMyA9IE1pZCBhbmQgU2lkZSBjaGFubmVscyAqL1xuICAgICAgICB2YXIgbl9jaG5fcHN5ID0gKGdmcC5tb2RlID09IE1QRUdNb2RlLkpPSU5UX1NURVJFTykgPyA0XG4gICAgICAgICAgICA6IGdmYy5jaGFubmVsc19vdXQ7XG5cbiAgICAgICAgdmJycHN5X2F0dGFja19kZXRlY3Rpb24oZ2ZwLCBidWZmZXIsIGJ1ZlBvcywgZ3Jfb3V0LCBtYXNraW5nX3JhdGlvLFxuICAgICAgICAgICAgbWFza2luZ19NU19yYXRpbywgZW5lcmd5LCBzdWJfc2hvcnRfZmFjdG9yLCBuc19hdHRhY2tzLFxuICAgICAgICAgICAgdXNlbG9uZ2Jsb2NrKTtcblxuICAgICAgICB2YnJwc3lfY29tcHV0ZV9ibG9ja190eXBlKGdmcCwgdXNlbG9uZ2Jsb2NrKTtcblxuICAgICAgICAvKiBMT05HIEJMT0NLIENBU0UgKi9cbiAgICAgICAge1xuICAgICAgICAgICAgZm9yICh2YXIgY2huID0gMDsgY2huIDwgbl9jaG5fcHN5OyBjaG4rKykge1xuICAgICAgICAgICAgICAgIHZhciBjaDAxID0gY2huICYgMHgwMTtcbiAgICAgICAgICAgICAgICB3c2FtcF9sID0gd3NhbXBfTDtcbiAgICAgICAgICAgICAgICB2YnJwc3lfY29tcHV0ZV9mZnRfbChnZnAsIGJ1ZmZlciwgYnVmUG9zLCBjaG4sIGdyX291dCxcbiAgICAgICAgICAgICAgICAgICAgZmZ0ZW5lcmd5LCB3c2FtcF9sLCBjaDAxKTtcblxuICAgICAgICAgICAgICAgIHZicnBzeV9jb21wdXRlX2xvdWRuZXNzX2FwcHJveGltYXRpb25fbChnZnAsIGdyX291dCwgY2huLFxuICAgICAgICAgICAgICAgICAgICBmZnRlbmVyZ3kpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHVzZWxvbmdibG9ja1tjaDAxXSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZicnBzeV9jb21wdXRlX21hc2tpbmdfbChnZmMsIGZmdGVuZXJneSwgZWJbY2huXSwgdGhyW2Nobl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjaG4pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZicnBzeV9za2lwX21hc2tpbmdfbChnZmMsIGNobik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh1c2Vsb25nYmxvY2tbMF0gKyB1c2Vsb25nYmxvY2tbMV0pID09IDIpIHtcbiAgICAgICAgICAgICAgICAvKiBNL1MgY2hhbm5lbCAqL1xuICAgICAgICAgICAgICAgIGlmIChnZnAubW9kZSA9PSBNUEVHTW9kZS5KT0lOVF9TVEVSRU8pIHtcbiAgICAgICAgICAgICAgICAgICAgdmJycHN5X2NvbXB1dGVfTVNfdGhyZXNob2xkcyhlYiwgdGhyLCBnZmMubWxkX2NiX2wsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZmMuQVRILmNiX2wsIGdmcC5BVEhsb3dlciAqIGdmYy5BVEguYWRqdXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2ZwLm1zZml4LCBnZmMubnBhcnRfbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogVE9ETzogYXBwbHkgYWRhcHRpdmUgQVRIIG1hc2tpbmcgaGVyZSA/PyAqL1xuICAgICAgICAgICAgZm9yICh2YXIgY2huID0gMDsgY2huIDwgbl9jaG5fcHN5OyBjaG4rKykge1xuICAgICAgICAgICAgICAgIHZhciBjaDAxID0gY2huICYgMHgwMTtcbiAgICAgICAgICAgICAgICBpZiAodXNlbG9uZ2Jsb2NrW2NoMDFdICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udmVydF9wYXJ0aXRpb24yc2NhbGVmYWNfbChnZmMsIGViW2Nobl0sIHRocltjaG5dLCBjaG4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qIFNIT1JUIEJMT0NLUyBDQVNFICovXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZvciAodmFyIHNibG9jayA9IDA7IHNibG9jayA8IDM7IHNibG9jaysrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY2huID0gMDsgY2huIDwgbl9jaG5fcHN5OyArK2Nobikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2gwMSA9IGNobiAmIDB4MDE7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHVzZWxvbmdibG9ja1tjaDAxXSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YnJwc3lfc2tpcF9tYXNraW5nX3MoZ2ZjLCBjaG4sIHNibG9jayk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBjb21wdXRlIG1hc2tpbmcgdGhyZXNob2xkcyBmb3Igc2hvcnQgYmxvY2tzICovXG4gICAgICAgICAgICAgICAgICAgICAgICB3c2FtcF9zID0gd3NhbXBfUztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZicnBzeV9jb21wdXRlX2ZmdF9zKGdmcCwgYnVmZmVyLCBidWZQb3MsIGNobiwgc2Jsb2NrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZmdGVuZXJneV9zLCB3c2FtcF9zLCBjaDAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZicnBzeV9jb21wdXRlX21hc2tpbmdfcyhnZnAsIGZmdGVuZXJneV9zLCBlYltjaG5dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocltjaG5dLCBjaG4sIHNibG9jayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCh1c2Vsb25nYmxvY2tbMF0gKyB1c2Vsb25nYmxvY2tbMV0pID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLyogTS9TIGNoYW5uZWwgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGdmcC5tb2RlID09IE1QRUdNb2RlLkpPSU5UX1NURVJFTykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmJycHN5X2NvbXB1dGVfTVNfdGhyZXNob2xkcyhlYiwgdGhyLCBnZmMubWxkX2NiX3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2ZjLkFUSC5jYl9zLCBnZnAuQVRIbG93ZXIgKiBnZmMuQVRILmFkanVzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZnAubXNmaXgsIGdmYy5ucGFydF9zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvKiBML1IgY2hhbm5lbCAqL1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBUT0RPOiBhcHBseSBhZGFwdGl2ZSBBVEggbWFza2luZyBoZXJlID8/ICovXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY2huID0gMDsgY2huIDwgbl9jaG5fcHN5OyArK2Nobikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2gwMSA9IGNobiAmIDB4MDE7XG4gICAgICAgICAgICAgICAgICAgIGlmICgwID09IHVzZWxvbmdibG9ja1tjaDAxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udmVydF9wYXJ0aXRpb24yc2NhbGVmYWNfcyhnZmMsIGViW2Nobl0sIHRocltjaG5dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNobiwgc2Jsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqKiogc2hvcnQgYmxvY2sgcHJlLWVjaG8gY29udHJvbCAqKioqL1xuICAgICAgICAgICAgZm9yICh2YXIgY2huID0gMDsgY2huIDwgbl9jaG5fcHN5OyBjaG4rKykge1xuICAgICAgICAgICAgICAgIHZhciBjaDAxID0gY2huICYgMHgwMTtcblxuICAgICAgICAgICAgICAgIGlmICh1c2Vsb25nYmxvY2tbY2gwMV0gIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgc2IgPSAwOyBzYiA8IEVuY29kZXIuU0JNQVhfczsgc2IrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3X3RobW0gPSBuZXdfZmxvYXQoMyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHNibG9jayA9IDA7IHNibG9jayA8IDM7IHNibG9jaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGhtbSA9IGdmYy50aG1bY2huXS5zW3NiXVtzYmxvY2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhtbSAqPSBOU19QUkVFQ0hPX0FUVDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuc19hdHRhY2tzW2Nobl1bc2Jsb2NrXSA+PSAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgbnNfYXR0YWNrc1tjaG5dW3NibG9jayArIDFdID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gKHNibG9jayAhPSAwKSA/IHNibG9jayAtIDEgOiAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gTlNfSU5URVJQKGdmYy50aG1bY2huXS5zW3NiXVtpZHhdLCB0aG1tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOU19QUkVFQ0hPX0FUVDEgKiBwY2ZhY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRobW0gPSBNYXRoLm1pbih0aG1tLCBwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnNfYXR0YWNrc1tjaG5dW3NibG9ja10gPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSAoc2Jsb2NrICE9IDApID8gc2Jsb2NrIC0gMSA6IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBOU19JTlRFUlAoZ2ZjLnRobVtjaG5dLnNbc2JdW2lkeF0sIHRobW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5TX1BSRUVDSE9fQVRUMiAqIHBjZmFjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhtbSA9IE1hdGgubWluKHRobW0sIHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgoc2Jsb2NrICE9IDAgJiYgbnNfYXR0YWNrc1tjaG5dW3NibG9jayAtIDFdID09IDMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgKHNibG9jayA9PSAwICYmIGdmYy5uc1BzeS5sYXN0QXR0YWNrc1tjaG5dID09IDMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IChzYmxvY2sgIT0gMikgPyBzYmxvY2sgKyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IE5TX0lOVEVSUChnZmMudGhtW2Nobl0uc1tzYl1baWR4XSwgdGhtbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTlNfUFJFRUNIT19BVFQyICogcGNmYWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aG1tID0gTWF0aC5taW4odGhtbSwgcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIHB1bHNlIGxpa2Ugc2lnbmFsIGRldGVjdGlvbiBmb3IgZmF0Ym95LndhdiBhbmQgc28gb24gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRobW0gKj0gc3ViX3Nob3J0X2ZhY3RvcltjaG5dW3NibG9ja107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld190aG1tW3NibG9ja10gPSB0aG1tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHNibG9jayA9IDA7IHNibG9jayA8IDM7IHNibG9jaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZmMudGhtW2Nobl0uc1tzYl1bc2Jsb2NrXSA9IG5ld190aG1tW3NibG9ja107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgY2huID0gMDsgY2huIDwgbl9jaG5fcHN5OyBjaG4rKykge1xuICAgICAgICAgICAgZ2ZjLm5zUHN5Lmxhc3RBdHRhY2tzW2Nobl0gPSBuc19hdHRhY2tzW2Nobl1bMl07XG4gICAgICAgIH1cblxuICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICAqIGRldGVybWluZSBmaW5hbCBibG9jayB0eXBlXG4gICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIHZicnBzeV9hcHBseV9ibG9ja190eXBlKGdmcCwgdXNlbG9uZ2Jsb2NrLCBibG9ja3R5cGVfZCk7XG5cbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAgKiBjb21wdXRlIHRoZSB2YWx1ZSBvZiBQRSB0byByZXR1cm4gLi4uIG5vIGRlbGF5IGFuZCBhZHZhbmNlXG4gICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIGZvciAodmFyIGNobiA9IDA7IGNobiA8IG5fY2huX3BzeTsgY2huKyspIHtcbiAgICAgICAgICAgIHZhciBwcGU7XG4gICAgICAgICAgICB2YXIgcHBlUG9zO1xuICAgICAgICAgICAgdmFyIHR5cGU7XG4gICAgICAgICAgICB2YXIgbXI7XG5cbiAgICAgICAgICAgIGlmIChjaG4gPiAxKSB7XG4gICAgICAgICAgICAgICAgcHBlID0gcGVyY2VwX01TX2VudHJvcHk7XG4gICAgICAgICAgICAgICAgcHBlUG9zID0gLTI7XG4gICAgICAgICAgICAgICAgdHlwZSA9IEVuY29kZXIuTk9STV9UWVBFO1xuICAgICAgICAgICAgICAgIGlmIChibG9ja3R5cGVfZFswXSA9PSBFbmNvZGVyLlNIT1JUX1RZUEVcbiAgICAgICAgICAgICAgICAgICAgfHwgYmxvY2t0eXBlX2RbMV0gPT0gRW5jb2Rlci5TSE9SVF9UWVBFKVxuICAgICAgICAgICAgICAgICAgICB0eXBlID0gRW5jb2Rlci5TSE9SVF9UWVBFO1xuICAgICAgICAgICAgICAgIG1yID0gbWFza2luZ19NU19yYXRpb1tncl9vdXRdW2NobiAtIDJdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcGUgPSBwZXJjZXBfZW50cm9weTtcbiAgICAgICAgICAgICAgICBwcGVQb3MgPSAwO1xuICAgICAgICAgICAgICAgIHR5cGUgPSBibG9ja3R5cGVfZFtjaG5dO1xuICAgICAgICAgICAgICAgIG1yID0gbWFza2luZ19yYXRpb1tncl9vdXRdW2Nobl07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlID09IEVuY29kZXIuU0hPUlRfVFlQRSkge1xuICAgICAgICAgICAgICAgIHBwZVtwcGVQb3MgKyBjaG5dID0gcGVjYWxjX3MobXIsIGdmYy5tYXNraW5nX2xvd2VyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHBlW3BwZVBvcyArIGNobl0gPSBwZWNhbGNfbChtciwgZ2ZjLm1hc2tpbmdfbG93ZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZ2ZwLmFuYWx5c2lzKSB7XG4gICAgICAgICAgICAgICAgZ2ZjLnBpbmZvLnBlW2dyX291dF1bY2huXSA9IHBwZVtwcGVQb3MgKyBjaG5dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHMzX2Z1bmNfeChiYXJrLCBoZl9zbG9wZSkge1xuICAgICAgICB2YXIgdGVtcHggPSBiYXJrLCB0ZW1weTtcblxuICAgICAgICBpZiAodGVtcHggPj0gMCkge1xuICAgICAgICAgICAgdGVtcHkgPSAtdGVtcHggKiAyNztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRlbXB5ID0gdGVtcHggKiBoZl9zbG9wZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGVtcHkgPD0gLTcyLjApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLmV4cCh0ZW1weSAqIExOX1RPX0xPRzEwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtX3MzX2Z1bmNfeChoZl9zbG9wZSkge1xuICAgICAgICB2YXIgbGltX2EgPSAwLCBsaW1fYiA9IDA7XG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB4ID0gMCwgbCwgaDtcbiAgICAgICAgICAgIGZvciAoeCA9IDA7IHMzX2Z1bmNfeCh4LCBoZl9zbG9wZSkgPiAxZS0yMDsgeCAtPSAxKVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGwgPSB4O1xuICAgICAgICAgICAgaCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoTWF0aC5hYnMoaCAtIGwpID4gMWUtMTIpIHtcbiAgICAgICAgICAgICAgICB4ID0gKGggKyBsKSAvIDI7XG4gICAgICAgICAgICAgICAgaWYgKHMzX2Z1bmNfeCh4LCBoZl9zbG9wZSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGggPSB4O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGwgPSB4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbV9hID0gbDtcbiAgICAgICAgfVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgeCA9IDAsIGwsIGg7XG4gICAgICAgICAgICBmb3IgKHggPSAwOyBzM19mdW5jX3goeCwgaGZfc2xvcGUpID4gMWUtMjA7IHggKz0gMSlcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICBsID0gMDtcbiAgICAgICAgICAgIGggPSB4O1xuICAgICAgICAgICAgd2hpbGUgKE1hdGguYWJzKGggLSBsKSA+IDFlLTEyKSB7XG4gICAgICAgICAgICAgICAgeCA9IChoICsgbCkgLyAyO1xuICAgICAgICAgICAgICAgIGlmIChzM19mdW5jX3goeCwgaGZfc2xvcGUpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBsID0geDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoID0geDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW1fYiA9IGg7XG4gICAgICAgIH1cbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgICAgICB2YXIgbSA9IDEwMDA7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPD0gbTsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHggPSBsaW1fYSArIGkgKiAobGltX2IgLSBsaW1fYSkgLyBtO1xuICAgICAgICAgICAgICAgIHZhciB5ID0gczNfZnVuY194KHgsIGhmX3Nsb3BlKTtcbiAgICAgICAgICAgICAgICBzdW0gKz0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybSA9IChtICsgMSkgLyAoc3VtICogKGxpbV9iIC0gbGltX2EpKTtcbiAgICAgICAgICAgICAgICAvKiBwcmludGYoIFwibm9ybSA9ICVsZlxcblwiLG5vcm0pOyAqL1xuICAgICAgICAgICAgICAgIHJldHVybiBub3JtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogICBUaGUgc3ByZWFkaW5nIGZ1bmN0aW9uLiAgVmFsdWVzIHJldHVybmVkIGluIHVuaXRzIG9mIGVuZXJneVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHMzX2Z1bmMoYmFyaykge1xuICAgICAgICB2YXIgdGVtcHgsIHgsIHRlbXB5LCB0ZW1wO1xuICAgICAgICB0ZW1weCA9IGJhcms7XG4gICAgICAgIGlmICh0ZW1weCA+PSAwKVxuICAgICAgICAgICAgdGVtcHggKj0gMztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGVtcHggKj0gMS41O1xuXG4gICAgICAgIGlmICh0ZW1weCA+PSAwLjUgJiYgdGVtcHggPD0gMi41KSB7XG4gICAgICAgICAgICB0ZW1wID0gdGVtcHggLSAwLjU7XG4gICAgICAgICAgICB4ID0gOC4wICogKHRlbXAgKiB0ZW1wIC0gMi4wICogdGVtcCk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgeCA9IDAuMDtcbiAgICAgICAgdGVtcHggKz0gMC40NzQ7XG4gICAgICAgIHRlbXB5ID0gMTUuODExMzg5ICsgNy41ICogdGVtcHggLSAxNy41XG4gICAgICAgICAgICAqIE1hdGguc3FydCgxLjAgKyB0ZW1weCAqIHRlbXB4KTtcblxuICAgICAgICBpZiAodGVtcHkgPD0gLTYwLjApXG4gICAgICAgICAgICByZXR1cm4gMC4wO1xuXG4gICAgICAgIHRlbXB4ID0gTWF0aC5leHAoKHggKyB0ZW1weSkgKiBMTl9UT19MT0cxMCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxQUkU+XG4gICAgICAgICAqIE5vcm1hbGl6YXRpb24uICBUaGUgc3ByZWFkaW5nIGZ1bmN0aW9uIHNob3VsZCBiZSBub3JtYWxpemVkIHNvIHRoYXQ6XG4gICAgICAgICAqICtpbmZcbiAgICAgICAgICogL1xuICAgICAgICAgKiB8ICBzMyBbIGJhcmsgXSAgZChiYXJrKSAgID0gIDFcbiAgICAgICAgICogL1xuICAgICAgICAgKiAtaW5mXG4gICAgICAgICAqIDwvUFJFPlxuICAgICAgICAgKi9cbiAgICAgICAgdGVtcHggLz0gLjY2MDkxOTM7XG4gICAgICAgIHJldHVybiB0ZW1weDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZWUgZm9yIGV4YW1wbGUgXCJad2lja2VyOiBQc3ljaG9ha3VzdGlrLCAxOTgyOyBJU0JOIDMtNTQwLTExNDAxLTdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmcmVxMmJhcmsoZnJlcSkge1xuICAgICAgICAvKiBpbnB1dDogZnJlcSBpbiBoeiBvdXRwdXQ6IGJhcmtzICovXG4gICAgICAgIGlmIChmcmVxIDwgMClcbiAgICAgICAgICAgIGZyZXEgPSAwO1xuICAgICAgICBmcmVxID0gZnJlcSAqIDAuMDAxO1xuICAgICAgICByZXR1cm4gMTMuMCAqIE1hdGguYXRhbiguNzYgKiBmcmVxKSArIDMuNVxuICAgICAgICAgICAgKiBNYXRoLmF0YW4oZnJlcSAqIGZyZXEgLyAoNy41ICogNy41KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdF9udW1saW5lKG51bWxpbmVzLCBibywgYm0sIGJ2YWwsIGJ2YWxfd2lkdGgsIG1sZCwgYm9fdywgc2ZyZXEsIGJsa3NpemUsIHNjYWxlcG9zLCBkZWx0YWZyZXEsIHNibWF4KSB7XG4gICAgICAgIHZhciBiX2ZycSA9IG5ld19mbG9hdChFbmNvZGVyLkNCQU5EUyArIDEpO1xuICAgICAgICB2YXIgc2FtcGxlX2ZyZXFfZnJhYyA9IHNmcmVxIC8gKHNibWF4ID4gMTUgPyAyICogNTc2IDogMiAqIDE5Mik7XG4gICAgICAgIHZhciBwYXJ0aXRpb24gPSBuZXdfaW50KEVuY29kZXIuSEJMS1NJWkUpO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgc2ZyZXEgLz0gYmxrc2l6ZTtcbiAgICAgICAgdmFyIGogPSAwO1xuICAgICAgICB2YXIgbmkgPSAwO1xuICAgICAgICAvKiBjb21wdXRlIG51bWxpbmVzLCB0aGUgbnVtYmVyIG9mIHNwZWN0cmFsIGxpbmVzIGluIGVhY2ggcGFydGl0aW9uIGJhbmQgKi9cbiAgICAgICAgLyogZWFjaCBwYXJ0aXRpb24gYmFuZCBzaG91bGQgYmUgYWJvdXQgREVMQkFSSyB3aWRlLiAqL1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgRW5jb2Rlci5DQkFORFM7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJhcmsxO1xuICAgICAgICAgICAgdmFyIGoyO1xuICAgICAgICAgICAgYmFyazEgPSBmcmVxMmJhcmsoc2ZyZXEgKiBqKTtcblxuICAgICAgICAgICAgYl9mcnFbaV0gPSBzZnJlcSAqIGo7XG5cbiAgICAgICAgICAgIGZvciAoajIgPSBqOyBmcmVxMmJhcmsoc2ZyZXEgKiBqMikgLSBiYXJrMSA8IERFTEJBUktcbiAgICAgICAgICAgICYmIGoyIDw9IGJsa3NpemUgLyAyOyBqMisrKVxuICAgICAgICAgICAgICAgIDtcblxuICAgICAgICAgICAgbnVtbGluZXNbaV0gPSBqMiAtIGo7XG4gICAgICAgICAgICBuaSA9IGkgKyAxO1xuXG4gICAgICAgICAgICB3aGlsZSAoaiA8IGoyKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGogPCBFbmNvZGVyLkhCTEtTSVpFKTtcbiAgICAgICAgICAgICAgICBwYXJ0aXRpb25baisrXSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaiA+IGJsa3NpemUgLyAyKSB7XG4gICAgICAgICAgICAgICAgaiA9IGJsa3NpemUgLyAyO1xuICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoaSA8IEVuY29kZXIuQ0JBTkRTKTtcbiAgICAgICAgYl9mcnFbaV0gPSBzZnJlcSAqIGo7XG5cbiAgICAgICAgZm9yICh2YXIgc2ZiID0gMDsgc2ZiIDwgc2JtYXg7IHNmYisrKSB7XG4gICAgICAgICAgICB2YXIgaTEsIGkyLCBzdGFydCwgZW5kO1xuICAgICAgICAgICAgdmFyIGFyZztcbiAgICAgICAgICAgIHN0YXJ0ID0gc2NhbGVwb3Nbc2ZiXTtcbiAgICAgICAgICAgIGVuZCA9IHNjYWxlcG9zW3NmYiArIDFdO1xuXG4gICAgICAgICAgICBpMSA9IDAgfCBNYXRoLmZsb29yKC41ICsgZGVsdGFmcmVxICogKHN0YXJ0IC0gLjUpKTtcbiAgICAgICAgICAgIGlmIChpMSA8IDApXG4gICAgICAgICAgICAgICAgaTEgPSAwO1xuICAgICAgICAgICAgaTIgPSAwIHwgTWF0aC5mbG9vciguNSArIGRlbHRhZnJlcSAqIChlbmQgLSAuNSkpO1xuXG4gICAgICAgICAgICBpZiAoaTIgPiBibGtzaXplIC8gMilcbiAgICAgICAgICAgICAgICBpMiA9IGJsa3NpemUgLyAyO1xuXG4gICAgICAgICAgICBibVtzZmJdID0gKHBhcnRpdGlvbltpMV0gKyBwYXJ0aXRpb25baTJdKSAvIDI7XG4gICAgICAgICAgICBib1tzZmJdID0gcGFydGl0aW9uW2kyXTtcbiAgICAgICAgICAgIHZhciBmX3RtcCA9IHNhbXBsZV9mcmVxX2ZyYWMgKiBlbmQ7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogY2FsY3VsYXRlIGhvdyBtdWNoIG9mIHRoaXMgYmFuZCBiZWxvbmdzIHRvIGN1cnJlbnQgc2NhbGVmYWN0b3JcbiAgICAgICAgICAgICAqIGJhbmRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYm9fd1tzZmJdID0gKGZfdG1wIC0gYl9mcnFbYm9bc2ZiXV0pXG4gICAgICAgICAgICAgICAgLyAoYl9mcnFbYm9bc2ZiXSArIDFdIC0gYl9mcnFbYm9bc2ZiXV0pO1xuICAgICAgICAgICAgaWYgKGJvX3dbc2ZiXSA8IDApIHtcbiAgICAgICAgICAgICAgICBib193W3NmYl0gPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoYm9fd1tzZmJdID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBib193W3NmYl0gPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIHNldHVwIHN0ZXJlbyBkZW1hc2tpbmcgdGhyZXNob2xkcyAqL1xuICAgICAgICAgICAgLyogZm9ybXVsYSByZXZlcnNlIGVuZ2luZXJyZWQgZnJvbSBwbG90IGluIHBhcGVyICovXG4gICAgICAgICAgICBhcmcgPSBmcmVxMmJhcmsoc2ZyZXEgKiBzY2FsZXBvc1tzZmJdICogZGVsdGFmcmVxKTtcbiAgICAgICAgICAgIGFyZyA9ICggTWF0aC5taW4oYXJnLCAxNS41KSAvIDE1LjUpO1xuXG4gICAgICAgICAgICBtbGRbc2ZiXSA9IE1hdGgucG93KDEwLjAsXG4gICAgICAgICAgICAgICAgMS4yNSAqICgxIC0gTWF0aC5jb3MoTWF0aC5QSSAqIGFyZykpIC0gMi41KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGNvbXB1dGUgYmFyayB2YWx1ZXMgb2YgZWFjaCBjcml0aWNhbCBiYW5kICovXG4gICAgICAgIGogPSAwO1xuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IG5pOyBrKyspIHtcbiAgICAgICAgICAgIHZhciB3ID0gbnVtbGluZXNba107XG4gICAgICAgICAgICB2YXIgYmFyazEsIGJhcmsyO1xuXG4gICAgICAgICAgICBiYXJrMSA9IGZyZXEyYmFyayhzZnJlcSAqIChqKSk7XG4gICAgICAgICAgICBiYXJrMiA9IGZyZXEyYmFyayhzZnJlcSAqIChqICsgdyAtIDEpKTtcbiAgICAgICAgICAgIGJ2YWxba10gPSAuNSAqIChiYXJrMSArIGJhcmsyKTtcblxuICAgICAgICAgICAgYmFyazEgPSBmcmVxMmJhcmsoc2ZyZXEgKiAoaiAtIC41KSk7XG4gICAgICAgICAgICBiYXJrMiA9IGZyZXEyYmFyayhzZnJlcSAqIChqICsgdyAtIC41KSk7XG4gICAgICAgICAgICBidmFsX3dpZHRoW2tdID0gYmFyazIgLSBiYXJrMTtcbiAgICAgICAgICAgIGogKz0gdztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuaTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0X3MzX3ZhbHVlcyhzM2luZCwgbnBhcnQsIGJ2YWwsIGJ2YWxfd2lkdGgsIG5vcm0sIHVzZV9vbGRfczMpIHtcbiAgICAgICAgdmFyIHMzID0gbmV3X2Zsb2F0X24oW0VuY29kZXIuQ0JBTkRTLCBFbmNvZGVyLkNCQU5EU10pO1xuICAgICAgICAvKlxuICAgICAgICAgKiBUaGUgczMgYXJyYXkgaXMgbm90IGxpbmVhciBpbiB0aGUgYmFyayBzY2FsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogYnZhbFt4XSBzaG91bGQgYmUgdXNlZCB0byBnZXQgdGhlIGJhcmsgdmFsdWUuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgajtcbiAgICAgICAgdmFyIG51bWJlck9mTm9uZVplcm8gPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8UFJFPlxuICAgICAgICAgKiBzW2ldW2pdLCB0aGUgdmFsdWUgb2YgdGhlIHNwcmVhZGluZyBmdW5jdGlvbixcbiAgICAgICAgICogY2VudGVyZWQgYXQgYmFuZCBqIChtYXNrZXIpLCBmb3IgYmFuZCBpIChtYXNrZWUpXG4gICAgICAgICAqXG4gICAgICAgICAqIGkuZS46IHN1bSBvdmVyIGogdG8gc3ByZWFkIGludG8gc2lnbmFsIGJhcmt2YWw9aVxuICAgICAgICAgKiBOT1RFOiBpIGFuZCBqIGFyZSB1c2VkIG9wcG9zaXRlIGFzIGluIHRoZSBJU08gZG9jc1xuICAgICAgICAgKiA8L1BSRT5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh1c2Vfb2xkX3MzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5wYXJ0OyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbnBhcnQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IHMzX2Z1bmMoYnZhbFtpXSAtIGJ2YWxbal0pICogYnZhbF93aWR0aFtqXTtcbiAgICAgICAgICAgICAgICAgICAgczNbaV1bal0gPSB2ICogbm9ybVtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbnBhcnQ7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBoZl9zbG9wZSA9IDE1ICsgTWF0aC5taW4oMjEgLyBidmFsW2pdLCAxMik7XG4gICAgICAgICAgICAgICAgdmFyIHMzX3hfbm9ybSA9IG5vcm1fczNfZnVuY194KGhmX3Nsb3BlKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5wYXJ0OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSBzM194X25vcm1cbiAgICAgICAgICAgICAgICAgICAgICAgICogczNfZnVuY194KGJ2YWxbaV0gLSBidmFsW2pdLCBoZl9zbG9wZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICogYnZhbF93aWR0aFtqXTtcbiAgICAgICAgICAgICAgICAgICAgczNbaV1bal0gPSB2ICogbm9ybVtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBucGFydDsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbnBhcnQ7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChzM1tpXVtqXSA+IDAuMClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzM2luZFtpXVswXSA9IGo7XG5cbiAgICAgICAgICAgIGZvciAoaiA9IG5wYXJ0IC0gMTsgaiA+IDA7IGotLSkge1xuICAgICAgICAgICAgICAgIGlmIChzM1tpXVtqXSA+IDAuMClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzM2luZFtpXVsxXSA9IGo7XG4gICAgICAgICAgICBudW1iZXJPZk5vbmVaZXJvICs9IChzM2luZFtpXVsxXSAtIHMzaW5kW2ldWzBdICsgMSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcCA9IG5ld19mbG9hdChudW1iZXJPZk5vbmVaZXJvKTtcbiAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5wYXJ0OyBpKyspXG4gICAgICAgICAgICBmb3IgKGogPSBzM2luZFtpXVswXTsgaiA8PSBzM2luZFtpXVsxXTsgaisrKVxuICAgICAgICAgICAgICAgIHBbaysrXSA9IHMzW2ldW2pdO1xuXG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0ZXJlb19kZW1hc2soZikge1xuICAgICAgICAvKiBzZXR1cCBzdGVyZW8gZGVtYXNraW5nIHRocmVzaG9sZHMgKi9cbiAgICAgICAgLyogZm9ybXVsYSByZXZlcnNlIGVuZ2luZXJyZWQgZnJvbSBwbG90IGluIHBhcGVyICovXG4gICAgICAgIHZhciBhcmcgPSBmcmVxMmJhcmsoZik7XG4gICAgICAgIGFyZyA9IChNYXRoLm1pbihhcmcsIDE1LjUpIC8gMTUuNSk7XG5cbiAgICAgICAgcmV0dXJuIE1hdGgucG93KDEwLjAsXG4gICAgICAgICAgICAxLjI1ICogKDEgLSBNYXRoLmNvcyhNYXRoLlBJICogYXJnKSkgLSAyLjUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5PVEU6IHRoZSBiaXRyYXRlIHJlZHVjdGlvbiBmcm9tIHRoZSBpbnRlci1jaGFubmVsIG1hc2tpbmcgZWZmZWN0IGlzIGxvd1xuICAgICAqIGNvbXBhcmVkIHRvIHRoZSBjaGFuY2Ugb2YgZ2V0dGluZyBhbm55b2luZyBhcnRlZmFjdHMuIEwzcHN5Y2hvX2FuYWxfdmJyXG4gICAgICogZG9lcyBub3QgdXNlIHRoaXMgZmVhdHVyZS4gKFJvYmVydCAwNzEyMTYpXG4gICAgICovXG4gICAgdGhpcy5wc3ltb2RlbF9pbml0ID0gZnVuY3Rpb24gKGdmcCkge1xuICAgICAgICB2YXIgZ2ZjID0gZ2ZwLmludGVybmFsX2ZsYWdzO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIHVzZU9sZFMzID0gdHJ1ZTtcbiAgICAgICAgdmFyIGJ2bF9hID0gMTMsIGJ2bF9iID0gMjQ7XG4gICAgICAgIHZhciBzbnJfbF9hID0gMCwgc25yX2xfYiA9IDA7XG4gICAgICAgIHZhciBzbnJfc19hID0gLTguMjUsIHNucl9zX2IgPSAtNC41O1xuICAgICAgICB2YXIgYnZhbCA9IG5ld19mbG9hdChFbmNvZGVyLkNCQU5EUyk7XG4gICAgICAgIHZhciBidmFsX3dpZHRoID0gbmV3X2Zsb2F0KEVuY29kZXIuQ0JBTkRTKTtcbiAgICAgICAgdmFyIG5vcm0gPSBuZXdfZmxvYXQoRW5jb2Rlci5DQkFORFMpO1xuICAgICAgICB2YXIgc2ZyZXEgPSBnZnAub3V0X3NhbXBsZXJhdGU7XG5cbiAgICAgICAgc3dpdGNoIChnZnAuZXhwZXJpbWVudGFsWikge1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1c2VPbGRTMyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgdXNlT2xkUzMgPSAoZ2ZwLlZCUiA9PSBWYnJNb2RlLnZicl9tdHJoIHx8IGdmcC5WQlIgPT0gVmJyTW9kZS52YnJfbXQpID8gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgOiB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHVzZU9sZFMzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgYnZsX2EgPSA4O1xuICAgICAgICAgICAgICAgIHNucl9sX2EgPSAtMS43NTtcbiAgICAgICAgICAgICAgICBzbnJfbF9iID0gLTAuMDEyNTtcbiAgICAgICAgICAgICAgICBzbnJfc19hID0gLTguMjU7XG4gICAgICAgICAgICAgICAgc25yX3NfYiA9IC0yLjI1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGdmYy5tc19lbmVyX3JhdGlvX29sZCA9IC4yNTtcbiAgICAgICAgZ2ZjLmJsb2NrdHlwZV9vbGRbMF0gPSBnZmMuYmxvY2t0eXBlX29sZFsxXSA9IEVuY29kZXIuTk9STV9UWVBFO1xuICAgICAgICAvLyB0aGUgdmJyIGhlYWRlciBpcyBsb25nIGJsb2Nrc1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA0OyArK2kpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgRW5jb2Rlci5DQkFORFM7ICsraikge1xuICAgICAgICAgICAgICAgIGdmYy5uYl8xW2ldW2pdID0gMWUyMDtcbiAgICAgICAgICAgICAgICBnZmMubmJfMltpXVtqXSA9IDFlMjA7XG4gICAgICAgICAgICAgICAgZ2ZjLm5iX3MxW2ldW2pdID0gZ2ZjLm5iX3MyW2ldW2pdID0gMS4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgc2IgPSAwOyBzYiA8IEVuY29kZXIuU0JNQVhfbDsgc2IrKykge1xuICAgICAgICAgICAgICAgIGdmYy5lbltpXS5sW3NiXSA9IDFlMjA7XG4gICAgICAgICAgICAgICAgZ2ZjLnRobVtpXS5sW3NiXSA9IDFlMjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDM7ICsraikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHNiID0gMDsgc2IgPCBFbmNvZGVyLlNCTUFYX3M7IHNiKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZ2ZjLmVuW2ldLnNbc2JdW2pdID0gMWUyMDtcbiAgICAgICAgICAgICAgICAgICAgZ2ZjLnRobVtpXS5zW3NiXVtqXSA9IDFlMjA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdmYy5uc1BzeS5sYXN0QXR0YWNrc1tpXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDk7IGorKylcbiAgICAgICAgICAgICAgICBnZmMubnNQc3kubGFzdF9lbl9zdWJzaG9ydFtpXVtqXSA9IDEwLjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGluaXQuIGZvciBsb3VkbmVzcyBhcHByb3guIC1qZCAyMDAxIG1hciAyNyAqL1xuICAgICAgICBnZmMubG91ZG5lc3Nfc3Ffc2F2ZVswXSA9IGdmYy5sb3VkbmVzc19zcV9zYXZlWzFdID0gMC4wO1xuXG4gICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICAqIG5vdyBjb21wdXRlIHRoZSBwc3ljaG9hY291c3RpYyBtb2RlbCBzcGVjaWZpYyBjb25zdGFudHNcbiAgICAgICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyogY29tcHV0ZSBudW1saW5lcywgYm8sIGJtLCBidmFsLCBidmFsX3dpZHRoLCBtbGQgKi9cblxuICAgICAgICBnZmMubnBhcnRfbCA9IGluaXRfbnVtbGluZShnZmMubnVtbGluZXNfbCwgZ2ZjLmJvX2wsIGdmYy5ibV9sLCBidmFsLFxuICAgICAgICAgICAgYnZhbF93aWR0aCwgZ2ZjLm1sZF9sLCBnZmMuUFNZLmJvX2xfd2VpZ2h0LCBzZnJlcSxcbiAgICAgICAgICAgIEVuY29kZXIuQkxLU0laRSwgZ2ZjLnNjYWxlZmFjX2JhbmQubCwgRW5jb2Rlci5CTEtTSVpFXG4gICAgICAgICAgICAvICgyLjAgKiA1NzYpLCBFbmNvZGVyLlNCTUFYX2wpO1xuICAgICAgICBhc3NlcnQoZ2ZjLm5wYXJ0X2wgPCBFbmNvZGVyLkNCQU5EUyk7XG4gICAgICAgIC8qIGNvbXB1dGUgdGhlIHNwcmVhZGluZyBmdW5jdGlvbiAqL1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZ2ZjLm5wYXJ0X2w7IGkrKykge1xuICAgICAgICAgICAgdmFyIHNuciA9IHNucl9sX2E7XG4gICAgICAgICAgICBpZiAoYnZhbFtpXSA+PSBidmxfYSkge1xuICAgICAgICAgICAgICAgIHNuciA9IHNucl9sX2IgKiAoYnZhbFtpXSAtIGJ2bF9hKSAvIChidmxfYiAtIGJ2bF9hKSArIHNucl9sX2FcbiAgICAgICAgICAgICAgICAgICAgKiAoYnZsX2IgLSBidmFsW2ldKSAvIChidmxfYiAtIGJ2bF9hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vcm1baV0gPSBNYXRoLnBvdygxMC4wLCBzbnIgLyAxMC4wKTtcbiAgICAgICAgICAgIGlmIChnZmMubnVtbGluZXNfbFtpXSA+IDApIHtcbiAgICAgICAgICAgICAgICBnZmMucm51bWxpbmVzX2xbaV0gPSAxLjAgLyBnZmMubnVtbGluZXNfbFtpXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2ZjLnJudW1saW5lc19sW2ldID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnZmMuczNfbGwgPSBpbml0X3MzX3ZhbHVlcyhnZmMuczNpbmQsIGdmYy5ucGFydF9sLCBidmFsLCBidmFsX3dpZHRoLFxuICAgICAgICAgICAgbm9ybSwgdXNlT2xkUzMpO1xuXG4gICAgICAgIC8qIGNvbXB1dGUgbG9uZyBibG9jayBzcGVjaWZpYyB2YWx1ZXMsIEFUSCBhbmQgTUlOVkFMICovXG4gICAgICAgIHZhciBqID0gMDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGdmYy5ucGFydF9sOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB4O1xuXG4gICAgICAgICAgICAvKiBBVEggKi9cbiAgICAgICAgICAgIHggPSBGbG9hdC5NQVhfVkFMVUU7XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGdmYy5udW1saW5lc19sW2ldOyBrKyssIGorKykge1xuICAgICAgICAgICAgICAgIHZhciBmcmVxID0gc2ZyZXEgKiBqIC8gKDEwMDAuMCAqIEVuY29kZXIuQkxLU0laRSk7XG4gICAgICAgICAgICAgICAgdmFyIGxldmVsO1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogQVRIIGJlbG93IDEwMCBIeiBjb25zdGFudCwgbm90IGZ1cnRoZXIgY2xpbWJpbmdcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBsZXZlbCA9IHRoaXMuQVRIZm9ybXVsYShmcmVxICogMTAwMCwgZ2ZwKSAtIDIwO1xuICAgICAgICAgICAgICAgIC8vIHNjYWxlIHRvIEZGVCB1bml0czsgcmV0dXJuZWQgdmFsdWUgaXMgaW4gZEJcbiAgICAgICAgICAgICAgICBsZXZlbCA9IE1hdGgucG93KDEwLiwgMC4xICogbGV2ZWwpO1xuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgZnJvbSBkQiAuIGVuZXJneVxuICAgICAgICAgICAgICAgIGxldmVsICo9IGdmYy5udW1saW5lc19sW2ldO1xuICAgICAgICAgICAgICAgIGlmICh4ID4gbGV2ZWwpXG4gICAgICAgICAgICAgICAgICAgIHggPSBsZXZlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdmYy5BVEguY2JfbFtpXSA9IHg7XG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBNSU5WQUwuIEZvciBsb3cgZnJlcSwgdGhlIHN0cmVuZ3RoIG9mIHRoZSBtYXNraW5nIGlzIGxpbWl0ZWQgYnlcbiAgICAgICAgICAgICAqIG1pbnZhbCB0aGlzIGlzIGFuIElTTyBNUEVHMSB0aGluZywgZG9udCBrbm93IGlmIGl0IGlzIHJlYWxseVxuICAgICAgICAgICAgICogbmVlZGVkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBGSVhNRTogaXQgZG9lcyB3b3JrIHRvIHJlZHVjZSBsb3ctZnJlcSBwcm9ibGVtcyBpbiBTNTMtV2luZC1TYXhcbiAgICAgICAgICAgICAqIGFuZCBsZWFkLXZvaWNlIHNhbXBsZXMsIGJ1dCBpbnRyb2R1Y2VzIHNvbWUgMyBrYnBzIGJpdCBibG9hdCB0b28uXG4gICAgICAgICAgICAgKiBUT0RPOiBGdXJ0aGVyIHJlZmluZW1lbnQgb2YgdGhlIHNoYXBlIG9mIHRoaXMgaGFjay5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgeCA9IC0yMCArIGJ2YWxbaV0gKiAyMCAvIDEwO1xuICAgICAgICAgICAgaWYgKHggPiA2KSB7XG4gICAgICAgICAgICAgICAgeCA9IDEwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4IDwgLTE1KSB7XG4gICAgICAgICAgICAgICAgeCA9IC0xNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHggLT0gOC47XG4gICAgICAgICAgICBnZmMubWludmFsX2xbaV0gPSAoTWF0aC5wb3coMTAuMCwgeCAvIDEwLikgKiBnZmMubnVtbGluZXNfbFtpXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICAqIGRvIHRoZSBzYW1lIHRoaW5ncyBmb3Igc2hvcnQgYmxvY2tzXG4gICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIGdmYy5ucGFydF9zID0gaW5pdF9udW1saW5lKGdmYy5udW1saW5lc19zLCBnZmMuYm9fcywgZ2ZjLmJtX3MsIGJ2YWwsXG4gICAgICAgICAgICBidmFsX3dpZHRoLCBnZmMubWxkX3MsIGdmYy5QU1kuYm9fc193ZWlnaHQsIHNmcmVxLFxuICAgICAgICAgICAgRW5jb2Rlci5CTEtTSVpFX3MsIGdmYy5zY2FsZWZhY19iYW5kLnMsIEVuY29kZXIuQkxLU0laRV9zXG4gICAgICAgICAgICAvICgyLjAgKiAxOTIpLCBFbmNvZGVyLlNCTUFYX3MpO1xuICAgICAgICBhc3NlcnQoZ2ZjLm5wYXJ0X3MgPCBFbmNvZGVyLkNCQU5EUyk7XG5cbiAgICAgICAgLyogU05SIGZvcm11bGEuIHNob3J0IGJsb2NrIGlzIG5vcm1hbGl6ZWQgYnkgU05SLiBpcyBpdCBzdGlsbCByaWdodCA/ICovXG4gICAgICAgIGogPSAwO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZ2ZjLm5wYXJ0X3M7IGkrKykge1xuICAgICAgICAgICAgdmFyIHg7XG4gICAgICAgICAgICB2YXIgc25yID0gc25yX3NfYTtcbiAgICAgICAgICAgIGlmIChidmFsW2ldID49IGJ2bF9hKSB7XG4gICAgICAgICAgICAgICAgc25yID0gc25yX3NfYiAqIChidmFsW2ldIC0gYnZsX2EpIC8gKGJ2bF9iIC0gYnZsX2EpICsgc25yX3NfYVxuICAgICAgICAgICAgICAgICAgICAqIChidmxfYiAtIGJ2YWxbaV0pIC8gKGJ2bF9iIC0gYnZsX2EpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9ybVtpXSA9IE1hdGgucG93KDEwLjAsIHNuciAvIDEwLjApO1xuXG4gICAgICAgICAgICAvKiBBVEggKi9cbiAgICAgICAgICAgIHggPSBGbG9hdC5NQVhfVkFMVUU7XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGdmYy5udW1saW5lc19zW2ldOyBrKyssIGorKykge1xuICAgICAgICAgICAgICAgIHZhciBmcmVxID0gc2ZyZXEgKiBqIC8gKDEwMDAuMCAqIEVuY29kZXIuQkxLU0laRV9zKTtcbiAgICAgICAgICAgICAgICB2YXIgbGV2ZWw7XG4gICAgICAgICAgICAgICAgLyogZnJlcSA9IE1pbiguMSxmcmVxKTsgKi9cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIEFUSCBiZWxvdyAxMDAgSHogY29uc3RhbnQsIG5vdFxuICAgICAgICAgICAgICAgICAqIGZ1cnRoZXIgY2xpbWJpbmdcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBsZXZlbCA9IHRoaXMuQVRIZm9ybXVsYShmcmVxICogMTAwMCwgZ2ZwKSAtIDIwO1xuICAgICAgICAgICAgICAgIC8vIHNjYWxlIHRvIEZGVCB1bml0czsgcmV0dXJuZWQgdmFsdWUgaXMgaW4gZEJcbiAgICAgICAgICAgICAgICBsZXZlbCA9IE1hdGgucG93KDEwLiwgMC4xICogbGV2ZWwpO1xuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgZnJvbSBkQiAuIGVuZXJneVxuICAgICAgICAgICAgICAgIGxldmVsICo9IGdmYy5udW1saW5lc19zW2ldO1xuICAgICAgICAgICAgICAgIGlmICh4ID4gbGV2ZWwpXG4gICAgICAgICAgICAgICAgICAgIHggPSBsZXZlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdmYy5BVEguY2Jfc1tpXSA9IHg7XG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBNSU5WQUwuIEZvciBsb3cgZnJlcSwgdGhlIHN0cmVuZ3RoIG9mIHRoZSBtYXNraW5nIGlzIGxpbWl0ZWQgYnlcbiAgICAgICAgICAgICAqIG1pbnZhbCB0aGlzIGlzIGFuIElTTyBNUEVHMSB0aGluZywgZG9udCBrbm93IGlmIGl0IGlzIHJlYWxseVxuICAgICAgICAgICAgICogbmVlZGVkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHggPSAoLTcuMCArIGJ2YWxbaV0gKiA3LjAgLyAxMi4wKTtcbiAgICAgICAgICAgIGlmIChidmFsW2ldID4gMTIpIHtcbiAgICAgICAgICAgICAgICB4ICo9IDEgKyBNYXRoLmxvZygxICsgeCkgKiAzLjE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnZhbFtpXSA8IDEyKSB7XG4gICAgICAgICAgICAgICAgeCAqPSAxICsgTWF0aC5sb2coMSAtIHgpICogMi4zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHggPCAtMTUpIHtcbiAgICAgICAgICAgICAgICB4ID0gLTE1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeCAtPSA4O1xuICAgICAgICAgICAgZ2ZjLm1pbnZhbF9zW2ldID0gTWF0aC5wb3coMTAuMCwgeCAvIDEwKVxuICAgICAgICAgICAgICAgICogZ2ZjLm51bWxpbmVzX3NbaV07XG4gICAgICAgIH1cblxuICAgICAgICBnZmMuczNfc3MgPSBpbml0X3MzX3ZhbHVlcyhnZmMuczNpbmRfcywgZ2ZjLm5wYXJ0X3MsIGJ2YWwsIGJ2YWxfd2lkdGgsXG4gICAgICAgICAgICBub3JtLCB1c2VPbGRTMyk7XG5cbiAgICAgICAgaW5pdF9tYXNrX2FkZF9tYXhfdmFsdWVzKCk7XG4gICAgICAgIGZmdC5pbml0X2ZmdChnZmMpO1xuXG4gICAgICAgIC8qIHNldHVwIHRlbXBvcmFsIG1hc2tpbmcgKi9cbiAgICAgICAgZ2ZjLmRlY2F5ID0gTWF0aC5leHAoLTEuMCAqIExPRzEwXG4gICAgICAgICAgICAvICh0ZW1wb3JhbG1hc2tfc3VzdGFpbl9zZWMgKiBzZnJlcSAvIDE5Mi4wKSk7XG5cbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIG1zZml4O1xuICAgICAgICAgICAgbXNmaXggPSBOU19NU0ZJWDtcbiAgICAgICAgICAgIGlmICgoZ2ZwLmV4cF9uc3BzeXR1bmUgJiAyKSAhPSAwKVxuICAgICAgICAgICAgICAgIG1zZml4ID0gMS4wO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGdmcC5tc2ZpeCkgPiAwLjApXG4gICAgICAgICAgICAgICAgbXNmaXggPSBnZnAubXNmaXg7XG4gICAgICAgICAgICBnZnAubXNmaXggPSBtc2ZpeDtcblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIHNwcmVhZCBvbmx5IGZyb20gbnBhcnRfbCBiYW5kcy4gTm9ybWFsbHksIHdlIHVzZSB0aGUgc3ByZWFkaW5nXG4gICAgICAgICAgICAgKiBmdW5jdGlvbiB0byBjb252b2x2ZSBmcm9tIG5wYXJ0X2wgZG93biB0byBucGFydF9sIGJhbmRzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZvciAodmFyIGIgPSAwOyBiIDwgZ2ZjLm5wYXJ0X2w7IGIrKylcbiAgICAgICAgICAgICAgICBpZiAoZ2ZjLnMzaW5kW2JdWzFdID4gZ2ZjLm5wYXJ0X2wgLSAxKVxuICAgICAgICAgICAgICAgICAgICBnZmMuczNpbmRbYl1bMV0gPSBnZmMubnBhcnRfbCAtIDE7XG4gICAgICAgIH1cblxuICAgICAgICAvKlxuICAgICAgICAgKiBwcmVwYXJlIGZvciBBVEggYXV0byBhZGp1c3RtZW50OiB3ZSB3YW50IHRvIGRlY3JlYXNlIHRoZSBBVEggYnkgMTIgZEJcbiAgICAgICAgICogcGVyIHNlY29uZFxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGZyYW1lX2R1cmF0aW9uID0gKDU3Ni4gKiBnZmMubW9kZV9nciAvIHNmcmVxKTtcbiAgICAgICAgZ2ZjLkFUSC5kZWNheSA9IE1hdGgucG93KDEwLiwgLTEyLiAvIDEwLiAqIGZyYW1lX2R1cmF0aW9uKTtcbiAgICAgICAgZ2ZjLkFUSC5hZGp1c3QgPSAwLjAxO1xuICAgICAgICAvKiBtaW5pbXVtLCBmb3IgbGVhZGluZyBsb3cgbG91ZG5lc3MgKi9cbiAgICAgICAgZ2ZjLkFUSC5hZGp1c3RMaW1pdCA9IDEuMDtcbiAgICAgICAgLyogb24gbGVhZCwgYWxsb3cgYWRqdXN0IHVwIHRvIG1heGltdW0gKi9cblxuICAgICAgICBhc3NlcnQoZ2ZjLmJvX2xbRW5jb2Rlci5TQk1BWF9sIC0gMV0gPD0gZ2ZjLm5wYXJ0X2wpO1xuICAgICAgICBhc3NlcnQoZ2ZjLmJvX3NbRW5jb2Rlci5TQk1BWF9zIC0gMV0gPD0gZ2ZjLm5wYXJ0X3MpO1xuXG4gICAgICAgIGlmIChnZnAuQVRIdHlwZSAhPSAtMSkge1xuICAgICAgICAgICAgLyogY29tcHV0ZSBlcXVhbCBsb3VkbmVzcyB3ZWlnaHRzIChlcWxfdykgKi9cbiAgICAgICAgICAgIHZhciBmcmVxO1xuICAgICAgICAgICAgdmFyIGZyZXFfaW5jID0gZ2ZwLm91dF9zYW1wbGVyYXRlXG4gICAgICAgICAgICAgICAgLyAoRW5jb2Rlci5CTEtTSVpFKTtcbiAgICAgICAgICAgIHZhciBlcWxfYmFsYW5jZSA9IDAuMDtcbiAgICAgICAgICAgIGZyZXEgPSAwLjA7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgRW5jb2Rlci5CTEtTSVpFIC8gMjsgKytpKSB7XG4gICAgICAgICAgICAgICAgLyogY29udmVydCBBVEggZEIgdG8gcmVsYXRpdmUgcG93ZXIgKG5vdCBkQikgKi9cbiAgICAgICAgICAgICAgICAvKiB0byBkZXRlcm1pbmUgZXFsX3cgKi9cbiAgICAgICAgICAgICAgICBmcmVxICs9IGZyZXFfaW5jO1xuICAgICAgICAgICAgICAgIGdmYy5BVEguZXFsX3dbaV0gPSAxLiAvIE1hdGgucG93KDEwLCB0aGlzLkFUSGZvcm11bGEoZnJlcSwgZ2ZwKSAvIDEwKTtcbiAgICAgICAgICAgICAgICBlcWxfYmFsYW5jZSArPSBnZmMuQVRILmVxbF93W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXFsX2JhbGFuY2UgPSAxLjAgLyBlcWxfYmFsYW5jZTtcbiAgICAgICAgICAgIGZvciAoaSA9IEVuY29kZXIuQkxLU0laRSAvIDI7IC0taSA+PSAwOykgeyAvKiBzY2FsZSB3ZWlnaHRzICovXG4gICAgICAgICAgICAgICAgZ2ZjLkFUSC5lcWxfd1tpXSAqPSBlcWxfYmFsYW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB7XG4gICAgICAgICAgICBmb3IgKHZhciBiID0gaiA9IDA7IGIgPCBnZmMubnBhcnRfczsgKytiKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGdmYy5udW1saW5lc19zW2JdOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgKytqO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydChqID09IDEyOSk7XG4gICAgICAgICAgICBmb3IgKHZhciBiID0gaiA9IDA7IGIgPCBnZmMubnBhcnRfbDsgKytiKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGdmYy5udW1saW5lc19sW2JdOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgKytqO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydChqID09IDUxMyk7XG4gICAgICAgIH1cbiAgICAgICAgaiA9IDA7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBnZmMubnBhcnRfbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZnJlcSA9IHNmcmVxICogKGogKyBnZmMubnVtbGluZXNfbFtpXSAvIDIpIC8gKDEuMCAqIEVuY29kZXIuQkxLU0laRSk7XG4gICAgICAgICAgICBnZmMubWxkX2NiX2xbaV0gPSBzdGVyZW9fZGVtYXNrKGZyZXEpO1xuICAgICAgICAgICAgaiArPSBnZmMubnVtbGluZXNfbFtpXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgaSA8IEVuY29kZXIuQ0JBTkRTOyArK2kpIHtcbiAgICAgICAgICAgIGdmYy5tbGRfY2JfbFtpXSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaiA9IDA7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBnZmMubnBhcnRfczsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZnJlcSA9IHNmcmVxICogKGogKyBnZmMubnVtbGluZXNfc1tpXSAvIDIpIC8gKDEuMCAqIEVuY29kZXIuQkxLU0laRV9zKTtcbiAgICAgICAgICAgIGdmYy5tbGRfY2Jfc1tpXSA9IHN0ZXJlb19kZW1hc2soZnJlcSk7XG4gICAgICAgICAgICBqICs9IGdmYy5udW1saW5lc19zW2ldO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyBpIDwgRW5jb2Rlci5DQkFORFM7ICsraSkge1xuICAgICAgICAgICAgZ2ZjLm1sZF9jYl9zW2ldID0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaG9zZSBBVEggZm9ybXVsYXMgYXJlIHJldHVybmluZyB0aGVpciBtaW5pbXVtIHZhbHVlIGZvciBpbnB1dCA9IC0xXG4gICAgICovXG4gICAgZnVuY3Rpb24gQVRIZm9ybXVsYV9HQihmLCB2YWx1ZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogPFBSRT5cbiAgICAgICAgICogIGZyb20gUGFpbnRlciAmIFNwYW5pYXNcbiAgICAgICAgICogICAgICAgICAgIG1vZGlmaWVkIGJ5IEdhYnJpZWwgQm91dmlnbmUgdG8gYmV0dGVyIGZpdCB0aGUgcmVhbGl0eVxuICAgICAgICAgKiAgICAgICAgICAgYXRoID0gICAgMy42NDAgKiBwb3coZiwtMC44KVxuICAgICAgICAgKiAgICAgICAgICAgLSA2LjgwMCAqIGV4cCgtMC42KnBvdyhmLTMuNCwyLjApKVxuICAgICAgICAgKiAgICAgICAgICAgKyA2LjAwMCAqIGV4cCgtMC4xNSpwb3coZi04LjcsMi4wKSlcbiAgICAgICAgICogICAgICAgICAgICsgMC42KiAwLjAwMSAqIHBvdyhmLDQuMCk7XG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgICAgICBJbiB0aGUgcGFzdCBMQU1FIHdhcyB1c2luZyB0aGUgUGFpbnRlciAmU3BhbmlhcyBmb3JtdWxhLlxuICAgICAgICAgKiAgICAgICAgICAgQnV0IHdlIGhhZCBzb21lIHJlY3VycmVudCBwcm9ibGVtcyB3aXRoIEhGIGNvbnRlbnQuXG4gICAgICAgICAqICAgICAgICAgICBXZSBtZWFzdXJlZCByZWFsIEFUSCB2YWx1ZXMsIGFuZCBmb3VuZCB0aGUgb2xkZXIgZm9ybXVsYVxuICAgICAgICAgKiAgICAgICAgICAgdG8gYmUgaW5hY2N1cmF0ZSBpbiB0aGUgaGlnaGVyIHBhcnQuIFNvIHdlIG1hZGUgdGhpcyBuZXdcbiAgICAgICAgICogICAgICAgICAgIGZvcm11bGEgYW5kIHRoaXMgc29sdmVkIG1vc3Qgb2YgSEYgcHJvYmxlbWF0aWMgdGVzdCBjYXNlcy5cbiAgICAgICAgICogICAgICAgICAgIFRoZSB0cmFkZW9mZiBpcyB0aGF0IGluIFZCUiBtb2RlIGl0IGluY3JlYXNlcyBhIGxvdCB0aGVcbiAgICAgICAgICogICAgICAgICAgIGJpdHJhdGUuXG4gICAgICAgICAqIDwvUFJFPlxuICAgICAgICAgKi9cblxuICAgICAgICAvKlxuICAgICAgICAgKiBUaGlzIGN1cnZlIGNhbiBiZSBhZGp1c3RlZCBhY2NvcmRpbmcgdG8gdGhlIFZCUiBzY2FsZTogaXQgYWRqdXN0c1xuICAgICAgICAgKiBmcm9tIHNvbWV0aGluZyBjbG9zZSB0byBQYWludGVyICYgU3BhbmlhcyBvbiBWOSB1cCB0byBCb3V2aWduZSdzXG4gICAgICAgICAqIGZvcm11bGEgZm9yIFYwLiBUaGlzIHdheSB0aGUgVkJSIGJpdHJhdGUgaXMgbW9yZSBiYWxhbmNlZCBhY2NvcmRpbmdcbiAgICAgICAgICogdG8gdGhlIC1WIHZhbHVlLlxuICAgICAgICAgKi9cblxuICAgICAgICAvLyB0aGUgZm9sbG93aW5nIEhhY2sgYWxsb3dzIHRvIGFzayBmb3IgdGhlIGxvd2VzdCB2YWx1ZVxuICAgICAgICBpZiAoZiA8IC0uMylcbiAgICAgICAgICAgIGYgPSAzNDEwO1xuXG4gICAgICAgIC8vIGNvbnZlcnQgdG8ga2h6XG4gICAgICAgIGYgLz0gMTAwMDtcbiAgICAgICAgZiA9IE1hdGgubWF4KDAuMSwgZik7XG4gICAgICAgIHZhciBhdGggPSAzLjY0MCAqIE1hdGgucG93KGYsIC0wLjgpIC0gNi44MDBcbiAgICAgICAgICAgICogTWF0aC5leHAoLTAuNiAqIE1hdGgucG93KGYgLSAzLjQsIDIuMCkpICsgNi4wMDBcbiAgICAgICAgICAgICogTWF0aC5leHAoLTAuMTUgKiBNYXRoLnBvdyhmIC0gOC43LCAyLjApKVxuICAgICAgICAgICAgKyAoMC42ICsgMC4wNCAqIHZhbHVlKSAqIDAuMDAxICogTWF0aC5wb3coZiwgNC4wKTtcbiAgICAgICAgcmV0dXJuIGF0aDtcbiAgICB9XG5cbiAgICB0aGlzLkFUSGZvcm11bGEgPSBmdW5jdGlvbiAoZiwgZ2ZwKSB7XG4gICAgICAgIHZhciBhdGg7XG4gICAgICAgIHN3aXRjaCAoZ2ZwLkFUSHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBhdGggPSBBVEhmb3JtdWxhX0dCKGYsIDkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIC8vIG92ZXIgc2Vuc2l0aXZlLCBzaG91bGQgcHJvYmFibHkgYmUgcmVtb3ZlZFxuICAgICAgICAgICAgICAgIGF0aCA9IEFUSGZvcm11bGFfR0IoZiwgLTEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGF0aCA9IEFUSGZvcm11bGFfR0IoZiwgMCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgLy8gbW9kaWZpY2F0aW9uIG9mIEdCIGZvcm11bGEgYnkgUm9lbFxuICAgICAgICAgICAgICAgIGF0aCA9IEFUSGZvcm11bGFfR0IoZiwgMSkgKyA2O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGF0aCA9IEFUSGZvcm11bGFfR0IoZiwgZ2ZwLkFUSGN1cnZlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYXRoID0gQVRIZm9ybXVsYV9HQihmLCAwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXRoO1xuICAgIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBzeU1vZGVsO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lamejs/src/js/PsyModel.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lamejs/src/js/Quantize.js":
/*!************************************************!*\
  !*** ./node_modules/lamejs/src/js/Quantize.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/*\n * MP3 quantization\n *\n *      Copyright (c) 1999-2000 Mark Taylor\n *      Copyright (c) 1999-2003 Takehiro Tominaga\n *      Copyright (c) 2000-2007 Robert Hegemann\n *      Copyright (c) 2001-2005 Gabriel Bouvigne\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.     See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */\n\n/* $Id: Quantize.java,v 1.24 2011/05/24 20:48:06 kenchis Exp $ */\n\n//package mp3;\n\n//import java.util.Arrays;\nvar common = __webpack_require__(/*! ./common.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/common.js\");\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\nvar VBRQuantize = __webpack_require__(/*! ./VBRQuantize.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/VBRQuantize.js\");\nvar CalcNoiseResult = __webpack_require__(/*! ./CalcNoiseResult.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/CalcNoiseResult.js\");\nvar CalcNoiseData = __webpack_require__(/*! ./CalcNoiseData.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/CalcNoiseData.js\");\nvar Encoder = __webpack_require__(/*! ./Encoder.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/Encoder.js\");\nvar GrInfo = __webpack_require__(/*! ./GrInfo.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/GrInfo.js\");\nvar L3Side = __webpack_require__(/*! ./L3Side.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/L3Side.js\");\n\nfunction Quantize() {\n    var bs;\n    this.rv = null;\n    var rv;\n    this.qupvt = null;\n    var qupvt;\n\n    var vbr = new VBRQuantize();\n    var tk;\n\n    this.setModules = function (_bs, _rv, _qupvt, _tk) {\n        bs = _bs;\n        rv = _rv;\n        this.rv = _rv;\n        qupvt = _qupvt;\n        this.qupvt = _qupvt;\n        tk = _tk;\n        vbr.setModules(qupvt, tk);\n    }\n\n    /**\n     * convert from L/R <. Mid/Side\n     */\n    this.ms_convert = function (l3_side, gr) {\n        for (var i = 0; i < 576; ++i) {\n            var l = l3_side.tt[gr][0].xr[i];\n            var r = l3_side.tt[gr][1].xr[i];\n            l3_side.tt[gr][0].xr[i] = (l + r) * (Util.SQRT2 * 0.5);\n            l3_side.tt[gr][1].xr[i] = (l - r) * (Util.SQRT2 * 0.5);\n        }\n    };\n\n    /**\n     * mt 6/99\n     *\n     * initializes cod_info, scalefac and xrpow\n     *\n     * returns 0 if all energies in xr are zero, else 1\n     */\n    function init_xrpow_core(cod_info, xrpow, upper, sum) {\n        sum = 0;\n        for (var i = 0; i <= upper; ++i) {\n            var tmp = Math.abs(cod_info.xr[i]);\n            sum += tmp;\n            xrpow[i] = Math.sqrt(tmp * Math.sqrt(tmp));\n\n            if (xrpow[i] > cod_info.xrpow_max)\n                cod_info.xrpow_max = xrpow[i];\n        }\n        return sum;\n    }\n\n    this.init_xrpow = function (gfc, cod_info, xrpow) {\n        var sum = 0;\n        var upper = 0 | cod_info.max_nonzero_coeff;\n\n        assert(xrpow != null);\n        cod_info.xrpow_max = 0;\n\n        /*\n         * check if there is some energy we have to quantize and calculate xrpow\n         * matching our fresh scalefactors\n         */\n        assert(0 <= upper && upper <= 575);\n\n        Arrays.fill(xrpow, upper, 576, 0);\n\n        sum = init_xrpow_core(cod_info, xrpow, upper, sum);\n\n        /*\n         * return 1 if we have something to quantize, else 0\n         */\n        if (sum > 1E-20) {\n            var j = 0;\n            if ((gfc.substep_shaping & 2) != 0)\n                j = 1;\n\n            for (var i = 0; i < cod_info.psymax; i++)\n                gfc.pseudohalf[i] = j;\n\n            return true;\n        }\n\n        Arrays.fill(cod_info.l3_enc, 0, 576, 0);\n        return false;\n    }\n\n    /**\n     * Gabriel Bouvigne feb/apr 2003<BR>\n     * Analog silence detection in partitionned sfb21 or sfb12 for short blocks\n     *\n     * From top to bottom of sfb, changes to 0 coeffs which are below ath. It\n     * stops on the first coeff higher than ath.\n     */\n    function psfb21_analogsilence(gfc, cod_info) {\n        var ath = gfc.ATH;\n        var xr = cod_info.xr;\n\n        if (cod_info.block_type != Encoder.SHORT_TYPE) {\n            /* NORM, START or STOP type, but not SHORT blocks */\n            var stop = false;\n            for (var gsfb = Encoder.PSFB21 - 1; gsfb >= 0 && !stop; gsfb--) {\n                var start = gfc.scalefac_band.psfb21[gsfb];\n                var end = gfc.scalefac_band.psfb21[gsfb + 1];\n                var ath21 = qupvt.athAdjust(ath.adjust, ath.psfb21[gsfb],\n                    ath.floor);\n\n                if (gfc.nsPsy.longfact[21] > 1e-12)\n                    ath21 *= gfc.nsPsy.longfact[21];\n\n                for (var j = end - 1; j >= start; j--) {\n                    if (Math.abs(xr[j]) < ath21)\n                        xr[j] = 0;\n                    else {\n                        stop = true;\n                        break;\n                    }\n                }\n            }\n        } else {\n            /* note: short blocks coeffs are reordered */\n            for (var block = 0; block < 3; block++) {\n                var stop = false;\n                for (var gsfb = Encoder.PSFB12 - 1; gsfb >= 0 && !stop; gsfb--) {\n                    var start = gfc.scalefac_band.s[12]\n                        * 3\n                        + (gfc.scalefac_band.s[13] - gfc.scalefac_band.s[12])\n                        * block\n                        + (gfc.scalefac_band.psfb12[gsfb] - gfc.scalefac_band.psfb12[0]);\n                    var end = start\n                        + (gfc.scalefac_band.psfb12[gsfb + 1] - gfc.scalefac_band.psfb12[gsfb]);\n                    var ath12 = qupvt.athAdjust(ath.adjust, ath.psfb12[gsfb],\n                        ath.floor);\n\n                    if (gfc.nsPsy.shortfact[12] > 1e-12)\n                        ath12 *= gfc.nsPsy.shortfact[12];\n\n                    for (var j = end - 1; j >= start; j--) {\n                        if (Math.abs(xr[j]) < ath12)\n                            xr[j] = 0;\n                        else {\n                            stop = true;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n    }\n\n    this.init_outer_loop = function (gfc, cod_info) {\n        /*\n         * initialize fresh cod_info\n         */\n        cod_info.part2_3_length = 0;\n        cod_info.big_values = 0;\n        cod_info.count1 = 0;\n        cod_info.global_gain = 210;\n        cod_info.scalefac_compress = 0;\n        /* mixed_block_flag, block_type was set in psymodel.c */\n        cod_info.table_select[0] = 0;\n        cod_info.table_select[1] = 0;\n        cod_info.table_select[2] = 0;\n        cod_info.subblock_gain[0] = 0;\n        cod_info.subblock_gain[1] = 0;\n        cod_info.subblock_gain[2] = 0;\n        cod_info.subblock_gain[3] = 0;\n        /* this one is always 0 */\n        cod_info.region0_count = 0;\n        cod_info.region1_count = 0;\n        cod_info.preflag = 0;\n        cod_info.scalefac_scale = 0;\n        cod_info.count1table_select = 0;\n        cod_info.part2_length = 0;\n        cod_info.sfb_lmax = Encoder.SBPSY_l;\n        cod_info.sfb_smin = Encoder.SBPSY_s;\n        cod_info.psy_lmax = gfc.sfb21_extra ? Encoder.SBMAX_l : Encoder.SBPSY_l;\n        cod_info.psymax = cod_info.psy_lmax;\n        cod_info.sfbmax = cod_info.sfb_lmax;\n        cod_info.sfbdivide = 11;\n        for (var sfb = 0; sfb < Encoder.SBMAX_l; sfb++) {\n            cod_info.width[sfb] = gfc.scalefac_band.l[sfb + 1]\n                - gfc.scalefac_band.l[sfb];\n            /* which is always 0. */\n            cod_info.window[sfb] = 3;\n        }\n        if (cod_info.block_type == Encoder.SHORT_TYPE) {\n            var ixwork = new_float(576);\n\n            cod_info.sfb_smin = 0;\n            cod_info.sfb_lmax = 0;\n            if (cod_info.mixed_block_flag != 0) {\n                /*\n                 * MPEG-1: sfbs 0-7 long block, 3-12 short blocks MPEG-2(.5):\n                 * sfbs 0-5 long block, 3-12 short blocks\n                 */\n                cod_info.sfb_smin = 3;\n                cod_info.sfb_lmax = gfc.mode_gr * 2 + 4;\n            }\n            cod_info.psymax = cod_info.sfb_lmax\n                + 3\n                * ((gfc.sfb21_extra ? Encoder.SBMAX_s : Encoder.SBPSY_s) - cod_info.sfb_smin);\n            cod_info.sfbmax = cod_info.sfb_lmax + 3\n                * (Encoder.SBPSY_s - cod_info.sfb_smin);\n            cod_info.sfbdivide = cod_info.sfbmax - 18;\n            cod_info.psy_lmax = cod_info.sfb_lmax;\n            /* re-order the short blocks, for more efficient encoding below */\n            /* By Takehiro TOMINAGA */\n            /*\n             * Within each scalefactor band, data is given for successive time\n             * windows, beginning with window 0 and ending with window 2. Within\n             * each window, the quantized values are then arranged in order of\n             * increasing frequency...\n             */\n            var ix = gfc.scalefac_band.l[cod_info.sfb_lmax];\n            System.arraycopy(cod_info.xr, 0, ixwork, 0, 576);\n            for (var sfb = cod_info.sfb_smin; sfb < Encoder.SBMAX_s; sfb++) {\n                var start = gfc.scalefac_band.s[sfb];\n                var end = gfc.scalefac_band.s[sfb + 1];\n                for (var window = 0; window < 3; window++) {\n                    for (var l = start; l < end; l++) {\n                        cod_info.xr[ix++] = ixwork[3 * l + window];\n                    }\n                }\n            }\n\n            var j = cod_info.sfb_lmax;\n            for (var sfb = cod_info.sfb_smin; sfb < Encoder.SBMAX_s; sfb++) {\n                cod_info.width[j] = cod_info.width[j + 1] = cod_info.width[j + 2] = gfc.scalefac_band.s[sfb + 1]\n                    - gfc.scalefac_band.s[sfb];\n                cod_info.window[j] = 0;\n                cod_info.window[j + 1] = 1;\n                cod_info.window[j + 2] = 2;\n                j += 3;\n            }\n        }\n\n        cod_info.count1bits = 0;\n        cod_info.sfb_partition_table = qupvt.nr_of_sfb_block[0][0];\n        cod_info.slen[0] = 0;\n        cod_info.slen[1] = 0;\n        cod_info.slen[2] = 0;\n        cod_info.slen[3] = 0;\n\n        cod_info.max_nonzero_coeff = 575;\n\n        /*\n         * fresh scalefactors are all zero\n         */\n        Arrays.fill(cod_info.scalefac, 0);\n\n        psfb21_analogsilence(gfc, cod_info);\n    };\n\n    function BinSearchDirection(ordinal) {\n        this.ordinal = ordinal;\n    }\n\n    BinSearchDirection.BINSEARCH_NONE = new BinSearchDirection(0);\n    BinSearchDirection.BINSEARCH_UP = new BinSearchDirection(1);\n    BinSearchDirection.BINSEARCH_DOWN = new BinSearchDirection(2);\n\n    /**\n     * author/date??\n     *\n     * binary step size search used by outer_loop to get a quantizer step size\n     * to start with\n     */\n    function bin_search_StepSize(gfc, cod_info, desired_rate, ch, xrpow) {\n        var nBits;\n        var CurrentStep = gfc.CurrentStep[ch];\n        var flagGoneOver = false;\n        var start = gfc.OldValue[ch];\n        var Direction = BinSearchDirection.BINSEARCH_NONE;\n        cod_info.global_gain = start;\n        desired_rate -= cod_info.part2_length;\n\n        assert(CurrentStep != 0);\n        for (; ;) {\n            var step;\n            nBits = tk.count_bits(gfc, xrpow, cod_info, null);\n\n            if (CurrentStep == 1 || nBits == desired_rate)\n                break;\n            /* nothing to adjust anymore */\n\n            if (nBits > desired_rate) {\n                /* increase Quantize_StepSize */\n                if (Direction == BinSearchDirection.BINSEARCH_DOWN)\n                    flagGoneOver = true;\n\n                if (flagGoneOver)\n                    CurrentStep /= 2;\n                Direction = BinSearchDirection.BINSEARCH_UP;\n                step = CurrentStep;\n            } else {\n                /* decrease Quantize_StepSize */\n                if (Direction == BinSearchDirection.BINSEARCH_UP)\n                    flagGoneOver = true;\n\n                if (flagGoneOver)\n                    CurrentStep /= 2;\n                Direction = BinSearchDirection.BINSEARCH_DOWN;\n                step = -CurrentStep;\n            }\n            cod_info.global_gain += step;\n            if (cod_info.global_gain < 0) {\n                cod_info.global_gain = 0;\n                flagGoneOver = true;\n            }\n            if (cod_info.global_gain > 255) {\n                cod_info.global_gain = 255;\n                flagGoneOver = true;\n            }\n        }\n\n        assert(cod_info.global_gain >= 0);\n        assert(cod_info.global_gain < 256);\n\n        while (nBits > desired_rate && cod_info.global_gain < 255) {\n            cod_info.global_gain++;\n            nBits = tk.count_bits(gfc, xrpow, cod_info, null);\n        }\n        gfc.CurrentStep[ch] = (start - cod_info.global_gain >= 4) ? 4 : 2;\n        gfc.OldValue[ch] = cod_info.global_gain;\n        cod_info.part2_3_length = nBits;\n        return nBits;\n    }\n\n    this.trancate_smallspectrums = function (gfc, gi, l3_xmin, work) {\n        var distort = new_float(L3Side.SFBMAX);\n\n        if ((0 == (gfc.substep_shaping & 4) && gi.block_type == Encoder.SHORT_TYPE)\n            || (gfc.substep_shaping & 0x80) != 0)\n            return;\n        qupvt.calc_noise(gi, l3_xmin, distort, new CalcNoiseResult(), null);\n        for (var j = 0; j < 576; j++) {\n            var xr = 0.0;\n            if (gi.l3_enc[j] != 0)\n                xr = Math.abs(gi.xr[j]);\n            work[j] = xr;\n        }\n\n        var j = 0;\n        var sfb = 8;\n        if (gi.block_type == Encoder.SHORT_TYPE)\n            sfb = 6;\n        do {\n            var allowedNoise, trancateThreshold;\n            var nsame, start;\n\n            var width = gi.width[sfb];\n            j += width;\n            if (distort[sfb] >= 1.0)\n                continue;\n\n            Arrays.sort(work, j - width, width);\n            if (BitStream.EQ(work[j - 1], 0.0))\n                continue;\n            /* all zero sfb */\n\n            allowedNoise = (1.0 - distort[sfb]) * l3_xmin[sfb];\n            trancateThreshold = 0.0;\n            start = 0;\n            do {\n                var noise;\n                for (nsame = 1; start + nsame < width; nsame++)\n                    if (BitStream.NEQ(work[start + j - width], work[start + j\n                        + nsame - width]))\n                        break;\n\n                noise = work[start + j - width] * work[start + j - width]\n                    * nsame;\n                if (allowedNoise < noise) {\n                    if (start != 0)\n                        trancateThreshold = work[start + j - width - 1];\n                    break;\n                }\n                allowedNoise -= noise;\n                start += nsame;\n            } while (start < width);\n            if (BitStream.EQ(trancateThreshold, 0.0))\n                continue;\n\n            do {\n                if (Math.abs(gi.xr[j - width]) <= trancateThreshold)\n                    gi.l3_enc[j - width] = 0;\n            } while (--width > 0);\n        } while (++sfb < gi.psymax);\n\n        gi.part2_3_length = tk.noquant_count_bits(gfc, gi, null);\n    };\n\n    /**\n     * author/date??\n     *\n     * Function: Returns zero if there is a scalefac which has not been\n     * amplified. Otherwise it returns one.\n     */\n    function loop_break(cod_info) {\n        for (var sfb = 0; sfb < cod_info.sfbmax; sfb++)\n            if (cod_info.scalefac[sfb]\n                + cod_info.subblock_gain[cod_info.window[sfb]] == 0)\n                return false;\n\n        return true;\n    }\n\n    /* mt 5/99: Function: Improved calc_noise for a single channel */\n\n    function penalties(noise) {\n        return Util.FAST_LOG10((0.368 + 0.632 * noise * noise * noise));\n    }\n\n    /**\n     * author/date??\n     *\n     * several different codes to decide which quantization is better\n     */\n    function get_klemm_noise(distort, gi) {\n        var klemm_noise = 1E-37;\n        for (var sfb = 0; sfb < gi.psymax; sfb++)\n            klemm_noise += penalties(distort[sfb]);\n\n        return Math.max(1e-20, klemm_noise);\n    }\n\n    function quant_compare(quant_comp, best, calc, gi, distort) {\n        /**\n         * noise is given in decibels (dB) relative to masking thesholds.<BR>\n         *\n         * over_noise: ??? (the previous comment is fully wrong)<BR>\n         * tot_noise: ??? (the previous comment is fully wrong)<BR>\n         * max_noise: max quantization noise\n         */\n        var better;\n\n        switch (quant_comp) {\n            default:\n            case 9:\n            {\n                if (best.over_count > 0) {\n                    /* there are distorted sfb */\n                    better = calc.over_SSD <= best.over_SSD;\n                    if (calc.over_SSD == best.over_SSD)\n                        better = calc.bits < best.bits;\n                } else {\n                    /* no distorted sfb */\n                    better = ((calc.max_noise < 0) && ((calc.max_noise * 10 + calc.bits) <= (best.max_noise * 10 + best.bits)));\n                }\n                break;\n            }\n\n            case 0:\n                better = calc.over_count < best.over_count\n                    || (calc.over_count == best.over_count && calc.over_noise < best.over_noise)\n                    || (calc.over_count == best.over_count\n                    && BitStream.EQ(calc.over_noise, best.over_noise) && calc.tot_noise < best.tot_noise);\n                break;\n\n            case 8:\n                calc.max_noise = get_klemm_noise(distort, gi);\n            //$FALL-THROUGH$\n            case 1:\n                better = calc.max_noise < best.max_noise;\n                break;\n            case 2:\n                better = calc.tot_noise < best.tot_noise;\n                break;\n            case 3:\n                better = (calc.tot_noise < best.tot_noise)\n                    && (calc.max_noise < best.max_noise);\n                break;\n            case 4:\n                better = (calc.max_noise <= 0.0 && best.max_noise > 0.2)\n                    || (calc.max_noise <= 0.0 && best.max_noise < 0.0\n                    && best.max_noise > calc.max_noise - 0.2 && calc.tot_noise < best.tot_noise)\n                    || (calc.max_noise <= 0.0 && best.max_noise > 0.0\n                    && best.max_noise > calc.max_noise - 0.2 && calc.tot_noise < best.tot_noise\n                    + best.over_noise)\n                    || (calc.max_noise > 0.0 && best.max_noise > -0.05\n                    && best.max_noise > calc.max_noise - 0.1 && calc.tot_noise\n                    + calc.over_noise < best.tot_noise\n                    + best.over_noise)\n                    || (calc.max_noise > 0.0 && best.max_noise > -0.1\n                    && best.max_noise > calc.max_noise - 0.15 && calc.tot_noise\n                    + calc.over_noise + calc.over_noise < best.tot_noise\n                    + best.over_noise + best.over_noise);\n                break;\n            case 5:\n                better = calc.over_noise < best.over_noise\n                    || (BitStream.EQ(calc.over_noise, best.over_noise) && calc.tot_noise < best.tot_noise);\n                break;\n            case 6:\n                better = calc.over_noise < best.over_noise\n                    || (BitStream.EQ(calc.over_noise, best.over_noise) && (calc.max_noise < best.max_noise || (BitStream\n                        .EQ(calc.max_noise, best.max_noise) && calc.tot_noise <= best.tot_noise)));\n                break;\n            case 7:\n                better = calc.over_count < best.over_count\n                    || calc.over_noise < best.over_noise;\n                break;\n        }\n\n        if (best.over_count == 0) {\n            /*\n             * If no distorted bands, only use this quantization if it is\n             * better, and if it uses less bits. Unfortunately, part2_3_length\n             * is sometimes a poor estimator of the final size at low bitrates.\n             */\n            better = better && calc.bits < best.bits;\n        }\n\n        return better;\n    }\n\n    /**\n     * author/date??\n     *\n     * <PRE>\n     *  Amplify the scalefactor bands that violate the masking threshold.\n     *  See ISO 11172-3 Section C.1.5.4.3.5\n     *\n     *  distort[] = noise/masking\n     *  distort[] > 1   ==> noise is not masked\n     *  distort[] < 1   ==> noise is masked\n     *  max_dist = maximum value of distort[]\n     *\n     *  Three algorithms:\n     *  noise_shaping_amp\n     *        0             Amplify all bands with distort[]>1.\n     *\n     *        1             Amplify all bands with distort[] >= max_dist^(.5);\n     *                     ( 50% in the db scale)\n     *\n     *        2             Amplify first band with distort[] >= max_dist;\n     *\n     *\n     *  For algorithms 0 and 1, if max_dist < 1, then amplify all bands\n     *  with distort[] >= .95*max_dist.  This is to make sure we always\n     *  amplify at least one band.\n     * </PRE>\n     */\n    function amp_scalefac_bands(gfp, cod_info, distort, xrpow, bRefine) {\n        var gfc = gfp.internal_flags;\n        var ifqstep34;\n\n        if (cod_info.scalefac_scale == 0) {\n            ifqstep34 = 1.29683955465100964055;\n            /* 2**(.75*.5) */\n        } else {\n            ifqstep34 = 1.68179283050742922612;\n            /* 2**(.75*1) */\n        }\n\n        /* compute maximum value of distort[] */\n        var trigger = 0;\n        for (var sfb = 0; sfb < cod_info.sfbmax; sfb++) {\n            if (trigger < distort[sfb])\n                trigger = distort[sfb];\n        }\n\n        var noise_shaping_amp = gfc.noise_shaping_amp;\n        if (noise_shaping_amp == 3) {\n            if (bRefine)\n                noise_shaping_amp = 2;\n            else\n                noise_shaping_amp = 1;\n        }\n        switch (noise_shaping_amp) {\n            case 2:\n                /* amplify exactly 1 band */\n                break;\n\n            case 1:\n                /* amplify bands within 50% of max (on db scale) */\n                if (trigger > 1.0)\n                    trigger = Math.pow(trigger, .5);\n                else\n                    trigger *= .95;\n                break;\n\n            case 0:\n            default:\n                /* ISO algorithm. amplify all bands with distort>1 */\n                if (trigger > 1.0)\n                    trigger = 1.0;\n                else\n                    trigger *= .95;\n                break;\n        }\n\n        var j = 0;\n        for (var sfb = 0; sfb < cod_info.sfbmax; sfb++) {\n            var width = cod_info.width[sfb];\n            var l;\n            j += width;\n            if (distort[sfb] < trigger)\n                continue;\n\n            if ((gfc.substep_shaping & 2) != 0) {\n                gfc.pseudohalf[sfb] = (0 == gfc.pseudohalf[sfb]) ? 1 : 0;\n                if (0 == gfc.pseudohalf[sfb] && gfc.noise_shaping_amp == 2)\n                    return;\n            }\n            cod_info.scalefac[sfb]++;\n            for (l = -width; l < 0; l++) {\n                xrpow[j + l] *= ifqstep34;\n                if (xrpow[j + l] > cod_info.xrpow_max)\n                    cod_info.xrpow_max = xrpow[j + l];\n            }\n\n            if (gfc.noise_shaping_amp == 2)\n                return;\n        }\n    }\n\n    /**\n     * Takehiro Tominaga 2000-xx-xx\n     *\n     * turns on scalefac scale and adjusts scalefactors\n     */\n    function inc_scalefac_scale(cod_info, xrpow) {\n        var ifqstep34 = 1.29683955465100964055;\n\n        var j = 0;\n        for (var sfb = 0; sfb < cod_info.sfbmax; sfb++) {\n            var width = cod_info.width[sfb];\n            var s = cod_info.scalefac[sfb];\n            if (cod_info.preflag != 0)\n                s += qupvt.pretab[sfb];\n            j += width;\n            if ((s & 1) != 0) {\n                s++;\n                for (var l = -width; l < 0; l++) {\n                    xrpow[j + l] *= ifqstep34;\n                    if (xrpow[j + l] > cod_info.xrpow_max)\n                        cod_info.xrpow_max = xrpow[j + l];\n                }\n            }\n            cod_info.scalefac[sfb] = s >> 1;\n        }\n        cod_info.preflag = 0;\n        cod_info.scalefac_scale = 1;\n    }\n\n    /**\n     * Takehiro Tominaga 2000-xx-xx\n     *\n     * increases the subblock gain and adjusts scalefactors\n     */\n    function inc_subblock_gain(gfc, cod_info, xrpow) {\n        var sfb;\n        var scalefac = cod_info.scalefac;\n\n        /* subbloc_gain can't do anything in the long block region */\n        for (sfb = 0; sfb < cod_info.sfb_lmax; sfb++) {\n            if (scalefac[sfb] >= 16)\n                return true;\n        }\n\n        for (var window = 0; window < 3; window++) {\n            var s1 = 0;\n            var s2 = 0;\n\n            for (sfb = cod_info.sfb_lmax + window; sfb < cod_info.sfbdivide; sfb += 3) {\n                if (s1 < scalefac[sfb])\n                    s1 = scalefac[sfb];\n            }\n            for (; sfb < cod_info.sfbmax; sfb += 3) {\n                if (s2 < scalefac[sfb])\n                    s2 = scalefac[sfb];\n            }\n\n            if (s1 < 16 && s2 < 8)\n                continue;\n\n            if (cod_info.subblock_gain[window] >= 7)\n                return true;\n\n            /*\n             * even though there is no scalefactor for sfb12 subblock gain\n             * affects upper frequencies too, that's why we have to go up to\n             * SBMAX_s\n             */\n            cod_info.subblock_gain[window]++;\n            var j = gfc.scalefac_band.l[cod_info.sfb_lmax];\n            for (sfb = cod_info.sfb_lmax + window; sfb < cod_info.sfbmax; sfb += 3) {\n                var amp;\n                var width = cod_info.width[sfb];\n                var s = scalefac[sfb];\n                assert(s >= 0);\n                s = s - (4 >> cod_info.scalefac_scale);\n                if (s >= 0) {\n                    scalefac[sfb] = s;\n                    j += width * 3;\n                    continue;\n                }\n\n                scalefac[sfb] = 0;\n                {\n                    var gain = 210 + (s << (cod_info.scalefac_scale + 1));\n                    amp = qupvt.IPOW20(gain);\n                }\n                j += width * (window + 1);\n                for (var l = -width; l < 0; l++) {\n                    xrpow[j + l] *= amp;\n                    if (xrpow[j + l] > cod_info.xrpow_max)\n                        cod_info.xrpow_max = xrpow[j + l];\n                }\n                j += width * (3 - window - 1);\n            }\n\n            {\n                var amp = qupvt.IPOW20(202);\n                j += cod_info.width[sfb] * (window + 1);\n                for (var l = -cod_info.width[sfb]; l < 0; l++) {\n                    xrpow[j + l] *= amp;\n                    if (xrpow[j + l] > cod_info.xrpow_max)\n                        cod_info.xrpow_max = xrpow[j + l];\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * <PRE>\n     *  Takehiro Tominaga /date??\n     *  Robert Hegemann 2000-09-06: made a function of it\n     *\n     *  amplifies scalefactor bands,\n     *   - if all are already amplified returns 0\n     *   - if some bands are amplified too much:\n     *      * try to increase scalefac_scale\n     *      * if already scalefac_scale was set\n     *          try on short blocks to increase subblock gain\n     * </PRE>\n     */\n    function balance_noise(gfp, cod_info, distort, xrpow, bRefine) {\n        var gfc = gfp.internal_flags;\n\n        amp_scalefac_bands(gfp, cod_info, distort, xrpow, bRefine);\n\n        /*\n         * check to make sure we have not amplified too much loop_break returns\n         * 0 if there is an unamplified scalefac scale_bitcount returns 0 if no\n         * scalefactors are too large\n         */\n\n        var status = loop_break(cod_info);\n\n        if (status)\n            return false;\n        /* all bands amplified */\n\n        /*\n         * not all scalefactors have been amplified. so these scalefacs are\n         * possibly valid. encode them:\n         */\n        if (gfc.mode_gr == 2)\n            status = tk.scale_bitcount(cod_info);\n        else\n            status = tk.scale_bitcount_lsf(gfc, cod_info);\n\n        if (!status)\n            return true;\n        /* amplified some bands not exceeding limits */\n\n        /*\n         * some scalefactors are too large. lets try setting scalefac_scale=1\n         */\n        if (gfc.noise_shaping > 1) {\n            Arrays.fill(gfc.pseudohalf, 0);\n            if (0 == cod_info.scalefac_scale) {\n                inc_scalefac_scale(cod_info, xrpow);\n                status = false;\n            } else {\n                if (cod_info.block_type == Encoder.SHORT_TYPE\n                    && gfc.subblock_gain > 0) {\n                    status = (inc_subblock_gain(gfc, cod_info, xrpow) || loop_break(cod_info));\n                }\n            }\n        }\n\n        if (!status) {\n            if (gfc.mode_gr == 2)\n                status = tk.scale_bitcount(cod_info);\n            else\n                status = tk.scale_bitcount_lsf(gfc, cod_info);\n        }\n        return !status;\n    }\n\n    /**\n     * <PRE>\n     *  Function: The outer iteration loop controls the masking conditions\n     *  of all scalefactorbands. It computes the best scalefac and\n     *  global gain. This module calls the inner iteration loop\n     *\n     *  mt 5/99 completely rewritten to allow for bit reservoir control,\n     *  mid/side channels with L/R or mid/side masking thresholds,\n     *  and chooses best quantization instead of last quantization when\n     *  no distortion free quantization can be found.\n     *\n     *  added VBR support mt 5/99\n     *\n     *  some code shuffle rh 9/00\n     * </PRE>\n     *\n     * @param l3_xmin\n     *            allowed distortion\n     * @param xrpow\n     *            coloured magnitudes of spectral\n     * @param targ_bits\n     *            maximum allowed bits\n     */\n    this.outer_loop = function (gfp, cod_info, l3_xmin, xrpow, ch, targ_bits) {\n        var gfc = gfp.internal_flags;\n        var cod_info_w = new GrInfo();\n        var save_xrpow = new_float(576);\n        var distort = new_float(L3Side.SFBMAX);\n        var best_noise_info = new CalcNoiseResult();\n        var better;\n        var prev_noise = new CalcNoiseData();\n        var best_part2_3_length = 9999999;\n        var bEndOfSearch = false;\n        var bRefine = false;\n        var best_ggain_pass1 = 0;\n\n        bin_search_StepSize(gfc, cod_info, targ_bits, ch, xrpow);\n\n        if (0 == gfc.noise_shaping)\n        /* fast mode, no noise shaping, we are ready */\n            return 100;\n        /* default noise_info.over_count */\n\n        /* compute the distortion in this quantization */\n        /* coefficients and thresholds both l/r (or both mid/side) */\n        qupvt.calc_noise(cod_info, l3_xmin, distort, best_noise_info,\n            prev_noise);\n        best_noise_info.bits = cod_info.part2_3_length;\n\n        cod_info_w.assign(cod_info);\n        var age = 0;\n        System.arraycopy(xrpow, 0, save_xrpow, 0, 576);\n\n        while (!bEndOfSearch) {\n            /* BEGIN MAIN LOOP */\n            do {\n                var noise_info = new CalcNoiseResult();\n                var search_limit;\n                var maxggain = 255;\n\n                /*\n                 * When quantization with no distorted bands is found, allow up\n                 * to X new unsuccesful tries in serial. This gives us more\n                 * possibilities for different quant_compare modes. Much more\n                 * than 3 makes not a big difference, it is only slower.\n                 */\n\n                if ((gfc.substep_shaping & 2) != 0) {\n                    search_limit = 20;\n                } else {\n                    search_limit = 3;\n                }\n\n                /*\n                 * Check if the last scalefactor band is distorted. in VBR mode\n                 * we can't get rid of the distortion, so quit now and VBR mode\n                 * will try again with more bits. (makes a 10% speed increase,\n                 * the files I tested were binary identical, 2000/05/20 Robert\n                 * Hegemann) distort[] > 1 means noise > allowed noise\n                 */\n                if (gfc.sfb21_extra) {\n                    if (distort[cod_info_w.sfbmax] > 1.0)\n                        break;\n                    if (cod_info_w.block_type == Encoder.SHORT_TYPE\n                        && (distort[cod_info_w.sfbmax + 1] > 1.0 || distort[cod_info_w.sfbmax + 2] > 1.0))\n                        break;\n                }\n\n                /* try a new scalefactor conbination on cod_info_w */\n                if (!balance_noise(gfp, cod_info_w, distort, xrpow, bRefine))\n                    break;\n                if (cod_info_w.scalefac_scale != 0)\n                    maxggain = 254;\n\n                /*\n                 * inner_loop starts with the initial quantization step computed\n                 * above and slowly increases until the bits < huff_bits. Thus\n                 * it is important not to start with too large of an inital\n                 * quantization step. Too small is ok, but inner_loop will take\n                 * longer\n                 */\n                var huff_bits = targ_bits - cod_info_w.part2_length;\n                if (huff_bits <= 0)\n                    break;\n\n                /*\n                 * increase quantizer stepsize until needed bits are below\n                 * maximum\n                 */\n                while ((cod_info_w.part2_3_length = tk.count_bits(gfc, xrpow,\n                    cod_info_w, prev_noise)) > huff_bits\n                && cod_info_w.global_gain <= maxggain)\n                    cod_info_w.global_gain++;\n\n                if (cod_info_w.global_gain > maxggain)\n                    break;\n\n                if (best_noise_info.over_count == 0) {\n\n                    while ((cod_info_w.part2_3_length = tk.count_bits(gfc,\n                        xrpow, cod_info_w, prev_noise)) > best_part2_3_length\n                    && cod_info_w.global_gain <= maxggain)\n                        cod_info_w.global_gain++;\n\n                    if (cod_info_w.global_gain > maxggain)\n                        break;\n                }\n\n                /* compute the distortion in this quantization */\n                qupvt.calc_noise(cod_info_w, l3_xmin, distort, noise_info,\n                    prev_noise);\n                noise_info.bits = cod_info_w.part2_3_length;\n\n                /*\n                 * check if this quantization is better than our saved\n                 * quantization\n                 */\n                if (cod_info.block_type != Encoder.SHORT_TYPE) {\n                    // NORM, START or STOP type\n                    better = gfp.quant_comp;\n                } else\n                    better = gfp.quant_comp_short;\n\n                better = quant_compare(better, best_noise_info, noise_info,\n                    cod_info_w, distort) ? 1 : 0;\n\n                /* save data so we can restore this quantization later */\n                if (better != 0) {\n                    best_part2_3_length = cod_info.part2_3_length;\n                    best_noise_info = noise_info;\n                    cod_info.assign(cod_info_w);\n                    age = 0;\n                    /* save data so we can restore this quantization later */\n                    /* store for later reuse */\n                    System.arraycopy(xrpow, 0, save_xrpow, 0, 576);\n                } else {\n                    /* early stop? */\n                    if (gfc.full_outer_loop == 0) {\n                        if (++age > search_limit\n                            && best_noise_info.over_count == 0)\n                            break;\n                        if ((gfc.noise_shaping_amp == 3) && bRefine && age > 30)\n                            break;\n                        if ((gfc.noise_shaping_amp == 3)\n                            && bRefine\n                            && (cod_info_w.global_gain - best_ggain_pass1) > 15)\n                            break;\n                    }\n                }\n            } while ((cod_info_w.global_gain + cod_info_w.scalefac_scale) < 255);\n\n            if (gfc.noise_shaping_amp == 3) {\n                if (!bRefine) {\n                    /* refine search */\n                    cod_info_w.assign(cod_info);\n                    System.arraycopy(save_xrpow, 0, xrpow, 0, 576);\n                    age = 0;\n                    best_ggain_pass1 = cod_info_w.global_gain;\n\n                    bRefine = true;\n                } else {\n                    /* search already refined, stop */\n                    bEndOfSearch = true;\n                }\n\n            } else {\n                bEndOfSearch = true;\n            }\n        }\n\n        assert((cod_info.global_gain + cod_info.scalefac_scale) <= 255);\n        /*\n         * finish up\n         */\n        if (gfp.VBR == VbrMode.vbr_rh || gfp.VBR == VbrMode.vbr_mtrh)\n        /* restore for reuse on next try */\n            System.arraycopy(save_xrpow, 0, xrpow, 0, 576);\n        /*\n         * do the 'substep shaping'\n         */\n        else if ((gfc.substep_shaping & 1) != 0)\n            trancate_smallspectrums(gfc, cod_info, l3_xmin, xrpow);\n\n        return best_noise_info.over_count;\n    }\n\n    /**\n     * Robert Hegemann 2000-09-06\n     *\n     * update reservoir status after FINAL quantization/bitrate\n     */\n    this.iteration_finish_one = function (gfc, gr, ch) {\n        var l3_side = gfc.l3_side;\n        var cod_info = l3_side.tt[gr][ch];\n\n        /*\n         * try some better scalefac storage\n         */\n        tk.best_scalefac_store(gfc, gr, ch, l3_side);\n\n        /*\n         * best huffman_divide may save some bits too\n         */\n        if (gfc.use_best_huffman == 1)\n            tk.best_huffman_divide(gfc, cod_info);\n\n        /*\n         * update reservoir status after FINAL quantization/bitrate\n         */\n        rv.ResvAdjust(gfc, cod_info);\n    };\n\n    /**\n     *\n     * 2000-09-04 Robert Hegemann\n     *\n     * @param l3_xmin\n     *            allowed distortion of the scalefactor\n     * @param xrpow\n     *            coloured magnitudes of spectral values\n     */\n    this.VBR_encode_granule = function (gfp, cod_info, l3_xmin, xrpow, ch, min_bits, max_bits) {\n        var gfc = gfp.internal_flags;\n        var bst_cod_info = new GrInfo();\n        var bst_xrpow = new_float(576);\n        var Max_bits = max_bits;\n        var real_bits = max_bits + 1;\n        var this_bits = (max_bits + min_bits) / 2;\n        var dbits, over, found = 0;\n        var sfb21_extra = gfc.sfb21_extra;\n\n        assert(Max_bits <= LameInternalFlags.MAX_BITS_PER_CHANNEL);\n        Arrays.fill(bst_cod_info.l3_enc, 0);\n\n        /*\n         * search within round about 40 bits of optimal\n         */\n        do {\n            assert(this_bits >= min_bits);\n            assert(this_bits <= max_bits);\n            assert(min_bits <= max_bits);\n\n            if (this_bits > Max_bits - 42)\n                gfc.sfb21_extra = false;\n            else\n                gfc.sfb21_extra = sfb21_extra;\n\n            over = outer_loop(gfp, cod_info, l3_xmin, xrpow, ch, this_bits);\n\n            /*\n             * is quantization as good as we are looking for ? in this case: is\n             * no scalefactor band distorted?\n             */\n            if (over <= 0) {\n                found = 1;\n                /*\n                 * now we know it can be done with \"real_bits\" and maybe we can\n                 * skip some iterations\n                 */\n                real_bits = cod_info.part2_3_length;\n\n                /*\n                 * store best quantization so far\n                 */\n                bst_cod_info.assign(cod_info);\n                System.arraycopy(xrpow, 0, bst_xrpow, 0, 576);\n\n                /*\n                 * try with fewer bits\n                 */\n                max_bits = real_bits - 32;\n                dbits = max_bits - min_bits;\n                this_bits = (max_bits + min_bits) / 2;\n            } else {\n                /*\n                 * try with more bits\n                 */\n                min_bits = this_bits + 32;\n                dbits = max_bits - min_bits;\n                this_bits = (max_bits + min_bits) / 2;\n\n                if (found != 0) {\n                    found = 2;\n                    /*\n                     * start again with best quantization so far\n                     */\n                    cod_info.assign(bst_cod_info);\n                    System.arraycopy(bst_xrpow, 0, xrpow, 0, 576);\n                }\n            }\n        } while (dbits > 12);\n\n        gfc.sfb21_extra = sfb21_extra;\n\n        /*\n         * found=0 => nothing found, use last one found=1 => we just found the\n         * best and left the loop found=2 => we restored a good one and have now\n         * l3_enc to restore too\n         */\n        if (found == 2) {\n            System.arraycopy(bst_cod_info.l3_enc, 0, cod_info.l3_enc, 0, 576);\n        }\n        assert(cod_info.part2_3_length <= Max_bits);\n    }\n\n    /**\n     * Robert Hegemann 2000-09-05\n     *\n     * calculates * how many bits are available for analog silent granules * how\n     * many bits to use for the lowest allowed bitrate * how many bits each\n     * bitrate would provide\n     */\n    this.get_framebits = function (gfp, frameBits) {\n        var gfc = gfp.internal_flags;\n\n        /*\n         * always use at least this many bits per granule per channel unless we\n         * detect analog silence, see below\n         */\n        gfc.bitrate_index = gfc.VBR_min_bitrate;\n        var bitsPerFrame = bs.getframebits(gfp);\n\n        /*\n         * bits for analog silence\n         */\n        gfc.bitrate_index = 1;\n        bitsPerFrame = bs.getframebits(gfp);\n\n        for (var i = 1; i <= gfc.VBR_max_bitrate; i++) {\n            gfc.bitrate_index = i;\n            var mb = new MeanBits(bitsPerFrame);\n            frameBits[i] = rv.ResvFrameBegin(gfp, mb);\n            bitsPerFrame = mb.bits;\n        }\n    };\n\n    /* RH: this one needs to be overhauled sometime */\n\n    /**\n     * <PRE>\n     *  2000-09-04 Robert Hegemann\n     *\n     *  * converts LR to MS coding when necessary\n     *  * calculates allowed/adjusted quantization noise amounts\n     *  * detects analog silent frames\n     *\n     *  some remarks:\n     *  - lower masking depending on Quality setting\n     *  - quality control together with adjusted ATH MDCT scaling\n     *    on lower quality setting allocate more noise from\n     *    ATH masking, and on higher quality setting allocate\n     *    less noise from ATH masking.\n     *  - experiments show that going more than 2dB over GPSYCHO's\n     *    limits ends up in very annoying artefacts\n     * </PRE>\n     */\n    this.VBR_old_prepare = function (gfp, pe, ms_ener_ratio, ratio, l3_xmin, frameBits, min_bits,\n                                     max_bits, bands) {\n        var gfc = gfp.internal_flags;\n\n        var masking_lower_db, adjust = 0.0;\n        var analog_silence = 1;\n        var bits = 0;\n\n        gfc.bitrate_index = gfc.VBR_max_bitrate;\n        var avg = rv.ResvFrameBegin(gfp, new MeanBits(0)) / gfc.mode_gr;\n\n        get_framebits(gfp, frameBits);\n\n        for (var gr = 0; gr < gfc.mode_gr; gr++) {\n            var mxb = qupvt.on_pe(gfp, pe, max_bits[gr], avg, gr, 0);\n            if (gfc.mode_ext == Encoder.MPG_MD_MS_LR) {\n                ms_convert(gfc.l3_side, gr);\n                qupvt.reduce_side(max_bits[gr], ms_ener_ratio[gr], avg, mxb);\n            }\n            for (var ch = 0; ch < gfc.channels_out; ++ch) {\n                var cod_info = gfc.l3_side.tt[gr][ch];\n\n                if (cod_info.block_type != Encoder.SHORT_TYPE) {\n                    // NORM, START or STOP type\n                    adjust = 1.28 / (1 + Math\n                            .exp(3.5 - pe[gr][ch] / 300.)) - 0.05;\n                    masking_lower_db = gfc.PSY.mask_adjust - adjust;\n                } else {\n                    adjust = 2.56 / (1 + Math\n                            .exp(3.5 - pe[gr][ch] / 300.)) - 0.14;\n                    masking_lower_db = gfc.PSY.mask_adjust_short - adjust;\n                }\n                gfc.masking_lower = Math.pow(10.0,\n                    masking_lower_db * 0.1);\n\n                init_outer_loop(gfc, cod_info);\n                bands[gr][ch] = qupvt.calc_xmin(gfp, ratio[gr][ch], cod_info,\n                    l3_xmin[gr][ch]);\n                if (bands[gr][ch] != 0)\n                    analog_silence = 0;\n\n                min_bits[gr][ch] = 126;\n\n                bits += max_bits[gr][ch];\n            }\n        }\n        for (var gr = 0; gr < gfc.mode_gr; gr++) {\n            for (var ch = 0; ch < gfc.channels_out; ch++) {\n                if (bits > frameBits[gfc.VBR_max_bitrate]) {\n                    max_bits[gr][ch] *= frameBits[gfc.VBR_max_bitrate];\n                    max_bits[gr][ch] /= bits;\n                }\n                if (min_bits[gr][ch] > max_bits[gr][ch])\n                    min_bits[gr][ch] = max_bits[gr][ch];\n\n            }\n            /* for ch */\n        }\n        /* for gr */\n\n        return analog_silence;\n    };\n\n    this.bitpressure_strategy = function (gfc, l3_xmin, min_bits, max_bits) {\n        for (var gr = 0; gr < gfc.mode_gr; gr++) {\n            for (var ch = 0; ch < gfc.channels_out; ch++) {\n                var gi = gfc.l3_side.tt[gr][ch];\n                var pxmin = l3_xmin[gr][ch];\n                var pxminPos = 0;\n                for (var sfb = 0; sfb < gi.psy_lmax; sfb++)\n                    pxmin[pxminPos++] *= 1. + .029 * sfb * sfb\n                        / Encoder.SBMAX_l / Encoder.SBMAX_l;\n\n                if (gi.block_type == Encoder.SHORT_TYPE) {\n                    for (var sfb = gi.sfb_smin; sfb < Encoder.SBMAX_s; sfb++) {\n                        pxmin[pxminPos++] *= 1. + .029 * sfb * sfb\n                            / Encoder.SBMAX_s / Encoder.SBMAX_s;\n                        pxmin[pxminPos++] *= 1. + .029 * sfb * sfb\n                            / Encoder.SBMAX_s / Encoder.SBMAX_s;\n                        pxmin[pxminPos++] *= 1. + .029 * sfb * sfb\n                            / Encoder.SBMAX_s / Encoder.SBMAX_s;\n                    }\n                }\n                max_bits[gr][ch] = 0 | Math.max(min_bits[gr][ch],\n                        0.9 * max_bits[gr][ch]);\n            }\n        }\n    };\n\n    this.VBR_new_prepare = function (gfp, pe, ratio, l3_xmin, frameBits, max_bits) {\n        var gfc = gfp.internal_flags;\n\n        var analog_silence = 1;\n        var avg = 0, bits = 0;\n        var maximum_framebits;\n\n        if (!gfp.free_format) {\n            gfc.bitrate_index = gfc.VBR_max_bitrate;\n\n            var mb = new MeanBits(avg);\n            rv.ResvFrameBegin(gfp, mb);\n            avg = mb.bits;\n\n            get_framebits(gfp, frameBits);\n            maximum_framebits = frameBits[gfc.VBR_max_bitrate];\n        } else {\n            gfc.bitrate_index = 0;\n            var mb = new MeanBits(avg);\n            maximum_framebits = rv.ResvFrameBegin(gfp, mb);\n            avg = mb.bits;\n            frameBits[0] = maximum_framebits;\n        }\n\n        for (var gr = 0; gr < gfc.mode_gr; gr++) {\n            qupvt.on_pe(gfp, pe, max_bits[gr], avg, gr, 0);\n            if (gfc.mode_ext == Encoder.MPG_MD_MS_LR) {\n                ms_convert(gfc.l3_side, gr);\n            }\n            for (var ch = 0; ch < gfc.channels_out; ++ch) {\n                var cod_info = gfc.l3_side.tt[gr][ch];\n\n                gfc.masking_lower = Math.pow(10.0,\n                    gfc.PSY.mask_adjust * 0.1);\n\n                init_outer_loop(gfc, cod_info);\n                if (0 != qupvt.calc_xmin(gfp, ratio[gr][ch], cod_info,\n                        l3_xmin[gr][ch]))\n                    analog_silence = 0;\n\n                bits += max_bits[gr][ch];\n            }\n        }\n        for (var gr = 0; gr < gfc.mode_gr; gr++) {\n            for (var ch = 0; ch < gfc.channels_out; ch++) {\n                if (bits > maximum_framebits) {\n                    max_bits[gr][ch] *= maximum_framebits;\n                    max_bits[gr][ch] /= bits;\n                }\n\n            }\n            /* for ch */\n        }\n        /* for gr */\n\n        return analog_silence;\n    };\n\n    /**\n     * calculates target bits for ABR encoding\n     *\n     * mt 2000/05/31\n     */\n    this.calc_target_bits = function (gfp, pe, ms_ener_ratio, targ_bits, analog_silence_bits, max_frame_bits) {\n        var gfc = gfp.internal_flags;\n        var l3_side = gfc.l3_side;\n        var res_factor;\n        var gr, ch, totbits, mean_bits = 0;\n\n        gfc.bitrate_index = gfc.VBR_max_bitrate;\n        var mb = new MeanBits(mean_bits);\n        max_frame_bits[0] = rv.ResvFrameBegin(gfp, mb);\n        mean_bits = mb.bits;\n\n        gfc.bitrate_index = 1;\n        mean_bits = bs.getframebits(gfp) - gfc.sideinfo_len * 8;\n        analog_silence_bits[0] = mean_bits / (gfc.mode_gr * gfc.channels_out);\n\n        mean_bits = gfp.VBR_mean_bitrate_kbps * gfp.framesize * 1000;\n        if ((gfc.substep_shaping & 1) != 0)\n            mean_bits *= 1.09;\n        mean_bits /= gfp.out_samplerate;\n        mean_bits -= gfc.sideinfo_len * 8;\n        mean_bits /= (gfc.mode_gr * gfc.channels_out);\n\n        /**\n         * <PRE>\n         *           res_factor is the percentage of the target bitrate that should\n         *           be used on average.  the remaining bits are added to the\n         *           bitreservoir and used for difficult to encode frames.\n         *\n         *           Since we are tracking the average bitrate, we should adjust\n         *           res_factor \"on the fly\", increasing it if the average bitrate\n         *           is greater than the requested bitrate, and decreasing it\n         *           otherwise.  Reasonable ranges are from .9 to 1.0\n         *\n         *           Until we get the above suggestion working, we use the following\n         *           tuning:\n         *           compression ratio    res_factor\n         *           5.5  (256kbps)         1.0      no need for bitreservoir\n         *           11   (128kbps)         .93      7% held for reservoir\n         *\n         *           with linear interpolation for other values.\n         * </PRE>\n         */\n        res_factor = .93 + .07 * (11.0 - gfp.compression_ratio)\n            / (11.0 - 5.5);\n        if (res_factor < .90)\n            res_factor = .90;\n        if (res_factor > 1.00)\n            res_factor = 1.00;\n\n        for (gr = 0; gr < gfc.mode_gr; gr++) {\n            var sum = 0;\n            for (ch = 0; ch < gfc.channels_out; ch++) {\n                targ_bits[gr][ch] = (int)(res_factor * mean_bits);\n\n                if (pe[gr][ch] > 700) {\n                    var add_bits = (int)((pe[gr][ch] - 700) / 1.4);\n\n                    var cod_info = l3_side.tt[gr][ch];\n                    targ_bits[gr][ch] = (int)(res_factor * mean_bits);\n\n                    /* short blocks use a little extra, no matter what the pe */\n                    if (cod_info.block_type == Encoder.SHORT_TYPE) {\n                        if (add_bits < mean_bits / 2)\n                            add_bits = mean_bits / 2;\n                    }\n                    /* at most increase bits by 1.5*average */\n                    if (add_bits > mean_bits * 3 / 2)\n                        add_bits = mean_bits * 3 / 2;\n                    else if (add_bits < 0)\n                        add_bits = 0;\n\n                    targ_bits[gr][ch] += add_bits;\n                }\n                if (targ_bits[gr][ch] > LameInternalFlags.MAX_BITS_PER_CHANNEL) {\n                    targ_bits[gr][ch] = LameInternalFlags.MAX_BITS_PER_CHANNEL;\n                }\n                sum += targ_bits[gr][ch];\n            }\n            /* for ch */\n            if (sum > LameInternalFlags.MAX_BITS_PER_GRANULE) {\n                for (ch = 0; ch < gfc.channels_out; ++ch) {\n                    targ_bits[gr][ch] *= LameInternalFlags.MAX_BITS_PER_GRANULE;\n                    targ_bits[gr][ch] /= sum;\n                }\n            }\n        }\n        /* for gr */\n\n        if (gfc.mode_ext == Encoder.MPG_MD_MS_LR)\n            for (gr = 0; gr < gfc.mode_gr; gr++) {\n                qupvt.reduce_side(targ_bits[gr], ms_ener_ratio[gr], mean_bits\n                    * gfc.channels_out,\n                    LameInternalFlags.MAX_BITS_PER_GRANULE);\n            }\n\n        /*\n         * sum target bits\n         */\n        totbits = 0;\n        for (gr = 0; gr < gfc.mode_gr; gr++) {\n            for (ch = 0; ch < gfc.channels_out; ch++) {\n                if (targ_bits[gr][ch] > LameInternalFlags.MAX_BITS_PER_CHANNEL)\n                    targ_bits[gr][ch] = LameInternalFlags.MAX_BITS_PER_CHANNEL;\n                totbits += targ_bits[gr][ch];\n            }\n        }\n\n        /*\n         * repartion target bits if needed\n         */\n        if (totbits > max_frame_bits[0]) {\n            for (gr = 0; gr < gfc.mode_gr; gr++) {\n                for (ch = 0; ch < gfc.channels_out; ch++) {\n                    targ_bits[gr][ch] *= max_frame_bits[0];\n                    targ_bits[gr][ch] /= totbits;\n                }\n            }\n        }\n    }\n\n}\n\nmodule.exports = Quantize;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL1F1YW50aXplLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQywrRUFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixtQkFBTyxDQUFDLHlGQUFrQjtBQUM1QyxzQkFBc0IsbUJBQU8sQ0FBQyxpR0FBc0I7QUFDcEQsb0JBQW9CLG1CQUFPLENBQUMsNkZBQW9CO0FBQ2hELGNBQWMsbUJBQU8sQ0FBQyxpRkFBYztBQUNwQyxhQUFhLG1CQUFPLENBQUMsK0VBQWE7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLCtFQUFhOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIscUJBQXFCO0FBQ2pEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxvQkFBb0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQ0FBc0MsWUFBWTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsZ0NBQWdDLFdBQVc7QUFDM0M7QUFDQSxvREFBb0Qsb0JBQW9CO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBDQUEwQyxZQUFZO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVCQUF1QjtBQUNyRTtBQUNBO0FBQ0EscUNBQXFDLFlBQVk7QUFDakQsd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsdUJBQXVCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx1QkFBdUI7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxVQUFVOztBQUVWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdUJBQXVCO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLHVCQUF1QjtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsdUJBQXVCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE9BQU87QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsdUJBQXVCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTtBQUNBOztBQUVBLDZCQUE2QixZQUFZO0FBQ3pDO0FBQ0E7O0FBRUEsbURBQW1ELDBCQUEwQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsdUJBQXVCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdUJBQXVCO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtCQUFrQjtBQUMzQyw2QkFBNkIsdUJBQXVCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLGtCQUFrQjtBQUMzQyw2QkFBNkIsdUJBQXVCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxtQkFBbUI7QUFDckQ7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRCx1QkFBdUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLGtCQUFrQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix1QkFBdUI7QUFDcEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDLDZCQUE2Qix1QkFBdUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix1QkFBdUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLGtCQUFrQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkMseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtCQUFrQjtBQUMzQyw2QkFBNkIsdUJBQXVCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbGFtZWpzL3NyYy9qcy9RdWFudGl6ZS5qcz84NzkxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBNUDMgcXVhbnRpemF0aW9uXG4gKlxuICogICAgICBDb3B5cmlnaHQgKGMpIDE5OTktMjAwMCBNYXJrIFRheWxvclxuICogICAgICBDb3B5cmlnaHQgKGMpIDE5OTktMjAwMyBUYWtlaGlybyBUb21pbmFnYVxuICogICAgICBDb3B5cmlnaHQgKGMpIDIwMDAtMjAwNyBSb2JlcnQgSGVnZW1hbm5cbiAqICAgICAgQ29weXJpZ2h0IChjKSAyMDAxLTIwMDUgR2FicmllbCBCb3V2aWduZVxuICpcbiAqIFRoaXMgbGlicmFyeSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAqIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcbiAqIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb247IGVpdGhlclxuICogdmVyc2lvbiAyIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuICpcbiAqIFRoaXMgbGlicmFyeSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gICAgIFNlZSB0aGUgR05VXG4gKiBMaWJyYXJ5IEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG4gKiBMaWNlbnNlIGFsb25nIHdpdGggdGhpcyBsaWJyYXJ5OyBpZiBub3QsIHdyaXRlIHRvIHRoZVxuICogRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsXG4gKiBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cbiAqL1xuXG4vKiAkSWQ6IFF1YW50aXplLmphdmEsdiAxLjI0IDIwMTEvMDUvMjQgMjA6NDg6MDYga2VuY2hpcyBFeHAgJCAqL1xuXG4vL3BhY2thZ2UgbXAzO1xuXG4vL2ltcG9ydCBqYXZhLnV0aWwuQXJyYXlzO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uLmpzJyk7XG52YXIgU3lzdGVtID0gY29tbW9uLlN5c3RlbTtcbnZhciBWYnJNb2RlID0gY29tbW9uLlZick1vZGU7XG52YXIgRmxvYXQgPSBjb21tb24uRmxvYXQ7XG52YXIgU2hvcnRCbG9jayA9IGNvbW1vbi5TaG9ydEJsb2NrO1xudmFyIFV0aWwgPSBjb21tb24uVXRpbDtcbnZhciBBcnJheXMgPSBjb21tb24uQXJyYXlzO1xudmFyIG5ld19hcnJheV9uID0gY29tbW9uLm5ld19hcnJheV9uO1xudmFyIG5ld19ieXRlID0gY29tbW9uLm5ld19ieXRlO1xudmFyIG5ld19kb3VibGUgPSBjb21tb24ubmV3X2RvdWJsZTtcbnZhciBuZXdfZmxvYXQgPSBjb21tb24ubmV3X2Zsb2F0O1xudmFyIG5ld19mbG9hdF9uID0gY29tbW9uLm5ld19mbG9hdF9uO1xudmFyIG5ld19pbnQgPSBjb21tb24ubmV3X2ludDtcbnZhciBuZXdfaW50X24gPSBjb21tb24ubmV3X2ludF9uO1xudmFyIGFzc2VydCA9IGNvbW1vbi5hc3NlcnQ7XG5cbnZhciBWQlJRdWFudGl6ZSA9IHJlcXVpcmUoJy4vVkJSUXVhbnRpemUuanMnKTtcbnZhciBDYWxjTm9pc2VSZXN1bHQgPSByZXF1aXJlKCcuL0NhbGNOb2lzZVJlc3VsdC5qcycpO1xudmFyIENhbGNOb2lzZURhdGEgPSByZXF1aXJlKCcuL0NhbGNOb2lzZURhdGEuanMnKTtcbnZhciBFbmNvZGVyID0gcmVxdWlyZSgnLi9FbmNvZGVyLmpzJyk7XG52YXIgR3JJbmZvID0gcmVxdWlyZSgnLi9HckluZm8uanMnKTtcbnZhciBMM1NpZGUgPSByZXF1aXJlKCcuL0wzU2lkZS5qcycpO1xuXG5mdW5jdGlvbiBRdWFudGl6ZSgpIHtcbiAgICB2YXIgYnM7XG4gICAgdGhpcy5ydiA9IG51bGw7XG4gICAgdmFyIHJ2O1xuICAgIHRoaXMucXVwdnQgPSBudWxsO1xuICAgIHZhciBxdXB2dDtcblxuICAgIHZhciB2YnIgPSBuZXcgVkJSUXVhbnRpemUoKTtcbiAgICB2YXIgdGs7XG5cbiAgICB0aGlzLnNldE1vZHVsZXMgPSBmdW5jdGlvbiAoX2JzLCBfcnYsIF9xdXB2dCwgX3RrKSB7XG4gICAgICAgIGJzID0gX2JzO1xuICAgICAgICBydiA9IF9ydjtcbiAgICAgICAgdGhpcy5ydiA9IF9ydjtcbiAgICAgICAgcXVwdnQgPSBfcXVwdnQ7XG4gICAgICAgIHRoaXMucXVwdnQgPSBfcXVwdnQ7XG4gICAgICAgIHRrID0gX3RrO1xuICAgICAgICB2YnIuc2V0TW9kdWxlcyhxdXB2dCwgdGspO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNvbnZlcnQgZnJvbSBML1IgPC4gTWlkL1NpZGVcbiAgICAgKi9cbiAgICB0aGlzLm1zX2NvbnZlcnQgPSBmdW5jdGlvbiAobDNfc2lkZSwgZ3IpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA1NzY7ICsraSkge1xuICAgICAgICAgICAgdmFyIGwgPSBsM19zaWRlLnR0W2dyXVswXS54cltpXTtcbiAgICAgICAgICAgIHZhciByID0gbDNfc2lkZS50dFtncl1bMV0ueHJbaV07XG4gICAgICAgICAgICBsM19zaWRlLnR0W2dyXVswXS54cltpXSA9IChsICsgcikgKiAoVXRpbC5TUVJUMiAqIDAuNSk7XG4gICAgICAgICAgICBsM19zaWRlLnR0W2dyXVsxXS54cltpXSA9IChsIC0gcikgKiAoVXRpbC5TUVJUMiAqIDAuNSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogbXQgNi85OVxuICAgICAqXG4gICAgICogaW5pdGlhbGl6ZXMgY29kX2luZm8sIHNjYWxlZmFjIGFuZCB4cnBvd1xuICAgICAqXG4gICAgICogcmV0dXJucyAwIGlmIGFsbCBlbmVyZ2llcyBpbiB4ciBhcmUgemVybywgZWxzZSAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdF94cnBvd19jb3JlKGNvZF9pbmZvLCB4cnBvdywgdXBwZXIsIHN1bSkge1xuICAgICAgICBzdW0gPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSB1cHBlcjsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdG1wID0gTWF0aC5hYnMoY29kX2luZm8ueHJbaV0pO1xuICAgICAgICAgICAgc3VtICs9IHRtcDtcbiAgICAgICAgICAgIHhycG93W2ldID0gTWF0aC5zcXJ0KHRtcCAqIE1hdGguc3FydCh0bXApKTtcblxuICAgICAgICAgICAgaWYgKHhycG93W2ldID4gY29kX2luZm8ueHJwb3dfbWF4KVxuICAgICAgICAgICAgICAgIGNvZF9pbmZvLnhycG93X21heCA9IHhycG93W2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdW07XG4gICAgfVxuXG4gICAgdGhpcy5pbml0X3hycG93ID0gZnVuY3Rpb24gKGdmYywgY29kX2luZm8sIHhycG93KSB7XG4gICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICB2YXIgdXBwZXIgPSAwIHwgY29kX2luZm8ubWF4X25vbnplcm9fY29lZmY7XG5cbiAgICAgICAgYXNzZXJ0KHhycG93ICE9IG51bGwpO1xuICAgICAgICBjb2RfaW5mby54cnBvd19tYXggPSAwO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIGNoZWNrIGlmIHRoZXJlIGlzIHNvbWUgZW5lcmd5IHdlIGhhdmUgdG8gcXVhbnRpemUgYW5kIGNhbGN1bGF0ZSB4cnBvd1xuICAgICAgICAgKiBtYXRjaGluZyBvdXIgZnJlc2ggc2NhbGVmYWN0b3JzXG4gICAgICAgICAqL1xuICAgICAgICBhc3NlcnQoMCA8PSB1cHBlciAmJiB1cHBlciA8PSA1NzUpO1xuXG4gICAgICAgIEFycmF5cy5maWxsKHhycG93LCB1cHBlciwgNTc2LCAwKTtcblxuICAgICAgICBzdW0gPSBpbml0X3hycG93X2NvcmUoY29kX2luZm8sIHhycG93LCB1cHBlciwgc3VtKTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiByZXR1cm4gMSBpZiB3ZSBoYXZlIHNvbWV0aGluZyB0byBxdWFudGl6ZSwgZWxzZSAwXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoc3VtID4gMUUtMjApIHtcbiAgICAgICAgICAgIHZhciBqID0gMDtcbiAgICAgICAgICAgIGlmICgoZ2ZjLnN1YnN0ZXBfc2hhcGluZyAmIDIpICE9IDApXG4gICAgICAgICAgICAgICAgaiA9IDE7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29kX2luZm8ucHN5bWF4OyBpKyspXG4gICAgICAgICAgICAgICAgZ2ZjLnBzZXVkb2hhbGZbaV0gPSBqO1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIEFycmF5cy5maWxsKGNvZF9pbmZvLmwzX2VuYywgMCwgNTc2LCAwKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdhYnJpZWwgQm91dmlnbmUgZmViL2FwciAyMDAzPEJSPlxuICAgICAqIEFuYWxvZyBzaWxlbmNlIGRldGVjdGlvbiBpbiBwYXJ0aXRpb25uZWQgc2ZiMjEgb3Igc2ZiMTIgZm9yIHNob3J0IGJsb2Nrc1xuICAgICAqXG4gICAgICogRnJvbSB0b3AgdG8gYm90dG9tIG9mIHNmYiwgY2hhbmdlcyB0byAwIGNvZWZmcyB3aGljaCBhcmUgYmVsb3cgYXRoLiBJdFxuICAgICAqIHN0b3BzIG9uIHRoZSBmaXJzdCBjb2VmZiBoaWdoZXIgdGhhbiBhdGguXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHNmYjIxX2FuYWxvZ3NpbGVuY2UoZ2ZjLCBjb2RfaW5mbykge1xuICAgICAgICB2YXIgYXRoID0gZ2ZjLkFUSDtcbiAgICAgICAgdmFyIHhyID0gY29kX2luZm8ueHI7XG5cbiAgICAgICAgaWYgKGNvZF9pbmZvLmJsb2NrX3R5cGUgIT0gRW5jb2Rlci5TSE9SVF9UWVBFKSB7XG4gICAgICAgICAgICAvKiBOT1JNLCBTVEFSVCBvciBTVE9QIHR5cGUsIGJ1dCBub3QgU0hPUlQgYmxvY2tzICovXG4gICAgICAgICAgICB2YXIgc3RvcCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgZ3NmYiA9IEVuY29kZXIuUFNGQjIxIC0gMTsgZ3NmYiA+PSAwICYmICFzdG9wOyBnc2ZiLS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBnZmMuc2NhbGVmYWNfYmFuZC5wc2ZiMjFbZ3NmYl07XG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IGdmYy5zY2FsZWZhY19iYW5kLnBzZmIyMVtnc2ZiICsgMV07XG4gICAgICAgICAgICAgICAgdmFyIGF0aDIxID0gcXVwdnQuYXRoQWRqdXN0KGF0aC5hZGp1c3QsIGF0aC5wc2ZiMjFbZ3NmYl0sXG4gICAgICAgICAgICAgICAgICAgIGF0aC5mbG9vcik7XG5cbiAgICAgICAgICAgICAgICBpZiAoZ2ZjLm5zUHN5LmxvbmdmYWN0WzIxXSA+IDFlLTEyKVxuICAgICAgICAgICAgICAgICAgICBhdGgyMSAqPSBnZmMubnNQc3kubG9uZ2ZhY3RbMjFdO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGVuZCAtIDE7IGogPj0gc3RhcnQ7IGotLSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoeHJbal0pIDwgYXRoMjEpXG4gICAgICAgICAgICAgICAgICAgICAgICB4cltqXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8qIG5vdGU6IHNob3J0IGJsb2NrcyBjb2VmZnMgYXJlIHJlb3JkZXJlZCAqL1xuICAgICAgICAgICAgZm9yICh2YXIgYmxvY2sgPSAwOyBibG9jayA8IDM7IGJsb2NrKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RvcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGdzZmIgPSBFbmNvZGVyLlBTRkIxMiAtIDE7IGdzZmIgPj0gMCAmJiAhc3RvcDsgZ3NmYi0tKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IGdmYy5zY2FsZWZhY19iYW5kLnNbMTJdXG4gICAgICAgICAgICAgICAgICAgICAgICAqIDNcbiAgICAgICAgICAgICAgICAgICAgICAgICsgKGdmYy5zY2FsZWZhY19iYW5kLnNbMTNdIC0gZ2ZjLnNjYWxlZmFjX2JhbmQuc1sxMl0pXG4gICAgICAgICAgICAgICAgICAgICAgICAqIGJsb2NrXG4gICAgICAgICAgICAgICAgICAgICAgICArIChnZmMuc2NhbGVmYWNfYmFuZC5wc2ZiMTJbZ3NmYl0gLSBnZmMuc2NhbGVmYWNfYmFuZC5wc2ZiMTJbMF0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kID0gc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICsgKGdmYy5zY2FsZWZhY19iYW5kLnBzZmIxMltnc2ZiICsgMV0gLSBnZmMuc2NhbGVmYWNfYmFuZC5wc2ZiMTJbZ3NmYl0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXRoMTIgPSBxdXB2dC5hdGhBZGp1c3QoYXRoLmFkanVzdCwgYXRoLnBzZmIxMltnc2ZiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0aC5mbG9vcik7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGdmYy5uc1BzeS5zaG9ydGZhY3RbMTJdID4gMWUtMTIpXG4gICAgICAgICAgICAgICAgICAgICAgICBhdGgxMiAqPSBnZmMubnNQc3kuc2hvcnRmYWN0WzEyXTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gZW5kIC0gMTsgaiA+PSBzdGFydDsgai0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoeHJbal0pIDwgYXRoMTIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeHJbal0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHRoaXMuaW5pdF9vdXRlcl9sb29wID0gZnVuY3Rpb24gKGdmYywgY29kX2luZm8pIHtcbiAgICAgICAgLypcbiAgICAgICAgICogaW5pdGlhbGl6ZSBmcmVzaCBjb2RfaW5mb1xuICAgICAgICAgKi9cbiAgICAgICAgY29kX2luZm8ucGFydDJfM19sZW5ndGggPSAwO1xuICAgICAgICBjb2RfaW5mby5iaWdfdmFsdWVzID0gMDtcbiAgICAgICAgY29kX2luZm8uY291bnQxID0gMDtcbiAgICAgICAgY29kX2luZm8uZ2xvYmFsX2dhaW4gPSAyMTA7XG4gICAgICAgIGNvZF9pbmZvLnNjYWxlZmFjX2NvbXByZXNzID0gMDtcbiAgICAgICAgLyogbWl4ZWRfYmxvY2tfZmxhZywgYmxvY2tfdHlwZSB3YXMgc2V0IGluIHBzeW1vZGVsLmMgKi9cbiAgICAgICAgY29kX2luZm8udGFibGVfc2VsZWN0WzBdID0gMDtcbiAgICAgICAgY29kX2luZm8udGFibGVfc2VsZWN0WzFdID0gMDtcbiAgICAgICAgY29kX2luZm8udGFibGVfc2VsZWN0WzJdID0gMDtcbiAgICAgICAgY29kX2luZm8uc3ViYmxvY2tfZ2FpblswXSA9IDA7XG4gICAgICAgIGNvZF9pbmZvLnN1YmJsb2NrX2dhaW5bMV0gPSAwO1xuICAgICAgICBjb2RfaW5mby5zdWJibG9ja19nYWluWzJdID0gMDtcbiAgICAgICAgY29kX2luZm8uc3ViYmxvY2tfZ2FpblszXSA9IDA7XG4gICAgICAgIC8qIHRoaXMgb25lIGlzIGFsd2F5cyAwICovXG4gICAgICAgIGNvZF9pbmZvLnJlZ2lvbjBfY291bnQgPSAwO1xuICAgICAgICBjb2RfaW5mby5yZWdpb24xX2NvdW50ID0gMDtcbiAgICAgICAgY29kX2luZm8ucHJlZmxhZyA9IDA7XG4gICAgICAgIGNvZF9pbmZvLnNjYWxlZmFjX3NjYWxlID0gMDtcbiAgICAgICAgY29kX2luZm8uY291bnQxdGFibGVfc2VsZWN0ID0gMDtcbiAgICAgICAgY29kX2luZm8ucGFydDJfbGVuZ3RoID0gMDtcbiAgICAgICAgY29kX2luZm8uc2ZiX2xtYXggPSBFbmNvZGVyLlNCUFNZX2w7XG4gICAgICAgIGNvZF9pbmZvLnNmYl9zbWluID0gRW5jb2Rlci5TQlBTWV9zO1xuICAgICAgICBjb2RfaW5mby5wc3lfbG1heCA9IGdmYy5zZmIyMV9leHRyYSA/IEVuY29kZXIuU0JNQVhfbCA6IEVuY29kZXIuU0JQU1lfbDtcbiAgICAgICAgY29kX2luZm8ucHN5bWF4ID0gY29kX2luZm8ucHN5X2xtYXg7XG4gICAgICAgIGNvZF9pbmZvLnNmYm1heCA9IGNvZF9pbmZvLnNmYl9sbWF4O1xuICAgICAgICBjb2RfaW5mby5zZmJkaXZpZGUgPSAxMTtcbiAgICAgICAgZm9yICh2YXIgc2ZiID0gMDsgc2ZiIDwgRW5jb2Rlci5TQk1BWF9sOyBzZmIrKykge1xuICAgICAgICAgICAgY29kX2luZm8ud2lkdGhbc2ZiXSA9IGdmYy5zY2FsZWZhY19iYW5kLmxbc2ZiICsgMV1cbiAgICAgICAgICAgICAgICAtIGdmYy5zY2FsZWZhY19iYW5kLmxbc2ZiXTtcbiAgICAgICAgICAgIC8qIHdoaWNoIGlzIGFsd2F5cyAwLiAqL1xuICAgICAgICAgICAgY29kX2luZm8ud2luZG93W3NmYl0gPSAzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RfaW5mby5ibG9ja190eXBlID09IEVuY29kZXIuU0hPUlRfVFlQRSkge1xuICAgICAgICAgICAgdmFyIGl4d29yayA9IG5ld19mbG9hdCg1NzYpO1xuXG4gICAgICAgICAgICBjb2RfaW5mby5zZmJfc21pbiA9IDA7XG4gICAgICAgICAgICBjb2RfaW5mby5zZmJfbG1heCA9IDA7XG4gICAgICAgICAgICBpZiAoY29kX2luZm8ubWl4ZWRfYmxvY2tfZmxhZyAhPSAwKSB7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBNUEVHLTE6IHNmYnMgMC03IGxvbmcgYmxvY2ssIDMtMTIgc2hvcnQgYmxvY2tzIE1QRUctMiguNSk6XG4gICAgICAgICAgICAgICAgICogc2ZicyAwLTUgbG9uZyBibG9jaywgMy0xMiBzaG9ydCBibG9ja3NcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjb2RfaW5mby5zZmJfc21pbiA9IDM7XG4gICAgICAgICAgICAgICAgY29kX2luZm8uc2ZiX2xtYXggPSBnZmMubW9kZV9nciAqIDIgKyA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29kX2luZm8ucHN5bWF4ID0gY29kX2luZm8uc2ZiX2xtYXhcbiAgICAgICAgICAgICAgICArIDNcbiAgICAgICAgICAgICAgICAqICgoZ2ZjLnNmYjIxX2V4dHJhID8gRW5jb2Rlci5TQk1BWF9zIDogRW5jb2Rlci5TQlBTWV9zKSAtIGNvZF9pbmZvLnNmYl9zbWluKTtcbiAgICAgICAgICAgIGNvZF9pbmZvLnNmYm1heCA9IGNvZF9pbmZvLnNmYl9sbWF4ICsgM1xuICAgICAgICAgICAgICAgICogKEVuY29kZXIuU0JQU1lfcyAtIGNvZF9pbmZvLnNmYl9zbWluKTtcbiAgICAgICAgICAgIGNvZF9pbmZvLnNmYmRpdmlkZSA9IGNvZF9pbmZvLnNmYm1heCAtIDE4O1xuICAgICAgICAgICAgY29kX2luZm8ucHN5X2xtYXggPSBjb2RfaW5mby5zZmJfbG1heDtcbiAgICAgICAgICAgIC8qIHJlLW9yZGVyIHRoZSBzaG9ydCBibG9ja3MsIGZvciBtb3JlIGVmZmljaWVudCBlbmNvZGluZyBiZWxvdyAqL1xuICAgICAgICAgICAgLyogQnkgVGFrZWhpcm8gVE9NSU5BR0EgKi9cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBXaXRoaW4gZWFjaCBzY2FsZWZhY3RvciBiYW5kLCBkYXRhIGlzIGdpdmVuIGZvciBzdWNjZXNzaXZlIHRpbWVcbiAgICAgICAgICAgICAqIHdpbmRvd3MsIGJlZ2lubmluZyB3aXRoIHdpbmRvdyAwIGFuZCBlbmRpbmcgd2l0aCB3aW5kb3cgMi4gV2l0aGluXG4gICAgICAgICAgICAgKiBlYWNoIHdpbmRvdywgdGhlIHF1YW50aXplZCB2YWx1ZXMgYXJlIHRoZW4gYXJyYW5nZWQgaW4gb3JkZXIgb2ZcbiAgICAgICAgICAgICAqIGluY3JlYXNpbmcgZnJlcXVlbmN5Li4uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBpeCA9IGdmYy5zY2FsZWZhY19iYW5kLmxbY29kX2luZm8uc2ZiX2xtYXhdO1xuICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weShjb2RfaW5mby54ciwgMCwgaXh3b3JrLCAwLCA1NzYpO1xuICAgICAgICAgICAgZm9yICh2YXIgc2ZiID0gY29kX2luZm8uc2ZiX3NtaW47IHNmYiA8IEVuY29kZXIuU0JNQVhfczsgc2ZiKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBnZmMuc2NhbGVmYWNfYmFuZC5zW3NmYl07XG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IGdmYy5zY2FsZWZhY19iYW5kLnNbc2ZiICsgMV07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgd2luZG93ID0gMDsgd2luZG93IDwgMzsgd2luZG93KyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbCA9IHN0YXJ0OyBsIDwgZW5kOyBsKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZF9pbmZvLnhyW2l4KytdID0gaXh3b3JrWzMgKiBsICsgd2luZG93XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGogPSBjb2RfaW5mby5zZmJfbG1heDtcbiAgICAgICAgICAgIGZvciAodmFyIHNmYiA9IGNvZF9pbmZvLnNmYl9zbWluOyBzZmIgPCBFbmNvZGVyLlNCTUFYX3M7IHNmYisrKSB7XG4gICAgICAgICAgICAgICAgY29kX2luZm8ud2lkdGhbal0gPSBjb2RfaW5mby53aWR0aFtqICsgMV0gPSBjb2RfaW5mby53aWR0aFtqICsgMl0gPSBnZmMuc2NhbGVmYWNfYmFuZC5zW3NmYiArIDFdXG4gICAgICAgICAgICAgICAgICAgIC0gZ2ZjLnNjYWxlZmFjX2JhbmQuc1tzZmJdO1xuICAgICAgICAgICAgICAgIGNvZF9pbmZvLndpbmRvd1tqXSA9IDA7XG4gICAgICAgICAgICAgICAgY29kX2luZm8ud2luZG93W2ogKyAxXSA9IDE7XG4gICAgICAgICAgICAgICAgY29kX2luZm8ud2luZG93W2ogKyAyXSA9IDI7XG4gICAgICAgICAgICAgICAgaiArPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29kX2luZm8uY291bnQxYml0cyA9IDA7XG4gICAgICAgIGNvZF9pbmZvLnNmYl9wYXJ0aXRpb25fdGFibGUgPSBxdXB2dC5ucl9vZl9zZmJfYmxvY2tbMF1bMF07XG4gICAgICAgIGNvZF9pbmZvLnNsZW5bMF0gPSAwO1xuICAgICAgICBjb2RfaW5mby5zbGVuWzFdID0gMDtcbiAgICAgICAgY29kX2luZm8uc2xlblsyXSA9IDA7XG4gICAgICAgIGNvZF9pbmZvLnNsZW5bM10gPSAwO1xuXG4gICAgICAgIGNvZF9pbmZvLm1heF9ub256ZXJvX2NvZWZmID0gNTc1O1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIGZyZXNoIHNjYWxlZmFjdG9ycyBhcmUgYWxsIHplcm9cbiAgICAgICAgICovXG4gICAgICAgIEFycmF5cy5maWxsKGNvZF9pbmZvLnNjYWxlZmFjLCAwKTtcblxuICAgICAgICBwc2ZiMjFfYW5hbG9nc2lsZW5jZShnZmMsIGNvZF9pbmZvKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gQmluU2VhcmNoRGlyZWN0aW9uKG9yZGluYWwpIHtcbiAgICAgICAgdGhpcy5vcmRpbmFsID0gb3JkaW5hbDtcbiAgICB9XG5cbiAgICBCaW5TZWFyY2hEaXJlY3Rpb24uQklOU0VBUkNIX05PTkUgPSBuZXcgQmluU2VhcmNoRGlyZWN0aW9uKDApO1xuICAgIEJpblNlYXJjaERpcmVjdGlvbi5CSU5TRUFSQ0hfVVAgPSBuZXcgQmluU2VhcmNoRGlyZWN0aW9uKDEpO1xuICAgIEJpblNlYXJjaERpcmVjdGlvbi5CSU5TRUFSQ0hfRE9XTiA9IG5ldyBCaW5TZWFyY2hEaXJlY3Rpb24oMik7XG5cbiAgICAvKipcbiAgICAgKiBhdXRob3IvZGF0ZT8/XG4gICAgICpcbiAgICAgKiBiaW5hcnkgc3RlcCBzaXplIHNlYXJjaCB1c2VkIGJ5IG91dGVyX2xvb3AgdG8gZ2V0IGEgcXVhbnRpemVyIHN0ZXAgc2l6ZVxuICAgICAqIHRvIHN0YXJ0IHdpdGhcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5fc2VhcmNoX1N0ZXBTaXplKGdmYywgY29kX2luZm8sIGRlc2lyZWRfcmF0ZSwgY2gsIHhycG93KSB7XG4gICAgICAgIHZhciBuQml0cztcbiAgICAgICAgdmFyIEN1cnJlbnRTdGVwID0gZ2ZjLkN1cnJlbnRTdGVwW2NoXTtcbiAgICAgICAgdmFyIGZsYWdHb25lT3ZlciA9IGZhbHNlO1xuICAgICAgICB2YXIgc3RhcnQgPSBnZmMuT2xkVmFsdWVbY2hdO1xuICAgICAgICB2YXIgRGlyZWN0aW9uID0gQmluU2VhcmNoRGlyZWN0aW9uLkJJTlNFQVJDSF9OT05FO1xuICAgICAgICBjb2RfaW5mby5nbG9iYWxfZ2FpbiA9IHN0YXJ0O1xuICAgICAgICBkZXNpcmVkX3JhdGUgLT0gY29kX2luZm8ucGFydDJfbGVuZ3RoO1xuXG4gICAgICAgIGFzc2VydChDdXJyZW50U3RlcCAhPSAwKTtcbiAgICAgICAgZm9yICg7IDspIHtcbiAgICAgICAgICAgIHZhciBzdGVwO1xuICAgICAgICAgICAgbkJpdHMgPSB0ay5jb3VudF9iaXRzKGdmYywgeHJwb3csIGNvZF9pbmZvLCBudWxsKTtcblxuICAgICAgICAgICAgaWYgKEN1cnJlbnRTdGVwID09IDEgfHwgbkJpdHMgPT0gZGVzaXJlZF9yYXRlKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLyogbm90aGluZyB0byBhZGp1c3QgYW55bW9yZSAqL1xuXG4gICAgICAgICAgICBpZiAobkJpdHMgPiBkZXNpcmVkX3JhdGUpIHtcbiAgICAgICAgICAgICAgICAvKiBpbmNyZWFzZSBRdWFudGl6ZV9TdGVwU2l6ZSAqL1xuICAgICAgICAgICAgICAgIGlmIChEaXJlY3Rpb24gPT0gQmluU2VhcmNoRGlyZWN0aW9uLkJJTlNFQVJDSF9ET1dOKVxuICAgICAgICAgICAgICAgICAgICBmbGFnR29uZU92ZXIgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZsYWdHb25lT3ZlcilcbiAgICAgICAgICAgICAgICAgICAgQ3VycmVudFN0ZXAgLz0gMjtcbiAgICAgICAgICAgICAgICBEaXJlY3Rpb24gPSBCaW5TZWFyY2hEaXJlY3Rpb24uQklOU0VBUkNIX1VQO1xuICAgICAgICAgICAgICAgIHN0ZXAgPSBDdXJyZW50U3RlcDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLyogZGVjcmVhc2UgUXVhbnRpemVfU3RlcFNpemUgKi9cbiAgICAgICAgICAgICAgICBpZiAoRGlyZWN0aW9uID09IEJpblNlYXJjaERpcmVjdGlvbi5CSU5TRUFSQ0hfVVApXG4gICAgICAgICAgICAgICAgICAgIGZsYWdHb25lT3ZlciA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoZmxhZ0dvbmVPdmVyKVxuICAgICAgICAgICAgICAgICAgICBDdXJyZW50U3RlcCAvPSAyO1xuICAgICAgICAgICAgICAgIERpcmVjdGlvbiA9IEJpblNlYXJjaERpcmVjdGlvbi5CSU5TRUFSQ0hfRE9XTjtcbiAgICAgICAgICAgICAgICBzdGVwID0gLUN1cnJlbnRTdGVwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29kX2luZm8uZ2xvYmFsX2dhaW4gKz0gc3RlcDtcbiAgICAgICAgICAgIGlmIChjb2RfaW5mby5nbG9iYWxfZ2FpbiA8IDApIHtcbiAgICAgICAgICAgICAgICBjb2RfaW5mby5nbG9iYWxfZ2FpbiA9IDA7XG4gICAgICAgICAgICAgICAgZmxhZ0dvbmVPdmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2RfaW5mby5nbG9iYWxfZ2FpbiA+IDI1NSkge1xuICAgICAgICAgICAgICAgIGNvZF9pbmZvLmdsb2JhbF9nYWluID0gMjU1O1xuICAgICAgICAgICAgICAgIGZsYWdHb25lT3ZlciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhc3NlcnQoY29kX2luZm8uZ2xvYmFsX2dhaW4gPj0gMCk7XG4gICAgICAgIGFzc2VydChjb2RfaW5mby5nbG9iYWxfZ2FpbiA8IDI1Nik7XG5cbiAgICAgICAgd2hpbGUgKG5CaXRzID4gZGVzaXJlZF9yYXRlICYmIGNvZF9pbmZvLmdsb2JhbF9nYWluIDwgMjU1KSB7XG4gICAgICAgICAgICBjb2RfaW5mby5nbG9iYWxfZ2FpbisrO1xuICAgICAgICAgICAgbkJpdHMgPSB0ay5jb3VudF9iaXRzKGdmYywgeHJwb3csIGNvZF9pbmZvLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBnZmMuQ3VycmVudFN0ZXBbY2hdID0gKHN0YXJ0IC0gY29kX2luZm8uZ2xvYmFsX2dhaW4gPj0gNCkgPyA0IDogMjtcbiAgICAgICAgZ2ZjLk9sZFZhbHVlW2NoXSA9IGNvZF9pbmZvLmdsb2JhbF9nYWluO1xuICAgICAgICBjb2RfaW5mby5wYXJ0Ml8zX2xlbmd0aCA9IG5CaXRzO1xuICAgICAgICByZXR1cm4gbkJpdHM7XG4gICAgfVxuXG4gICAgdGhpcy50cmFuY2F0ZV9zbWFsbHNwZWN0cnVtcyA9IGZ1bmN0aW9uIChnZmMsIGdpLCBsM194bWluLCB3b3JrKSB7XG4gICAgICAgIHZhciBkaXN0b3J0ID0gbmV3X2Zsb2F0KEwzU2lkZS5TRkJNQVgpO1xuXG4gICAgICAgIGlmICgoMCA9PSAoZ2ZjLnN1YnN0ZXBfc2hhcGluZyAmIDQpICYmIGdpLmJsb2NrX3R5cGUgPT0gRW5jb2Rlci5TSE9SVF9UWVBFKVxuICAgICAgICAgICAgfHwgKGdmYy5zdWJzdGVwX3NoYXBpbmcgJiAweDgwKSAhPSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBxdXB2dC5jYWxjX25vaXNlKGdpLCBsM194bWluLCBkaXN0b3J0LCBuZXcgQ2FsY05vaXNlUmVzdWx0KCksIG51bGwpO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDU3NjsgaisrKSB7XG4gICAgICAgICAgICB2YXIgeHIgPSAwLjA7XG4gICAgICAgICAgICBpZiAoZ2kubDNfZW5jW2pdICE9IDApXG4gICAgICAgICAgICAgICAgeHIgPSBNYXRoLmFicyhnaS54cltqXSk7XG4gICAgICAgICAgICB3b3JrW2pdID0geHI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaiA9IDA7XG4gICAgICAgIHZhciBzZmIgPSA4O1xuICAgICAgICBpZiAoZ2kuYmxvY2tfdHlwZSA9PSBFbmNvZGVyLlNIT1JUX1RZUEUpXG4gICAgICAgICAgICBzZmIgPSA2O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICB2YXIgYWxsb3dlZE5vaXNlLCB0cmFuY2F0ZVRocmVzaG9sZDtcbiAgICAgICAgICAgIHZhciBuc2FtZSwgc3RhcnQ7XG5cbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGdpLndpZHRoW3NmYl07XG4gICAgICAgICAgICBqICs9IHdpZHRoO1xuICAgICAgICAgICAgaWYgKGRpc3RvcnRbc2ZiXSA+PSAxLjApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIEFycmF5cy5zb3J0KHdvcmssIGogLSB3aWR0aCwgd2lkdGgpO1xuICAgICAgICAgICAgaWYgKEJpdFN0cmVhbS5FUSh3b3JrW2ogLSAxXSwgMC4wKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIC8qIGFsbCB6ZXJvIHNmYiAqL1xuXG4gICAgICAgICAgICBhbGxvd2VkTm9pc2UgPSAoMS4wIC0gZGlzdG9ydFtzZmJdKSAqIGwzX3htaW5bc2ZiXTtcbiAgICAgICAgICAgIHRyYW5jYXRlVGhyZXNob2xkID0gMC4wO1xuICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHZhciBub2lzZTtcbiAgICAgICAgICAgICAgICBmb3IgKG5zYW1lID0gMTsgc3RhcnQgKyBuc2FtZSA8IHdpZHRoOyBuc2FtZSsrKVxuICAgICAgICAgICAgICAgICAgICBpZiAoQml0U3RyZWFtLk5FUSh3b3JrW3N0YXJ0ICsgaiAtIHdpZHRoXSwgd29ya1tzdGFydCArIGpcbiAgICAgICAgICAgICAgICAgICAgICAgICsgbnNhbWUgLSB3aWR0aF0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBub2lzZSA9IHdvcmtbc3RhcnQgKyBqIC0gd2lkdGhdICogd29ya1tzdGFydCArIGogLSB3aWR0aF1cbiAgICAgICAgICAgICAgICAgICAgKiBuc2FtZTtcbiAgICAgICAgICAgICAgICBpZiAoYWxsb3dlZE5vaXNlIDwgbm9pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0ICE9IDApXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuY2F0ZVRocmVzaG9sZCA9IHdvcmtbc3RhcnQgKyBqIC0gd2lkdGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFsbG93ZWROb2lzZSAtPSBub2lzZTtcbiAgICAgICAgICAgICAgICBzdGFydCArPSBuc2FtZTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHN0YXJ0IDwgd2lkdGgpO1xuICAgICAgICAgICAgaWYgKEJpdFN0cmVhbS5FUSh0cmFuY2F0ZVRocmVzaG9sZCwgMC4wKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhnaS54cltqIC0gd2lkdGhdKSA8PSB0cmFuY2F0ZVRocmVzaG9sZClcbiAgICAgICAgICAgICAgICAgICAgZ2kubDNfZW5jW2ogLSB3aWR0aF0gPSAwO1xuICAgICAgICAgICAgfSB3aGlsZSAoLS13aWR0aCA+IDApO1xuICAgICAgICB9IHdoaWxlICgrK3NmYiA8IGdpLnBzeW1heCk7XG5cbiAgICAgICAgZ2kucGFydDJfM19sZW5ndGggPSB0ay5ub3F1YW50X2NvdW50X2JpdHMoZ2ZjLCBnaSwgbnVsbCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGF1dGhvci9kYXRlPz9cbiAgICAgKlxuICAgICAqIEZ1bmN0aW9uOiBSZXR1cm5zIHplcm8gaWYgdGhlcmUgaXMgYSBzY2FsZWZhYyB3aGljaCBoYXMgbm90IGJlZW5cbiAgICAgKiBhbXBsaWZpZWQuIE90aGVyd2lzZSBpdCByZXR1cm5zIG9uZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb29wX2JyZWFrKGNvZF9pbmZvKSB7XG4gICAgICAgIGZvciAodmFyIHNmYiA9IDA7IHNmYiA8IGNvZF9pbmZvLnNmYm1heDsgc2ZiKyspXG4gICAgICAgICAgICBpZiAoY29kX2luZm8uc2NhbGVmYWNbc2ZiXVxuICAgICAgICAgICAgICAgICsgY29kX2luZm8uc3ViYmxvY2tfZ2Fpbltjb2RfaW5mby53aW5kb3dbc2ZiXV0gPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyogbXQgNS85OTogRnVuY3Rpb246IEltcHJvdmVkIGNhbGNfbm9pc2UgZm9yIGEgc2luZ2xlIGNoYW5uZWwgKi9cblxuICAgIGZ1bmN0aW9uIHBlbmFsdGllcyhub2lzZSkge1xuICAgICAgICByZXR1cm4gVXRpbC5GQVNUX0xPRzEwKCgwLjM2OCArIDAuNjMyICogbm9pc2UgKiBub2lzZSAqIG5vaXNlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYXV0aG9yL2RhdGU/P1xuICAgICAqXG4gICAgICogc2V2ZXJhbCBkaWZmZXJlbnQgY29kZXMgdG8gZGVjaWRlIHdoaWNoIHF1YW50aXphdGlvbiBpcyBiZXR0ZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRfa2xlbW1fbm9pc2UoZGlzdG9ydCwgZ2kpIHtcbiAgICAgICAgdmFyIGtsZW1tX25vaXNlID0gMUUtMzc7XG4gICAgICAgIGZvciAodmFyIHNmYiA9IDA7IHNmYiA8IGdpLnBzeW1heDsgc2ZiKyspXG4gICAgICAgICAgICBrbGVtbV9ub2lzZSArPSBwZW5hbHRpZXMoZGlzdG9ydFtzZmJdKTtcblxuICAgICAgICByZXR1cm4gTWF0aC5tYXgoMWUtMjAsIGtsZW1tX25vaXNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBxdWFudF9jb21wYXJlKHF1YW50X2NvbXAsIGJlc3QsIGNhbGMsIGdpLCBkaXN0b3J0KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBub2lzZSBpcyBnaXZlbiBpbiBkZWNpYmVscyAoZEIpIHJlbGF0aXZlIHRvIG1hc2tpbmcgdGhlc2hvbGRzLjxCUj5cbiAgICAgICAgICpcbiAgICAgICAgICogb3Zlcl9ub2lzZTogPz8/ICh0aGUgcHJldmlvdXMgY29tbWVudCBpcyBmdWxseSB3cm9uZyk8QlI+XG4gICAgICAgICAqIHRvdF9ub2lzZTogPz8/ICh0aGUgcHJldmlvdXMgY29tbWVudCBpcyBmdWxseSB3cm9uZyk8QlI+XG4gICAgICAgICAqIG1heF9ub2lzZTogbWF4IHF1YW50aXphdGlvbiBub2lzZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGJldHRlcjtcblxuICAgICAgICBzd2l0Y2ggKHF1YW50X2NvbXApIHtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKGJlc3Qub3Zlcl9jb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLyogdGhlcmUgYXJlIGRpc3RvcnRlZCBzZmIgKi9cbiAgICAgICAgICAgICAgICAgICAgYmV0dGVyID0gY2FsYy5vdmVyX1NTRCA8PSBiZXN0Lm92ZXJfU1NEO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsYy5vdmVyX1NTRCA9PSBiZXN0Lm92ZXJfU1NEKVxuICAgICAgICAgICAgICAgICAgICAgICAgYmV0dGVyID0gY2FsYy5iaXRzIDwgYmVzdC5iaXRzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIG5vIGRpc3RvcnRlZCBzZmIgKi9cbiAgICAgICAgICAgICAgICAgICAgYmV0dGVyID0gKChjYWxjLm1heF9ub2lzZSA8IDApICYmICgoY2FsYy5tYXhfbm9pc2UgKiAxMCArIGNhbGMuYml0cykgPD0gKGJlc3QubWF4X25vaXNlICogMTAgKyBiZXN0LmJpdHMpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgYmV0dGVyID0gY2FsYy5vdmVyX2NvdW50IDwgYmVzdC5vdmVyX2NvdW50XG4gICAgICAgICAgICAgICAgICAgIHx8IChjYWxjLm92ZXJfY291bnQgPT0gYmVzdC5vdmVyX2NvdW50ICYmIGNhbGMub3Zlcl9ub2lzZSA8IGJlc3Qub3Zlcl9ub2lzZSlcbiAgICAgICAgICAgICAgICAgICAgfHwgKGNhbGMub3Zlcl9jb3VudCA9PSBiZXN0Lm92ZXJfY291bnRcbiAgICAgICAgICAgICAgICAgICAgJiYgQml0U3RyZWFtLkVRKGNhbGMub3Zlcl9ub2lzZSwgYmVzdC5vdmVyX25vaXNlKSAmJiBjYWxjLnRvdF9ub2lzZSA8IGJlc3QudG90X25vaXNlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIGNhbGMubWF4X25vaXNlID0gZ2V0X2tsZW1tX25vaXNlKGRpc3RvcnQsIGdpKTtcbiAgICAgICAgICAgIC8vJEZBTEwtVEhST1VHSCRcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBiZXR0ZXIgPSBjYWxjLm1heF9ub2lzZSA8IGJlc3QubWF4X25vaXNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGJldHRlciA9IGNhbGMudG90X25vaXNlIDwgYmVzdC50b3Rfbm9pc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgYmV0dGVyID0gKGNhbGMudG90X25vaXNlIDwgYmVzdC50b3Rfbm9pc2UpXG4gICAgICAgICAgICAgICAgICAgICYmIChjYWxjLm1heF9ub2lzZSA8IGJlc3QubWF4X25vaXNlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBiZXR0ZXIgPSAoY2FsYy5tYXhfbm9pc2UgPD0gMC4wICYmIGJlc3QubWF4X25vaXNlID4gMC4yKVxuICAgICAgICAgICAgICAgICAgICB8fCAoY2FsYy5tYXhfbm9pc2UgPD0gMC4wICYmIGJlc3QubWF4X25vaXNlIDwgMC4wXG4gICAgICAgICAgICAgICAgICAgICYmIGJlc3QubWF4X25vaXNlID4gY2FsYy5tYXhfbm9pc2UgLSAwLjIgJiYgY2FsYy50b3Rfbm9pc2UgPCBiZXN0LnRvdF9ub2lzZSlcbiAgICAgICAgICAgICAgICAgICAgfHwgKGNhbGMubWF4X25vaXNlIDw9IDAuMCAmJiBiZXN0Lm1heF9ub2lzZSA+IDAuMFxuICAgICAgICAgICAgICAgICAgICAmJiBiZXN0Lm1heF9ub2lzZSA+IGNhbGMubWF4X25vaXNlIC0gMC4yICYmIGNhbGMudG90X25vaXNlIDwgYmVzdC50b3Rfbm9pc2VcbiAgICAgICAgICAgICAgICAgICAgKyBiZXN0Lm92ZXJfbm9pc2UpXG4gICAgICAgICAgICAgICAgICAgIHx8IChjYWxjLm1heF9ub2lzZSA+IDAuMCAmJiBiZXN0Lm1heF9ub2lzZSA+IC0wLjA1XG4gICAgICAgICAgICAgICAgICAgICYmIGJlc3QubWF4X25vaXNlID4gY2FsYy5tYXhfbm9pc2UgLSAwLjEgJiYgY2FsYy50b3Rfbm9pc2VcbiAgICAgICAgICAgICAgICAgICAgKyBjYWxjLm92ZXJfbm9pc2UgPCBiZXN0LnRvdF9ub2lzZVxuICAgICAgICAgICAgICAgICAgICArIGJlc3Qub3Zlcl9ub2lzZSlcbiAgICAgICAgICAgICAgICAgICAgfHwgKGNhbGMubWF4X25vaXNlID4gMC4wICYmIGJlc3QubWF4X25vaXNlID4gLTAuMVxuICAgICAgICAgICAgICAgICAgICAmJiBiZXN0Lm1heF9ub2lzZSA+IGNhbGMubWF4X25vaXNlIC0gMC4xNSAmJiBjYWxjLnRvdF9ub2lzZVxuICAgICAgICAgICAgICAgICAgICArIGNhbGMub3Zlcl9ub2lzZSArIGNhbGMub3Zlcl9ub2lzZSA8IGJlc3QudG90X25vaXNlXG4gICAgICAgICAgICAgICAgICAgICsgYmVzdC5vdmVyX25vaXNlICsgYmVzdC5vdmVyX25vaXNlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBiZXR0ZXIgPSBjYWxjLm92ZXJfbm9pc2UgPCBiZXN0Lm92ZXJfbm9pc2VcbiAgICAgICAgICAgICAgICAgICAgfHwgKEJpdFN0cmVhbS5FUShjYWxjLm92ZXJfbm9pc2UsIGJlc3Qub3Zlcl9ub2lzZSkgJiYgY2FsYy50b3Rfbm9pc2UgPCBiZXN0LnRvdF9ub2lzZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgYmV0dGVyID0gY2FsYy5vdmVyX25vaXNlIDwgYmVzdC5vdmVyX25vaXNlXG4gICAgICAgICAgICAgICAgICAgIHx8IChCaXRTdHJlYW0uRVEoY2FsYy5vdmVyX25vaXNlLCBiZXN0Lm92ZXJfbm9pc2UpICYmIChjYWxjLm1heF9ub2lzZSA8IGJlc3QubWF4X25vaXNlIHx8IChCaXRTdHJlYW1cbiAgICAgICAgICAgICAgICAgICAgICAgIC5FUShjYWxjLm1heF9ub2lzZSwgYmVzdC5tYXhfbm9pc2UpICYmIGNhbGMudG90X25vaXNlIDw9IGJlc3QudG90X25vaXNlKSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIGJldHRlciA9IGNhbGMub3Zlcl9jb3VudCA8IGJlc3Qub3Zlcl9jb3VudFxuICAgICAgICAgICAgICAgICAgICB8fCBjYWxjLm92ZXJfbm9pc2UgPCBiZXN0Lm92ZXJfbm9pc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYmVzdC5vdmVyX2NvdW50ID09IDApIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBJZiBubyBkaXN0b3J0ZWQgYmFuZHMsIG9ubHkgdXNlIHRoaXMgcXVhbnRpemF0aW9uIGlmIGl0IGlzXG4gICAgICAgICAgICAgKiBiZXR0ZXIsIGFuZCBpZiBpdCB1c2VzIGxlc3MgYml0cy4gVW5mb3J0dW5hdGVseSwgcGFydDJfM19sZW5ndGhcbiAgICAgICAgICAgICAqIGlzIHNvbWV0aW1lcyBhIHBvb3IgZXN0aW1hdG9yIG9mIHRoZSBmaW5hbCBzaXplIGF0IGxvdyBiaXRyYXRlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYmV0dGVyID0gYmV0dGVyICYmIGNhbGMuYml0cyA8IGJlc3QuYml0cztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBiZXR0ZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYXV0aG9yL2RhdGU/P1xuICAgICAqXG4gICAgICogPFBSRT5cbiAgICAgKiAgQW1wbGlmeSB0aGUgc2NhbGVmYWN0b3IgYmFuZHMgdGhhdCB2aW9sYXRlIHRoZSBtYXNraW5nIHRocmVzaG9sZC5cbiAgICAgKiAgU2VlIElTTyAxMTE3Mi0zIFNlY3Rpb24gQy4xLjUuNC4zLjVcbiAgICAgKlxuICAgICAqICBkaXN0b3J0W10gPSBub2lzZS9tYXNraW5nXG4gICAgICogIGRpc3RvcnRbXSA+IDEgICA9PT4gbm9pc2UgaXMgbm90IG1hc2tlZFxuICAgICAqICBkaXN0b3J0W10gPCAxICAgPT0+IG5vaXNlIGlzIG1hc2tlZFxuICAgICAqICBtYXhfZGlzdCA9IG1heGltdW0gdmFsdWUgb2YgZGlzdG9ydFtdXG4gICAgICpcbiAgICAgKiAgVGhyZWUgYWxnb3JpdGhtczpcbiAgICAgKiAgbm9pc2Vfc2hhcGluZ19hbXBcbiAgICAgKiAgICAgICAgMCAgICAgICAgICAgICBBbXBsaWZ5IGFsbCBiYW5kcyB3aXRoIGRpc3RvcnRbXT4xLlxuICAgICAqXG4gICAgICogICAgICAgIDEgICAgICAgICAgICAgQW1wbGlmeSBhbGwgYmFuZHMgd2l0aCBkaXN0b3J0W10gPj0gbWF4X2Rpc3ReKC41KTtcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICggNTAlIGluIHRoZSBkYiBzY2FsZSlcbiAgICAgKlxuICAgICAqICAgICAgICAyICAgICAgICAgICAgIEFtcGxpZnkgZmlyc3QgYmFuZCB3aXRoIGRpc3RvcnRbXSA+PSBtYXhfZGlzdDtcbiAgICAgKlxuICAgICAqXG4gICAgICogIEZvciBhbGdvcml0aG1zIDAgYW5kIDEsIGlmIG1heF9kaXN0IDwgMSwgdGhlbiBhbXBsaWZ5IGFsbCBiYW5kc1xuICAgICAqICB3aXRoIGRpc3RvcnRbXSA+PSAuOTUqbWF4X2Rpc3QuICBUaGlzIGlzIHRvIG1ha2Ugc3VyZSB3ZSBhbHdheXNcbiAgICAgKiAgYW1wbGlmeSBhdCBsZWFzdCBvbmUgYmFuZC5cbiAgICAgKiA8L1BSRT5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhbXBfc2NhbGVmYWNfYmFuZHMoZ2ZwLCBjb2RfaW5mbywgZGlzdG9ydCwgeHJwb3csIGJSZWZpbmUpIHtcbiAgICAgICAgdmFyIGdmYyA9IGdmcC5pbnRlcm5hbF9mbGFncztcbiAgICAgICAgdmFyIGlmcXN0ZXAzNDtcblxuICAgICAgICBpZiAoY29kX2luZm8uc2NhbGVmYWNfc2NhbGUgPT0gMCkge1xuICAgICAgICAgICAgaWZxc3RlcDM0ID0gMS4yOTY4Mzk1NTQ2NTEwMDk2NDA1NTtcbiAgICAgICAgICAgIC8qIDIqKiguNzUqLjUpICovXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZnFzdGVwMzQgPSAxLjY4MTc5MjgzMDUwNzQyOTIyNjEyO1xuICAgICAgICAgICAgLyogMioqKC43NSoxKSAqL1xuICAgICAgICB9XG5cbiAgICAgICAgLyogY29tcHV0ZSBtYXhpbXVtIHZhbHVlIG9mIGRpc3RvcnRbXSAqL1xuICAgICAgICB2YXIgdHJpZ2dlciA9IDA7XG4gICAgICAgIGZvciAodmFyIHNmYiA9IDA7IHNmYiA8IGNvZF9pbmZvLnNmYm1heDsgc2ZiKyspIHtcbiAgICAgICAgICAgIGlmICh0cmlnZ2VyIDwgZGlzdG9ydFtzZmJdKVxuICAgICAgICAgICAgICAgIHRyaWdnZXIgPSBkaXN0b3J0W3NmYl07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbm9pc2Vfc2hhcGluZ19hbXAgPSBnZmMubm9pc2Vfc2hhcGluZ19hbXA7XG4gICAgICAgIGlmIChub2lzZV9zaGFwaW5nX2FtcCA9PSAzKSB7XG4gICAgICAgICAgICBpZiAoYlJlZmluZSlcbiAgICAgICAgICAgICAgICBub2lzZV9zaGFwaW5nX2FtcCA9IDI7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbm9pc2Vfc2hhcGluZ19hbXAgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAobm9pc2Vfc2hhcGluZ19hbXApIHtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAvKiBhbXBsaWZ5IGV4YWN0bHkgMSBiYW5kICovXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAvKiBhbXBsaWZ5IGJhbmRzIHdpdGhpbiA1MCUgb2YgbWF4IChvbiBkYiBzY2FsZSkgKi9cbiAgICAgICAgICAgICAgICBpZiAodHJpZ2dlciA+IDEuMClcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlciA9IE1hdGgucG93KHRyaWdnZXIsIC41KTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXIgKj0gLjk1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8qIElTTyBhbGdvcml0aG0uIGFtcGxpZnkgYWxsIGJhbmRzIHdpdGggZGlzdG9ydD4xICovXG4gICAgICAgICAgICAgICAgaWYgKHRyaWdnZXIgPiAxLjApXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXIgPSAxLjA7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyICo9IC45NTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBqID0gMDtcbiAgICAgICAgZm9yICh2YXIgc2ZiID0gMDsgc2ZiIDwgY29kX2luZm8uc2ZibWF4OyBzZmIrKykge1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gY29kX2luZm8ud2lkdGhbc2ZiXTtcbiAgICAgICAgICAgIHZhciBsO1xuICAgICAgICAgICAgaiArPSB3aWR0aDtcbiAgICAgICAgICAgIGlmIChkaXN0b3J0W3NmYl0gPCB0cmlnZ2VyKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBpZiAoKGdmYy5zdWJzdGVwX3NoYXBpbmcgJiAyKSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgZ2ZjLnBzZXVkb2hhbGZbc2ZiXSA9ICgwID09IGdmYy5wc2V1ZG9oYWxmW3NmYl0pID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgaWYgKDAgPT0gZ2ZjLnBzZXVkb2hhbGZbc2ZiXSAmJiBnZmMubm9pc2Vfc2hhcGluZ19hbXAgPT0gMilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29kX2luZm8uc2NhbGVmYWNbc2ZiXSsrO1xuICAgICAgICAgICAgZm9yIChsID0gLXdpZHRoOyBsIDwgMDsgbCsrKSB7XG4gICAgICAgICAgICAgICAgeHJwb3dbaiArIGxdICo9IGlmcXN0ZXAzNDtcbiAgICAgICAgICAgICAgICBpZiAoeHJwb3dbaiArIGxdID4gY29kX2luZm8ueHJwb3dfbWF4KVxuICAgICAgICAgICAgICAgICAgICBjb2RfaW5mby54cnBvd19tYXggPSB4cnBvd1tqICsgbF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChnZmMubm9pc2Vfc2hhcGluZ19hbXAgPT0gMilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUYWtlaGlybyBUb21pbmFnYSAyMDAwLXh4LXh4XG4gICAgICpcbiAgICAgKiB0dXJucyBvbiBzY2FsZWZhYyBzY2FsZSBhbmQgYWRqdXN0cyBzY2FsZWZhY3RvcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmNfc2NhbGVmYWNfc2NhbGUoY29kX2luZm8sIHhycG93KSB7XG4gICAgICAgIHZhciBpZnFzdGVwMzQgPSAxLjI5NjgzOTU1NDY1MTAwOTY0MDU1O1xuXG4gICAgICAgIHZhciBqID0gMDtcbiAgICAgICAgZm9yICh2YXIgc2ZiID0gMDsgc2ZiIDwgY29kX2luZm8uc2ZibWF4OyBzZmIrKykge1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gY29kX2luZm8ud2lkdGhbc2ZiXTtcbiAgICAgICAgICAgIHZhciBzID0gY29kX2luZm8uc2NhbGVmYWNbc2ZiXTtcbiAgICAgICAgICAgIGlmIChjb2RfaW5mby5wcmVmbGFnICE9IDApXG4gICAgICAgICAgICAgICAgcyArPSBxdXB2dC5wcmV0YWJbc2ZiXTtcbiAgICAgICAgICAgIGogKz0gd2lkdGg7XG4gICAgICAgICAgICBpZiAoKHMgJiAxKSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgcysrO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSAtd2lkdGg7IGwgPCAwOyBsKyspIHtcbiAgICAgICAgICAgICAgICAgICAgeHJwb3dbaiArIGxdICo9IGlmcXN0ZXAzNDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhycG93W2ogKyBsXSA+IGNvZF9pbmZvLnhycG93X21heClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZF9pbmZvLnhycG93X21heCA9IHhycG93W2ogKyBsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2RfaW5mby5zY2FsZWZhY1tzZmJdID0gcyA+PiAxO1xuICAgICAgICB9XG4gICAgICAgIGNvZF9pbmZvLnByZWZsYWcgPSAwO1xuICAgICAgICBjb2RfaW5mby5zY2FsZWZhY19zY2FsZSA9IDE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGFrZWhpcm8gVG9taW5hZ2EgMjAwMC14eC14eFxuICAgICAqXG4gICAgICogaW5jcmVhc2VzIHRoZSBzdWJibG9jayBnYWluIGFuZCBhZGp1c3RzIHNjYWxlZmFjdG9yc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluY19zdWJibG9ja19nYWluKGdmYywgY29kX2luZm8sIHhycG93KSB7XG4gICAgICAgIHZhciBzZmI7XG4gICAgICAgIHZhciBzY2FsZWZhYyA9IGNvZF9pbmZvLnNjYWxlZmFjO1xuXG4gICAgICAgIC8qIHN1YmJsb2NfZ2FpbiBjYW4ndCBkbyBhbnl0aGluZyBpbiB0aGUgbG9uZyBibG9jayByZWdpb24gKi9cbiAgICAgICAgZm9yIChzZmIgPSAwOyBzZmIgPCBjb2RfaW5mby5zZmJfbG1heDsgc2ZiKyspIHtcbiAgICAgICAgICAgIGlmIChzY2FsZWZhY1tzZmJdID49IDE2KVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgd2luZG93ID0gMDsgd2luZG93IDwgMzsgd2luZG93KyspIHtcbiAgICAgICAgICAgIHZhciBzMSA9IDA7XG4gICAgICAgICAgICB2YXIgczIgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKHNmYiA9IGNvZF9pbmZvLnNmYl9sbWF4ICsgd2luZG93OyBzZmIgPCBjb2RfaW5mby5zZmJkaXZpZGU7IHNmYiArPSAzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHMxIDwgc2NhbGVmYWNbc2ZiXSlcbiAgICAgICAgICAgICAgICAgICAgczEgPSBzY2FsZWZhY1tzZmJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICg7IHNmYiA8IGNvZF9pbmZvLnNmYm1heDsgc2ZiICs9IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAoczIgPCBzY2FsZWZhY1tzZmJdKVxuICAgICAgICAgICAgICAgICAgICBzMiA9IHNjYWxlZmFjW3NmYl07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzMSA8IDE2ICYmIHMyIDwgOClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgaWYgKGNvZF9pbmZvLnN1YmJsb2NrX2dhaW5bd2luZG93XSA+PSA3KVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogZXZlbiB0aG91Z2ggdGhlcmUgaXMgbm8gc2NhbGVmYWN0b3IgZm9yIHNmYjEyIHN1YmJsb2NrIGdhaW5cbiAgICAgICAgICAgICAqIGFmZmVjdHMgdXBwZXIgZnJlcXVlbmNpZXMgdG9vLCB0aGF0J3Mgd2h5IHdlIGhhdmUgdG8gZ28gdXAgdG9cbiAgICAgICAgICAgICAqIFNCTUFYX3NcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29kX2luZm8uc3ViYmxvY2tfZ2Fpblt3aW5kb3ddKys7XG4gICAgICAgICAgICB2YXIgaiA9IGdmYy5zY2FsZWZhY19iYW5kLmxbY29kX2luZm8uc2ZiX2xtYXhdO1xuICAgICAgICAgICAgZm9yIChzZmIgPSBjb2RfaW5mby5zZmJfbG1heCArIHdpbmRvdzsgc2ZiIDwgY29kX2luZm8uc2ZibWF4OyBzZmIgKz0gMykge1xuICAgICAgICAgICAgICAgIHZhciBhbXA7XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gY29kX2luZm8ud2lkdGhbc2ZiXTtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IHNjYWxlZmFjW3NmYl07XG4gICAgICAgICAgICAgICAgYXNzZXJ0KHMgPj0gMCk7XG4gICAgICAgICAgICAgICAgcyA9IHMgLSAoNCA+PiBjb2RfaW5mby5zY2FsZWZhY19zY2FsZSk7XG4gICAgICAgICAgICAgICAgaWYgKHMgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzY2FsZWZhY1tzZmJdID0gcztcbiAgICAgICAgICAgICAgICAgICAgaiArPSB3aWR0aCAqIDM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNjYWxlZmFjW3NmYl0gPSAwO1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdhaW4gPSAyMTAgKyAocyA8PCAoY29kX2luZm8uc2NhbGVmYWNfc2NhbGUgKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgIGFtcCA9IHF1cHZ0LklQT1cyMChnYWluKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaiArPSB3aWR0aCAqICh3aW5kb3cgKyAxKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBsID0gLXdpZHRoOyBsIDwgMDsgbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHhycG93W2ogKyBsXSAqPSBhbXA7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4cnBvd1tqICsgbF0gPiBjb2RfaW5mby54cnBvd19tYXgpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RfaW5mby54cnBvd19tYXggPSB4cnBvd1tqICsgbF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGogKz0gd2lkdGggKiAoMyAtIHdpbmRvdyAtIDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIGFtcCA9IHF1cHZ0LklQT1cyMCgyMDIpO1xuICAgICAgICAgICAgICAgIGogKz0gY29kX2luZm8ud2lkdGhbc2ZiXSAqICh3aW5kb3cgKyAxKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBsID0gLWNvZF9pbmZvLndpZHRoW3NmYl07IGwgPCAwOyBsKyspIHtcbiAgICAgICAgICAgICAgICAgICAgeHJwb3dbaiArIGxdICo9IGFtcDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhycG93W2ogKyBsXSA+IGNvZF9pbmZvLnhycG93X21heClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZF9pbmZvLnhycG93X21heCA9IHhycG93W2ogKyBsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIDxQUkU+XG4gICAgICogIFRha2VoaXJvIFRvbWluYWdhIC9kYXRlPz9cbiAgICAgKiAgUm9iZXJ0IEhlZ2VtYW5uIDIwMDAtMDktMDY6IG1hZGUgYSBmdW5jdGlvbiBvZiBpdFxuICAgICAqXG4gICAgICogIGFtcGxpZmllcyBzY2FsZWZhY3RvciBiYW5kcyxcbiAgICAgKiAgIC0gaWYgYWxsIGFyZSBhbHJlYWR5IGFtcGxpZmllZCByZXR1cm5zIDBcbiAgICAgKiAgIC0gaWYgc29tZSBiYW5kcyBhcmUgYW1wbGlmaWVkIHRvbyBtdWNoOlxuICAgICAqICAgICAgKiB0cnkgdG8gaW5jcmVhc2Ugc2NhbGVmYWNfc2NhbGVcbiAgICAgKiAgICAgICogaWYgYWxyZWFkeSBzY2FsZWZhY19zY2FsZSB3YXMgc2V0XG4gICAgICogICAgICAgICAgdHJ5IG9uIHNob3J0IGJsb2NrcyB0byBpbmNyZWFzZSBzdWJibG9jayBnYWluXG4gICAgICogPC9QUkU+XG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFsYW5jZV9ub2lzZShnZnAsIGNvZF9pbmZvLCBkaXN0b3J0LCB4cnBvdywgYlJlZmluZSkge1xuICAgICAgICB2YXIgZ2ZjID0gZ2ZwLmludGVybmFsX2ZsYWdzO1xuXG4gICAgICAgIGFtcF9zY2FsZWZhY19iYW5kcyhnZnAsIGNvZF9pbmZvLCBkaXN0b3J0LCB4cnBvdywgYlJlZmluZSk7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogY2hlY2sgdG8gbWFrZSBzdXJlIHdlIGhhdmUgbm90IGFtcGxpZmllZCB0b28gbXVjaCBsb29wX2JyZWFrIHJldHVybnNcbiAgICAgICAgICogMCBpZiB0aGVyZSBpcyBhbiB1bmFtcGxpZmllZCBzY2FsZWZhYyBzY2FsZV9iaXRjb3VudCByZXR1cm5zIDAgaWYgbm9cbiAgICAgICAgICogc2NhbGVmYWN0b3JzIGFyZSB0b28gbGFyZ2VcbiAgICAgICAgICovXG5cbiAgICAgICAgdmFyIHN0YXR1cyA9IGxvb3BfYnJlYWsoY29kX2luZm8pO1xuXG4gICAgICAgIGlmIChzdGF0dXMpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8qIGFsbCBiYW5kcyBhbXBsaWZpZWQgKi9cblxuICAgICAgICAvKlxuICAgICAgICAgKiBub3QgYWxsIHNjYWxlZmFjdG9ycyBoYXZlIGJlZW4gYW1wbGlmaWVkLiBzbyB0aGVzZSBzY2FsZWZhY3MgYXJlXG4gICAgICAgICAqIHBvc3NpYmx5IHZhbGlkLiBlbmNvZGUgdGhlbTpcbiAgICAgICAgICovXG4gICAgICAgIGlmIChnZmMubW9kZV9nciA9PSAyKVxuICAgICAgICAgICAgc3RhdHVzID0gdGsuc2NhbGVfYml0Y291bnQoY29kX2luZm8pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBzdGF0dXMgPSB0ay5zY2FsZV9iaXRjb3VudF9sc2YoZ2ZjLCBjb2RfaW5mbyk7XG5cbiAgICAgICAgaWYgKCFzdGF0dXMpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLyogYW1wbGlmaWVkIHNvbWUgYmFuZHMgbm90IGV4Y2VlZGluZyBsaW1pdHMgKi9cblxuICAgICAgICAvKlxuICAgICAgICAgKiBzb21lIHNjYWxlZmFjdG9ycyBhcmUgdG9vIGxhcmdlLiBsZXRzIHRyeSBzZXR0aW5nIHNjYWxlZmFjX3NjYWxlPTFcbiAgICAgICAgICovXG4gICAgICAgIGlmIChnZmMubm9pc2Vfc2hhcGluZyA+IDEpIHtcbiAgICAgICAgICAgIEFycmF5cy5maWxsKGdmYy5wc2V1ZG9oYWxmLCAwKTtcbiAgICAgICAgICAgIGlmICgwID09IGNvZF9pbmZvLnNjYWxlZmFjX3NjYWxlKSB7XG4gICAgICAgICAgICAgICAgaW5jX3NjYWxlZmFjX3NjYWxlKGNvZF9pbmZvLCB4cnBvdyk7XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb2RfaW5mby5ibG9ja190eXBlID09IEVuY29kZXIuU0hPUlRfVFlQRVxuICAgICAgICAgICAgICAgICAgICAmJiBnZmMuc3ViYmxvY2tfZ2FpbiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gKGluY19zdWJibG9ja19nYWluKGdmYywgY29kX2luZm8sIHhycG93KSB8fCBsb29wX2JyZWFrKGNvZF9pbmZvKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzdGF0dXMpIHtcbiAgICAgICAgICAgIGlmIChnZmMubW9kZV9nciA9PSAyKVxuICAgICAgICAgICAgICAgIHN0YXR1cyA9IHRrLnNjYWxlX2JpdGNvdW50KGNvZF9pbmZvKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSB0ay5zY2FsZV9iaXRjb3VudF9sc2YoZ2ZjLCBjb2RfaW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFzdGF0dXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogPFBSRT5cbiAgICAgKiAgRnVuY3Rpb246IFRoZSBvdXRlciBpdGVyYXRpb24gbG9vcCBjb250cm9scyB0aGUgbWFza2luZyBjb25kaXRpb25zXG4gICAgICogIG9mIGFsbCBzY2FsZWZhY3RvcmJhbmRzLiBJdCBjb21wdXRlcyB0aGUgYmVzdCBzY2FsZWZhYyBhbmRcbiAgICAgKiAgZ2xvYmFsIGdhaW4uIFRoaXMgbW9kdWxlIGNhbGxzIHRoZSBpbm5lciBpdGVyYXRpb24gbG9vcFxuICAgICAqXG4gICAgICogIG10IDUvOTkgY29tcGxldGVseSByZXdyaXR0ZW4gdG8gYWxsb3cgZm9yIGJpdCByZXNlcnZvaXIgY29udHJvbCxcbiAgICAgKiAgbWlkL3NpZGUgY2hhbm5lbHMgd2l0aCBML1Igb3IgbWlkL3NpZGUgbWFza2luZyB0aHJlc2hvbGRzLFxuICAgICAqICBhbmQgY2hvb3NlcyBiZXN0IHF1YW50aXphdGlvbiBpbnN0ZWFkIG9mIGxhc3QgcXVhbnRpemF0aW9uIHdoZW5cbiAgICAgKiAgbm8gZGlzdG9ydGlvbiBmcmVlIHF1YW50aXphdGlvbiBjYW4gYmUgZm91bmQuXG4gICAgICpcbiAgICAgKiAgYWRkZWQgVkJSIHN1cHBvcnQgbXQgNS85OVxuICAgICAqXG4gICAgICogIHNvbWUgY29kZSBzaHVmZmxlIHJoIDkvMDBcbiAgICAgKiA8L1BSRT5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsM194bWluXG4gICAgICogICAgICAgICAgICBhbGxvd2VkIGRpc3RvcnRpb25cbiAgICAgKiBAcGFyYW0geHJwb3dcbiAgICAgKiAgICAgICAgICAgIGNvbG91cmVkIG1hZ25pdHVkZXMgb2Ygc3BlY3RyYWxcbiAgICAgKiBAcGFyYW0gdGFyZ19iaXRzXG4gICAgICogICAgICAgICAgICBtYXhpbXVtIGFsbG93ZWQgYml0c1xuICAgICAqL1xuICAgIHRoaXMub3V0ZXJfbG9vcCA9IGZ1bmN0aW9uIChnZnAsIGNvZF9pbmZvLCBsM194bWluLCB4cnBvdywgY2gsIHRhcmdfYml0cykge1xuICAgICAgICB2YXIgZ2ZjID0gZ2ZwLmludGVybmFsX2ZsYWdzO1xuICAgICAgICB2YXIgY29kX2luZm9fdyA9IG5ldyBHckluZm8oKTtcbiAgICAgICAgdmFyIHNhdmVfeHJwb3cgPSBuZXdfZmxvYXQoNTc2KTtcbiAgICAgICAgdmFyIGRpc3RvcnQgPSBuZXdfZmxvYXQoTDNTaWRlLlNGQk1BWCk7XG4gICAgICAgIHZhciBiZXN0X25vaXNlX2luZm8gPSBuZXcgQ2FsY05vaXNlUmVzdWx0KCk7XG4gICAgICAgIHZhciBiZXR0ZXI7XG4gICAgICAgIHZhciBwcmV2X25vaXNlID0gbmV3IENhbGNOb2lzZURhdGEoKTtcbiAgICAgICAgdmFyIGJlc3RfcGFydDJfM19sZW5ndGggPSA5OTk5OTk5O1xuICAgICAgICB2YXIgYkVuZE9mU2VhcmNoID0gZmFsc2U7XG4gICAgICAgIHZhciBiUmVmaW5lID0gZmFsc2U7XG4gICAgICAgIHZhciBiZXN0X2dnYWluX3Bhc3MxID0gMDtcblxuICAgICAgICBiaW5fc2VhcmNoX1N0ZXBTaXplKGdmYywgY29kX2luZm8sIHRhcmdfYml0cywgY2gsIHhycG93KTtcblxuICAgICAgICBpZiAoMCA9PSBnZmMubm9pc2Vfc2hhcGluZylcbiAgICAgICAgLyogZmFzdCBtb2RlLCBubyBub2lzZSBzaGFwaW5nLCB3ZSBhcmUgcmVhZHkgKi9cbiAgICAgICAgICAgIHJldHVybiAxMDA7XG4gICAgICAgIC8qIGRlZmF1bHQgbm9pc2VfaW5mby5vdmVyX2NvdW50ICovXG5cbiAgICAgICAgLyogY29tcHV0ZSB0aGUgZGlzdG9ydGlvbiBpbiB0aGlzIHF1YW50aXphdGlvbiAqL1xuICAgICAgICAvKiBjb2VmZmljaWVudHMgYW5kIHRocmVzaG9sZHMgYm90aCBsL3IgKG9yIGJvdGggbWlkL3NpZGUpICovXG4gICAgICAgIHF1cHZ0LmNhbGNfbm9pc2UoY29kX2luZm8sIGwzX3htaW4sIGRpc3RvcnQsIGJlc3Rfbm9pc2VfaW5mbyxcbiAgICAgICAgICAgIHByZXZfbm9pc2UpO1xuICAgICAgICBiZXN0X25vaXNlX2luZm8uYml0cyA9IGNvZF9pbmZvLnBhcnQyXzNfbGVuZ3RoO1xuXG4gICAgICAgIGNvZF9pbmZvX3cuYXNzaWduKGNvZF9pbmZvKTtcbiAgICAgICAgdmFyIGFnZSA9IDA7XG4gICAgICAgIFN5c3RlbS5hcnJheWNvcHkoeHJwb3csIDAsIHNhdmVfeHJwb3csIDAsIDU3Nik7XG5cbiAgICAgICAgd2hpbGUgKCFiRW5kT2ZTZWFyY2gpIHtcbiAgICAgICAgICAgIC8qIEJFR0lOIE1BSU4gTE9PUCAqL1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHZhciBub2lzZV9pbmZvID0gbmV3IENhbGNOb2lzZVJlc3VsdCgpO1xuICAgICAgICAgICAgICAgIHZhciBzZWFyY2hfbGltaXQ7XG4gICAgICAgICAgICAgICAgdmFyIG1heGdnYWluID0gMjU1O1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBXaGVuIHF1YW50aXphdGlvbiB3aXRoIG5vIGRpc3RvcnRlZCBiYW5kcyBpcyBmb3VuZCwgYWxsb3cgdXBcbiAgICAgICAgICAgICAgICAgKiB0byBYIG5ldyB1bnN1Y2Nlc2Z1bCB0cmllcyBpbiBzZXJpYWwuIFRoaXMgZ2l2ZXMgdXMgbW9yZVxuICAgICAgICAgICAgICAgICAqIHBvc3NpYmlsaXRpZXMgZm9yIGRpZmZlcmVudCBxdWFudF9jb21wYXJlIG1vZGVzLiBNdWNoIG1vcmVcbiAgICAgICAgICAgICAgICAgKiB0aGFuIDMgbWFrZXMgbm90IGEgYmlnIGRpZmZlcmVuY2UsIGl0IGlzIG9ubHkgc2xvd2VyLlxuICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgaWYgKChnZmMuc3Vic3RlcF9zaGFwaW5nICYgMikgIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzZWFyY2hfbGltaXQgPSAyMDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWFyY2hfbGltaXQgPSAzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogQ2hlY2sgaWYgdGhlIGxhc3Qgc2NhbGVmYWN0b3IgYmFuZCBpcyBkaXN0b3J0ZWQuIGluIFZCUiBtb2RlXG4gICAgICAgICAgICAgICAgICogd2UgY2FuJ3QgZ2V0IHJpZCBvZiB0aGUgZGlzdG9ydGlvbiwgc28gcXVpdCBub3cgYW5kIFZCUiBtb2RlXG4gICAgICAgICAgICAgICAgICogd2lsbCB0cnkgYWdhaW4gd2l0aCBtb3JlIGJpdHMuIChtYWtlcyBhIDEwJSBzcGVlZCBpbmNyZWFzZSxcbiAgICAgICAgICAgICAgICAgKiB0aGUgZmlsZXMgSSB0ZXN0ZWQgd2VyZSBiaW5hcnkgaWRlbnRpY2FsLCAyMDAwLzA1LzIwIFJvYmVydFxuICAgICAgICAgICAgICAgICAqIEhlZ2VtYW5uKSBkaXN0b3J0W10gPiAxIG1lYW5zIG5vaXNlID4gYWxsb3dlZCBub2lzZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmIChnZmMuc2ZiMjFfZXh0cmEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3RvcnRbY29kX2luZm9fdy5zZmJtYXhdID4gMS4wKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RfaW5mb193LmJsb2NrX3R5cGUgPT0gRW5jb2Rlci5TSE9SVF9UWVBFXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiAoZGlzdG9ydFtjb2RfaW5mb193LnNmYm1heCArIDFdID4gMS4wIHx8IGRpc3RvcnRbY29kX2luZm9fdy5zZmJtYXggKyAyXSA+IDEuMCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvKiB0cnkgYSBuZXcgc2NhbGVmYWN0b3IgY29uYmluYXRpb24gb24gY29kX2luZm9fdyAqL1xuICAgICAgICAgICAgICAgIGlmICghYmFsYW5jZV9ub2lzZShnZnAsIGNvZF9pbmZvX3csIGRpc3RvcnQsIHhycG93LCBiUmVmaW5lKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKGNvZF9pbmZvX3cuc2NhbGVmYWNfc2NhbGUgIT0gMClcbiAgICAgICAgICAgICAgICAgICAgbWF4Z2dhaW4gPSAyNTQ7XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIGlubmVyX2xvb3Agc3RhcnRzIHdpdGggdGhlIGluaXRpYWwgcXVhbnRpemF0aW9uIHN0ZXAgY29tcHV0ZWRcbiAgICAgICAgICAgICAgICAgKiBhYm92ZSBhbmQgc2xvd2x5IGluY3JlYXNlcyB1bnRpbCB0aGUgYml0cyA8IGh1ZmZfYml0cy4gVGh1c1xuICAgICAgICAgICAgICAgICAqIGl0IGlzIGltcG9ydGFudCBub3QgdG8gc3RhcnQgd2l0aCB0b28gbGFyZ2Ugb2YgYW4gaW5pdGFsXG4gICAgICAgICAgICAgICAgICogcXVhbnRpemF0aW9uIHN0ZXAuIFRvbyBzbWFsbCBpcyBvaywgYnV0IGlubmVyX2xvb3Agd2lsbCB0YWtlXG4gICAgICAgICAgICAgICAgICogbG9uZ2VyXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIGh1ZmZfYml0cyA9IHRhcmdfYml0cyAtIGNvZF9pbmZvX3cucGFydDJfbGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChodWZmX2JpdHMgPD0gMClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIGluY3JlYXNlIHF1YW50aXplciBzdGVwc2l6ZSB1bnRpbCBuZWVkZWQgYml0cyBhcmUgYmVsb3dcbiAgICAgICAgICAgICAgICAgKiBtYXhpbXVtXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgd2hpbGUgKChjb2RfaW5mb193LnBhcnQyXzNfbGVuZ3RoID0gdGsuY291bnRfYml0cyhnZmMsIHhycG93LFxuICAgICAgICAgICAgICAgICAgICBjb2RfaW5mb193LCBwcmV2X25vaXNlKSkgPiBodWZmX2JpdHNcbiAgICAgICAgICAgICAgICAmJiBjb2RfaW5mb193Lmdsb2JhbF9nYWluIDw9IG1heGdnYWluKVxuICAgICAgICAgICAgICAgICAgICBjb2RfaW5mb193Lmdsb2JhbF9nYWluKys7XG5cbiAgICAgICAgICAgICAgICBpZiAoY29kX2luZm9fdy5nbG9iYWxfZ2FpbiA+IG1heGdnYWluKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGlmIChiZXN0X25vaXNlX2luZm8ub3Zlcl9jb3VudCA9PSAwKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChjb2RfaW5mb193LnBhcnQyXzNfbGVuZ3RoID0gdGsuY291bnRfYml0cyhnZmMsXG4gICAgICAgICAgICAgICAgICAgICAgICB4cnBvdywgY29kX2luZm9fdywgcHJldl9ub2lzZSkpID4gYmVzdF9wYXJ0Ml8zX2xlbmd0aFxuICAgICAgICAgICAgICAgICAgICAmJiBjb2RfaW5mb193Lmdsb2JhbF9nYWluIDw9IG1heGdnYWluKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29kX2luZm9fdy5nbG9iYWxfZ2FpbisrO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RfaW5mb193Lmdsb2JhbF9nYWluID4gbWF4Z2dhaW4pXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvKiBjb21wdXRlIHRoZSBkaXN0b3J0aW9uIGluIHRoaXMgcXVhbnRpemF0aW9uICovXG4gICAgICAgICAgICAgICAgcXVwdnQuY2FsY19ub2lzZShjb2RfaW5mb193LCBsM194bWluLCBkaXN0b3J0LCBub2lzZV9pbmZvLFxuICAgICAgICAgICAgICAgICAgICBwcmV2X25vaXNlKTtcbiAgICAgICAgICAgICAgICBub2lzZV9pbmZvLmJpdHMgPSBjb2RfaW5mb193LnBhcnQyXzNfbGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBjaGVjayBpZiB0aGlzIHF1YW50aXphdGlvbiBpcyBiZXR0ZXIgdGhhbiBvdXIgc2F2ZWRcbiAgICAgICAgICAgICAgICAgKiBxdWFudGl6YXRpb25cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoY29kX2luZm8uYmxvY2tfdHlwZSAhPSBFbmNvZGVyLlNIT1JUX1RZUEUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTk9STSwgU1RBUlQgb3IgU1RPUCB0eXBlXG4gICAgICAgICAgICAgICAgICAgIGJldHRlciA9IGdmcC5xdWFudF9jb21wO1xuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICBiZXR0ZXIgPSBnZnAucXVhbnRfY29tcF9zaG9ydDtcblxuICAgICAgICAgICAgICAgIGJldHRlciA9IHF1YW50X2NvbXBhcmUoYmV0dGVyLCBiZXN0X25vaXNlX2luZm8sIG5vaXNlX2luZm8sXG4gICAgICAgICAgICAgICAgICAgIGNvZF9pbmZvX3csIGRpc3RvcnQpID8gMSA6IDA7XG5cbiAgICAgICAgICAgICAgICAvKiBzYXZlIGRhdGEgc28gd2UgY2FuIHJlc3RvcmUgdGhpcyBxdWFudGl6YXRpb24gbGF0ZXIgKi9cbiAgICAgICAgICAgICAgICBpZiAoYmV0dGVyICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYmVzdF9wYXJ0Ml8zX2xlbmd0aCA9IGNvZF9pbmZvLnBhcnQyXzNfbGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBiZXN0X25vaXNlX2luZm8gPSBub2lzZV9pbmZvO1xuICAgICAgICAgICAgICAgICAgICBjb2RfaW5mby5hc3NpZ24oY29kX2luZm9fdyk7XG4gICAgICAgICAgICAgICAgICAgIGFnZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIC8qIHNhdmUgZGF0YSBzbyB3ZSBjYW4gcmVzdG9yZSB0aGlzIHF1YW50aXphdGlvbiBsYXRlciAqL1xuICAgICAgICAgICAgICAgICAgICAvKiBzdG9yZSBmb3IgbGF0ZXIgcmV1c2UgKi9cbiAgICAgICAgICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weSh4cnBvdywgMCwgc2F2ZV94cnBvdywgMCwgNTc2KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvKiBlYXJseSBzdG9wPyAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2ZjLmZ1bGxfb3V0ZXJfbG9vcCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKythZ2UgPiBzZWFyY2hfbGltaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBiZXN0X25vaXNlX2luZm8ub3Zlcl9jb3VudCA9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChnZmMubm9pc2Vfc2hhcGluZ19hbXAgPT0gMykgJiYgYlJlZmluZSAmJiBhZ2UgPiAzMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZ2ZjLm5vaXNlX3NoYXBpbmdfYW1wID09IDMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgYlJlZmluZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIChjb2RfaW5mb193Lmdsb2JhbF9nYWluIC0gYmVzdF9nZ2Fpbl9wYXNzMSkgPiAxNSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKChjb2RfaW5mb193Lmdsb2JhbF9nYWluICsgY29kX2luZm9fdy5zY2FsZWZhY19zY2FsZSkgPCAyNTUpO1xuXG4gICAgICAgICAgICBpZiAoZ2ZjLm5vaXNlX3NoYXBpbmdfYW1wID09IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWJSZWZpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogcmVmaW5lIHNlYXJjaCAqL1xuICAgICAgICAgICAgICAgICAgICBjb2RfaW5mb193LmFzc2lnbihjb2RfaW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIFN5c3RlbS5hcnJheWNvcHkoc2F2ZV94cnBvdywgMCwgeHJwb3csIDAsIDU3Nik7XG4gICAgICAgICAgICAgICAgICAgIGFnZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RfZ2dhaW5fcGFzczEgPSBjb2RfaW5mb193Lmdsb2JhbF9nYWluO1xuXG4gICAgICAgICAgICAgICAgICAgIGJSZWZpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIHNlYXJjaCBhbHJlYWR5IHJlZmluZWQsIHN0b3AgKi9cbiAgICAgICAgICAgICAgICAgICAgYkVuZE9mU2VhcmNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYkVuZE9mU2VhcmNoID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFzc2VydCgoY29kX2luZm8uZ2xvYmFsX2dhaW4gKyBjb2RfaW5mby5zY2FsZWZhY19zY2FsZSkgPD0gMjU1KTtcbiAgICAgICAgLypcbiAgICAgICAgICogZmluaXNoIHVwXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoZ2ZwLlZCUiA9PSBWYnJNb2RlLnZicl9yaCB8fCBnZnAuVkJSID09IFZick1vZGUudmJyX210cmgpXG4gICAgICAgIC8qIHJlc3RvcmUgZm9yIHJldXNlIG9uIG5leHQgdHJ5ICovXG4gICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KHNhdmVfeHJwb3csIDAsIHhycG93LCAwLCA1NzYpO1xuICAgICAgICAvKlxuICAgICAgICAgKiBkbyB0aGUgJ3N1YnN0ZXAgc2hhcGluZydcbiAgICAgICAgICovXG4gICAgICAgIGVsc2UgaWYgKChnZmMuc3Vic3RlcF9zaGFwaW5nICYgMSkgIT0gMClcbiAgICAgICAgICAgIHRyYW5jYXRlX3NtYWxsc3BlY3RydW1zKGdmYywgY29kX2luZm8sIGwzX3htaW4sIHhycG93KTtcblxuICAgICAgICByZXR1cm4gYmVzdF9ub2lzZV9pbmZvLm92ZXJfY291bnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUm9iZXJ0IEhlZ2VtYW5uIDIwMDAtMDktMDZcbiAgICAgKlxuICAgICAqIHVwZGF0ZSByZXNlcnZvaXIgc3RhdHVzIGFmdGVyIEZJTkFMIHF1YW50aXphdGlvbi9iaXRyYXRlXG4gICAgICovXG4gICAgdGhpcy5pdGVyYXRpb25fZmluaXNoX29uZSA9IGZ1bmN0aW9uIChnZmMsIGdyLCBjaCkge1xuICAgICAgICB2YXIgbDNfc2lkZSA9IGdmYy5sM19zaWRlO1xuICAgICAgICB2YXIgY29kX2luZm8gPSBsM19zaWRlLnR0W2dyXVtjaF07XG5cbiAgICAgICAgLypcbiAgICAgICAgICogdHJ5IHNvbWUgYmV0dGVyIHNjYWxlZmFjIHN0b3JhZ2VcbiAgICAgICAgICovXG4gICAgICAgIHRrLmJlc3Rfc2NhbGVmYWNfc3RvcmUoZ2ZjLCBnciwgY2gsIGwzX3NpZGUpO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIGJlc3QgaHVmZm1hbl9kaXZpZGUgbWF5IHNhdmUgc29tZSBiaXRzIHRvb1xuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGdmYy51c2VfYmVzdF9odWZmbWFuID09IDEpXG4gICAgICAgICAgICB0ay5iZXN0X2h1ZmZtYW5fZGl2aWRlKGdmYywgY29kX2luZm8pO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIHVwZGF0ZSByZXNlcnZvaXIgc3RhdHVzIGFmdGVyIEZJTkFMIHF1YW50aXphdGlvbi9iaXRyYXRlXG4gICAgICAgICAqL1xuICAgICAgICBydi5SZXN2QWRqdXN0KGdmYywgY29kX2luZm8pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIDIwMDAtMDktMDQgUm9iZXJ0IEhlZ2VtYW5uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbDNfeG1pblxuICAgICAqICAgICAgICAgICAgYWxsb3dlZCBkaXN0b3J0aW9uIG9mIHRoZSBzY2FsZWZhY3RvclxuICAgICAqIEBwYXJhbSB4cnBvd1xuICAgICAqICAgICAgICAgICAgY29sb3VyZWQgbWFnbml0dWRlcyBvZiBzcGVjdHJhbCB2YWx1ZXNcbiAgICAgKi9cbiAgICB0aGlzLlZCUl9lbmNvZGVfZ3JhbnVsZSA9IGZ1bmN0aW9uIChnZnAsIGNvZF9pbmZvLCBsM194bWluLCB4cnBvdywgY2gsIG1pbl9iaXRzLCBtYXhfYml0cykge1xuICAgICAgICB2YXIgZ2ZjID0gZ2ZwLmludGVybmFsX2ZsYWdzO1xuICAgICAgICB2YXIgYnN0X2NvZF9pbmZvID0gbmV3IEdySW5mbygpO1xuICAgICAgICB2YXIgYnN0X3hycG93ID0gbmV3X2Zsb2F0KDU3Nik7XG4gICAgICAgIHZhciBNYXhfYml0cyA9IG1heF9iaXRzO1xuICAgICAgICB2YXIgcmVhbF9iaXRzID0gbWF4X2JpdHMgKyAxO1xuICAgICAgICB2YXIgdGhpc19iaXRzID0gKG1heF9iaXRzICsgbWluX2JpdHMpIC8gMjtcbiAgICAgICAgdmFyIGRiaXRzLCBvdmVyLCBmb3VuZCA9IDA7XG4gICAgICAgIHZhciBzZmIyMV9leHRyYSA9IGdmYy5zZmIyMV9leHRyYTtcblxuICAgICAgICBhc3NlcnQoTWF4X2JpdHMgPD0gTGFtZUludGVybmFsRmxhZ3MuTUFYX0JJVFNfUEVSX0NIQU5ORUwpO1xuICAgICAgICBBcnJheXMuZmlsbChic3RfY29kX2luZm8ubDNfZW5jLCAwKTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBzZWFyY2ggd2l0aGluIHJvdW5kIGFib3V0IDQwIGJpdHMgb2Ygb3B0aW1hbFxuICAgICAgICAgKi9cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgYXNzZXJ0KHRoaXNfYml0cyA+PSBtaW5fYml0cyk7XG4gICAgICAgICAgICBhc3NlcnQodGhpc19iaXRzIDw9IG1heF9iaXRzKTtcbiAgICAgICAgICAgIGFzc2VydChtaW5fYml0cyA8PSBtYXhfYml0cyk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzX2JpdHMgPiBNYXhfYml0cyAtIDQyKVxuICAgICAgICAgICAgICAgIGdmYy5zZmIyMV9leHRyYSA9IGZhbHNlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGdmYy5zZmIyMV9leHRyYSA9IHNmYjIxX2V4dHJhO1xuXG4gICAgICAgICAgICBvdmVyID0gb3V0ZXJfbG9vcChnZnAsIGNvZF9pbmZvLCBsM194bWluLCB4cnBvdywgY2gsIHRoaXNfYml0cyk7XG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBpcyBxdWFudGl6YXRpb24gYXMgZ29vZCBhcyB3ZSBhcmUgbG9va2luZyBmb3IgPyBpbiB0aGlzIGNhc2U6IGlzXG4gICAgICAgICAgICAgKiBubyBzY2FsZWZhY3RvciBiYW5kIGRpc3RvcnRlZD9cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKG92ZXIgPD0gMCkge1xuICAgICAgICAgICAgICAgIGZvdW5kID0gMTtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIG5vdyB3ZSBrbm93IGl0IGNhbiBiZSBkb25lIHdpdGggXCJyZWFsX2JpdHNcIiBhbmQgbWF5YmUgd2UgY2FuXG4gICAgICAgICAgICAgICAgICogc2tpcCBzb21lIGl0ZXJhdGlvbnNcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICByZWFsX2JpdHMgPSBjb2RfaW5mby5wYXJ0Ml8zX2xlbmd0aDtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogc3RvcmUgYmVzdCBxdWFudGl6YXRpb24gc28gZmFyXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgYnN0X2NvZF9pbmZvLmFzc2lnbihjb2RfaW5mbyk7XG4gICAgICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weSh4cnBvdywgMCwgYnN0X3hycG93LCAwLCA1NzYpO1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiB0cnkgd2l0aCBmZXdlciBiaXRzXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgbWF4X2JpdHMgPSByZWFsX2JpdHMgLSAzMjtcbiAgICAgICAgICAgICAgICBkYml0cyA9IG1heF9iaXRzIC0gbWluX2JpdHM7XG4gICAgICAgICAgICAgICAgdGhpc19iaXRzID0gKG1heF9iaXRzICsgbWluX2JpdHMpIC8gMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiB0cnkgd2l0aCBtb3JlIGJpdHNcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBtaW5fYml0cyA9IHRoaXNfYml0cyArIDMyO1xuICAgICAgICAgICAgICAgIGRiaXRzID0gbWF4X2JpdHMgLSBtaW5fYml0cztcbiAgICAgICAgICAgICAgICB0aGlzX2JpdHMgPSAobWF4X2JpdHMgKyBtaW5fYml0cykgLyAyO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSAyO1xuICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgKiBzdGFydCBhZ2FpbiB3aXRoIGJlc3QgcXVhbnRpemF0aW9uIHNvIGZhclxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgY29kX2luZm8uYXNzaWduKGJzdF9jb2RfaW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIFN5c3RlbS5hcnJheWNvcHkoYnN0X3hycG93LCAwLCB4cnBvdywgMCwgNTc2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGRiaXRzID4gMTIpO1xuXG4gICAgICAgIGdmYy5zZmIyMV9leHRyYSA9IHNmYjIxX2V4dHJhO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIGZvdW5kPTAgPT4gbm90aGluZyBmb3VuZCwgdXNlIGxhc3Qgb25lIGZvdW5kPTEgPT4gd2UganVzdCBmb3VuZCB0aGVcbiAgICAgICAgICogYmVzdCBhbmQgbGVmdCB0aGUgbG9vcCBmb3VuZD0yID0+IHdlIHJlc3RvcmVkIGEgZ29vZCBvbmUgYW5kIGhhdmUgbm93XG4gICAgICAgICAqIGwzX2VuYyB0byByZXN0b3JlIHRvb1xuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGZvdW5kID09IDIpIHtcbiAgICAgICAgICAgIFN5c3RlbS5hcnJheWNvcHkoYnN0X2NvZF9pbmZvLmwzX2VuYywgMCwgY29kX2luZm8ubDNfZW5jLCAwLCA1NzYpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChjb2RfaW5mby5wYXJ0Ml8zX2xlbmd0aCA8PSBNYXhfYml0cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUm9iZXJ0IEhlZ2VtYW5uIDIwMDAtMDktMDVcbiAgICAgKlxuICAgICAqIGNhbGN1bGF0ZXMgKiBob3cgbWFueSBiaXRzIGFyZSBhdmFpbGFibGUgZm9yIGFuYWxvZyBzaWxlbnQgZ3JhbnVsZXMgKiBob3dcbiAgICAgKiBtYW55IGJpdHMgdG8gdXNlIGZvciB0aGUgbG93ZXN0IGFsbG93ZWQgYml0cmF0ZSAqIGhvdyBtYW55IGJpdHMgZWFjaFxuICAgICAqIGJpdHJhdGUgd291bGQgcHJvdmlkZVxuICAgICAqL1xuICAgIHRoaXMuZ2V0X2ZyYW1lYml0cyA9IGZ1bmN0aW9uIChnZnAsIGZyYW1lQml0cykge1xuICAgICAgICB2YXIgZ2ZjID0gZ2ZwLmludGVybmFsX2ZsYWdzO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIGFsd2F5cyB1c2UgYXQgbGVhc3QgdGhpcyBtYW55IGJpdHMgcGVyIGdyYW51bGUgcGVyIGNoYW5uZWwgdW5sZXNzIHdlXG4gICAgICAgICAqIGRldGVjdCBhbmFsb2cgc2lsZW5jZSwgc2VlIGJlbG93XG4gICAgICAgICAqL1xuICAgICAgICBnZmMuYml0cmF0ZV9pbmRleCA9IGdmYy5WQlJfbWluX2JpdHJhdGU7XG4gICAgICAgIHZhciBiaXRzUGVyRnJhbWUgPSBicy5nZXRmcmFtZWJpdHMoZ2ZwKTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBiaXRzIGZvciBhbmFsb2cgc2lsZW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2ZjLmJpdHJhdGVfaW5kZXggPSAxO1xuICAgICAgICBiaXRzUGVyRnJhbWUgPSBicy5nZXRmcmFtZWJpdHMoZ2ZwKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBnZmMuVkJSX21heF9iaXRyYXRlOyBpKyspIHtcbiAgICAgICAgICAgIGdmYy5iaXRyYXRlX2luZGV4ID0gaTtcbiAgICAgICAgICAgIHZhciBtYiA9IG5ldyBNZWFuQml0cyhiaXRzUGVyRnJhbWUpO1xuICAgICAgICAgICAgZnJhbWVCaXRzW2ldID0gcnYuUmVzdkZyYW1lQmVnaW4oZ2ZwLCBtYik7XG4gICAgICAgICAgICBiaXRzUGVyRnJhbWUgPSBtYi5iaXRzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qIFJIOiB0aGlzIG9uZSBuZWVkcyB0byBiZSBvdmVyaGF1bGVkIHNvbWV0aW1lICovXG5cbiAgICAvKipcbiAgICAgKiA8UFJFPlxuICAgICAqICAyMDAwLTA5LTA0IFJvYmVydCBIZWdlbWFublxuICAgICAqXG4gICAgICogICogY29udmVydHMgTFIgdG8gTVMgY29kaW5nIHdoZW4gbmVjZXNzYXJ5XG4gICAgICogICogY2FsY3VsYXRlcyBhbGxvd2VkL2FkanVzdGVkIHF1YW50aXphdGlvbiBub2lzZSBhbW91bnRzXG4gICAgICogICogZGV0ZWN0cyBhbmFsb2cgc2lsZW50IGZyYW1lc1xuICAgICAqXG4gICAgICogIHNvbWUgcmVtYXJrczpcbiAgICAgKiAgLSBsb3dlciBtYXNraW5nIGRlcGVuZGluZyBvbiBRdWFsaXR5IHNldHRpbmdcbiAgICAgKiAgLSBxdWFsaXR5IGNvbnRyb2wgdG9nZXRoZXIgd2l0aCBhZGp1c3RlZCBBVEggTURDVCBzY2FsaW5nXG4gICAgICogICAgb24gbG93ZXIgcXVhbGl0eSBzZXR0aW5nIGFsbG9jYXRlIG1vcmUgbm9pc2UgZnJvbVxuICAgICAqICAgIEFUSCBtYXNraW5nLCBhbmQgb24gaGlnaGVyIHF1YWxpdHkgc2V0dGluZyBhbGxvY2F0ZVxuICAgICAqICAgIGxlc3Mgbm9pc2UgZnJvbSBBVEggbWFza2luZy5cbiAgICAgKiAgLSBleHBlcmltZW50cyBzaG93IHRoYXQgZ29pbmcgbW9yZSB0aGFuIDJkQiBvdmVyIEdQU1lDSE8nc1xuICAgICAqICAgIGxpbWl0cyBlbmRzIHVwIGluIHZlcnkgYW5ub3lpbmcgYXJ0ZWZhY3RzXG4gICAgICogPC9QUkU+XG4gICAgICovXG4gICAgdGhpcy5WQlJfb2xkX3ByZXBhcmUgPSBmdW5jdGlvbiAoZ2ZwLCBwZSwgbXNfZW5lcl9yYXRpbywgcmF0aW8sIGwzX3htaW4sIGZyYW1lQml0cywgbWluX2JpdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4X2JpdHMsIGJhbmRzKSB7XG4gICAgICAgIHZhciBnZmMgPSBnZnAuaW50ZXJuYWxfZmxhZ3M7XG5cbiAgICAgICAgdmFyIG1hc2tpbmdfbG93ZXJfZGIsIGFkanVzdCA9IDAuMDtcbiAgICAgICAgdmFyIGFuYWxvZ19zaWxlbmNlID0gMTtcbiAgICAgICAgdmFyIGJpdHMgPSAwO1xuXG4gICAgICAgIGdmYy5iaXRyYXRlX2luZGV4ID0gZ2ZjLlZCUl9tYXhfYml0cmF0ZTtcbiAgICAgICAgdmFyIGF2ZyA9IHJ2LlJlc3ZGcmFtZUJlZ2luKGdmcCwgbmV3IE1lYW5CaXRzKDApKSAvIGdmYy5tb2RlX2dyO1xuXG4gICAgICAgIGdldF9mcmFtZWJpdHMoZ2ZwLCBmcmFtZUJpdHMpO1xuXG4gICAgICAgIGZvciAodmFyIGdyID0gMDsgZ3IgPCBnZmMubW9kZV9ncjsgZ3IrKykge1xuICAgICAgICAgICAgdmFyIG14YiA9IHF1cHZ0Lm9uX3BlKGdmcCwgcGUsIG1heF9iaXRzW2dyXSwgYXZnLCBnciwgMCk7XG4gICAgICAgICAgICBpZiAoZ2ZjLm1vZGVfZXh0ID09IEVuY29kZXIuTVBHX01EX01TX0xSKSB7XG4gICAgICAgICAgICAgICAgbXNfY29udmVydChnZmMubDNfc2lkZSwgZ3IpO1xuICAgICAgICAgICAgICAgIHF1cHZ0LnJlZHVjZV9zaWRlKG1heF9iaXRzW2dyXSwgbXNfZW5lcl9yYXRpb1tncl0sIGF2ZywgbXhiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGNoID0gMDsgY2ggPCBnZmMuY2hhbm5lbHNfb3V0OyArK2NoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvZF9pbmZvID0gZ2ZjLmwzX3NpZGUudHRbZ3JdW2NoXTtcblxuICAgICAgICAgICAgICAgIGlmIChjb2RfaW5mby5ibG9ja190eXBlICE9IEVuY29kZXIuU0hPUlRfVFlQRSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOT1JNLCBTVEFSVCBvciBTVE9QIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgYWRqdXN0ID0gMS4yOCAvICgxICsgTWF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5leHAoMy41IC0gcGVbZ3JdW2NoXSAvIDMwMC4pKSAtIDAuMDU7XG4gICAgICAgICAgICAgICAgICAgIG1hc2tpbmdfbG93ZXJfZGIgPSBnZmMuUFNZLm1hc2tfYWRqdXN0IC0gYWRqdXN0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFkanVzdCA9IDIuNTYgLyAoMSArIE1hdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZXhwKDMuNSAtIHBlW2dyXVtjaF0gLyAzMDAuKSkgLSAwLjE0O1xuICAgICAgICAgICAgICAgICAgICBtYXNraW5nX2xvd2VyX2RiID0gZ2ZjLlBTWS5tYXNrX2FkanVzdF9zaG9ydCAtIGFkanVzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2ZjLm1hc2tpbmdfbG93ZXIgPSBNYXRoLnBvdygxMC4wLFxuICAgICAgICAgICAgICAgICAgICBtYXNraW5nX2xvd2VyX2RiICogMC4xKTtcblxuICAgICAgICAgICAgICAgIGluaXRfb3V0ZXJfbG9vcChnZmMsIGNvZF9pbmZvKTtcbiAgICAgICAgICAgICAgICBiYW5kc1tncl1bY2hdID0gcXVwdnQuY2FsY194bWluKGdmcCwgcmF0aW9bZ3JdW2NoXSwgY29kX2luZm8sXG4gICAgICAgICAgICAgICAgICAgIGwzX3htaW5bZ3JdW2NoXSk7XG4gICAgICAgICAgICAgICAgaWYgKGJhbmRzW2dyXVtjaF0gIT0gMClcbiAgICAgICAgICAgICAgICAgICAgYW5hbG9nX3NpbGVuY2UgPSAwO1xuXG4gICAgICAgICAgICAgICAgbWluX2JpdHNbZ3JdW2NoXSA9IDEyNjtcblxuICAgICAgICAgICAgICAgIGJpdHMgKz0gbWF4X2JpdHNbZ3JdW2NoXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBnciA9IDA7IGdyIDwgZ2ZjLm1vZGVfZ3I7IGdyKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGNoID0gMDsgY2ggPCBnZmMuY2hhbm5lbHNfb3V0OyBjaCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJpdHMgPiBmcmFtZUJpdHNbZ2ZjLlZCUl9tYXhfYml0cmF0ZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4X2JpdHNbZ3JdW2NoXSAqPSBmcmFtZUJpdHNbZ2ZjLlZCUl9tYXhfYml0cmF0ZV07XG4gICAgICAgICAgICAgICAgICAgIG1heF9iaXRzW2dyXVtjaF0gLz0gYml0cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1pbl9iaXRzW2dyXVtjaF0gPiBtYXhfYml0c1tncl1bY2hdKVxuICAgICAgICAgICAgICAgICAgICBtaW5fYml0c1tncl1bY2hdID0gbWF4X2JpdHNbZ3JdW2NoXTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogZm9yIGNoICovXG4gICAgICAgIH1cbiAgICAgICAgLyogZm9yIGdyICovXG5cbiAgICAgICAgcmV0dXJuIGFuYWxvZ19zaWxlbmNlO1xuICAgIH07XG5cbiAgICB0aGlzLmJpdHByZXNzdXJlX3N0cmF0ZWd5ID0gZnVuY3Rpb24gKGdmYywgbDNfeG1pbiwgbWluX2JpdHMsIG1heF9iaXRzKSB7XG4gICAgICAgIGZvciAodmFyIGdyID0gMDsgZ3IgPCBnZmMubW9kZV9ncjsgZ3IrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgY2ggPSAwOyBjaCA8IGdmYy5jaGFubmVsc19vdXQ7IGNoKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZ2kgPSBnZmMubDNfc2lkZS50dFtncl1bY2hdO1xuICAgICAgICAgICAgICAgIHZhciBweG1pbiA9IGwzX3htaW5bZ3JdW2NoXTtcbiAgICAgICAgICAgICAgICB2YXIgcHhtaW5Qb3MgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHNmYiA9IDA7IHNmYiA8IGdpLnBzeV9sbWF4OyBzZmIrKylcbiAgICAgICAgICAgICAgICAgICAgcHhtaW5bcHhtaW5Qb3MrK10gKj0gMS4gKyAuMDI5ICogc2ZiICogc2ZiXG4gICAgICAgICAgICAgICAgICAgICAgICAvIEVuY29kZXIuU0JNQVhfbCAvIEVuY29kZXIuU0JNQVhfbDtcblxuICAgICAgICAgICAgICAgIGlmIChnaS5ibG9ja190eXBlID09IEVuY29kZXIuU0hPUlRfVFlQRSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBzZmIgPSBnaS5zZmJfc21pbjsgc2ZiIDwgRW5jb2Rlci5TQk1BWF9zOyBzZmIrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHhtaW5bcHhtaW5Qb3MrK10gKj0gMS4gKyAuMDI5ICogc2ZiICogc2ZiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyBFbmNvZGVyLlNCTUFYX3MgLyBFbmNvZGVyLlNCTUFYX3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBweG1pbltweG1pblBvcysrXSAqPSAxLiArIC4wMjkgKiBzZmIgKiBzZmJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvIEVuY29kZXIuU0JNQVhfcyAvIEVuY29kZXIuU0JNQVhfcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHB4bWluW3B4bWluUG9zKytdICo9IDEuICsgLjAyOSAqIHNmYiAqIHNmYlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gRW5jb2Rlci5TQk1BWF9zIC8gRW5jb2Rlci5TQk1BWF9zO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1heF9iaXRzW2dyXVtjaF0gPSAwIHwgTWF0aC5tYXgobWluX2JpdHNbZ3JdW2NoXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAuOSAqIG1heF9iaXRzW2dyXVtjaF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuVkJSX25ld19wcmVwYXJlID0gZnVuY3Rpb24gKGdmcCwgcGUsIHJhdGlvLCBsM194bWluLCBmcmFtZUJpdHMsIG1heF9iaXRzKSB7XG4gICAgICAgIHZhciBnZmMgPSBnZnAuaW50ZXJuYWxfZmxhZ3M7XG5cbiAgICAgICAgdmFyIGFuYWxvZ19zaWxlbmNlID0gMTtcbiAgICAgICAgdmFyIGF2ZyA9IDAsIGJpdHMgPSAwO1xuICAgICAgICB2YXIgbWF4aW11bV9mcmFtZWJpdHM7XG5cbiAgICAgICAgaWYgKCFnZnAuZnJlZV9mb3JtYXQpIHtcbiAgICAgICAgICAgIGdmYy5iaXRyYXRlX2luZGV4ID0gZ2ZjLlZCUl9tYXhfYml0cmF0ZTtcblxuICAgICAgICAgICAgdmFyIG1iID0gbmV3IE1lYW5CaXRzKGF2Zyk7XG4gICAgICAgICAgICBydi5SZXN2RnJhbWVCZWdpbihnZnAsIG1iKTtcbiAgICAgICAgICAgIGF2ZyA9IG1iLmJpdHM7XG5cbiAgICAgICAgICAgIGdldF9mcmFtZWJpdHMoZ2ZwLCBmcmFtZUJpdHMpO1xuICAgICAgICAgICAgbWF4aW11bV9mcmFtZWJpdHMgPSBmcmFtZUJpdHNbZ2ZjLlZCUl9tYXhfYml0cmF0ZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZmMuYml0cmF0ZV9pbmRleCA9IDA7XG4gICAgICAgICAgICB2YXIgbWIgPSBuZXcgTWVhbkJpdHMoYXZnKTtcbiAgICAgICAgICAgIG1heGltdW1fZnJhbWViaXRzID0gcnYuUmVzdkZyYW1lQmVnaW4oZ2ZwLCBtYik7XG4gICAgICAgICAgICBhdmcgPSBtYi5iaXRzO1xuICAgICAgICAgICAgZnJhbWVCaXRzWzBdID0gbWF4aW11bV9mcmFtZWJpdHM7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBnciA9IDA7IGdyIDwgZ2ZjLm1vZGVfZ3I7IGdyKyspIHtcbiAgICAgICAgICAgIHF1cHZ0Lm9uX3BlKGdmcCwgcGUsIG1heF9iaXRzW2dyXSwgYXZnLCBnciwgMCk7XG4gICAgICAgICAgICBpZiAoZ2ZjLm1vZGVfZXh0ID09IEVuY29kZXIuTVBHX01EX01TX0xSKSB7XG4gICAgICAgICAgICAgICAgbXNfY29udmVydChnZmMubDNfc2lkZSwgZ3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgY2ggPSAwOyBjaCA8IGdmYy5jaGFubmVsc19vdXQ7ICsrY2gpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29kX2luZm8gPSBnZmMubDNfc2lkZS50dFtncl1bY2hdO1xuXG4gICAgICAgICAgICAgICAgZ2ZjLm1hc2tpbmdfbG93ZXIgPSBNYXRoLnBvdygxMC4wLFxuICAgICAgICAgICAgICAgICAgICBnZmMuUFNZLm1hc2tfYWRqdXN0ICogMC4xKTtcblxuICAgICAgICAgICAgICAgIGluaXRfb3V0ZXJfbG9vcChnZmMsIGNvZF9pbmZvKTtcbiAgICAgICAgICAgICAgICBpZiAoMCAhPSBxdXB2dC5jYWxjX3htaW4oZ2ZwLCByYXRpb1tncl1bY2hdLCBjb2RfaW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGwzX3htaW5bZ3JdW2NoXSkpXG4gICAgICAgICAgICAgICAgICAgIGFuYWxvZ19zaWxlbmNlID0gMDtcblxuICAgICAgICAgICAgICAgIGJpdHMgKz0gbWF4X2JpdHNbZ3JdW2NoXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBnciA9IDA7IGdyIDwgZ2ZjLm1vZGVfZ3I7IGdyKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGNoID0gMDsgY2ggPCBnZmMuY2hhbm5lbHNfb3V0OyBjaCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJpdHMgPiBtYXhpbXVtX2ZyYW1lYml0cykge1xuICAgICAgICAgICAgICAgICAgICBtYXhfYml0c1tncl1bY2hdICo9IG1heGltdW1fZnJhbWViaXRzO1xuICAgICAgICAgICAgICAgICAgICBtYXhfYml0c1tncl1bY2hdIC89IGJpdHM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBmb3IgY2ggKi9cbiAgICAgICAgfVxuICAgICAgICAvKiBmb3IgZ3IgKi9cblxuICAgICAgICByZXR1cm4gYW5hbG9nX3NpbGVuY2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZXMgdGFyZ2V0IGJpdHMgZm9yIEFCUiBlbmNvZGluZ1xuICAgICAqXG4gICAgICogbXQgMjAwMC8wNS8zMVxuICAgICAqL1xuICAgIHRoaXMuY2FsY190YXJnZXRfYml0cyA9IGZ1bmN0aW9uIChnZnAsIHBlLCBtc19lbmVyX3JhdGlvLCB0YXJnX2JpdHMsIGFuYWxvZ19zaWxlbmNlX2JpdHMsIG1heF9mcmFtZV9iaXRzKSB7XG4gICAgICAgIHZhciBnZmMgPSBnZnAuaW50ZXJuYWxfZmxhZ3M7XG4gICAgICAgIHZhciBsM19zaWRlID0gZ2ZjLmwzX3NpZGU7XG4gICAgICAgIHZhciByZXNfZmFjdG9yO1xuICAgICAgICB2YXIgZ3IsIGNoLCB0b3RiaXRzLCBtZWFuX2JpdHMgPSAwO1xuXG4gICAgICAgIGdmYy5iaXRyYXRlX2luZGV4ID0gZ2ZjLlZCUl9tYXhfYml0cmF0ZTtcbiAgICAgICAgdmFyIG1iID0gbmV3IE1lYW5CaXRzKG1lYW5fYml0cyk7XG4gICAgICAgIG1heF9mcmFtZV9iaXRzWzBdID0gcnYuUmVzdkZyYW1lQmVnaW4oZ2ZwLCBtYik7XG4gICAgICAgIG1lYW5fYml0cyA9IG1iLmJpdHM7XG5cbiAgICAgICAgZ2ZjLmJpdHJhdGVfaW5kZXggPSAxO1xuICAgICAgICBtZWFuX2JpdHMgPSBicy5nZXRmcmFtZWJpdHMoZ2ZwKSAtIGdmYy5zaWRlaW5mb19sZW4gKiA4O1xuICAgICAgICBhbmFsb2dfc2lsZW5jZV9iaXRzWzBdID0gbWVhbl9iaXRzIC8gKGdmYy5tb2RlX2dyICogZ2ZjLmNoYW5uZWxzX291dCk7XG5cbiAgICAgICAgbWVhbl9iaXRzID0gZ2ZwLlZCUl9tZWFuX2JpdHJhdGVfa2JwcyAqIGdmcC5mcmFtZXNpemUgKiAxMDAwO1xuICAgICAgICBpZiAoKGdmYy5zdWJzdGVwX3NoYXBpbmcgJiAxKSAhPSAwKVxuICAgICAgICAgICAgbWVhbl9iaXRzICo9IDEuMDk7XG4gICAgICAgIG1lYW5fYml0cyAvPSBnZnAub3V0X3NhbXBsZXJhdGU7XG4gICAgICAgIG1lYW5fYml0cyAtPSBnZmMuc2lkZWluZm9fbGVuICogODtcbiAgICAgICAgbWVhbl9iaXRzIC89IChnZmMubW9kZV9nciAqIGdmYy5jaGFubmVsc19vdXQpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8UFJFPlxuICAgICAgICAgKiAgICAgICAgICAgcmVzX2ZhY3RvciBpcyB0aGUgcGVyY2VudGFnZSBvZiB0aGUgdGFyZ2V0IGJpdHJhdGUgdGhhdCBzaG91bGRcbiAgICAgICAgICogICAgICAgICAgIGJlIHVzZWQgb24gYXZlcmFnZS4gIHRoZSByZW1haW5pbmcgYml0cyBhcmUgYWRkZWQgdG8gdGhlXG4gICAgICAgICAqICAgICAgICAgICBiaXRyZXNlcnZvaXIgYW5kIHVzZWQgZm9yIGRpZmZpY3VsdCB0byBlbmNvZGUgZnJhbWVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgICAgU2luY2Ugd2UgYXJlIHRyYWNraW5nIHRoZSBhdmVyYWdlIGJpdHJhdGUsIHdlIHNob3VsZCBhZGp1c3RcbiAgICAgICAgICogICAgICAgICAgIHJlc19mYWN0b3IgXCJvbiB0aGUgZmx5XCIsIGluY3JlYXNpbmcgaXQgaWYgdGhlIGF2ZXJhZ2UgYml0cmF0ZVxuICAgICAgICAgKiAgICAgICAgICAgaXMgZ3JlYXRlciB0aGFuIHRoZSByZXF1ZXN0ZWQgYml0cmF0ZSwgYW5kIGRlY3JlYXNpbmcgaXRcbiAgICAgICAgICogICAgICAgICAgIG90aGVyd2lzZS4gIFJlYXNvbmFibGUgcmFuZ2VzIGFyZSBmcm9tIC45IHRvIDEuMFxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgICAgVW50aWwgd2UgZ2V0IHRoZSBhYm92ZSBzdWdnZXN0aW9uIHdvcmtpbmcsIHdlIHVzZSB0aGUgZm9sbG93aW5nXG4gICAgICAgICAqICAgICAgICAgICB0dW5pbmc6XG4gICAgICAgICAqICAgICAgICAgICBjb21wcmVzc2lvbiByYXRpbyAgICByZXNfZmFjdG9yXG4gICAgICAgICAqICAgICAgICAgICA1LjUgICgyNTZrYnBzKSAgICAgICAgIDEuMCAgICAgIG5vIG5lZWQgZm9yIGJpdHJlc2Vydm9pclxuICAgICAgICAgKiAgICAgICAgICAgMTEgICAoMTI4a2JwcykgICAgICAgICAuOTMgICAgICA3JSBoZWxkIGZvciByZXNlcnZvaXJcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAgICAgIHdpdGggbGluZWFyIGludGVycG9sYXRpb24gZm9yIG90aGVyIHZhbHVlcy5cbiAgICAgICAgICogPC9QUkU+XG4gICAgICAgICAqL1xuICAgICAgICByZXNfZmFjdG9yID0gLjkzICsgLjA3ICogKDExLjAgLSBnZnAuY29tcHJlc3Npb25fcmF0aW8pXG4gICAgICAgICAgICAvICgxMS4wIC0gNS41KTtcbiAgICAgICAgaWYgKHJlc19mYWN0b3IgPCAuOTApXG4gICAgICAgICAgICByZXNfZmFjdG9yID0gLjkwO1xuICAgICAgICBpZiAocmVzX2ZhY3RvciA+IDEuMDApXG4gICAgICAgICAgICByZXNfZmFjdG9yID0gMS4wMDtcblxuICAgICAgICBmb3IgKGdyID0gMDsgZ3IgPCBnZmMubW9kZV9ncjsgZ3IrKykge1xuICAgICAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgICAgICBmb3IgKGNoID0gMDsgY2ggPCBnZmMuY2hhbm5lbHNfb3V0OyBjaCsrKSB7XG4gICAgICAgICAgICAgICAgdGFyZ19iaXRzW2dyXVtjaF0gPSAoaW50KShyZXNfZmFjdG9yICogbWVhbl9iaXRzKTtcblxuICAgICAgICAgICAgICAgIGlmIChwZVtncl1bY2hdID4gNzAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhZGRfYml0cyA9IChpbnQpKChwZVtncl1bY2hdIC0gNzAwKSAvIDEuNCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvZF9pbmZvID0gbDNfc2lkZS50dFtncl1bY2hdO1xuICAgICAgICAgICAgICAgICAgICB0YXJnX2JpdHNbZ3JdW2NoXSA9IChpbnQpKHJlc19mYWN0b3IgKiBtZWFuX2JpdHMpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8qIHNob3J0IGJsb2NrcyB1c2UgYSBsaXR0bGUgZXh0cmEsIG5vIG1hdHRlciB3aGF0IHRoZSBwZSAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kX2luZm8uYmxvY2tfdHlwZSA9PSBFbmNvZGVyLlNIT1JUX1RZUEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGRfYml0cyA8IG1lYW5fYml0cyAvIDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkX2JpdHMgPSBtZWFuX2JpdHMgLyAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8qIGF0IG1vc3QgaW5jcmVhc2UgYml0cyBieSAxLjUqYXZlcmFnZSAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkX2JpdHMgPiBtZWFuX2JpdHMgKiAzIC8gMilcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZF9iaXRzID0gbWVhbl9iaXRzICogMyAvIDI7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFkZF9iaXRzIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZF9iaXRzID0gMDtcblxuICAgICAgICAgICAgICAgICAgICB0YXJnX2JpdHNbZ3JdW2NoXSArPSBhZGRfYml0cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdfYml0c1tncl1bY2hdID4gTGFtZUludGVybmFsRmxhZ3MuTUFYX0JJVFNfUEVSX0NIQU5ORUwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ19iaXRzW2dyXVtjaF0gPSBMYW1lSW50ZXJuYWxGbGFncy5NQVhfQklUU19QRVJfQ0hBTk5FTDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3VtICs9IHRhcmdfYml0c1tncl1bY2hdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogZm9yIGNoICovXG4gICAgICAgICAgICBpZiAoc3VtID4gTGFtZUludGVybmFsRmxhZ3MuTUFYX0JJVFNfUEVSX0dSQU5VTEUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNoID0gMDsgY2ggPCBnZmMuY2hhbm5lbHNfb3V0OyArK2NoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdfYml0c1tncl1bY2hdICo9IExhbWVJbnRlcm5hbEZsYWdzLk1BWF9CSVRTX1BFUl9HUkFOVUxFO1xuICAgICAgICAgICAgICAgICAgICB0YXJnX2JpdHNbZ3JdW2NoXSAvPSBzdW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qIGZvciBnciAqL1xuXG4gICAgICAgIGlmIChnZmMubW9kZV9leHQgPT0gRW5jb2Rlci5NUEdfTURfTVNfTFIpXG4gICAgICAgICAgICBmb3IgKGdyID0gMDsgZ3IgPCBnZmMubW9kZV9ncjsgZ3IrKykge1xuICAgICAgICAgICAgICAgIHF1cHZ0LnJlZHVjZV9zaWRlKHRhcmdfYml0c1tncl0sIG1zX2VuZXJfcmF0aW9bZ3JdLCBtZWFuX2JpdHNcbiAgICAgICAgICAgICAgICAgICAgKiBnZmMuY2hhbm5lbHNfb3V0LFxuICAgICAgICAgICAgICAgICAgICBMYW1lSW50ZXJuYWxGbGFncy5NQVhfQklUU19QRVJfR1JBTlVMRSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgLypcbiAgICAgICAgICogc3VtIHRhcmdldCBiaXRzXG4gICAgICAgICAqL1xuICAgICAgICB0b3RiaXRzID0gMDtcbiAgICAgICAgZm9yIChnciA9IDA7IGdyIDwgZ2ZjLm1vZGVfZ3I7IGdyKyspIHtcbiAgICAgICAgICAgIGZvciAoY2ggPSAwOyBjaCA8IGdmYy5jaGFubmVsc19vdXQ7IGNoKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ19iaXRzW2dyXVtjaF0gPiBMYW1lSW50ZXJuYWxGbGFncy5NQVhfQklUU19QRVJfQ0hBTk5FTClcbiAgICAgICAgICAgICAgICAgICAgdGFyZ19iaXRzW2dyXVtjaF0gPSBMYW1lSW50ZXJuYWxGbGFncy5NQVhfQklUU19QRVJfQ0hBTk5FTDtcbiAgICAgICAgICAgICAgICB0b3RiaXRzICs9IHRhcmdfYml0c1tncl1bY2hdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLypcbiAgICAgICAgICogcmVwYXJ0aW9uIHRhcmdldCBiaXRzIGlmIG5lZWRlZFxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRvdGJpdHMgPiBtYXhfZnJhbWVfYml0c1swXSkge1xuICAgICAgICAgICAgZm9yIChnciA9IDA7IGdyIDwgZ2ZjLm1vZGVfZ3I7IGdyKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNoID0gMDsgY2ggPCBnZmMuY2hhbm5lbHNfb3V0OyBjaCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdfYml0c1tncl1bY2hdICo9IG1heF9mcmFtZV9iaXRzWzBdO1xuICAgICAgICAgICAgICAgICAgICB0YXJnX2JpdHNbZ3JdW2NoXSAvPSB0b3RiaXRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFF1YW50aXplO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lamejs/src/js/Quantize.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lamejs/src/js/QuantizePVT.js":
/*!***************************************************!*\
  !*** ./node_modules/lamejs/src/js/QuantizePVT.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/*\n *      quantize_pvt source file\n *\n *      Copyright (c) 1999-2002 Takehiro Tominaga\n *      Copyright (c) 2000-2002 Robert Hegemann\n *      Copyright (c) 2001 Naoki Shibata\n *      Copyright (c) 2002-2005 Gabriel Bouvigne\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */\n\n/* $Id: QuantizePVT.java,v 1.24 2011/05/24 20:48:06 kenchis Exp $ */\nvar ScaleFac = __webpack_require__(/*! ./ScaleFac.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/ScaleFac.js\");\nvar common = __webpack_require__(/*! ./common.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/common.js\");\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\nvar Encoder = __webpack_require__(/*! ./Encoder.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/Encoder.js\");\nvar MeanBits = __webpack_require__(/*! ./MeanBits.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/MeanBits.js\");\nvar LameInternalFlags = __webpack_require__(/*! ./LameInternalFlags.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/LameInternalFlags.js\");\n\nQuantizePVT.Q_MAX = (256 + 1);\nQuantizePVT.Q_MAX2 = 116;\nQuantizePVT.LARGE_BITS = 100000;\nQuantizePVT.IXMAX_VAL = 8206;\n\nfunction QuantizePVT() {\n    var BitStream = __webpack_require__(/*! ./BitStream.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/BitStream.js\");\n    var tak = null;\n    var rv = null;\n    var psy = null;\n\n    this.setModules = function (_tk, _rv, _psy) {\n        tak = _tk;\n        rv = _rv;\n        psy = _psy;\n    };\n\n    function POW20(x) {\n        assert(0 <= (x + QuantizePVT.Q_MAX2) && x < QuantizePVT.Q_MAX);\n        return pow20[x + QuantizePVT.Q_MAX2];\n    }\n\n    this.IPOW20 = function (x) {\n        assert(0 <= x && x < QuantizePVT.Q_MAX);\n        return ipow20[x];\n    }\n\n    /**\n     * smallest such that 1.0+DBL_EPSILON != 1.0\n     */\n    var DBL_EPSILON = 2.2204460492503131e-016;\n\n    /**\n     * ix always <= 8191+15. see count_bits()\n     */\n    var IXMAX_VAL = QuantizePVT.IXMAX_VAL;\n\n    var PRECALC_SIZE = (IXMAX_VAL + 2);\n\n    var Q_MAX = QuantizePVT.Q_MAX;\n\n\n    /**\n     * <CODE>\n     * minimum possible number of\n     * -cod_info.global_gain + ((scalefac[] + (cod_info.preflag ? pretab[sfb] : 0))\n     * << (cod_info.scalefac_scale + 1)) + cod_info.subblock_gain[cod_info.window[sfb]] * 8;\n     *\n     * for long block, 0+((15+3)<<2) = 18*4 = 72\n     * for short block, 0+(15<<2)+7*8 = 15*4+56 = 116\n     * </CODE>\n     */\n    var Q_MAX2 = QuantizePVT.Q_MAX2;\n\n    var LARGE_BITS = QuantizePVT.LARGE_BITS;\n\n\n    /**\n     * Assuming dynamic range=96dB, this value should be 92\n     */\n    var NSATHSCALE = 100;\n\n    /**\n     * The following table is used to implement the scalefactor partitioning for\n     * MPEG2 as described in section 2.4.3.2 of the IS. The indexing corresponds\n     * to the way the tables are presented in the IS:\n     *\n     * [table_number][row_in_table][column of nr_of_sfb]\n     */\n    this.nr_of_sfb_block = [\n        [[6, 5, 5, 5], [9, 9, 9, 9], [6, 9, 9, 9]],\n        [[6, 5, 7, 3], [9, 9, 12, 6], [6, 9, 12, 6]],\n        [[11, 10, 0, 0], [18, 18, 0, 0], [15, 18, 0, 0]],\n        [[7, 7, 7, 0], [12, 12, 12, 0], [6, 15, 12, 0]],\n        [[6, 6, 6, 3], [12, 9, 9, 6], [6, 12, 9, 6]],\n        [[8, 8, 5, 0], [15, 12, 9, 0], [6, 18, 9, 0]]];\n\n    /**\n     * Table B.6: layer3 preemphasis\n     */\n    var pretab = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,\n        2, 2, 3, 3, 3, 2, 0];\n    this.pretab = pretab;\n\n    /**\n     * Here are MPEG1 Table B.8 and MPEG2 Table B.1 -- Layer III scalefactor\n     * bands. <BR>\n     * Index into this using a method such as:<BR>\n     * idx = fr_ps.header.sampling_frequency + (fr_ps.header.version * 3)\n     */\n    this.sfBandIndex = [\n        // Table B.2.b: 22.05 kHz\n        new ScaleFac([0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 116, 140, 168, 200, 238, 284, 336, 396, 464,\n                522, 576],\n            [0, 4, 8, 12, 18, 24, 32, 42, 56, 74, 100, 132, 174, 192]\n            , [0, 0, 0, 0, 0, 0, 0] //  sfb21 pseudo sub bands\n            , [0, 0, 0, 0, 0, 0, 0] //  sfb12 pseudo sub bands\n        ),\n        /* Table B.2.c: 24 kHz */ /* docs: 332. mpg123(broken): 330 */\n        new ScaleFac([0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 114, 136, 162, 194, 232, 278, 332, 394, 464,\n                540, 576],\n            [0, 4, 8, 12, 18, 26, 36, 48, 62, 80, 104, 136, 180, 192]\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb21 pseudo sub bands */\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb12 pseudo sub bands */\n        ),\n        /* Table B.2.a: 16 kHz */\n        new ScaleFac([0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 116, 140, 168, 200, 238, 284, 336, 396, 464,\n                522, 576],\n            [0, 4, 8, 12, 18, 26, 36, 48, 62, 80, 104, 134, 174, 192]\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb21 pseudo sub bands */\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb12 pseudo sub bands */\n        ),\n        /* Table B.8.b: 44.1 kHz */\n        new ScaleFac([0, 4, 8, 12, 16, 20, 24, 30, 36, 44, 52, 62, 74, 90, 110, 134, 162, 196, 238, 288, 342, 418,\n                576],\n            [0, 4, 8, 12, 16, 22, 30, 40, 52, 66, 84, 106, 136, 192]\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb21 pseudo sub bands */\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb12 pseudo sub bands */\n        ),\n        /* Table B.8.c: 48 kHz */\n        new ScaleFac([0, 4, 8, 12, 16, 20, 24, 30, 36, 42, 50, 60, 72, 88, 106, 128, 156, 190, 230, 276, 330, 384,\n                576],\n            [0, 4, 8, 12, 16, 22, 28, 38, 50, 64, 80, 100, 126, 192]\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb21 pseudo sub bands */\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb12 pseudo sub bands */\n        ),\n        /* Table B.8.a: 32 kHz */\n        new ScaleFac([0, 4, 8, 12, 16, 20, 24, 30, 36, 44, 54, 66, 82, 102, 126, 156, 194, 240, 296, 364, 448, 550,\n                576],\n            [0, 4, 8, 12, 16, 22, 30, 42, 58, 78, 104, 138, 180, 192]\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb21 pseudo sub bands */\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb12 pseudo sub bands */\n        ),\n        /* MPEG-2.5 11.025 kHz */\n        new ScaleFac([0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 116, 140, 168, 200, 238, 284, 336, 396, 464,\n                522, 576],\n            [0 / 3, 12 / 3, 24 / 3, 36 / 3, 54 / 3, 78 / 3, 108 / 3, 144 / 3, 186 / 3, 240 / 3, 312 / 3,\n                402 / 3, 522 / 3, 576 / 3]\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb21 pseudo sub bands */\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb12 pseudo sub bands */\n        ),\n        /* MPEG-2.5 12 kHz */\n        new ScaleFac([0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 116, 140, 168, 200, 238, 284, 336, 396, 464,\n                522, 576],\n            [0 / 3, 12 / 3, 24 / 3, 36 / 3, 54 / 3, 78 / 3, 108 / 3, 144 / 3, 186 / 3, 240 / 3, 312 / 3,\n                402 / 3, 522 / 3, 576 / 3]\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb21 pseudo sub bands */\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb12 pseudo sub bands */\n        ),\n        /* MPEG-2.5 8 kHz */\n        new ScaleFac([0, 12, 24, 36, 48, 60, 72, 88, 108, 132, 160, 192, 232, 280, 336, 400, 476, 566, 568, 570,\n                572, 574, 576],\n            [0 / 3, 24 / 3, 48 / 3, 72 / 3, 108 / 3, 156 / 3, 216 / 3, 288 / 3, 372 / 3, 480 / 3, 486 / 3,\n                492 / 3, 498 / 3, 576 / 3]\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb21 pseudo sub bands */\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb12 pseudo sub bands */\n        )\n    ];\n\n    var pow20 = new_float(Q_MAX + Q_MAX2 + 1);\n    var ipow20 = new_float(Q_MAX);\n    var pow43 = new_float(PRECALC_SIZE);\n\n    var adj43 = new_float(PRECALC_SIZE);\n    this.adj43 = adj43;\n\n    /**\n     * <PRE>\n     * compute the ATH for each scalefactor band cd range: 0..96db\n     *\n     * Input: 3.3kHz signal 32767 amplitude (3.3kHz is where ATH is smallest =\n     * -5db) longblocks: sfb=12 en0/bw=-11db max_en0 = 1.3db shortblocks: sfb=5\n     * -9db 0db\n     *\n     * Input: 1 1 1 1 1 1 1 -1 -1 -1 -1 -1 -1 -1 (repeated) longblocks: amp=1\n     * sfb=12 en0/bw=-103 db max_en0 = -92db amp=32767 sfb=12 -12 db -1.4db\n     *\n     * Input: 1 1 1 1 1 1 1 -1 -1 -1 -1 -1 -1 -1 (repeated) shortblocks: amp=1\n     * sfb=5 en0/bw= -99 -86 amp=32767 sfb=5 -9 db 4db\n     *\n     *\n     * MAX energy of largest wave at 3.3kHz = 1db AVE energy of largest wave at\n     * 3.3kHz = -11db Let's take AVE: -11db = maximum signal in sfb=12. Dynamic\n     * range of CD: 96db. Therefor energy of smallest audible wave in sfb=12 =\n     * -11 - 96 = -107db = ATH at 3.3kHz.\n     *\n     * ATH formula for this wave: -5db. To adjust to LAME scaling, we need ATH =\n     * ATH_formula - 103 (db) ATH = ATH * 2.5e-10 (ener)\n     * </PRE>\n     */\n    function ATHmdct(gfp, f) {\n        var ath = psy.ATHformula(f, gfp);\n\n        ath -= NSATHSCALE;\n\n        /* modify the MDCT scaling for the ATH and convert to energy */\n        ath = Math.pow(10.0, ath / 10.0 + gfp.ATHlower);\n        return ath;\n    }\n\n    function compute_ath(gfp) {\n        var ATH_l = gfp.internal_flags.ATH.l;\n        var ATH_psfb21 = gfp.internal_flags.ATH.psfb21;\n        var ATH_s = gfp.internal_flags.ATH.s;\n        var ATH_psfb12 = gfp.internal_flags.ATH.psfb12;\n        var gfc = gfp.internal_flags;\n        var samp_freq = gfp.out_samplerate;\n\n        for (var sfb = 0; sfb < Encoder.SBMAX_l; sfb++) {\n            var start = gfc.scalefac_band.l[sfb];\n            var end = gfc.scalefac_band.l[sfb + 1];\n            ATH_l[sfb] = Float.MAX_VALUE;\n            for (var i = start; i < end; i++) {\n                var freq = i * samp_freq / (2 * 576);\n                var ATH_f = ATHmdct(gfp, freq);\n                /* freq in kHz */\n                ATH_l[sfb] = Math.min(ATH_l[sfb], ATH_f);\n            }\n        }\n\n        for (var sfb = 0; sfb < Encoder.PSFB21; sfb++) {\n            var start = gfc.scalefac_band.psfb21[sfb];\n            var end = gfc.scalefac_band.psfb21[sfb + 1];\n            ATH_psfb21[sfb] = Float.MAX_VALUE;\n            for (var i = start; i < end; i++) {\n                var freq = i * samp_freq / (2 * 576);\n                var ATH_f = ATHmdct(gfp, freq);\n                /* freq in kHz */\n                ATH_psfb21[sfb] = Math.min(ATH_psfb21[sfb], ATH_f);\n            }\n        }\n\n        for (var sfb = 0; sfb < Encoder.SBMAX_s; sfb++) {\n            var start = gfc.scalefac_band.s[sfb];\n            var end = gfc.scalefac_band.s[sfb + 1];\n            ATH_s[sfb] = Float.MAX_VALUE;\n            for (var i = start; i < end; i++) {\n                var freq = i * samp_freq / (2 * 192);\n                var ATH_f = ATHmdct(gfp, freq);\n                /* freq in kHz */\n                ATH_s[sfb] = Math.min(ATH_s[sfb], ATH_f);\n            }\n            ATH_s[sfb] *= (gfc.scalefac_band.s[sfb + 1] - gfc.scalefac_band.s[sfb]);\n        }\n\n        for (var sfb = 0; sfb < Encoder.PSFB12; sfb++) {\n            var start = gfc.scalefac_band.psfb12[sfb];\n            var end = gfc.scalefac_band.psfb12[sfb + 1];\n            ATH_psfb12[sfb] = Float.MAX_VALUE;\n            for (var i = start; i < end; i++) {\n                var freq = i * samp_freq / (2 * 192);\n                var ATH_f = ATHmdct(gfp, freq);\n                /* freq in kHz */\n                ATH_psfb12[sfb] = Math.min(ATH_psfb12[sfb], ATH_f);\n            }\n            /* not sure about the following */\n            ATH_psfb12[sfb] *= (gfc.scalefac_band.s[13] - gfc.scalefac_band.s[12]);\n        }\n\n        /*\n         * no-ATH mode: reduce ATH to -200 dB\n         */\n        if (gfp.noATH) {\n            for (var sfb = 0; sfb < Encoder.SBMAX_l; sfb++) {\n                ATH_l[sfb] = 1E-20;\n            }\n            for (var sfb = 0; sfb < Encoder.PSFB21; sfb++) {\n                ATH_psfb21[sfb] = 1E-20;\n            }\n            for (var sfb = 0; sfb < Encoder.SBMAX_s; sfb++) {\n                ATH_s[sfb] = 1E-20;\n            }\n            for (var sfb = 0; sfb < Encoder.PSFB12; sfb++) {\n                ATH_psfb12[sfb] = 1E-20;\n            }\n        }\n\n        /*\n         * work in progress, don't rely on it too much\n         */\n        gfc.ATH.floor = 10. * Math.log10(ATHmdct(gfp, -1.));\n    }\n\n    /**\n     * initialization for iteration_loop\n     */\n    this.iteration_init = function (gfp) {\n        var gfc = gfp.internal_flags;\n        var l3_side = gfc.l3_side;\n        var i;\n\n        if (gfc.iteration_init_init == 0) {\n            gfc.iteration_init_init = 1;\n\n            l3_side.main_data_begin = 0;\n            compute_ath(gfp);\n\n            pow43[0] = 0.0;\n            for (i = 1; i < PRECALC_SIZE; i++)\n                pow43[i] = Math.pow(i, 4.0 / 3.0);\n\n            for (i = 0; i < PRECALC_SIZE - 1; i++)\n                adj43[i] = ((i + 1) - Math.pow(\n                    0.5 * (pow43[i] + pow43[i + 1]), 0.75));\n            adj43[i] = 0.5;\n\n            for (i = 0; i < Q_MAX; i++)\n                ipow20[i] = Math.pow(2.0, (i - 210) * -0.1875);\n            for (i = 0; i <= Q_MAX + Q_MAX2; i++)\n                pow20[i] = Math.pow(2.0, (i - 210 - Q_MAX2) * 0.25);\n\n            tak.huffman_init(gfc);\n\n            {\n                var bass, alto, treble, sfb21;\n\n                i = (gfp.exp_nspsytune >> 2) & 63;\n                if (i >= 32)\n                    i -= 64;\n                bass = Math.pow(10, i / 4.0 / 10.0);\n\n                i = (gfp.exp_nspsytune >> 8) & 63;\n                if (i >= 32)\n                    i -= 64;\n                alto = Math.pow(10, i / 4.0 / 10.0);\n\n                i = (gfp.exp_nspsytune >> 14) & 63;\n                if (i >= 32)\n                    i -= 64;\n                treble = Math.pow(10, i / 4.0 / 10.0);\n\n                /*\n                 * to be compatible with Naoki's original code, the next 6 bits\n                 * define only the amount of changing treble for sfb21\n                 */\n                i = (gfp.exp_nspsytune >> 20) & 63;\n                if (i >= 32)\n                    i -= 64;\n                sfb21 = treble * Math.pow(10, i / 4.0 / 10.0);\n                for (i = 0; i < Encoder.SBMAX_l; i++) {\n                    var f;\n                    if (i <= 6)\n                        f = bass;\n                    else if (i <= 13)\n                        f = alto;\n                    else if (i <= 20)\n                        f = treble;\n                    else\n                        f = sfb21;\n\n                    gfc.nsPsy.longfact[i] = f;\n                }\n                for (i = 0; i < Encoder.SBMAX_s; i++) {\n                    var f;\n                    if (i <= 5)\n                        f = bass;\n                    else if (i <= 10)\n                        f = alto;\n                    else if (i <= 11)\n                        f = treble;\n                    else\n                        f = sfb21;\n\n                    gfc.nsPsy.shortfact[i] = f;\n                }\n            }\n        }\n    }\n\n    /**\n     * allocate bits among 2 channels based on PE<BR>\n     * mt 6/99<BR>\n     * bugfixes rh 8/01: often allocated more than the allowed 4095 bits\n     */\n    this.on_pe = function (gfp, pe,\n                           targ_bits, mean_bits, gr, cbr) {\n        var gfc = gfp.internal_flags;\n        var tbits = 0, bits;\n        var add_bits = new_int(2);\n        var ch;\n\n        /* allocate targ_bits for granule */\n        var mb = new MeanBits(tbits);\n        var extra_bits = rv.ResvMaxBits(gfp, mean_bits, mb, cbr);\n        tbits = mb.bits;\n        /* maximum allowed bits for this granule */\n        var max_bits = tbits + extra_bits;\n        if (max_bits > LameInternalFlags.MAX_BITS_PER_GRANULE) {\n            // hard limit per granule\n            max_bits = LameInternalFlags.MAX_BITS_PER_GRANULE;\n        }\n        for (bits = 0, ch = 0; ch < gfc.channels_out; ++ch) {\n            /******************************************************************\n             * allocate bits for each channel\n             ******************************************************************/\n            targ_bits[ch] = Math.min(LameInternalFlags.MAX_BITS_PER_CHANNEL,\n                tbits / gfc.channels_out);\n\n            add_bits[ch] = 0 | (targ_bits[ch] * pe[gr][ch] / 700.0 - targ_bits[ch]);\n\n            /* at most increase bits by 1.5*average */\n            if (add_bits[ch] > mean_bits * 3 / 4)\n                add_bits[ch] = mean_bits * 3 / 4;\n            if (add_bits[ch] < 0)\n                add_bits[ch] = 0;\n\n            if (add_bits[ch] + targ_bits[ch] > LameInternalFlags.MAX_BITS_PER_CHANNEL)\n                add_bits[ch] = Math.max(0,\n                    LameInternalFlags.MAX_BITS_PER_CHANNEL - targ_bits[ch]);\n\n            bits += add_bits[ch];\n        }\n        if (bits > extra_bits) {\n            for (ch = 0; ch < gfc.channels_out; ++ch) {\n                add_bits[ch] = extra_bits * add_bits[ch] / bits;\n            }\n        }\n\n        for (ch = 0; ch < gfc.channels_out; ++ch) {\n            targ_bits[ch] += add_bits[ch];\n            extra_bits -= add_bits[ch];\n        }\n\n        for (bits = 0, ch = 0; ch < gfc.channels_out; ++ch) {\n            bits += targ_bits[ch];\n        }\n        if (bits > LameInternalFlags.MAX_BITS_PER_GRANULE) {\n            var sum = 0;\n            for (ch = 0; ch < gfc.channels_out; ++ch) {\n                targ_bits[ch] *= LameInternalFlags.MAX_BITS_PER_GRANULE;\n                targ_bits[ch] /= bits;\n                sum += targ_bits[ch];\n            }\n            assert(sum <= LameInternalFlags.MAX_BITS_PER_GRANULE);\n        }\n\n        return max_bits;\n    }\n\n    this.reduce_side = function (targ_bits, ms_ener_ratio, mean_bits, max_bits) {\n        assert(max_bits <= LameInternalFlags.MAX_BITS_PER_GRANULE);\n        assert(targ_bits[0] + targ_bits[1] <= LameInternalFlags.MAX_BITS_PER_GRANULE);\n\n        /*\n         * ms_ener_ratio = 0: allocate 66/33 mid/side fac=.33 ms_ener_ratio =.5:\n         * allocate 50/50 mid/side fac= 0\n         */\n        /* 75/25 split is fac=.5 */\n        var fac = .33 * (.5 - ms_ener_ratio) / .5;\n        if (fac < 0)\n            fac = 0;\n        if (fac > .5)\n            fac = .5;\n\n        /* number of bits to move from side channel to mid channel */\n        /* move_bits = fac*targ_bits[1]; */\n        var move_bits = 0 | (fac * .5 * (targ_bits[0] + targ_bits[1]));\n\n        if (move_bits > LameInternalFlags.MAX_BITS_PER_CHANNEL - targ_bits[0]) {\n            move_bits = LameInternalFlags.MAX_BITS_PER_CHANNEL - targ_bits[0];\n        }\n        if (move_bits < 0)\n            move_bits = 0;\n\n        if (targ_bits[1] >= 125) {\n            /* dont reduce side channel below 125 bits */\n            if (targ_bits[1] - move_bits > 125) {\n\n                /* if mid channel already has 2x more than average, dont bother */\n                /* mean_bits = bits per granule (for both channels) */\n                if (targ_bits[0] < mean_bits)\n                    targ_bits[0] += move_bits;\n                targ_bits[1] -= move_bits;\n            } else {\n                targ_bits[0] += targ_bits[1] - 125;\n                targ_bits[1] = 125;\n            }\n        }\n\n        move_bits = targ_bits[0] + targ_bits[1];\n        if (move_bits > max_bits) {\n            targ_bits[0] = (max_bits * targ_bits[0]) / move_bits;\n            targ_bits[1] = (max_bits * targ_bits[1]) / move_bits;\n        }\n        assert(targ_bits[0] <= LameInternalFlags.MAX_BITS_PER_CHANNEL);\n        assert(targ_bits[1] <= LameInternalFlags.MAX_BITS_PER_CHANNEL);\n        assert(targ_bits[0] + targ_bits[1] <= LameInternalFlags.MAX_BITS_PER_GRANULE);\n    };\n\n    /**\n     *  Robert Hegemann 2001-04-27:\n     *  this adjusts the ATH, keeping the original noise floor\n     *  affects the higher frequencies more than the lower ones\n     */\n    this.athAdjust = function (a, x, athFloor) {\n        /*\n         * work in progress\n         */\n        var o = 90.30873362;\n        var p = 94.82444863;\n        var u = Util.FAST_LOG10_X(x, 10.0);\n        var v = a * a;\n        var w = 0.0;\n        u -= athFloor;\n        /* undo scaling */\n        if (v > 1E-20)\n            w = 1. + Util.FAST_LOG10_X(v, 10.0 / o);\n        if (w < 0)\n            w = 0.;\n        u *= w;\n        u += athFloor + o - p;\n        /* redo scaling */\n\n        return Math.pow(10., 0.1 * u);\n    };\n\n    /**\n     * Calculate the allowed distortion for each scalefactor band, as determined\n     * by the psychoacoustic model. xmin(sb) = ratio(sb) * en(sb) / bw(sb)\n     *\n     * returns number of sfb's with energy > ATH\n     */\n    this.calc_xmin = function (gfp, ratio, cod_info, pxmin) {\n        var pxminPos = 0;\n        var gfc = gfp.internal_flags;\n        var gsfb, j = 0, ath_over = 0;\n        var ATH = gfc.ATH;\n        var xr = cod_info.xr;\n        var enable_athaa_fix = (gfp.VBR == VbrMode.vbr_mtrh) ? 1 : 0;\n        var masking_lower = gfc.masking_lower;\n\n        if (gfp.VBR == VbrMode.vbr_mtrh || gfp.VBR == VbrMode.vbr_mt) {\n            /* was already done in PSY-Model */\n            masking_lower = 1.0;\n        }\n\n        for (gsfb = 0; gsfb < cod_info.psy_lmax; gsfb++) {\n            var en0, xmin;\n            var rh1, rh2;\n            var width, l;\n\n            if (gfp.VBR == VbrMode.vbr_rh || gfp.VBR == VbrMode.vbr_mtrh)\n                xmin = athAdjust(ATH.adjust, ATH.l[gsfb], ATH.floor);\n            else\n                xmin = ATH.adjust * ATH.l[gsfb];\n\n            width = cod_info.width[gsfb];\n            rh1 = xmin / width;\n            rh2 = DBL_EPSILON;\n            l = width >> 1;\n            en0 = 0.0;\n            do {\n                var xa, xb;\n                xa = xr[j] * xr[j];\n                en0 += xa;\n                rh2 += (xa < rh1) ? xa : rh1;\n                j++;\n                xb = xr[j] * xr[j];\n                en0 += xb;\n                rh2 += (xb < rh1) ? xb : rh1;\n                j++;\n            } while (--l > 0);\n            if (en0 > xmin)\n                ath_over++;\n\n            if (gsfb == Encoder.SBPSY_l) {\n                var x = xmin * gfc.nsPsy.longfact[gsfb];\n                if (rh2 < x) {\n                    rh2 = x;\n                }\n            }\n            if (enable_athaa_fix != 0) {\n                xmin = rh2;\n            }\n            if (!gfp.ATHonly) {\n                var e = ratio.en.l[gsfb];\n                if (e > 0.0) {\n                    var x;\n                    x = en0 * ratio.thm.l[gsfb] * masking_lower / e;\n                    if (enable_athaa_fix != 0)\n                        x *= gfc.nsPsy.longfact[gsfb];\n                    if (xmin < x)\n                        xmin = x;\n                }\n            }\n            if (enable_athaa_fix != 0)\n                pxmin[pxminPos++] = xmin;\n            else\n                pxmin[pxminPos++] = xmin * gfc.nsPsy.longfact[gsfb];\n        }\n        /* end of long block loop */\n\n        /* use this function to determine the highest non-zero coeff */\n        var max_nonzero = 575;\n        if (cod_info.block_type != Encoder.SHORT_TYPE) {\n            // NORM, START or STOP type, but not SHORT\n            var k = 576;\n            while (k-- != 0 && BitStream.EQ(xr[k], 0)) {\n                max_nonzero = k;\n            }\n        }\n        cod_info.max_nonzero_coeff = max_nonzero;\n\n        for (var sfb = cod_info.sfb_smin; gsfb < cod_info.psymax; sfb++, gsfb += 3) {\n            var width, b;\n            var tmpATH;\n            if (gfp.VBR == VbrMode.vbr_rh || gfp.VBR == VbrMode.vbr_mtrh)\n                tmpATH = athAdjust(ATH.adjust, ATH.s[sfb], ATH.floor);\n            else\n                tmpATH = ATH.adjust * ATH.s[sfb];\n\n            width = cod_info.width[gsfb];\n            for (b = 0; b < 3; b++) {\n                var en0 = 0.0, xmin;\n                var rh1, rh2;\n                var l = width >> 1;\n\n                rh1 = tmpATH / width;\n                rh2 = DBL_EPSILON;\n                do {\n                    var xa, xb;\n                    xa = xr[j] * xr[j];\n                    en0 += xa;\n                    rh2 += (xa < rh1) ? xa : rh1;\n                    j++;\n                    xb = xr[j] * xr[j];\n                    en0 += xb;\n                    rh2 += (xb < rh1) ? xb : rh1;\n                    j++;\n                } while (--l > 0);\n                if (en0 > tmpATH)\n                    ath_over++;\n                if (sfb == Encoder.SBPSY_s) {\n                    var x = tmpATH * gfc.nsPsy.shortfact[sfb];\n                    if (rh2 < x) {\n                        rh2 = x;\n                    }\n                }\n                if (enable_athaa_fix != 0)\n                    xmin = rh2;\n                else\n                    xmin = tmpATH;\n\n                if (!gfp.ATHonly && !gfp.ATHshort) {\n                    var e = ratio.en.s[sfb][b];\n                    if (e > 0.0) {\n                        var x;\n                        x = en0 * ratio.thm.s[sfb][b] * masking_lower / e;\n                        if (enable_athaa_fix != 0)\n                            x *= gfc.nsPsy.shortfact[sfb];\n                        if (xmin < x)\n                            xmin = x;\n                    }\n                }\n                if (enable_athaa_fix != 0)\n                    pxmin[pxminPos++] = xmin;\n                else\n                    pxmin[pxminPos++] = xmin * gfc.nsPsy.shortfact[sfb];\n            }\n            /* b */\n            if (gfp.useTemporal) {\n                if (pxmin[pxminPos - 3] > pxmin[pxminPos - 3 + 1])\n                    pxmin[pxminPos - 3 + 1] += (pxmin[pxminPos - 3] - pxmin[pxminPos - 3 + 1])\n                        * gfc.decay;\n                if (pxmin[pxminPos - 3 + 1] > pxmin[pxminPos - 3 + 2])\n                    pxmin[pxminPos - 3 + 2] += (pxmin[pxminPos - 3 + 1] - pxmin[pxminPos - 3 + 2])\n                        * gfc.decay;\n            }\n        }\n        /* end of short block sfb loop */\n\n        return ath_over;\n    };\n\n    function StartLine(j) {\n        this.s = j;\n    }\n\n    this.calc_noise_core = function (cod_info, startline, l, step) {\n        var noise = 0;\n        var j = startline.s;\n        var ix = cod_info.l3_enc;\n\n        if (j > cod_info.count1) {\n            while ((l--) != 0) {\n                var temp;\n                temp = cod_info.xr[j];\n                j++;\n                noise += temp * temp;\n                temp = cod_info.xr[j];\n                j++;\n                noise += temp * temp;\n            }\n        } else if (j > cod_info.big_values) {\n            var ix01 = new_float(2);\n            ix01[0] = 0;\n            ix01[1] = step;\n            while ((l--) != 0) {\n                var temp;\n                temp = Math.abs(cod_info.xr[j]) - ix01[ix[j]];\n                j++;\n                noise += temp * temp;\n                temp = Math.abs(cod_info.xr[j]) - ix01[ix[j]];\n                j++;\n                noise += temp * temp;\n            }\n        } else {\n            while ((l--) != 0) {\n                var temp;\n                temp = Math.abs(cod_info.xr[j]) - pow43[ix[j]] * step;\n                j++;\n                noise += temp * temp;\n                temp = Math.abs(cod_info.xr[j]) - pow43[ix[j]] * step;\n                j++;\n                noise += temp * temp;\n            }\n        }\n\n        startline.s = j;\n        return noise;\n    }\n\n    /**\n     * <PRE>\n     * -oo dB  =>  -1.00\n     * - 6 dB  =>  -0.97\n     * - 3 dB  =>  -0.80\n     * - 2 dB  =>  -0.64\n     * - 1 dB  =>  -0.38\n     *   0 dB  =>   0.00\n     * + 1 dB  =>  +0.49\n     * + 2 dB  =>  +1.06\n     * + 3 dB  =>  +1.68\n     * + 6 dB  =>  +3.69\n     * +10 dB  =>  +6.45\n     * </PRE>\n     */\n    this.calc_noise = function (cod_info, l3_xmin, distort, res, prev_noise) {\n        var distortPos = 0;\n        var l3_xminPos = 0;\n        var sfb, l, over = 0;\n        var over_noise_db = 0;\n        /* 0 dB relative to masking */\n        var tot_noise_db = 0;\n        /* -200 dB relative to masking */\n        var max_noise = -20.0;\n        var j = 0;\n        var scalefac = cod_info.scalefac;\n        var scalefacPos = 0;\n\n        res.over_SSD = 0;\n\n        for (sfb = 0; sfb < cod_info.psymax; sfb++) {\n            var s = cod_info.global_gain\n                - (((scalefac[scalefacPos++]) + (cod_info.preflag != 0 ? pretab[sfb]\n                    : 0)) << (cod_info.scalefac_scale + 1))\n                - cod_info.subblock_gain[cod_info.window[sfb]] * 8;\n            var noise = 0.0;\n\n            if (prev_noise != null && (prev_noise.step[sfb] == s)) {\n\n                /* use previously computed values */\n                noise = prev_noise.noise[sfb];\n                j += cod_info.width[sfb];\n                distort[distortPos++] = noise / l3_xmin[l3_xminPos++];\n\n                noise = prev_noise.noise_log[sfb];\n\n            } else {\n                var step = POW20(s);\n                l = cod_info.width[sfb] >> 1;\n\n                if ((j + cod_info.width[sfb]) > cod_info.max_nonzero_coeff) {\n                    var usefullsize;\n                    usefullsize = cod_info.max_nonzero_coeff - j + 1;\n\n                    if (usefullsize > 0)\n                        l = usefullsize >> 1;\n                    else\n                        l = 0;\n                }\n\n                var sl = new StartLine(j);\n                noise = this.calc_noise_core(cod_info, sl, l, step);\n                j = sl.s;\n\n                if (prev_noise != null) {\n                    /* save noise values */\n                    prev_noise.step[sfb] = s;\n                    prev_noise.noise[sfb] = noise;\n                }\n\n                noise = distort[distortPos++] = noise / l3_xmin[l3_xminPos++];\n\n                /* multiplying here is adding in dB, but can overflow */\n                noise = Util.FAST_LOG10(Math.max(noise, 1E-20));\n\n                if (prev_noise != null) {\n                    /* save noise values */\n                    prev_noise.noise_log[sfb] = noise;\n                }\n            }\n\n            if (prev_noise != null) {\n                /* save noise values */\n                prev_noise.global_gain = cod_info.global_gain;\n            }\n\n            tot_noise_db += noise;\n\n            if (noise > 0.0) {\n                var tmp;\n\n                tmp = Math.max(0 | (noise * 10 + .5), 1);\n                res.over_SSD += tmp * tmp;\n\n                over++;\n                /* multiplying here is adding in dB -but can overflow */\n                /* over_noise *= noise; */\n                over_noise_db += noise;\n            }\n            max_noise = Math.max(max_noise, noise);\n\n        }\n\n        res.over_count = over;\n        res.tot_noise = tot_noise_db;\n        res.over_noise = over_noise_db;\n        res.max_noise = max_noise;\n\n        return over;\n    }\n\n    /**\n     * updates plotting data\n     *\n     * Mark Taylor 2000-??-??\n     *\n     * Robert Hegemann: moved noise/distortion calc into it\n     */\n    this.set_pinfo = function (gfp, cod_info, ratio, gr, ch) {\n        var gfc = gfp.internal_flags;\n        var sfb, sfb2;\n        var l;\n        var en0, en1;\n        var ifqstep = (cod_info.scalefac_scale == 0) ? .5 : 1.0;\n        var scalefac = cod_info.scalefac;\n\n        var l3_xmin = new_float(L3Side.SFBMAX);\n        var xfsf = new_float(L3Side.SFBMAX);\n        var noise = new CalcNoiseResult();\n\n        calc_xmin(gfp, ratio, cod_info, l3_xmin);\n        calc_noise(cod_info, l3_xmin, xfsf, noise, null);\n\n        var j = 0;\n        sfb2 = cod_info.sfb_lmax;\n        if (cod_info.block_type != Encoder.SHORT_TYPE\n            && 0 == cod_info.mixed_block_flag)\n            sfb2 = 22;\n        for (sfb = 0; sfb < sfb2; sfb++) {\n            var start = gfc.scalefac_band.l[sfb];\n            var end = gfc.scalefac_band.l[sfb + 1];\n            var bw = end - start;\n            for (en0 = 0.0; j < end; j++)\n                en0 += cod_info.xr[j] * cod_info.xr[j];\n            en0 /= bw;\n            /* convert to MDCT units */\n            /* scaling so it shows up on FFT plot */\n            en1 = 1e15;\n            gfc.pinfo.en[gr][ch][sfb] = en1 * en0;\n            gfc.pinfo.xfsf[gr][ch][sfb] = en1 * l3_xmin[sfb] * xfsf[sfb] / bw;\n\n            if (ratio.en.l[sfb] > 0 && !gfp.ATHonly)\n                en0 = en0 / ratio.en.l[sfb];\n            else\n                en0 = 0.0;\n\n            gfc.pinfo.thr[gr][ch][sfb] = en1\n                * Math.max(en0 * ratio.thm.l[sfb], gfc.ATH.l[sfb]);\n\n            /* there is no scalefactor bands >= SBPSY_l */\n            gfc.pinfo.LAMEsfb[gr][ch][sfb] = 0;\n            if (cod_info.preflag != 0 && sfb >= 11)\n                gfc.pinfo.LAMEsfb[gr][ch][sfb] = -ifqstep * pretab[sfb];\n\n            if (sfb < Encoder.SBPSY_l) {\n                /* scfsi should be decoded by caller side */\n                assert(scalefac[sfb] >= 0);\n                gfc.pinfo.LAMEsfb[gr][ch][sfb] -= ifqstep * scalefac[sfb];\n            }\n        }\n        /* for sfb */\n\n        if (cod_info.block_type == Encoder.SHORT_TYPE) {\n            sfb2 = sfb;\n            for (sfb = cod_info.sfb_smin; sfb < Encoder.SBMAX_s; sfb++) {\n                var start = gfc.scalefac_band.s[sfb];\n                var end = gfc.scalefac_band.s[sfb + 1];\n                var bw = end - start;\n                for (var i = 0; i < 3; i++) {\n                    for (en0 = 0.0, l = start; l < end; l++) {\n                        en0 += cod_info.xr[j] * cod_info.xr[j];\n                        j++;\n                    }\n                    en0 = Math.max(en0 / bw, 1e-20);\n                    /* convert to MDCT units */\n                    /* scaling so it shows up on FFT plot */\n                    en1 = 1e15;\n\n                    gfc.pinfo.en_s[gr][ch][3 * sfb + i] = en1 * en0;\n                    gfc.pinfo.xfsf_s[gr][ch][3 * sfb + i] = en1 * l3_xmin[sfb2]\n                        * xfsf[sfb2] / bw;\n                    if (ratio.en.s[sfb][i] > 0)\n                        en0 = en0 / ratio.en.s[sfb][i];\n                    else\n                        en0 = 0.0;\n                    if (gfp.ATHonly || gfp.ATHshort)\n                        en0 = 0;\n\n                    gfc.pinfo.thr_s[gr][ch][3 * sfb + i] = en1\n                        * Math.max(en0 * ratio.thm.s[sfb][i],\n                            gfc.ATH.s[sfb]);\n\n                    /* there is no scalefactor bands >= SBPSY_s */\n                    gfc.pinfo.LAMEsfb_s[gr][ch][3 * sfb + i] = -2.0\n                        * cod_info.subblock_gain[i];\n                    if (sfb < Encoder.SBPSY_s) {\n                        gfc.pinfo.LAMEsfb_s[gr][ch][3 * sfb + i] -= ifqstep\n                            * scalefac[sfb2];\n                    }\n                    sfb2++;\n                }\n            }\n        }\n        /* block type short */\n        gfc.pinfo.LAMEqss[gr][ch] = cod_info.global_gain;\n        gfc.pinfo.LAMEmainbits[gr][ch] = cod_info.part2_3_length\n            + cod_info.part2_length;\n        gfc.pinfo.LAMEsfbits[gr][ch] = cod_info.part2_length;\n\n        gfc.pinfo.over[gr][ch] = noise.over_count;\n        gfc.pinfo.max_noise[gr][ch] = noise.max_noise * 10.0;\n        gfc.pinfo.over_noise[gr][ch] = noise.over_noise * 10.0;\n        gfc.pinfo.tot_noise[gr][ch] = noise.tot_noise * 10.0;\n        gfc.pinfo.over_SSD[gr][ch] = noise.over_SSD;\n    }\n\n    /**\n     * updates plotting data for a whole frame\n     *\n     * Robert Hegemann 2000-10-21\n     */\n    function set_frame_pinfo(gfp, ratio) {\n        var gfc = gfp.internal_flags;\n\n        gfc.masking_lower = 1.0;\n\n        /*\n         * for every granule and channel patch l3_enc and set info\n         */\n        for (var gr = 0; gr < gfc.mode_gr; gr++) {\n            for (var ch = 0; ch < gfc.channels_out; ch++) {\n                var cod_info = gfc.l3_side.tt[gr][ch];\n                var scalefac_sav = new_int(L3Side.SFBMAX);\n                System.arraycopy(cod_info.scalefac, 0, scalefac_sav, 0,\n                    scalefac_sav.length);\n\n                /*\n                 * reconstruct the scalefactors in case SCFSI was used\n                 */\n                if (gr == 1) {\n                    var sfb;\n                    for (sfb = 0; sfb < cod_info.sfb_lmax; sfb++) {\n                        if (cod_info.scalefac[sfb] < 0) /* scfsi */\n                            cod_info.scalefac[sfb] = gfc.l3_side.tt[0][ch].scalefac[sfb];\n                    }\n                }\n\n                set_pinfo(gfp, cod_info, ratio[gr][ch], gr, ch);\n                System.arraycopy(scalefac_sav, 0, cod_info.scalefac, 0,\n                    scalefac_sav.length);\n            }\n            /* for ch */\n        }\n        /* for gr */\n    }\n\n}\n\nmodule.exports = QuantizePVT;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL1F1YW50aXplUFZULmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxtRkFBZTtBQUN0QyxhQUFhLG1CQUFPLENBQUMsK0VBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLG1CQUFPLENBQUMsaUZBQWM7QUFDcEMsZUFBZSxtQkFBTyxDQUFDLG1GQUFlO0FBQ3RDLHdCQUF3QixtQkFBTyxDQUFDLHFHQUF3Qjs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQyxxRkFBZ0I7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsdUJBQXVCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxTQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsc0JBQXNCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxTQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsdUJBQXVCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxTQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixzQkFBc0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFNBQVM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix1QkFBdUI7QUFDckQ7QUFDQTtBQUNBLDhCQUE4QixzQkFBc0I7QUFDcEQ7QUFDQTtBQUNBLDhCQUE4Qix1QkFBdUI7QUFDckQ7QUFDQTtBQUNBLDhCQUE4QixzQkFBc0I7QUFDcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQzs7QUFFQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix1QkFBdUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsdUJBQXVCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUM7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLDBCQUEwQjtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsd0JBQXdCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyx1QkFBdUI7QUFDakU7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkMsK0NBQStDLFNBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtCQUFrQjtBQUMzQyw2QkFBNkIsdUJBQXVCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MseUJBQXlCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xhbWVqcy9zcmMvanMvUXVhbnRpemVQVlQuanM/MzRmYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogICAgICBxdWFudGl6ZV9wdnQgc291cmNlIGZpbGVcbiAqXG4gKiAgICAgIENvcHlyaWdodCAoYykgMTk5OS0yMDAyIFRha2VoaXJvIFRvbWluYWdhXG4gKiAgICAgIENvcHlyaWdodCAoYykgMjAwMC0yMDAyIFJvYmVydCBIZWdlbWFublxuICogICAgICBDb3B5cmlnaHQgKGMpIDIwMDEgTmFva2kgU2hpYmF0YVxuICogICAgICBDb3B5cmlnaHQgKGMpIDIwMDItMjAwNSBHYWJyaWVsIEJvdXZpZ25lXG4gKlxuICogVGhpcyBsaWJyYXJ5IGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICogbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuICogTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbjsgZWl0aGVyXG4gKiB2ZXJzaW9uIDIgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4gKlxuICogVGhpcyBsaWJyYXJ5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlVcbiAqIExpYnJhcnkgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcbiAqIExpY2Vuc2UgYWxvbmcgd2l0aCB0aGlzIGxpYnJhcnk7IGlmIG5vdCwgd3JpdGUgdG8gdGhlXG4gKiBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCxcbiAqIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuICovXG5cbi8qICRJZDogUXVhbnRpemVQVlQuamF2YSx2IDEuMjQgMjAxMS8wNS8yNCAyMDo0ODowNiBrZW5jaGlzIEV4cCAkICovXG52YXIgU2NhbGVGYWMgPSByZXF1aXJlKCcuL1NjYWxlRmFjLmpzJyk7XG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24uanMnKTtcbnZhciBTeXN0ZW0gPSBjb21tb24uU3lzdGVtO1xudmFyIFZick1vZGUgPSBjb21tb24uVmJyTW9kZTtcbnZhciBGbG9hdCA9IGNvbW1vbi5GbG9hdDtcbnZhciBTaG9ydEJsb2NrID0gY29tbW9uLlNob3J0QmxvY2s7XG52YXIgVXRpbCA9IGNvbW1vbi5VdGlsO1xudmFyIEFycmF5cyA9IGNvbW1vbi5BcnJheXM7XG52YXIgbmV3X2FycmF5X24gPSBjb21tb24ubmV3X2FycmF5X247XG52YXIgbmV3X2J5dGUgPSBjb21tb24ubmV3X2J5dGU7XG52YXIgbmV3X2RvdWJsZSA9IGNvbW1vbi5uZXdfZG91YmxlO1xudmFyIG5ld19mbG9hdCA9IGNvbW1vbi5uZXdfZmxvYXQ7XG52YXIgbmV3X2Zsb2F0X24gPSBjb21tb24ubmV3X2Zsb2F0X247XG52YXIgbmV3X2ludCA9IGNvbW1vbi5uZXdfaW50O1xudmFyIG5ld19pbnRfbiA9IGNvbW1vbi5uZXdfaW50X247XG52YXIgYXNzZXJ0ID0gY29tbW9uLmFzc2VydDtcblxudmFyIEVuY29kZXIgPSByZXF1aXJlKCcuL0VuY29kZXIuanMnKTtcbnZhciBNZWFuQml0cyA9IHJlcXVpcmUoJy4vTWVhbkJpdHMuanMnKTtcbnZhciBMYW1lSW50ZXJuYWxGbGFncyA9IHJlcXVpcmUoJy4vTGFtZUludGVybmFsRmxhZ3MuanMnKTtcblxuUXVhbnRpemVQVlQuUV9NQVggPSAoMjU2ICsgMSk7XG5RdWFudGl6ZVBWVC5RX01BWDIgPSAxMTY7XG5RdWFudGl6ZVBWVC5MQVJHRV9CSVRTID0gMTAwMDAwO1xuUXVhbnRpemVQVlQuSVhNQVhfVkFMID0gODIwNjtcblxuZnVuY3Rpb24gUXVhbnRpemVQVlQoKSB7XG4gICAgdmFyIEJpdFN0cmVhbSA9IHJlcXVpcmUoJy4vQml0U3RyZWFtLmpzJyk7XG4gICAgdmFyIHRhayA9IG51bGw7XG4gICAgdmFyIHJ2ID0gbnVsbDtcbiAgICB2YXIgcHN5ID0gbnVsbDtcblxuICAgIHRoaXMuc2V0TW9kdWxlcyA9IGZ1bmN0aW9uIChfdGssIF9ydiwgX3BzeSkge1xuICAgICAgICB0YWsgPSBfdGs7XG4gICAgICAgIHJ2ID0gX3J2O1xuICAgICAgICBwc3kgPSBfcHN5O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBQT1cyMCh4KSB7XG4gICAgICAgIGFzc2VydCgwIDw9ICh4ICsgUXVhbnRpemVQVlQuUV9NQVgyKSAmJiB4IDwgUXVhbnRpemVQVlQuUV9NQVgpO1xuICAgICAgICByZXR1cm4gcG93MjBbeCArIFF1YW50aXplUFZULlFfTUFYMl07XG4gICAgfVxuXG4gICAgdGhpcy5JUE9XMjAgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICBhc3NlcnQoMCA8PSB4ICYmIHggPCBRdWFudGl6ZVBWVC5RX01BWCk7XG4gICAgICAgIHJldHVybiBpcG93MjBbeF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc21hbGxlc3Qgc3VjaCB0aGF0IDEuMCtEQkxfRVBTSUxPTiAhPSAxLjBcbiAgICAgKi9cbiAgICB2YXIgREJMX0VQU0lMT04gPSAyLjIyMDQ0NjA0OTI1MDMxMzFlLTAxNjtcblxuICAgIC8qKlxuICAgICAqIGl4IGFsd2F5cyA8PSA4MTkxKzE1LiBzZWUgY291bnRfYml0cygpXG4gICAgICovXG4gICAgdmFyIElYTUFYX1ZBTCA9IFF1YW50aXplUFZULklYTUFYX1ZBTDtcblxuICAgIHZhciBQUkVDQUxDX1NJWkUgPSAoSVhNQVhfVkFMICsgMik7XG5cbiAgICB2YXIgUV9NQVggPSBRdWFudGl6ZVBWVC5RX01BWDtcblxuXG4gICAgLyoqXG4gICAgICogPENPREU+XG4gICAgICogbWluaW11bSBwb3NzaWJsZSBudW1iZXIgb2ZcbiAgICAgKiAtY29kX2luZm8uZ2xvYmFsX2dhaW4gKyAoKHNjYWxlZmFjW10gKyAoY29kX2luZm8ucHJlZmxhZyA/IHByZXRhYltzZmJdIDogMCkpXG4gICAgICogPDwgKGNvZF9pbmZvLnNjYWxlZmFjX3NjYWxlICsgMSkpICsgY29kX2luZm8uc3ViYmxvY2tfZ2Fpbltjb2RfaW5mby53aW5kb3dbc2ZiXV0gKiA4O1xuICAgICAqXG4gICAgICogZm9yIGxvbmcgYmxvY2ssIDArKCgxNSszKTw8MikgPSAxOCo0ID0gNzJcbiAgICAgKiBmb3Igc2hvcnQgYmxvY2ssIDArKDE1PDwyKSs3KjggPSAxNSo0KzU2ID0gMTE2XG4gICAgICogPC9DT0RFPlxuICAgICAqL1xuICAgIHZhciBRX01BWDIgPSBRdWFudGl6ZVBWVC5RX01BWDI7XG5cbiAgICB2YXIgTEFSR0VfQklUUyA9IFF1YW50aXplUFZULkxBUkdFX0JJVFM7XG5cblxuICAgIC8qKlxuICAgICAqIEFzc3VtaW5nIGR5bmFtaWMgcmFuZ2U9OTZkQiwgdGhpcyB2YWx1ZSBzaG91bGQgYmUgOTJcbiAgICAgKi9cbiAgICB2YXIgTlNBVEhTQ0FMRSA9IDEwMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmb2xsb3dpbmcgdGFibGUgaXMgdXNlZCB0byBpbXBsZW1lbnQgdGhlIHNjYWxlZmFjdG9yIHBhcnRpdGlvbmluZyBmb3JcbiAgICAgKiBNUEVHMiBhcyBkZXNjcmliZWQgaW4gc2VjdGlvbiAyLjQuMy4yIG9mIHRoZSBJUy4gVGhlIGluZGV4aW5nIGNvcnJlc3BvbmRzXG4gICAgICogdG8gdGhlIHdheSB0aGUgdGFibGVzIGFyZSBwcmVzZW50ZWQgaW4gdGhlIElTOlxuICAgICAqXG4gICAgICogW3RhYmxlX251bWJlcl1bcm93X2luX3RhYmxlXVtjb2x1bW4gb2YgbnJfb2Zfc2ZiXVxuICAgICAqL1xuICAgIHRoaXMubnJfb2Zfc2ZiX2Jsb2NrID0gW1xuICAgICAgICBbWzYsIDUsIDUsIDVdLCBbOSwgOSwgOSwgOV0sIFs2LCA5LCA5LCA5XV0sXG4gICAgICAgIFtbNiwgNSwgNywgM10sIFs5LCA5LCAxMiwgNl0sIFs2LCA5LCAxMiwgNl1dLFxuICAgICAgICBbWzExLCAxMCwgMCwgMF0sIFsxOCwgMTgsIDAsIDBdLCBbMTUsIDE4LCAwLCAwXV0sXG4gICAgICAgIFtbNywgNywgNywgMF0sIFsxMiwgMTIsIDEyLCAwXSwgWzYsIDE1LCAxMiwgMF1dLFxuICAgICAgICBbWzYsIDYsIDYsIDNdLCBbMTIsIDksIDksIDZdLCBbNiwgMTIsIDksIDZdXSxcbiAgICAgICAgW1s4LCA4LCA1LCAwXSwgWzE1LCAxMiwgOSwgMF0sIFs2LCAxOCwgOSwgMF1dXTtcblxuICAgIC8qKlxuICAgICAqIFRhYmxlIEIuNjogbGF5ZXIzIHByZWVtcGhhc2lzXG4gICAgICovXG4gICAgdmFyIHByZXRhYiA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAxLCAxLCAxLCAxLFxuICAgICAgICAyLCAyLCAzLCAzLCAzLCAyLCAwXTtcbiAgICB0aGlzLnByZXRhYiA9IHByZXRhYjtcblxuICAgIC8qKlxuICAgICAqIEhlcmUgYXJlIE1QRUcxIFRhYmxlIEIuOCBhbmQgTVBFRzIgVGFibGUgQi4xIC0tIExheWVyIElJSSBzY2FsZWZhY3RvclxuICAgICAqIGJhbmRzLiA8QlI+XG4gICAgICogSW5kZXggaW50byB0aGlzIHVzaW5nIGEgbWV0aG9kIHN1Y2ggYXM6PEJSPlxuICAgICAqIGlkeCA9IGZyX3BzLmhlYWRlci5zYW1wbGluZ19mcmVxdWVuY3kgKyAoZnJfcHMuaGVhZGVyLnZlcnNpb24gKiAzKVxuICAgICAqL1xuICAgIHRoaXMuc2ZCYW5kSW5kZXggPSBbXG4gICAgICAgIC8vIFRhYmxlIEIuMi5iOiAyMi4wNSBrSHpcbiAgICAgICAgbmV3IFNjYWxlRmFjKFswLCA2LCAxMiwgMTgsIDI0LCAzMCwgMzYsIDQ0LCA1NCwgNjYsIDgwLCA5NiwgMTE2LCAxNDAsIDE2OCwgMjAwLCAyMzgsIDI4NCwgMzM2LCAzOTYsIDQ2NCxcbiAgICAgICAgICAgICAgICA1MjIsIDU3Nl0sXG4gICAgICAgICAgICBbMCwgNCwgOCwgMTIsIDE4LCAyNCwgMzIsIDQyLCA1NiwgNzQsIDEwMCwgMTMyLCAxNzQsIDE5Ml1cbiAgICAgICAgICAgICwgWzAsIDAsIDAsIDAsIDAsIDAsIDBdIC8vICBzZmIyMSBwc2V1ZG8gc3ViIGJhbmRzXG4gICAgICAgICAgICAsIFswLCAwLCAwLCAwLCAwLCAwLCAwXSAvLyAgc2ZiMTIgcHNldWRvIHN1YiBiYW5kc1xuICAgICAgICApLFxuICAgICAgICAvKiBUYWJsZSBCLjIuYzogMjQga0h6ICovIC8qIGRvY3M6IDMzMi4gbXBnMTIzKGJyb2tlbik6IDMzMCAqL1xuICAgICAgICBuZXcgU2NhbGVGYWMoWzAsIDYsIDEyLCAxOCwgMjQsIDMwLCAzNiwgNDQsIDU0LCA2NiwgODAsIDk2LCAxMTQsIDEzNiwgMTYyLCAxOTQsIDIzMiwgMjc4LCAzMzIsIDM5NCwgNDY0LFxuICAgICAgICAgICAgICAgIDU0MCwgNTc2XSxcbiAgICAgICAgICAgIFswLCA0LCA4LCAxMiwgMTgsIDI2LCAzNiwgNDgsIDYyLCA4MCwgMTA0LCAxMzYsIDE4MCwgMTkyXVxuICAgICAgICAgICAgLCBbMCwgMCwgMCwgMCwgMCwgMCwgMF0gLyogIHNmYjIxIHBzZXVkbyBzdWIgYmFuZHMgKi9cbiAgICAgICAgICAgICwgWzAsIDAsIDAsIDAsIDAsIDAsIDBdIC8qICBzZmIxMiBwc2V1ZG8gc3ViIGJhbmRzICovXG4gICAgICAgICksXG4gICAgICAgIC8qIFRhYmxlIEIuMi5hOiAxNiBrSHogKi9cbiAgICAgICAgbmV3IFNjYWxlRmFjKFswLCA2LCAxMiwgMTgsIDI0LCAzMCwgMzYsIDQ0LCA1NCwgNjYsIDgwLCA5NiwgMTE2LCAxNDAsIDE2OCwgMjAwLCAyMzgsIDI4NCwgMzM2LCAzOTYsIDQ2NCxcbiAgICAgICAgICAgICAgICA1MjIsIDU3Nl0sXG4gICAgICAgICAgICBbMCwgNCwgOCwgMTIsIDE4LCAyNiwgMzYsIDQ4LCA2MiwgODAsIDEwNCwgMTM0LCAxNzQsIDE5Ml1cbiAgICAgICAgICAgICwgWzAsIDAsIDAsIDAsIDAsIDAsIDBdIC8qICBzZmIyMSBwc2V1ZG8gc3ViIGJhbmRzICovXG4gICAgICAgICAgICAsIFswLCAwLCAwLCAwLCAwLCAwLCAwXSAvKiAgc2ZiMTIgcHNldWRvIHN1YiBiYW5kcyAqL1xuICAgICAgICApLFxuICAgICAgICAvKiBUYWJsZSBCLjguYjogNDQuMSBrSHogKi9cbiAgICAgICAgbmV3IFNjYWxlRmFjKFswLCA0LCA4LCAxMiwgMTYsIDIwLCAyNCwgMzAsIDM2LCA0NCwgNTIsIDYyLCA3NCwgOTAsIDExMCwgMTM0LCAxNjIsIDE5NiwgMjM4LCAyODgsIDM0MiwgNDE4LFxuICAgICAgICAgICAgICAgIDU3Nl0sXG4gICAgICAgICAgICBbMCwgNCwgOCwgMTIsIDE2LCAyMiwgMzAsIDQwLCA1MiwgNjYsIDg0LCAxMDYsIDEzNiwgMTkyXVxuICAgICAgICAgICAgLCBbMCwgMCwgMCwgMCwgMCwgMCwgMF0gLyogIHNmYjIxIHBzZXVkbyBzdWIgYmFuZHMgKi9cbiAgICAgICAgICAgICwgWzAsIDAsIDAsIDAsIDAsIDAsIDBdIC8qICBzZmIxMiBwc2V1ZG8gc3ViIGJhbmRzICovXG4gICAgICAgICksXG4gICAgICAgIC8qIFRhYmxlIEIuOC5jOiA0OCBrSHogKi9cbiAgICAgICAgbmV3IFNjYWxlRmFjKFswLCA0LCA4LCAxMiwgMTYsIDIwLCAyNCwgMzAsIDM2LCA0MiwgNTAsIDYwLCA3MiwgODgsIDEwNiwgMTI4LCAxNTYsIDE5MCwgMjMwLCAyNzYsIDMzMCwgMzg0LFxuICAgICAgICAgICAgICAgIDU3Nl0sXG4gICAgICAgICAgICBbMCwgNCwgOCwgMTIsIDE2LCAyMiwgMjgsIDM4LCA1MCwgNjQsIDgwLCAxMDAsIDEyNiwgMTkyXVxuICAgICAgICAgICAgLCBbMCwgMCwgMCwgMCwgMCwgMCwgMF0gLyogIHNmYjIxIHBzZXVkbyBzdWIgYmFuZHMgKi9cbiAgICAgICAgICAgICwgWzAsIDAsIDAsIDAsIDAsIDAsIDBdIC8qICBzZmIxMiBwc2V1ZG8gc3ViIGJhbmRzICovXG4gICAgICAgICksXG4gICAgICAgIC8qIFRhYmxlIEIuOC5hOiAzMiBrSHogKi9cbiAgICAgICAgbmV3IFNjYWxlRmFjKFswLCA0LCA4LCAxMiwgMTYsIDIwLCAyNCwgMzAsIDM2LCA0NCwgNTQsIDY2LCA4MiwgMTAyLCAxMjYsIDE1NiwgMTk0LCAyNDAsIDI5NiwgMzY0LCA0NDgsIDU1MCxcbiAgICAgICAgICAgICAgICA1NzZdLFxuICAgICAgICAgICAgWzAsIDQsIDgsIDEyLCAxNiwgMjIsIDMwLCA0MiwgNTgsIDc4LCAxMDQsIDEzOCwgMTgwLCAxOTJdXG4gICAgICAgICAgICAsIFswLCAwLCAwLCAwLCAwLCAwLCAwXSAvKiAgc2ZiMjEgcHNldWRvIHN1YiBiYW5kcyAqL1xuICAgICAgICAgICAgLCBbMCwgMCwgMCwgMCwgMCwgMCwgMF0gLyogIHNmYjEyIHBzZXVkbyBzdWIgYmFuZHMgKi9cbiAgICAgICAgKSxcbiAgICAgICAgLyogTVBFRy0yLjUgMTEuMDI1IGtIeiAqL1xuICAgICAgICBuZXcgU2NhbGVGYWMoWzAsIDYsIDEyLCAxOCwgMjQsIDMwLCAzNiwgNDQsIDU0LCA2NiwgODAsIDk2LCAxMTYsIDE0MCwgMTY4LCAyMDAsIDIzOCwgMjg0LCAzMzYsIDM5NiwgNDY0LFxuICAgICAgICAgICAgICAgIDUyMiwgNTc2XSxcbiAgICAgICAgICAgIFswIC8gMywgMTIgLyAzLCAyNCAvIDMsIDM2IC8gMywgNTQgLyAzLCA3OCAvIDMsIDEwOCAvIDMsIDE0NCAvIDMsIDE4NiAvIDMsIDI0MCAvIDMsIDMxMiAvIDMsXG4gICAgICAgICAgICAgICAgNDAyIC8gMywgNTIyIC8gMywgNTc2IC8gM11cbiAgICAgICAgICAgICwgWzAsIDAsIDAsIDAsIDAsIDAsIDBdIC8qICBzZmIyMSBwc2V1ZG8gc3ViIGJhbmRzICovXG4gICAgICAgICAgICAsIFswLCAwLCAwLCAwLCAwLCAwLCAwXSAvKiAgc2ZiMTIgcHNldWRvIHN1YiBiYW5kcyAqL1xuICAgICAgICApLFxuICAgICAgICAvKiBNUEVHLTIuNSAxMiBrSHogKi9cbiAgICAgICAgbmV3IFNjYWxlRmFjKFswLCA2LCAxMiwgMTgsIDI0LCAzMCwgMzYsIDQ0LCA1NCwgNjYsIDgwLCA5NiwgMTE2LCAxNDAsIDE2OCwgMjAwLCAyMzgsIDI4NCwgMzM2LCAzOTYsIDQ2NCxcbiAgICAgICAgICAgICAgICA1MjIsIDU3Nl0sXG4gICAgICAgICAgICBbMCAvIDMsIDEyIC8gMywgMjQgLyAzLCAzNiAvIDMsIDU0IC8gMywgNzggLyAzLCAxMDggLyAzLCAxNDQgLyAzLCAxODYgLyAzLCAyNDAgLyAzLCAzMTIgLyAzLFxuICAgICAgICAgICAgICAgIDQwMiAvIDMsIDUyMiAvIDMsIDU3NiAvIDNdXG4gICAgICAgICAgICAsIFswLCAwLCAwLCAwLCAwLCAwLCAwXSAvKiAgc2ZiMjEgcHNldWRvIHN1YiBiYW5kcyAqL1xuICAgICAgICAgICAgLCBbMCwgMCwgMCwgMCwgMCwgMCwgMF0gLyogIHNmYjEyIHBzZXVkbyBzdWIgYmFuZHMgKi9cbiAgICAgICAgKSxcbiAgICAgICAgLyogTVBFRy0yLjUgOCBrSHogKi9cbiAgICAgICAgbmV3IFNjYWxlRmFjKFswLCAxMiwgMjQsIDM2LCA0OCwgNjAsIDcyLCA4OCwgMTA4LCAxMzIsIDE2MCwgMTkyLCAyMzIsIDI4MCwgMzM2LCA0MDAsIDQ3NiwgNTY2LCA1NjgsIDU3MCxcbiAgICAgICAgICAgICAgICA1NzIsIDU3NCwgNTc2XSxcbiAgICAgICAgICAgIFswIC8gMywgMjQgLyAzLCA0OCAvIDMsIDcyIC8gMywgMTA4IC8gMywgMTU2IC8gMywgMjE2IC8gMywgMjg4IC8gMywgMzcyIC8gMywgNDgwIC8gMywgNDg2IC8gMyxcbiAgICAgICAgICAgICAgICA0OTIgLyAzLCA0OTggLyAzLCA1NzYgLyAzXVxuICAgICAgICAgICAgLCBbMCwgMCwgMCwgMCwgMCwgMCwgMF0gLyogIHNmYjIxIHBzZXVkbyBzdWIgYmFuZHMgKi9cbiAgICAgICAgICAgICwgWzAsIDAsIDAsIDAsIDAsIDAsIDBdIC8qICBzZmIxMiBwc2V1ZG8gc3ViIGJhbmRzICovXG4gICAgICAgIClcbiAgICBdO1xuXG4gICAgdmFyIHBvdzIwID0gbmV3X2Zsb2F0KFFfTUFYICsgUV9NQVgyICsgMSk7XG4gICAgdmFyIGlwb3cyMCA9IG5ld19mbG9hdChRX01BWCk7XG4gICAgdmFyIHBvdzQzID0gbmV3X2Zsb2F0KFBSRUNBTENfU0laRSk7XG5cbiAgICB2YXIgYWRqNDMgPSBuZXdfZmxvYXQoUFJFQ0FMQ19TSVpFKTtcbiAgICB0aGlzLmFkajQzID0gYWRqNDM7XG5cbiAgICAvKipcbiAgICAgKiA8UFJFPlxuICAgICAqIGNvbXB1dGUgdGhlIEFUSCBmb3IgZWFjaCBzY2FsZWZhY3RvciBiYW5kIGNkIHJhbmdlOiAwLi45NmRiXG4gICAgICpcbiAgICAgKiBJbnB1dDogMy4za0h6IHNpZ25hbCAzMjc2NyBhbXBsaXR1ZGUgKDMuM2tIeiBpcyB3aGVyZSBBVEggaXMgc21hbGxlc3QgPVxuICAgICAqIC01ZGIpIGxvbmdibG9ja3M6IHNmYj0xMiBlbjAvYnc9LTExZGIgbWF4X2VuMCA9IDEuM2RiIHNob3J0YmxvY2tzOiBzZmI9NVxuICAgICAqIC05ZGIgMGRiXG4gICAgICpcbiAgICAgKiBJbnB1dDogMSAxIDEgMSAxIDEgMSAtMSAtMSAtMSAtMSAtMSAtMSAtMSAocmVwZWF0ZWQpIGxvbmdibG9ja3M6IGFtcD0xXG4gICAgICogc2ZiPTEyIGVuMC9idz0tMTAzIGRiIG1heF9lbjAgPSAtOTJkYiBhbXA9MzI3Njcgc2ZiPTEyIC0xMiBkYiAtMS40ZGJcbiAgICAgKlxuICAgICAqIElucHV0OiAxIDEgMSAxIDEgMSAxIC0xIC0xIC0xIC0xIC0xIC0xIC0xIChyZXBlYXRlZCkgc2hvcnRibG9ja3M6IGFtcD0xXG4gICAgICogc2ZiPTUgZW4wL2J3PSAtOTkgLTg2IGFtcD0zMjc2NyBzZmI9NSAtOSBkYiA0ZGJcbiAgICAgKlxuICAgICAqXG4gICAgICogTUFYIGVuZXJneSBvZiBsYXJnZXN0IHdhdmUgYXQgMy4za0h6ID0gMWRiIEFWRSBlbmVyZ3kgb2YgbGFyZ2VzdCB3YXZlIGF0XG4gICAgICogMy4za0h6ID0gLTExZGIgTGV0J3MgdGFrZSBBVkU6IC0xMWRiID0gbWF4aW11bSBzaWduYWwgaW4gc2ZiPTEyLiBEeW5hbWljXG4gICAgICogcmFuZ2Ugb2YgQ0Q6IDk2ZGIuIFRoZXJlZm9yIGVuZXJneSBvZiBzbWFsbGVzdCBhdWRpYmxlIHdhdmUgaW4gc2ZiPTEyID1cbiAgICAgKiAtMTEgLSA5NiA9IC0xMDdkYiA9IEFUSCBhdCAzLjNrSHouXG4gICAgICpcbiAgICAgKiBBVEggZm9ybXVsYSBmb3IgdGhpcyB3YXZlOiAtNWRiLiBUbyBhZGp1c3QgdG8gTEFNRSBzY2FsaW5nLCB3ZSBuZWVkIEFUSCA9XG4gICAgICogQVRIX2Zvcm11bGEgLSAxMDMgKGRiKSBBVEggPSBBVEggKiAyLjVlLTEwIChlbmVyKVxuICAgICAqIDwvUFJFPlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFUSG1kY3QoZ2ZwLCBmKSB7XG4gICAgICAgIHZhciBhdGggPSBwc3kuQVRIZm9ybXVsYShmLCBnZnApO1xuXG4gICAgICAgIGF0aCAtPSBOU0FUSFNDQUxFO1xuXG4gICAgICAgIC8qIG1vZGlmeSB0aGUgTURDVCBzY2FsaW5nIGZvciB0aGUgQVRIIGFuZCBjb252ZXJ0IHRvIGVuZXJneSAqL1xuICAgICAgICBhdGggPSBNYXRoLnBvdygxMC4wLCBhdGggLyAxMC4wICsgZ2ZwLkFUSGxvd2VyKTtcbiAgICAgICAgcmV0dXJuIGF0aDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlX2F0aChnZnApIHtcbiAgICAgICAgdmFyIEFUSF9sID0gZ2ZwLmludGVybmFsX2ZsYWdzLkFUSC5sO1xuICAgICAgICB2YXIgQVRIX3BzZmIyMSA9IGdmcC5pbnRlcm5hbF9mbGFncy5BVEgucHNmYjIxO1xuICAgICAgICB2YXIgQVRIX3MgPSBnZnAuaW50ZXJuYWxfZmxhZ3MuQVRILnM7XG4gICAgICAgIHZhciBBVEhfcHNmYjEyID0gZ2ZwLmludGVybmFsX2ZsYWdzLkFUSC5wc2ZiMTI7XG4gICAgICAgIHZhciBnZmMgPSBnZnAuaW50ZXJuYWxfZmxhZ3M7XG4gICAgICAgIHZhciBzYW1wX2ZyZXEgPSBnZnAub3V0X3NhbXBsZXJhdGU7XG5cbiAgICAgICAgZm9yICh2YXIgc2ZiID0gMDsgc2ZiIDwgRW5jb2Rlci5TQk1BWF9sOyBzZmIrKykge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gZ2ZjLnNjYWxlZmFjX2JhbmQubFtzZmJdO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGdmYy5zY2FsZWZhY19iYW5kLmxbc2ZiICsgMV07XG4gICAgICAgICAgICBBVEhfbFtzZmJdID0gRmxvYXQuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJlcSA9IGkgKiBzYW1wX2ZyZXEgLyAoMiAqIDU3Nik7XG4gICAgICAgICAgICAgICAgdmFyIEFUSF9mID0gQVRIbWRjdChnZnAsIGZyZXEpO1xuICAgICAgICAgICAgICAgIC8qIGZyZXEgaW4ga0h6ICovXG4gICAgICAgICAgICAgICAgQVRIX2xbc2ZiXSA9IE1hdGgubWluKEFUSF9sW3NmYl0sIEFUSF9mKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIHNmYiA9IDA7IHNmYiA8IEVuY29kZXIuUFNGQjIxOyBzZmIrKykge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gZ2ZjLnNjYWxlZmFjX2JhbmQucHNmYjIxW3NmYl07XG4gICAgICAgICAgICB2YXIgZW5kID0gZ2ZjLnNjYWxlZmFjX2JhbmQucHNmYjIxW3NmYiArIDFdO1xuICAgICAgICAgICAgQVRIX3BzZmIyMVtzZmJdID0gRmxvYXQuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJlcSA9IGkgKiBzYW1wX2ZyZXEgLyAoMiAqIDU3Nik7XG4gICAgICAgICAgICAgICAgdmFyIEFUSF9mID0gQVRIbWRjdChnZnAsIGZyZXEpO1xuICAgICAgICAgICAgICAgIC8qIGZyZXEgaW4ga0h6ICovXG4gICAgICAgICAgICAgICAgQVRIX3BzZmIyMVtzZmJdID0gTWF0aC5taW4oQVRIX3BzZmIyMVtzZmJdLCBBVEhfZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBzZmIgPSAwOyBzZmIgPCBFbmNvZGVyLlNCTUFYX3M7IHNmYisrKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBnZmMuc2NhbGVmYWNfYmFuZC5zW3NmYl07XG4gICAgICAgICAgICB2YXIgZW5kID0gZ2ZjLnNjYWxlZmFjX2JhbmQuc1tzZmIgKyAxXTtcbiAgICAgICAgICAgIEFUSF9zW3NmYl0gPSBGbG9hdC5NQVhfVkFMVUU7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBmcmVxID0gaSAqIHNhbXBfZnJlcSAvICgyICogMTkyKTtcbiAgICAgICAgICAgICAgICB2YXIgQVRIX2YgPSBBVEhtZGN0KGdmcCwgZnJlcSk7XG4gICAgICAgICAgICAgICAgLyogZnJlcSBpbiBrSHogKi9cbiAgICAgICAgICAgICAgICBBVEhfc1tzZmJdID0gTWF0aC5taW4oQVRIX3Nbc2ZiXSwgQVRIX2YpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQVRIX3Nbc2ZiXSAqPSAoZ2ZjLnNjYWxlZmFjX2JhbmQuc1tzZmIgKyAxXSAtIGdmYy5zY2FsZWZhY19iYW5kLnNbc2ZiXSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBzZmIgPSAwOyBzZmIgPCBFbmNvZGVyLlBTRkIxMjsgc2ZiKyspIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGdmYy5zY2FsZWZhY19iYW5kLnBzZmIxMltzZmJdO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGdmYy5zY2FsZWZhY19iYW5kLnBzZmIxMltzZmIgKyAxXTtcbiAgICAgICAgICAgIEFUSF9wc2ZiMTJbc2ZiXSA9IEZsb2F0Lk1BWF9WQUxVRTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyZXEgPSBpICogc2FtcF9mcmVxIC8gKDIgKiAxOTIpO1xuICAgICAgICAgICAgICAgIHZhciBBVEhfZiA9IEFUSG1kY3QoZ2ZwLCBmcmVxKTtcbiAgICAgICAgICAgICAgICAvKiBmcmVxIGluIGtIeiAqL1xuICAgICAgICAgICAgICAgIEFUSF9wc2ZiMTJbc2ZiXSA9IE1hdGgubWluKEFUSF9wc2ZiMTJbc2ZiXSwgQVRIX2YpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogbm90IHN1cmUgYWJvdXQgdGhlIGZvbGxvd2luZyAqL1xuICAgICAgICAgICAgQVRIX3BzZmIxMltzZmJdICo9IChnZmMuc2NhbGVmYWNfYmFuZC5zWzEzXSAtIGdmYy5zY2FsZWZhY19iYW5kLnNbMTJdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIG5vLUFUSCBtb2RlOiByZWR1Y2UgQVRIIHRvIC0yMDAgZEJcbiAgICAgICAgICovXG4gICAgICAgIGlmIChnZnAubm9BVEgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHNmYiA9IDA7IHNmYiA8IEVuY29kZXIuU0JNQVhfbDsgc2ZiKyspIHtcbiAgICAgICAgICAgICAgICBBVEhfbFtzZmJdID0gMUUtMjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBzZmIgPSAwOyBzZmIgPCBFbmNvZGVyLlBTRkIyMTsgc2ZiKyspIHtcbiAgICAgICAgICAgICAgICBBVEhfcHNmYjIxW3NmYl0gPSAxRS0yMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIHNmYiA9IDA7IHNmYiA8IEVuY29kZXIuU0JNQVhfczsgc2ZiKyspIHtcbiAgICAgICAgICAgICAgICBBVEhfc1tzZmJdID0gMUUtMjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBzZmIgPSAwOyBzZmIgPCBFbmNvZGVyLlBTRkIxMjsgc2ZiKyspIHtcbiAgICAgICAgICAgICAgICBBVEhfcHNmYjEyW3NmYl0gPSAxRS0yMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIHdvcmsgaW4gcHJvZ3Jlc3MsIGRvbid0IHJlbHkgb24gaXQgdG9vIG11Y2hcbiAgICAgICAgICovXG4gICAgICAgIGdmYy5BVEguZmxvb3IgPSAxMC4gKiBNYXRoLmxvZzEwKEFUSG1kY3QoZ2ZwLCAtMS4pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBpbml0aWFsaXphdGlvbiBmb3IgaXRlcmF0aW9uX2xvb3BcbiAgICAgKi9cbiAgICB0aGlzLml0ZXJhdGlvbl9pbml0ID0gZnVuY3Rpb24gKGdmcCkge1xuICAgICAgICB2YXIgZ2ZjID0gZ2ZwLmludGVybmFsX2ZsYWdzO1xuICAgICAgICB2YXIgbDNfc2lkZSA9IGdmYy5sM19zaWRlO1xuICAgICAgICB2YXIgaTtcblxuICAgICAgICBpZiAoZ2ZjLml0ZXJhdGlvbl9pbml0X2luaXQgPT0gMCkge1xuICAgICAgICAgICAgZ2ZjLml0ZXJhdGlvbl9pbml0X2luaXQgPSAxO1xuXG4gICAgICAgICAgICBsM19zaWRlLm1haW5fZGF0YV9iZWdpbiA9IDA7XG4gICAgICAgICAgICBjb21wdXRlX2F0aChnZnApO1xuXG4gICAgICAgICAgICBwb3c0M1swXSA9IDAuMDtcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBQUkVDQUxDX1NJWkU7IGkrKylcbiAgICAgICAgICAgICAgICBwb3c0M1tpXSA9IE1hdGgucG93KGksIDQuMCAvIDMuMCk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBQUkVDQUxDX1NJWkUgLSAxOyBpKyspXG4gICAgICAgICAgICAgICAgYWRqNDNbaV0gPSAoKGkgKyAxKSAtIE1hdGgucG93KFxuICAgICAgICAgICAgICAgICAgICAwLjUgKiAocG93NDNbaV0gKyBwb3c0M1tpICsgMV0pLCAwLjc1KSk7XG4gICAgICAgICAgICBhZGo0M1tpXSA9IDAuNTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IFFfTUFYOyBpKyspXG4gICAgICAgICAgICAgICAgaXBvdzIwW2ldID0gTWF0aC5wb3coMi4wLCAoaSAtIDIxMCkgKiAtMC4xODc1KTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPD0gUV9NQVggKyBRX01BWDI7IGkrKylcbiAgICAgICAgICAgICAgICBwb3cyMFtpXSA9IE1hdGgucG93KDIuMCwgKGkgLSAyMTAgLSBRX01BWDIpICogMC4yNSk7XG5cbiAgICAgICAgICAgIHRhay5odWZmbWFuX2luaXQoZ2ZjKTtcblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBiYXNzLCBhbHRvLCB0cmVibGUsIHNmYjIxO1xuXG4gICAgICAgICAgICAgICAgaSA9IChnZnAuZXhwX25zcHN5dHVuZSA+PiAyKSAmIDYzO1xuICAgICAgICAgICAgICAgIGlmIChpID49IDMyKVxuICAgICAgICAgICAgICAgICAgICBpIC09IDY0O1xuICAgICAgICAgICAgICAgIGJhc3MgPSBNYXRoLnBvdygxMCwgaSAvIDQuMCAvIDEwLjApO1xuXG4gICAgICAgICAgICAgICAgaSA9IChnZnAuZXhwX25zcHN5dHVuZSA+PiA4KSAmIDYzO1xuICAgICAgICAgICAgICAgIGlmIChpID49IDMyKVxuICAgICAgICAgICAgICAgICAgICBpIC09IDY0O1xuICAgICAgICAgICAgICAgIGFsdG8gPSBNYXRoLnBvdygxMCwgaSAvIDQuMCAvIDEwLjApO1xuXG4gICAgICAgICAgICAgICAgaSA9IChnZnAuZXhwX25zcHN5dHVuZSA+PiAxNCkgJiA2MztcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSAzMilcbiAgICAgICAgICAgICAgICAgICAgaSAtPSA2NDtcbiAgICAgICAgICAgICAgICB0cmVibGUgPSBNYXRoLnBvdygxMCwgaSAvIDQuMCAvIDEwLjApO1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiB0byBiZSBjb21wYXRpYmxlIHdpdGggTmFva2kncyBvcmlnaW5hbCBjb2RlLCB0aGUgbmV4dCA2IGJpdHNcbiAgICAgICAgICAgICAgICAgKiBkZWZpbmUgb25seSB0aGUgYW1vdW50IG9mIGNoYW5naW5nIHRyZWJsZSBmb3Igc2ZiMjFcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpID0gKGdmcC5leHBfbnNwc3l0dW5lID4+IDIwKSAmIDYzO1xuICAgICAgICAgICAgICAgIGlmIChpID49IDMyKVxuICAgICAgICAgICAgICAgICAgICBpIC09IDY0O1xuICAgICAgICAgICAgICAgIHNmYjIxID0gdHJlYmxlICogTWF0aC5wb3coMTAsIGkgLyA0LjAgLyAxMC4wKTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgRW5jb2Rlci5TQk1BWF9sOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGY7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpIDw9IDYpXG4gICAgICAgICAgICAgICAgICAgICAgICBmID0gYmFzcztcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaSA8PSAxMylcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPSBhbHRvO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpIDw9IDIwKVxuICAgICAgICAgICAgICAgICAgICAgICAgZiA9IHRyZWJsZTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgZiA9IHNmYjIxO1xuXG4gICAgICAgICAgICAgICAgICAgIGdmYy5uc1BzeS5sb25nZmFjdFtpXSA9IGY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBFbmNvZGVyLlNCTUFYX3M7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPD0gNSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPSBiYXNzO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpIDw9IDEwKVxuICAgICAgICAgICAgICAgICAgICAgICAgZiA9IGFsdG87XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGkgPD0gMTEpXG4gICAgICAgICAgICAgICAgICAgICAgICBmID0gdHJlYmxlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBmID0gc2ZiMjE7XG5cbiAgICAgICAgICAgICAgICAgICAgZ2ZjLm5zUHN5LnNob3J0ZmFjdFtpXSA9IGY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYWxsb2NhdGUgYml0cyBhbW9uZyAyIGNoYW5uZWxzIGJhc2VkIG9uIFBFPEJSPlxuICAgICAqIG10IDYvOTk8QlI+XG4gICAgICogYnVnZml4ZXMgcmggOC8wMTogb2Z0ZW4gYWxsb2NhdGVkIG1vcmUgdGhhbiB0aGUgYWxsb3dlZCA0MDk1IGJpdHNcbiAgICAgKi9cbiAgICB0aGlzLm9uX3BlID0gZnVuY3Rpb24gKGdmcCwgcGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnX2JpdHMsIG1lYW5fYml0cywgZ3IsIGNicikge1xuICAgICAgICB2YXIgZ2ZjID0gZ2ZwLmludGVybmFsX2ZsYWdzO1xuICAgICAgICB2YXIgdGJpdHMgPSAwLCBiaXRzO1xuICAgICAgICB2YXIgYWRkX2JpdHMgPSBuZXdfaW50KDIpO1xuICAgICAgICB2YXIgY2g7XG5cbiAgICAgICAgLyogYWxsb2NhdGUgdGFyZ19iaXRzIGZvciBncmFudWxlICovXG4gICAgICAgIHZhciBtYiA9IG5ldyBNZWFuQml0cyh0Yml0cyk7XG4gICAgICAgIHZhciBleHRyYV9iaXRzID0gcnYuUmVzdk1heEJpdHMoZ2ZwLCBtZWFuX2JpdHMsIG1iLCBjYnIpO1xuICAgICAgICB0Yml0cyA9IG1iLmJpdHM7XG4gICAgICAgIC8qIG1heGltdW0gYWxsb3dlZCBiaXRzIGZvciB0aGlzIGdyYW51bGUgKi9cbiAgICAgICAgdmFyIG1heF9iaXRzID0gdGJpdHMgKyBleHRyYV9iaXRzO1xuICAgICAgICBpZiAobWF4X2JpdHMgPiBMYW1lSW50ZXJuYWxGbGFncy5NQVhfQklUU19QRVJfR1JBTlVMRSkge1xuICAgICAgICAgICAgLy8gaGFyZCBsaW1pdCBwZXIgZ3JhbnVsZVxuICAgICAgICAgICAgbWF4X2JpdHMgPSBMYW1lSW50ZXJuYWxGbGFncy5NQVhfQklUU19QRVJfR1JBTlVMRTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGJpdHMgPSAwLCBjaCA9IDA7IGNoIDwgZ2ZjLmNoYW5uZWxzX291dDsgKytjaCkge1xuICAgICAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAgICAgICogYWxsb2NhdGUgYml0cyBmb3IgZWFjaCBjaGFubmVsXG4gICAgICAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAgICAgdGFyZ19iaXRzW2NoXSA9IE1hdGgubWluKExhbWVJbnRlcm5hbEZsYWdzLk1BWF9CSVRTX1BFUl9DSEFOTkVMLFxuICAgICAgICAgICAgICAgIHRiaXRzIC8gZ2ZjLmNoYW5uZWxzX291dCk7XG5cbiAgICAgICAgICAgIGFkZF9iaXRzW2NoXSA9IDAgfCAodGFyZ19iaXRzW2NoXSAqIHBlW2dyXVtjaF0gLyA3MDAuMCAtIHRhcmdfYml0c1tjaF0pO1xuXG4gICAgICAgICAgICAvKiBhdCBtb3N0IGluY3JlYXNlIGJpdHMgYnkgMS41KmF2ZXJhZ2UgKi9cbiAgICAgICAgICAgIGlmIChhZGRfYml0c1tjaF0gPiBtZWFuX2JpdHMgKiAzIC8gNClcbiAgICAgICAgICAgICAgICBhZGRfYml0c1tjaF0gPSBtZWFuX2JpdHMgKiAzIC8gNDtcbiAgICAgICAgICAgIGlmIChhZGRfYml0c1tjaF0gPCAwKVxuICAgICAgICAgICAgICAgIGFkZF9iaXRzW2NoXSA9IDA7XG5cbiAgICAgICAgICAgIGlmIChhZGRfYml0c1tjaF0gKyB0YXJnX2JpdHNbY2hdID4gTGFtZUludGVybmFsRmxhZ3MuTUFYX0JJVFNfUEVSX0NIQU5ORUwpXG4gICAgICAgICAgICAgICAgYWRkX2JpdHNbY2hdID0gTWF0aC5tYXgoMCxcbiAgICAgICAgICAgICAgICAgICAgTGFtZUludGVybmFsRmxhZ3MuTUFYX0JJVFNfUEVSX0NIQU5ORUwgLSB0YXJnX2JpdHNbY2hdKTtcblxuICAgICAgICAgICAgYml0cyArPSBhZGRfYml0c1tjaF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJpdHMgPiBleHRyYV9iaXRzKSB7XG4gICAgICAgICAgICBmb3IgKGNoID0gMDsgY2ggPCBnZmMuY2hhbm5lbHNfb3V0OyArK2NoKSB7XG4gICAgICAgICAgICAgICAgYWRkX2JpdHNbY2hdID0gZXh0cmFfYml0cyAqIGFkZF9iaXRzW2NoXSAvIGJpdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNoID0gMDsgY2ggPCBnZmMuY2hhbm5lbHNfb3V0OyArK2NoKSB7XG4gICAgICAgICAgICB0YXJnX2JpdHNbY2hdICs9IGFkZF9iaXRzW2NoXTtcbiAgICAgICAgICAgIGV4dHJhX2JpdHMgLT0gYWRkX2JpdHNbY2hdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChiaXRzID0gMCwgY2ggPSAwOyBjaCA8IGdmYy5jaGFubmVsc19vdXQ7ICsrY2gpIHtcbiAgICAgICAgICAgIGJpdHMgKz0gdGFyZ19iaXRzW2NoXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYml0cyA+IExhbWVJbnRlcm5hbEZsYWdzLk1BWF9CSVRTX1BFUl9HUkFOVUxFKSB7XG4gICAgICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgICAgIGZvciAoY2ggPSAwOyBjaCA8IGdmYy5jaGFubmVsc19vdXQ7ICsrY2gpIHtcbiAgICAgICAgICAgICAgICB0YXJnX2JpdHNbY2hdICo9IExhbWVJbnRlcm5hbEZsYWdzLk1BWF9CSVRTX1BFUl9HUkFOVUxFO1xuICAgICAgICAgICAgICAgIHRhcmdfYml0c1tjaF0gLz0gYml0cztcbiAgICAgICAgICAgICAgICBzdW0gKz0gdGFyZ19iaXRzW2NoXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydChzdW0gPD0gTGFtZUludGVybmFsRmxhZ3MuTUFYX0JJVFNfUEVSX0dSQU5VTEUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1heF9iaXRzO1xuICAgIH1cblxuICAgIHRoaXMucmVkdWNlX3NpZGUgPSBmdW5jdGlvbiAodGFyZ19iaXRzLCBtc19lbmVyX3JhdGlvLCBtZWFuX2JpdHMsIG1heF9iaXRzKSB7XG4gICAgICAgIGFzc2VydChtYXhfYml0cyA8PSBMYW1lSW50ZXJuYWxGbGFncy5NQVhfQklUU19QRVJfR1JBTlVMRSk7XG4gICAgICAgIGFzc2VydCh0YXJnX2JpdHNbMF0gKyB0YXJnX2JpdHNbMV0gPD0gTGFtZUludGVybmFsRmxhZ3MuTUFYX0JJVFNfUEVSX0dSQU5VTEUpO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIG1zX2VuZXJfcmF0aW8gPSAwOiBhbGxvY2F0ZSA2Ni8zMyBtaWQvc2lkZSBmYWM9LjMzIG1zX2VuZXJfcmF0aW8gPS41OlxuICAgICAgICAgKiBhbGxvY2F0ZSA1MC81MCBtaWQvc2lkZSBmYWM9IDBcbiAgICAgICAgICovXG4gICAgICAgIC8qIDc1LzI1IHNwbGl0IGlzIGZhYz0uNSAqL1xuICAgICAgICB2YXIgZmFjID0gLjMzICogKC41IC0gbXNfZW5lcl9yYXRpbykgLyAuNTtcbiAgICAgICAgaWYgKGZhYyA8IDApXG4gICAgICAgICAgICBmYWMgPSAwO1xuICAgICAgICBpZiAoZmFjID4gLjUpXG4gICAgICAgICAgICBmYWMgPSAuNTtcblxuICAgICAgICAvKiBudW1iZXIgb2YgYml0cyB0byBtb3ZlIGZyb20gc2lkZSBjaGFubmVsIHRvIG1pZCBjaGFubmVsICovXG4gICAgICAgIC8qIG1vdmVfYml0cyA9IGZhYyp0YXJnX2JpdHNbMV07ICovXG4gICAgICAgIHZhciBtb3ZlX2JpdHMgPSAwIHwgKGZhYyAqIC41ICogKHRhcmdfYml0c1swXSArIHRhcmdfYml0c1sxXSkpO1xuXG4gICAgICAgIGlmIChtb3ZlX2JpdHMgPiBMYW1lSW50ZXJuYWxGbGFncy5NQVhfQklUU19QRVJfQ0hBTk5FTCAtIHRhcmdfYml0c1swXSkge1xuICAgICAgICAgICAgbW92ZV9iaXRzID0gTGFtZUludGVybmFsRmxhZ3MuTUFYX0JJVFNfUEVSX0NIQU5ORUwgLSB0YXJnX2JpdHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vdmVfYml0cyA8IDApXG4gICAgICAgICAgICBtb3ZlX2JpdHMgPSAwO1xuXG4gICAgICAgIGlmICh0YXJnX2JpdHNbMV0gPj0gMTI1KSB7XG4gICAgICAgICAgICAvKiBkb250IHJlZHVjZSBzaWRlIGNoYW5uZWwgYmVsb3cgMTI1IGJpdHMgKi9cbiAgICAgICAgICAgIGlmICh0YXJnX2JpdHNbMV0gLSBtb3ZlX2JpdHMgPiAxMjUpIHtcblxuICAgICAgICAgICAgICAgIC8qIGlmIG1pZCBjaGFubmVsIGFscmVhZHkgaGFzIDJ4IG1vcmUgdGhhbiBhdmVyYWdlLCBkb250IGJvdGhlciAqL1xuICAgICAgICAgICAgICAgIC8qIG1lYW5fYml0cyA9IGJpdHMgcGVyIGdyYW51bGUgKGZvciBib3RoIGNoYW5uZWxzKSAqL1xuICAgICAgICAgICAgICAgIGlmICh0YXJnX2JpdHNbMF0gPCBtZWFuX2JpdHMpXG4gICAgICAgICAgICAgICAgICAgIHRhcmdfYml0c1swXSArPSBtb3ZlX2JpdHM7XG4gICAgICAgICAgICAgICAgdGFyZ19iaXRzWzFdIC09IG1vdmVfYml0cztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ19iaXRzWzBdICs9IHRhcmdfYml0c1sxXSAtIDEyNTtcbiAgICAgICAgICAgICAgICB0YXJnX2JpdHNbMV0gPSAxMjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtb3ZlX2JpdHMgPSB0YXJnX2JpdHNbMF0gKyB0YXJnX2JpdHNbMV07XG4gICAgICAgIGlmIChtb3ZlX2JpdHMgPiBtYXhfYml0cykge1xuICAgICAgICAgICAgdGFyZ19iaXRzWzBdID0gKG1heF9iaXRzICogdGFyZ19iaXRzWzBdKSAvIG1vdmVfYml0cztcbiAgICAgICAgICAgIHRhcmdfYml0c1sxXSA9IChtYXhfYml0cyAqIHRhcmdfYml0c1sxXSkgLyBtb3ZlX2JpdHM7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KHRhcmdfYml0c1swXSA8PSBMYW1lSW50ZXJuYWxGbGFncy5NQVhfQklUU19QRVJfQ0hBTk5FTCk7XG4gICAgICAgIGFzc2VydCh0YXJnX2JpdHNbMV0gPD0gTGFtZUludGVybmFsRmxhZ3MuTUFYX0JJVFNfUEVSX0NIQU5ORUwpO1xuICAgICAgICBhc3NlcnQodGFyZ19iaXRzWzBdICsgdGFyZ19iaXRzWzFdIDw9IExhbWVJbnRlcm5hbEZsYWdzLk1BWF9CSVRTX1BFUl9HUkFOVUxFKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogIFJvYmVydCBIZWdlbWFubiAyMDAxLTA0LTI3OlxuICAgICAqICB0aGlzIGFkanVzdHMgdGhlIEFUSCwga2VlcGluZyB0aGUgb3JpZ2luYWwgbm9pc2UgZmxvb3JcbiAgICAgKiAgYWZmZWN0cyB0aGUgaGlnaGVyIGZyZXF1ZW5jaWVzIG1vcmUgdGhhbiB0aGUgbG93ZXIgb25lc1xuICAgICAqL1xuICAgIHRoaXMuYXRoQWRqdXN0ID0gZnVuY3Rpb24gKGEsIHgsIGF0aEZsb29yKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAqIHdvcmsgaW4gcHJvZ3Jlc3NcbiAgICAgICAgICovXG4gICAgICAgIHZhciBvID0gOTAuMzA4NzMzNjI7XG4gICAgICAgIHZhciBwID0gOTQuODI0NDQ4NjM7XG4gICAgICAgIHZhciB1ID0gVXRpbC5GQVNUX0xPRzEwX1goeCwgMTAuMCk7XG4gICAgICAgIHZhciB2ID0gYSAqIGE7XG4gICAgICAgIHZhciB3ID0gMC4wO1xuICAgICAgICB1IC09IGF0aEZsb29yO1xuICAgICAgICAvKiB1bmRvIHNjYWxpbmcgKi9cbiAgICAgICAgaWYgKHYgPiAxRS0yMClcbiAgICAgICAgICAgIHcgPSAxLiArIFV0aWwuRkFTVF9MT0cxMF9YKHYsIDEwLjAgLyBvKTtcbiAgICAgICAgaWYgKHcgPCAwKVxuICAgICAgICAgICAgdyA9IDAuO1xuICAgICAgICB1ICo9IHc7XG4gICAgICAgIHUgKz0gYXRoRmxvb3IgKyBvIC0gcDtcbiAgICAgICAgLyogcmVkbyBzY2FsaW5nICovXG5cbiAgICAgICAgcmV0dXJuIE1hdGgucG93KDEwLiwgMC4xICogdSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgYWxsb3dlZCBkaXN0b3J0aW9uIGZvciBlYWNoIHNjYWxlZmFjdG9yIGJhbmQsIGFzIGRldGVybWluZWRcbiAgICAgKiBieSB0aGUgcHN5Y2hvYWNvdXN0aWMgbW9kZWwuIHhtaW4oc2IpID0gcmF0aW8oc2IpICogZW4oc2IpIC8gYncoc2IpXG4gICAgICpcbiAgICAgKiByZXR1cm5zIG51bWJlciBvZiBzZmIncyB3aXRoIGVuZXJneSA+IEFUSFxuICAgICAqL1xuICAgIHRoaXMuY2FsY194bWluID0gZnVuY3Rpb24gKGdmcCwgcmF0aW8sIGNvZF9pbmZvLCBweG1pbikge1xuICAgICAgICB2YXIgcHhtaW5Qb3MgPSAwO1xuICAgICAgICB2YXIgZ2ZjID0gZ2ZwLmludGVybmFsX2ZsYWdzO1xuICAgICAgICB2YXIgZ3NmYiwgaiA9IDAsIGF0aF9vdmVyID0gMDtcbiAgICAgICAgdmFyIEFUSCA9IGdmYy5BVEg7XG4gICAgICAgIHZhciB4ciA9IGNvZF9pbmZvLnhyO1xuICAgICAgICB2YXIgZW5hYmxlX2F0aGFhX2ZpeCA9IChnZnAuVkJSID09IFZick1vZGUudmJyX210cmgpID8gMSA6IDA7XG4gICAgICAgIHZhciBtYXNraW5nX2xvd2VyID0gZ2ZjLm1hc2tpbmdfbG93ZXI7XG5cbiAgICAgICAgaWYgKGdmcC5WQlIgPT0gVmJyTW9kZS52YnJfbXRyaCB8fCBnZnAuVkJSID09IFZick1vZGUudmJyX210KSB7XG4gICAgICAgICAgICAvKiB3YXMgYWxyZWFkeSBkb25lIGluIFBTWS1Nb2RlbCAqL1xuICAgICAgICAgICAgbWFza2luZ19sb3dlciA9IDEuMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoZ3NmYiA9IDA7IGdzZmIgPCBjb2RfaW5mby5wc3lfbG1heDsgZ3NmYisrKSB7XG4gICAgICAgICAgICB2YXIgZW4wLCB4bWluO1xuICAgICAgICAgICAgdmFyIHJoMSwgcmgyO1xuICAgICAgICAgICAgdmFyIHdpZHRoLCBsO1xuXG4gICAgICAgICAgICBpZiAoZ2ZwLlZCUiA9PSBWYnJNb2RlLnZicl9yaCB8fCBnZnAuVkJSID09IFZick1vZGUudmJyX210cmgpXG4gICAgICAgICAgICAgICAgeG1pbiA9IGF0aEFkanVzdChBVEguYWRqdXN0LCBBVEgubFtnc2ZiXSwgQVRILmZsb29yKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB4bWluID0gQVRILmFkanVzdCAqIEFUSC5sW2dzZmJdO1xuXG4gICAgICAgICAgICB3aWR0aCA9IGNvZF9pbmZvLndpZHRoW2dzZmJdO1xuICAgICAgICAgICAgcmgxID0geG1pbiAvIHdpZHRoO1xuICAgICAgICAgICAgcmgyID0gREJMX0VQU0lMT047XG4gICAgICAgICAgICBsID0gd2lkdGggPj4gMTtcbiAgICAgICAgICAgIGVuMCA9IDAuMDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB2YXIgeGEsIHhiO1xuICAgICAgICAgICAgICAgIHhhID0geHJbal0gKiB4cltqXTtcbiAgICAgICAgICAgICAgICBlbjAgKz0geGE7XG4gICAgICAgICAgICAgICAgcmgyICs9ICh4YSA8IHJoMSkgPyB4YSA6IHJoMTtcbiAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgeGIgPSB4cltqXSAqIHhyW2pdO1xuICAgICAgICAgICAgICAgIGVuMCArPSB4YjtcbiAgICAgICAgICAgICAgICByaDIgKz0gKHhiIDwgcmgxKSA/IHhiIDogcmgxO1xuICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIH0gd2hpbGUgKC0tbCA+IDApO1xuICAgICAgICAgICAgaWYgKGVuMCA+IHhtaW4pXG4gICAgICAgICAgICAgICAgYXRoX292ZXIrKztcblxuICAgICAgICAgICAgaWYgKGdzZmIgPT0gRW5jb2Rlci5TQlBTWV9sKSB7XG4gICAgICAgICAgICAgICAgdmFyIHggPSB4bWluICogZ2ZjLm5zUHN5LmxvbmdmYWN0W2dzZmJdO1xuICAgICAgICAgICAgICAgIGlmIChyaDIgPCB4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJoMiA9IHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuYWJsZV9hdGhhYV9maXggIT0gMCkge1xuICAgICAgICAgICAgICAgIHhtaW4gPSByaDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWdmcC5BVEhvbmx5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSByYXRpby5lbi5sW2dzZmJdO1xuICAgICAgICAgICAgICAgIGlmIChlID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4O1xuICAgICAgICAgICAgICAgICAgICB4ID0gZW4wICogcmF0aW8udGhtLmxbZ3NmYl0gKiBtYXNraW5nX2xvd2VyIC8gZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuYWJsZV9hdGhhYV9maXggIT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHggKj0gZ2ZjLm5zUHN5LmxvbmdmYWN0W2dzZmJdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeG1pbiA8IHgpXG4gICAgICAgICAgICAgICAgICAgICAgICB4bWluID0geDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5hYmxlX2F0aGFhX2ZpeCAhPSAwKVxuICAgICAgICAgICAgICAgIHB4bWluW3B4bWluUG9zKytdID0geG1pbjtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBweG1pbltweG1pblBvcysrXSA9IHhtaW4gKiBnZmMubnNQc3kubG9uZ2ZhY3RbZ3NmYl07XG4gICAgICAgIH1cbiAgICAgICAgLyogZW5kIG9mIGxvbmcgYmxvY2sgbG9vcCAqL1xuXG4gICAgICAgIC8qIHVzZSB0aGlzIGZ1bmN0aW9uIHRvIGRldGVybWluZSB0aGUgaGlnaGVzdCBub24temVybyBjb2VmZiAqL1xuICAgICAgICB2YXIgbWF4X25vbnplcm8gPSA1NzU7XG4gICAgICAgIGlmIChjb2RfaW5mby5ibG9ja190eXBlICE9IEVuY29kZXIuU0hPUlRfVFlQRSkge1xuICAgICAgICAgICAgLy8gTk9STSwgU1RBUlQgb3IgU1RPUCB0eXBlLCBidXQgbm90IFNIT1JUXG4gICAgICAgICAgICB2YXIgayA9IDU3NjtcbiAgICAgICAgICAgIHdoaWxlIChrLS0gIT0gMCAmJiBCaXRTdHJlYW0uRVEoeHJba10sIDApKSB7XG4gICAgICAgICAgICAgICAgbWF4X25vbnplcm8gPSBrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvZF9pbmZvLm1heF9ub256ZXJvX2NvZWZmID0gbWF4X25vbnplcm87XG5cbiAgICAgICAgZm9yICh2YXIgc2ZiID0gY29kX2luZm8uc2ZiX3NtaW47IGdzZmIgPCBjb2RfaW5mby5wc3ltYXg7IHNmYisrLCBnc2ZiICs9IDMpIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCwgYjtcbiAgICAgICAgICAgIHZhciB0bXBBVEg7XG4gICAgICAgICAgICBpZiAoZ2ZwLlZCUiA9PSBWYnJNb2RlLnZicl9yaCB8fCBnZnAuVkJSID09IFZick1vZGUudmJyX210cmgpXG4gICAgICAgICAgICAgICAgdG1wQVRIID0gYXRoQWRqdXN0KEFUSC5hZGp1c3QsIEFUSC5zW3NmYl0sIEFUSC5mbG9vcik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdG1wQVRIID0gQVRILmFkanVzdCAqIEFUSC5zW3NmYl07XG5cbiAgICAgICAgICAgIHdpZHRoID0gY29kX2luZm8ud2lkdGhbZ3NmYl07XG4gICAgICAgICAgICBmb3IgKGIgPSAwOyBiIDwgMzsgYisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVuMCA9IDAuMCwgeG1pbjtcbiAgICAgICAgICAgICAgICB2YXIgcmgxLCByaDI7XG4gICAgICAgICAgICAgICAgdmFyIGwgPSB3aWR0aCA+PiAxO1xuXG4gICAgICAgICAgICAgICAgcmgxID0gdG1wQVRIIC8gd2lkdGg7XG4gICAgICAgICAgICAgICAgcmgyID0gREJMX0VQU0lMT047XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeGEsIHhiO1xuICAgICAgICAgICAgICAgICAgICB4YSA9IHhyW2pdICogeHJbal07XG4gICAgICAgICAgICAgICAgICAgIGVuMCArPSB4YTtcbiAgICAgICAgICAgICAgICAgICAgcmgyICs9ICh4YSA8IHJoMSkgPyB4YSA6IHJoMTtcbiAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgICAgICB4YiA9IHhyW2pdICogeHJbal07XG4gICAgICAgICAgICAgICAgICAgIGVuMCArPSB4YjtcbiAgICAgICAgICAgICAgICAgICAgcmgyICs9ICh4YiA8IHJoMSkgPyB4YiA6IHJoMTtcbiAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbCA+IDApO1xuICAgICAgICAgICAgICAgIGlmIChlbjAgPiB0bXBBVEgpXG4gICAgICAgICAgICAgICAgICAgIGF0aF9vdmVyKys7XG4gICAgICAgICAgICAgICAgaWYgKHNmYiA9PSBFbmNvZGVyLlNCUFNZX3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSB0bXBBVEggKiBnZmMubnNQc3kuc2hvcnRmYWN0W3NmYl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChyaDIgPCB4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByaDIgPSB4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlbmFibGVfYXRoYWFfZml4ICE9IDApXG4gICAgICAgICAgICAgICAgICAgIHhtaW4gPSByaDI7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB4bWluID0gdG1wQVRIO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFnZnAuQVRIb25seSAmJiAhZ2ZwLkFUSHNob3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlID0gcmF0aW8uZW4uc1tzZmJdW2JdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZSA+IDAuMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHg7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gZW4wICogcmF0aW8udGhtLnNbc2ZiXVtiXSAqIG1hc2tpbmdfbG93ZXIgLyBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuYWJsZV9hdGhhYV9maXggIT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ICo9IGdmYy5uc1BzeS5zaG9ydGZhY3Rbc2ZiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4bWluIDwgeClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4bWluID0geDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZW5hYmxlX2F0aGFhX2ZpeCAhPSAwKVxuICAgICAgICAgICAgICAgICAgICBweG1pbltweG1pblBvcysrXSA9IHhtaW47XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBweG1pbltweG1pblBvcysrXSA9IHhtaW4gKiBnZmMubnNQc3kuc2hvcnRmYWN0W3NmYl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBiICovXG4gICAgICAgICAgICBpZiAoZ2ZwLnVzZVRlbXBvcmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHB4bWluW3B4bWluUG9zIC0gM10gPiBweG1pbltweG1pblBvcyAtIDMgKyAxXSlcbiAgICAgICAgICAgICAgICAgICAgcHhtaW5bcHhtaW5Qb3MgLSAzICsgMV0gKz0gKHB4bWluW3B4bWluUG9zIC0gM10gLSBweG1pbltweG1pblBvcyAtIDMgKyAxXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICogZ2ZjLmRlY2F5O1xuICAgICAgICAgICAgICAgIGlmIChweG1pbltweG1pblBvcyAtIDMgKyAxXSA+IHB4bWluW3B4bWluUG9zIC0gMyArIDJdKVxuICAgICAgICAgICAgICAgICAgICBweG1pbltweG1pblBvcyAtIDMgKyAyXSArPSAocHhtaW5bcHhtaW5Qb3MgLSAzICsgMV0gLSBweG1pbltweG1pblBvcyAtIDMgKyAyXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICogZ2ZjLmRlY2F5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qIGVuZCBvZiBzaG9ydCBibG9jayBzZmIgbG9vcCAqL1xuXG4gICAgICAgIHJldHVybiBhdGhfb3ZlcjtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gU3RhcnRMaW5lKGopIHtcbiAgICAgICAgdGhpcy5zID0gajtcbiAgICB9XG5cbiAgICB0aGlzLmNhbGNfbm9pc2VfY29yZSA9IGZ1bmN0aW9uIChjb2RfaW5mbywgc3RhcnRsaW5lLCBsLCBzdGVwKSB7XG4gICAgICAgIHZhciBub2lzZSA9IDA7XG4gICAgICAgIHZhciBqID0gc3RhcnRsaW5lLnM7XG4gICAgICAgIHZhciBpeCA9IGNvZF9pbmZvLmwzX2VuYztcblxuICAgICAgICBpZiAoaiA+IGNvZF9pbmZvLmNvdW50MSkge1xuICAgICAgICAgICAgd2hpbGUgKChsLS0pICE9IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVtcDtcbiAgICAgICAgICAgICAgICB0ZW1wID0gY29kX2luZm8ueHJbal07XG4gICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgIG5vaXNlICs9IHRlbXAgKiB0ZW1wO1xuICAgICAgICAgICAgICAgIHRlbXAgPSBjb2RfaW5mby54cltqXTtcbiAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgbm9pc2UgKz0gdGVtcCAqIHRlbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaiA+IGNvZF9pbmZvLmJpZ192YWx1ZXMpIHtcbiAgICAgICAgICAgIHZhciBpeDAxID0gbmV3X2Zsb2F0KDIpO1xuICAgICAgICAgICAgaXgwMVswXSA9IDA7XG4gICAgICAgICAgICBpeDAxWzFdID0gc3RlcDtcbiAgICAgICAgICAgIHdoaWxlICgobC0tKSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXA7XG4gICAgICAgICAgICAgICAgdGVtcCA9IE1hdGguYWJzKGNvZF9pbmZvLnhyW2pdKSAtIGl4MDFbaXhbal1dO1xuICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICBub2lzZSArPSB0ZW1wICogdGVtcDtcbiAgICAgICAgICAgICAgICB0ZW1wID0gTWF0aC5hYnMoY29kX2luZm8ueHJbal0pIC0gaXgwMVtpeFtqXV07XG4gICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgIG5vaXNlICs9IHRlbXAgKiB0ZW1wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKChsLS0pICE9IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVtcDtcbiAgICAgICAgICAgICAgICB0ZW1wID0gTWF0aC5hYnMoY29kX2luZm8ueHJbal0pIC0gcG93NDNbaXhbal1dICogc3RlcDtcbiAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgbm9pc2UgKz0gdGVtcCAqIHRlbXA7XG4gICAgICAgICAgICAgICAgdGVtcCA9IE1hdGguYWJzKGNvZF9pbmZvLnhyW2pdKSAtIHBvdzQzW2l4W2pdXSAqIHN0ZXA7XG4gICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgIG5vaXNlICs9IHRlbXAgKiB0ZW1wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnRsaW5lLnMgPSBqO1xuICAgICAgICByZXR1cm4gbm9pc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogPFBSRT5cbiAgICAgKiAtb28gZEIgID0+ICAtMS4wMFxuICAgICAqIC0gNiBkQiAgPT4gIC0wLjk3XG4gICAgICogLSAzIGRCICA9PiAgLTAuODBcbiAgICAgKiAtIDIgZEIgID0+ICAtMC42NFxuICAgICAqIC0gMSBkQiAgPT4gIC0wLjM4XG4gICAgICogICAwIGRCICA9PiAgIDAuMDBcbiAgICAgKiArIDEgZEIgID0+ICArMC40OVxuICAgICAqICsgMiBkQiAgPT4gICsxLjA2XG4gICAgICogKyAzIGRCICA9PiAgKzEuNjhcbiAgICAgKiArIDYgZEIgID0+ICArMy42OVxuICAgICAqICsxMCBkQiAgPT4gICs2LjQ1XG4gICAgICogPC9QUkU+XG4gICAgICovXG4gICAgdGhpcy5jYWxjX25vaXNlID0gZnVuY3Rpb24gKGNvZF9pbmZvLCBsM194bWluLCBkaXN0b3J0LCByZXMsIHByZXZfbm9pc2UpIHtcbiAgICAgICAgdmFyIGRpc3RvcnRQb3MgPSAwO1xuICAgICAgICB2YXIgbDNfeG1pblBvcyA9IDA7XG4gICAgICAgIHZhciBzZmIsIGwsIG92ZXIgPSAwO1xuICAgICAgICB2YXIgb3Zlcl9ub2lzZV9kYiA9IDA7XG4gICAgICAgIC8qIDAgZEIgcmVsYXRpdmUgdG8gbWFza2luZyAqL1xuICAgICAgICB2YXIgdG90X25vaXNlX2RiID0gMDtcbiAgICAgICAgLyogLTIwMCBkQiByZWxhdGl2ZSB0byBtYXNraW5nICovXG4gICAgICAgIHZhciBtYXhfbm9pc2UgPSAtMjAuMDtcbiAgICAgICAgdmFyIGogPSAwO1xuICAgICAgICB2YXIgc2NhbGVmYWMgPSBjb2RfaW5mby5zY2FsZWZhYztcbiAgICAgICAgdmFyIHNjYWxlZmFjUG9zID0gMDtcblxuICAgICAgICByZXMub3Zlcl9TU0QgPSAwO1xuXG4gICAgICAgIGZvciAoc2ZiID0gMDsgc2ZiIDwgY29kX2luZm8ucHN5bWF4OyBzZmIrKykge1xuICAgICAgICAgICAgdmFyIHMgPSBjb2RfaW5mby5nbG9iYWxfZ2FpblxuICAgICAgICAgICAgICAgIC0gKCgoc2NhbGVmYWNbc2NhbGVmYWNQb3MrK10pICsgKGNvZF9pbmZvLnByZWZsYWcgIT0gMCA/IHByZXRhYltzZmJdXG4gICAgICAgICAgICAgICAgICAgIDogMCkpIDw8IChjb2RfaW5mby5zY2FsZWZhY19zY2FsZSArIDEpKVxuICAgICAgICAgICAgICAgIC0gY29kX2luZm8uc3ViYmxvY2tfZ2Fpbltjb2RfaW5mby53aW5kb3dbc2ZiXV0gKiA4O1xuICAgICAgICAgICAgdmFyIG5vaXNlID0gMC4wO1xuXG4gICAgICAgICAgICBpZiAocHJldl9ub2lzZSAhPSBudWxsICYmIChwcmV2X25vaXNlLnN0ZXBbc2ZiXSA9PSBzKSkge1xuXG4gICAgICAgICAgICAgICAgLyogdXNlIHByZXZpb3VzbHkgY29tcHV0ZWQgdmFsdWVzICovXG4gICAgICAgICAgICAgICAgbm9pc2UgPSBwcmV2X25vaXNlLm5vaXNlW3NmYl07XG4gICAgICAgICAgICAgICAgaiArPSBjb2RfaW5mby53aWR0aFtzZmJdO1xuICAgICAgICAgICAgICAgIGRpc3RvcnRbZGlzdG9ydFBvcysrXSA9IG5vaXNlIC8gbDNfeG1pbltsM194bWluUG9zKytdO1xuXG4gICAgICAgICAgICAgICAgbm9pc2UgPSBwcmV2X25vaXNlLm5vaXNlX2xvZ1tzZmJdO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBzdGVwID0gUE9XMjAocyk7XG4gICAgICAgICAgICAgICAgbCA9IGNvZF9pbmZvLndpZHRoW3NmYl0gPj4gMTtcblxuICAgICAgICAgICAgICAgIGlmICgoaiArIGNvZF9pbmZvLndpZHRoW3NmYl0pID4gY29kX2luZm8ubWF4X25vbnplcm9fY29lZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVzZWZ1bGxzaXplO1xuICAgICAgICAgICAgICAgICAgICB1c2VmdWxsc2l6ZSA9IGNvZF9pbmZvLm1heF9ub256ZXJvX2NvZWZmIC0gaiArIDE7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHVzZWZ1bGxzaXplID4gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIGwgPSB1c2VmdWxsc2l6ZSA+PiAxO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBsID0gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgc2wgPSBuZXcgU3RhcnRMaW5lKGopO1xuICAgICAgICAgICAgICAgIG5vaXNlID0gdGhpcy5jYWxjX25vaXNlX2NvcmUoY29kX2luZm8sIHNsLCBsLCBzdGVwKTtcbiAgICAgICAgICAgICAgICBqID0gc2wucztcblxuICAgICAgICAgICAgICAgIGlmIChwcmV2X25vaXNlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogc2F2ZSBub2lzZSB2YWx1ZXMgKi9cbiAgICAgICAgICAgICAgICAgICAgcHJldl9ub2lzZS5zdGVwW3NmYl0gPSBzO1xuICAgICAgICAgICAgICAgICAgICBwcmV2X25vaXNlLm5vaXNlW3NmYl0gPSBub2lzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBub2lzZSA9IGRpc3RvcnRbZGlzdG9ydFBvcysrXSA9IG5vaXNlIC8gbDNfeG1pbltsM194bWluUG9zKytdO1xuXG4gICAgICAgICAgICAgICAgLyogbXVsdGlwbHlpbmcgaGVyZSBpcyBhZGRpbmcgaW4gZEIsIGJ1dCBjYW4gb3ZlcmZsb3cgKi9cbiAgICAgICAgICAgICAgICBub2lzZSA9IFV0aWwuRkFTVF9MT0cxMChNYXRoLm1heChub2lzZSwgMUUtMjApKTtcblxuICAgICAgICAgICAgICAgIGlmIChwcmV2X25vaXNlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogc2F2ZSBub2lzZSB2YWx1ZXMgKi9cbiAgICAgICAgICAgICAgICAgICAgcHJldl9ub2lzZS5ub2lzZV9sb2dbc2ZiXSA9IG5vaXNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHByZXZfbm9pc2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8qIHNhdmUgbm9pc2UgdmFsdWVzICovXG4gICAgICAgICAgICAgICAgcHJldl9ub2lzZS5nbG9iYWxfZ2FpbiA9IGNvZF9pbmZvLmdsb2JhbF9nYWluO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0b3Rfbm9pc2VfZGIgKz0gbm9pc2U7XG5cbiAgICAgICAgICAgIGlmIChub2lzZSA+IDAuMCkge1xuICAgICAgICAgICAgICAgIHZhciB0bXA7XG5cbiAgICAgICAgICAgICAgICB0bXAgPSBNYXRoLm1heCgwIHwgKG5vaXNlICogMTAgKyAuNSksIDEpO1xuICAgICAgICAgICAgICAgIHJlcy5vdmVyX1NTRCArPSB0bXAgKiB0bXA7XG5cbiAgICAgICAgICAgICAgICBvdmVyKys7XG4gICAgICAgICAgICAgICAgLyogbXVsdGlwbHlpbmcgaGVyZSBpcyBhZGRpbmcgaW4gZEIgLWJ1dCBjYW4gb3ZlcmZsb3cgKi9cbiAgICAgICAgICAgICAgICAvKiBvdmVyX25vaXNlICo9IG5vaXNlOyAqL1xuICAgICAgICAgICAgICAgIG92ZXJfbm9pc2VfZGIgKz0gbm9pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXhfbm9pc2UgPSBNYXRoLm1heChtYXhfbm9pc2UsIG5vaXNlKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmVzLm92ZXJfY291bnQgPSBvdmVyO1xuICAgICAgICByZXMudG90X25vaXNlID0gdG90X25vaXNlX2RiO1xuICAgICAgICByZXMub3Zlcl9ub2lzZSA9IG92ZXJfbm9pc2VfZGI7XG4gICAgICAgIHJlcy5tYXhfbm9pc2UgPSBtYXhfbm9pc2U7XG5cbiAgICAgICAgcmV0dXJuIG92ZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdXBkYXRlcyBwbG90dGluZyBkYXRhXG4gICAgICpcbiAgICAgKiBNYXJrIFRheWxvciAyMDAwLT8/LT8/XG4gICAgICpcbiAgICAgKiBSb2JlcnQgSGVnZW1hbm46IG1vdmVkIG5vaXNlL2Rpc3RvcnRpb24gY2FsYyBpbnRvIGl0XG4gICAgICovXG4gICAgdGhpcy5zZXRfcGluZm8gPSBmdW5jdGlvbiAoZ2ZwLCBjb2RfaW5mbywgcmF0aW8sIGdyLCBjaCkge1xuICAgICAgICB2YXIgZ2ZjID0gZ2ZwLmludGVybmFsX2ZsYWdzO1xuICAgICAgICB2YXIgc2ZiLCBzZmIyO1xuICAgICAgICB2YXIgbDtcbiAgICAgICAgdmFyIGVuMCwgZW4xO1xuICAgICAgICB2YXIgaWZxc3RlcCA9IChjb2RfaW5mby5zY2FsZWZhY19zY2FsZSA9PSAwKSA/IC41IDogMS4wO1xuICAgICAgICB2YXIgc2NhbGVmYWMgPSBjb2RfaW5mby5zY2FsZWZhYztcblxuICAgICAgICB2YXIgbDNfeG1pbiA9IG5ld19mbG9hdChMM1NpZGUuU0ZCTUFYKTtcbiAgICAgICAgdmFyIHhmc2YgPSBuZXdfZmxvYXQoTDNTaWRlLlNGQk1BWCk7XG4gICAgICAgIHZhciBub2lzZSA9IG5ldyBDYWxjTm9pc2VSZXN1bHQoKTtcblxuICAgICAgICBjYWxjX3htaW4oZ2ZwLCByYXRpbywgY29kX2luZm8sIGwzX3htaW4pO1xuICAgICAgICBjYWxjX25vaXNlKGNvZF9pbmZvLCBsM194bWluLCB4ZnNmLCBub2lzZSwgbnVsbCk7XG5cbiAgICAgICAgdmFyIGogPSAwO1xuICAgICAgICBzZmIyID0gY29kX2luZm8uc2ZiX2xtYXg7XG4gICAgICAgIGlmIChjb2RfaW5mby5ibG9ja190eXBlICE9IEVuY29kZXIuU0hPUlRfVFlQRVxuICAgICAgICAgICAgJiYgMCA9PSBjb2RfaW5mby5taXhlZF9ibG9ja19mbGFnKVxuICAgICAgICAgICAgc2ZiMiA9IDIyO1xuICAgICAgICBmb3IgKHNmYiA9IDA7IHNmYiA8IHNmYjI7IHNmYisrKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBnZmMuc2NhbGVmYWNfYmFuZC5sW3NmYl07XG4gICAgICAgICAgICB2YXIgZW5kID0gZ2ZjLnNjYWxlZmFjX2JhbmQubFtzZmIgKyAxXTtcbiAgICAgICAgICAgIHZhciBidyA9IGVuZCAtIHN0YXJ0O1xuICAgICAgICAgICAgZm9yIChlbjAgPSAwLjA7IGogPCBlbmQ7IGorKylcbiAgICAgICAgICAgICAgICBlbjAgKz0gY29kX2luZm8ueHJbal0gKiBjb2RfaW5mby54cltqXTtcbiAgICAgICAgICAgIGVuMCAvPSBidztcbiAgICAgICAgICAgIC8qIGNvbnZlcnQgdG8gTURDVCB1bml0cyAqL1xuICAgICAgICAgICAgLyogc2NhbGluZyBzbyBpdCBzaG93cyB1cCBvbiBGRlQgcGxvdCAqL1xuICAgICAgICAgICAgZW4xID0gMWUxNTtcbiAgICAgICAgICAgIGdmYy5waW5mby5lbltncl1bY2hdW3NmYl0gPSBlbjEgKiBlbjA7XG4gICAgICAgICAgICBnZmMucGluZm8ueGZzZltncl1bY2hdW3NmYl0gPSBlbjEgKiBsM194bWluW3NmYl0gKiB4ZnNmW3NmYl0gLyBidztcblxuICAgICAgICAgICAgaWYgKHJhdGlvLmVuLmxbc2ZiXSA+IDAgJiYgIWdmcC5BVEhvbmx5KVxuICAgICAgICAgICAgICAgIGVuMCA9IGVuMCAvIHJhdGlvLmVuLmxbc2ZiXTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBlbjAgPSAwLjA7XG5cbiAgICAgICAgICAgIGdmYy5waW5mby50aHJbZ3JdW2NoXVtzZmJdID0gZW4xXG4gICAgICAgICAgICAgICAgKiBNYXRoLm1heChlbjAgKiByYXRpby50aG0ubFtzZmJdLCBnZmMuQVRILmxbc2ZiXSk7XG5cbiAgICAgICAgICAgIC8qIHRoZXJlIGlzIG5vIHNjYWxlZmFjdG9yIGJhbmRzID49IFNCUFNZX2wgKi9cbiAgICAgICAgICAgIGdmYy5waW5mby5MQU1Fc2ZiW2dyXVtjaF1bc2ZiXSA9IDA7XG4gICAgICAgICAgICBpZiAoY29kX2luZm8ucHJlZmxhZyAhPSAwICYmIHNmYiA+PSAxMSlcbiAgICAgICAgICAgICAgICBnZmMucGluZm8uTEFNRXNmYltncl1bY2hdW3NmYl0gPSAtaWZxc3RlcCAqIHByZXRhYltzZmJdO1xuXG4gICAgICAgICAgICBpZiAoc2ZiIDwgRW5jb2Rlci5TQlBTWV9sKSB7XG4gICAgICAgICAgICAgICAgLyogc2Nmc2kgc2hvdWxkIGJlIGRlY29kZWQgYnkgY2FsbGVyIHNpZGUgKi9cbiAgICAgICAgICAgICAgICBhc3NlcnQoc2NhbGVmYWNbc2ZiXSA+PSAwKTtcbiAgICAgICAgICAgICAgICBnZmMucGluZm8uTEFNRXNmYltncl1bY2hdW3NmYl0gLT0gaWZxc3RlcCAqIHNjYWxlZmFjW3NmYl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyogZm9yIHNmYiAqL1xuXG4gICAgICAgIGlmIChjb2RfaW5mby5ibG9ja190eXBlID09IEVuY29kZXIuU0hPUlRfVFlQRSkge1xuICAgICAgICAgICAgc2ZiMiA9IHNmYjtcbiAgICAgICAgICAgIGZvciAoc2ZiID0gY29kX2luZm8uc2ZiX3NtaW47IHNmYiA8IEVuY29kZXIuU0JNQVhfczsgc2ZiKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBnZmMuc2NhbGVmYWNfYmFuZC5zW3NmYl07XG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IGdmYy5zY2FsZWZhY19iYW5kLnNbc2ZiICsgMV07XG4gICAgICAgICAgICAgICAgdmFyIGJ3ID0gZW5kIC0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChlbjAgPSAwLjAsIGwgPSBzdGFydDsgbCA8IGVuZDsgbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbjAgKz0gY29kX2luZm8ueHJbal0gKiBjb2RfaW5mby54cltqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbjAgPSBNYXRoLm1heChlbjAgLyBidywgMWUtMjApO1xuICAgICAgICAgICAgICAgICAgICAvKiBjb252ZXJ0IHRvIE1EQ1QgdW5pdHMgKi9cbiAgICAgICAgICAgICAgICAgICAgLyogc2NhbGluZyBzbyBpdCBzaG93cyB1cCBvbiBGRlQgcGxvdCAqL1xuICAgICAgICAgICAgICAgICAgICBlbjEgPSAxZTE1O1xuXG4gICAgICAgICAgICAgICAgICAgIGdmYy5waW5mby5lbl9zW2dyXVtjaF1bMyAqIHNmYiArIGldID0gZW4xICogZW4wO1xuICAgICAgICAgICAgICAgICAgICBnZmMucGluZm8ueGZzZl9zW2dyXVtjaF1bMyAqIHNmYiArIGldID0gZW4xICogbDNfeG1pbltzZmIyXVxuICAgICAgICAgICAgICAgICAgICAgICAgKiB4ZnNmW3NmYjJdIC8gYnc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYXRpby5lbi5zW3NmYl1baV0gPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgZW4wID0gZW4wIC8gcmF0aW8uZW4uc1tzZmJdW2ldO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBlbjAgPSAwLjA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnZnAuQVRIb25seSB8fCBnZnAuQVRIc2hvcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBlbjAgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIGdmYy5waW5mby50aHJfc1tncl1bY2hdWzMgKiBzZmIgKyBpXSA9IGVuMVxuICAgICAgICAgICAgICAgICAgICAgICAgKiBNYXRoLm1heChlbjAgKiByYXRpby50aG0uc1tzZmJdW2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdmYy5BVEguc1tzZmJdKTtcblxuICAgICAgICAgICAgICAgICAgICAvKiB0aGVyZSBpcyBubyBzY2FsZWZhY3RvciBiYW5kcyA+PSBTQlBTWV9zICovXG4gICAgICAgICAgICAgICAgICAgIGdmYy5waW5mby5MQU1Fc2ZiX3NbZ3JdW2NoXVszICogc2ZiICsgaV0gPSAtMi4wXG4gICAgICAgICAgICAgICAgICAgICAgICAqIGNvZF9pbmZvLnN1YmJsb2NrX2dhaW5baV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZmIgPCBFbmNvZGVyLlNCUFNZX3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdmYy5waW5mby5MQU1Fc2ZiX3NbZ3JdW2NoXVszICogc2ZiICsgaV0gLT0gaWZxc3RlcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICogc2NhbGVmYWNbc2ZiMl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2ZiMisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKiBibG9jayB0eXBlIHNob3J0ICovXG4gICAgICAgIGdmYy5waW5mby5MQU1FcXNzW2dyXVtjaF0gPSBjb2RfaW5mby5nbG9iYWxfZ2FpbjtcbiAgICAgICAgZ2ZjLnBpbmZvLkxBTUVtYWluYml0c1tncl1bY2hdID0gY29kX2luZm8ucGFydDJfM19sZW5ndGhcbiAgICAgICAgICAgICsgY29kX2luZm8ucGFydDJfbGVuZ3RoO1xuICAgICAgICBnZmMucGluZm8uTEFNRXNmYml0c1tncl1bY2hdID0gY29kX2luZm8ucGFydDJfbGVuZ3RoO1xuXG4gICAgICAgIGdmYy5waW5mby5vdmVyW2dyXVtjaF0gPSBub2lzZS5vdmVyX2NvdW50O1xuICAgICAgICBnZmMucGluZm8ubWF4X25vaXNlW2dyXVtjaF0gPSBub2lzZS5tYXhfbm9pc2UgKiAxMC4wO1xuICAgICAgICBnZmMucGluZm8ub3Zlcl9ub2lzZVtncl1bY2hdID0gbm9pc2Uub3Zlcl9ub2lzZSAqIDEwLjA7XG4gICAgICAgIGdmYy5waW5mby50b3Rfbm9pc2VbZ3JdW2NoXSA9IG5vaXNlLnRvdF9ub2lzZSAqIDEwLjA7XG4gICAgICAgIGdmYy5waW5mby5vdmVyX1NTRFtncl1bY2hdID0gbm9pc2Uub3Zlcl9TU0Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdXBkYXRlcyBwbG90dGluZyBkYXRhIGZvciBhIHdob2xlIGZyYW1lXG4gICAgICpcbiAgICAgKiBSb2JlcnQgSGVnZW1hbm4gMjAwMC0xMC0yMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldF9mcmFtZV9waW5mbyhnZnAsIHJhdGlvKSB7XG4gICAgICAgIHZhciBnZmMgPSBnZnAuaW50ZXJuYWxfZmxhZ3M7XG5cbiAgICAgICAgZ2ZjLm1hc2tpbmdfbG93ZXIgPSAxLjA7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogZm9yIGV2ZXJ5IGdyYW51bGUgYW5kIGNoYW5uZWwgcGF0Y2ggbDNfZW5jIGFuZCBzZXQgaW5mb1xuICAgICAgICAgKi9cbiAgICAgICAgZm9yICh2YXIgZ3IgPSAwOyBnciA8IGdmYy5tb2RlX2dyOyBncisrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBjaCA9IDA7IGNoIDwgZ2ZjLmNoYW5uZWxzX291dDsgY2grKykge1xuICAgICAgICAgICAgICAgIHZhciBjb2RfaW5mbyA9IGdmYy5sM19zaWRlLnR0W2dyXVtjaF07XG4gICAgICAgICAgICAgICAgdmFyIHNjYWxlZmFjX3NhdiA9IG5ld19pbnQoTDNTaWRlLlNGQk1BWCk7XG4gICAgICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weShjb2RfaW5mby5zY2FsZWZhYywgMCwgc2NhbGVmYWNfc2F2LCAwLFxuICAgICAgICAgICAgICAgICAgICBzY2FsZWZhY19zYXYubGVuZ3RoKTtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogcmVjb25zdHJ1Y3QgdGhlIHNjYWxlZmFjdG9ycyBpbiBjYXNlIFNDRlNJIHdhcyB1c2VkXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKGdyID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNmYjtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChzZmIgPSAwOyBzZmIgPCBjb2RfaW5mby5zZmJfbG1heDsgc2ZiKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RfaW5mby5zY2FsZWZhY1tzZmJdIDwgMCkgLyogc2Nmc2kgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RfaW5mby5zY2FsZWZhY1tzZmJdID0gZ2ZjLmwzX3NpZGUudHRbMF1bY2hdLnNjYWxlZmFjW3NmYl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZXRfcGluZm8oZ2ZwLCBjb2RfaW5mbywgcmF0aW9bZ3JdW2NoXSwgZ3IsIGNoKTtcbiAgICAgICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KHNjYWxlZmFjX3NhdiwgMCwgY29kX2luZm8uc2NhbGVmYWMsIDAsXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlZmFjX3Nhdi5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogZm9yIGNoICovXG4gICAgICAgIH1cbiAgICAgICAgLyogZm9yIGdyICovXG4gICAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gUXVhbnRpemVQVlQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lamejs/src/js/QuantizePVT.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lamejs/src/js/ReplayGain.js":
/*!**************************************************!*\
  !*** ./node_modules/lamejs/src/js/ReplayGain.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var common = __webpack_require__(/*! ./common.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/common.js\");\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\nvar GainAnalysis = __webpack_require__(/*! ./GainAnalysis.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/GainAnalysis.js\");\n\nfunction ReplayGain() {\n    this.linprebuf = new_float(GainAnalysis.MAX_ORDER * 2);\n    /**\n     * left input samples, with pre-buffer\n     */\n    this.linpre = 0;\n    this.lstepbuf = new_float(GainAnalysis.MAX_SAMPLES_PER_WINDOW + GainAnalysis.MAX_ORDER);\n    /**\n     * left \"first step\" (i.e. post first filter) samples\n     */\n    this.lstep = 0;\n    this.loutbuf = new_float(GainAnalysis.MAX_SAMPLES_PER_WINDOW + GainAnalysis.MAX_ORDER);\n    /**\n     * left \"out\" (i.e. post second filter) samples\n     */\n    this.lout = 0;\n    this.rinprebuf = new_float(GainAnalysis.MAX_ORDER * 2);\n    /**\n     * right input samples ...\n     */\n    this.rinpre = 0;\n    this.rstepbuf = new_float(GainAnalysis.MAX_SAMPLES_PER_WINDOW + GainAnalysis.MAX_ORDER);\n    this.rstep = 0;\n    this.routbuf = new_float(GainAnalysis.MAX_SAMPLES_PER_WINDOW + GainAnalysis.MAX_ORDER);\n    this.rout = 0;\n    /**\n     * number of samples required to reach number of milliseconds required\n     * for RMS window\n     */\n    this.sampleWindow = 0;\n    this.totsamp = 0;\n    this.lsum = 0.;\n    this.rsum = 0.;\n    this.freqindex = 0;\n    this.first = 0;\n    this.A = new_int(0 | (GainAnalysis.STEPS_per_dB * GainAnalysis.MAX_dB));\n    this.B = new_int(0 | (GainAnalysis.STEPS_per_dB * GainAnalysis.MAX_dB));\n\n}\n\nmodule.exports = ReplayGain;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL1JlcGxheUdhaW4uanMiLCJtYXBwaW5ncyI6IkFBQUEsYUFBYSxtQkFBTyxDQUFDLCtFQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLG1CQUFPLENBQUMsMkZBQW1COztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbGFtZWpzL3NyYy9qcy9SZXBsYXlHYWluLmpzPzE4YTAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uLmpzJyk7XG52YXIgU3lzdGVtID0gY29tbW9uLlN5c3RlbTtcbnZhciBWYnJNb2RlID0gY29tbW9uLlZick1vZGU7XG52YXIgRmxvYXQgPSBjb21tb24uRmxvYXQ7XG52YXIgU2hvcnRCbG9jayA9IGNvbW1vbi5TaG9ydEJsb2NrO1xudmFyIFV0aWwgPSBjb21tb24uVXRpbDtcbnZhciBBcnJheXMgPSBjb21tb24uQXJyYXlzO1xudmFyIG5ld19hcnJheV9uID0gY29tbW9uLm5ld19hcnJheV9uO1xudmFyIG5ld19ieXRlID0gY29tbW9uLm5ld19ieXRlO1xudmFyIG5ld19kb3VibGUgPSBjb21tb24ubmV3X2RvdWJsZTtcbnZhciBuZXdfZmxvYXQgPSBjb21tb24ubmV3X2Zsb2F0O1xudmFyIG5ld19mbG9hdF9uID0gY29tbW9uLm5ld19mbG9hdF9uO1xudmFyIG5ld19pbnQgPSBjb21tb24ubmV3X2ludDtcbnZhciBuZXdfaW50X24gPSBjb21tb24ubmV3X2ludF9uO1xudmFyIGFzc2VydCA9IGNvbW1vbi5hc3NlcnQ7XG5cbnZhciBHYWluQW5hbHlzaXMgPSByZXF1aXJlKCcuL0dhaW5BbmFseXNpcy5qcycpO1xuXG5mdW5jdGlvbiBSZXBsYXlHYWluKCkge1xuICAgIHRoaXMubGlucHJlYnVmID0gbmV3X2Zsb2F0KEdhaW5BbmFseXNpcy5NQVhfT1JERVIgKiAyKTtcbiAgICAvKipcbiAgICAgKiBsZWZ0IGlucHV0IHNhbXBsZXMsIHdpdGggcHJlLWJ1ZmZlclxuICAgICAqL1xuICAgIHRoaXMubGlucHJlID0gMDtcbiAgICB0aGlzLmxzdGVwYnVmID0gbmV3X2Zsb2F0KEdhaW5BbmFseXNpcy5NQVhfU0FNUExFU19QRVJfV0lORE9XICsgR2FpbkFuYWx5c2lzLk1BWF9PUkRFUik7XG4gICAgLyoqXG4gICAgICogbGVmdCBcImZpcnN0IHN0ZXBcIiAoaS5lLiBwb3N0IGZpcnN0IGZpbHRlcikgc2FtcGxlc1xuICAgICAqL1xuICAgIHRoaXMubHN0ZXAgPSAwO1xuICAgIHRoaXMubG91dGJ1ZiA9IG5ld19mbG9hdChHYWluQW5hbHlzaXMuTUFYX1NBTVBMRVNfUEVSX1dJTkRPVyArIEdhaW5BbmFseXNpcy5NQVhfT1JERVIpO1xuICAgIC8qKlxuICAgICAqIGxlZnQgXCJvdXRcIiAoaS5lLiBwb3N0IHNlY29uZCBmaWx0ZXIpIHNhbXBsZXNcbiAgICAgKi9cbiAgICB0aGlzLmxvdXQgPSAwO1xuICAgIHRoaXMucmlucHJlYnVmID0gbmV3X2Zsb2F0KEdhaW5BbmFseXNpcy5NQVhfT1JERVIgKiAyKTtcbiAgICAvKipcbiAgICAgKiByaWdodCBpbnB1dCBzYW1wbGVzIC4uLlxuICAgICAqL1xuICAgIHRoaXMucmlucHJlID0gMDtcbiAgICB0aGlzLnJzdGVwYnVmID0gbmV3X2Zsb2F0KEdhaW5BbmFseXNpcy5NQVhfU0FNUExFU19QRVJfV0lORE9XICsgR2FpbkFuYWx5c2lzLk1BWF9PUkRFUik7XG4gICAgdGhpcy5yc3RlcCA9IDA7XG4gICAgdGhpcy5yb3V0YnVmID0gbmV3X2Zsb2F0KEdhaW5BbmFseXNpcy5NQVhfU0FNUExFU19QRVJfV0lORE9XICsgR2FpbkFuYWx5c2lzLk1BWF9PUkRFUik7XG4gICAgdGhpcy5yb3V0ID0gMDtcbiAgICAvKipcbiAgICAgKiBudW1iZXIgb2Ygc2FtcGxlcyByZXF1aXJlZCB0byByZWFjaCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHJlcXVpcmVkXG4gICAgICogZm9yIFJNUyB3aW5kb3dcbiAgICAgKi9cbiAgICB0aGlzLnNhbXBsZVdpbmRvdyA9IDA7XG4gICAgdGhpcy50b3RzYW1wID0gMDtcbiAgICB0aGlzLmxzdW0gPSAwLjtcbiAgICB0aGlzLnJzdW0gPSAwLjtcbiAgICB0aGlzLmZyZXFpbmRleCA9IDA7XG4gICAgdGhpcy5maXJzdCA9IDA7XG4gICAgdGhpcy5BID0gbmV3X2ludCgwIHwgKEdhaW5BbmFseXNpcy5TVEVQU19wZXJfZEIgKiBHYWluQW5hbHlzaXMuTUFYX2RCKSk7XG4gICAgdGhpcy5CID0gbmV3X2ludCgwIHwgKEdhaW5BbmFseXNpcy5TVEVQU19wZXJfZEIgKiBHYWluQW5hbHlzaXMuTUFYX2RCKSk7XG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZXBsYXlHYWluO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lamejs/src/js/ReplayGain.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lamejs/src/js/Reservoir.js":
/*!*************************************************!*\
  !*** ./node_modules/lamejs/src/js/Reservoir.js ***!
  \*************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/*\n *      bit reservoir source file\n *\n *      Copyright (c) 1999-2000 Mark Taylor\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */\n\n/* $Id: Reservoir.java,v 1.9 2011/05/24 20:48:06 kenchis Exp $ */\n\n//package mp3;\n\n/**\n * ResvFrameBegin:<BR>\n * Called (repeatedly) at the beginning of a frame. Updates the maximum size of\n * the reservoir, and checks to make sure main_data_begin was set properly by\n * the formatter<BR>\n * Background information:\n * \n * This is the original text from the ISO standard. Because of sooo many bugs\n * and irritations correcting comments are added in brackets []. A '^W' means\n * you should remove the last word.\n * \n * <PRE>\n *  1. The following rule can be used to calculate the maximum\n *     number of bits used for one granule [^W frame]:<BR>\n *     At the highest possible bitrate of Layer III (320 kbps\n *     per stereo signal [^W^W^W], 48 kHz) the frames must be of\n *     [^W^W^W are designed to have] constant length, i.e.\n *     one buffer [^W^W the frame] length is:<BR>\n * \n *         320 kbps * 1152/48 kHz = 7680 bit = 960 byte\n * \n *     This value is used as the maximum buffer per channel [^W^W] at\n *     lower bitrates [than 320 kbps]. At 64 kbps mono or 128 kbps\n *     stereo the main granule length is 64 kbps * 576/48 kHz = 768 bit\n *     [per granule and channel] at 48 kHz sampling frequency.\n *     This means that there is a maximum deviation (short time buffer\n *     [= reservoir]) of 7680 - 2*2*768 = 4608 bits is allowed at 64 kbps.\n *     The actual deviation is equal to the number of bytes [with the\n *     meaning of octets] denoted by the main_data_end offset pointer.\n *     The actual maximum deviation is (2^9-1)*8 bit = 4088 bits\n *     [for MPEG-1 and (2^8-1)*8 bit for MPEG-2, both are hard limits].\n *     ... The xchange of buffer bits between the left and right channel\n *     is allowed without restrictions [exception: dual channel].\n *     Because of the [constructed] constraint on the buffer size\n *     main_data_end is always set to 0 in the case of bit_rate_index==14,\n *     i.e. data rate 320 kbps per stereo signal [^W^W^W]. In this case\n *     all data are allocated between adjacent header [^W sync] words\n *     [, i.e. there is no buffering at all].\n * </PRE>\n */\n\nvar common = __webpack_require__(/*! ./common.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/common.js\");\nvar assert = common.assert;\n\nfunction Reservoir() {\n\tvar bs;\n\n\tthis.setModules  = function(_bs) {\n\t\tbs = _bs;\n\t}\n\n\tthis.ResvFrameBegin = function(gfp, mean_bits) {\n\t\tvar gfc = gfp.internal_flags;\n\t\tvar maxmp3buf;\n\t\tvar l3_side = gfc.l3_side;\n\n\t\tvar frameLength = bs.getframebits(gfp);\n\t\tmean_bits.bits = (frameLength - gfc.sideinfo_len * 8) / gfc.mode_gr;\n\n\t\t/**\n\t\t * <PRE>\n\t\t *  Meaning of the variables:\n\t\t *      resvLimit: (0, 8, ..., 8*255 (MPEG-2), 8*511 (MPEG-1))\n\t\t *          Number of bits can be stored in previous frame(s) due to\n\t\t *          counter size constaints\n\t\t *      maxmp3buf: ( ??? ... 8*1951 (MPEG-1 and 2), 8*2047 (MPEG-2.5))\n\t\t *          Number of bits allowed to encode one frame (you can take 8*511 bit\n\t\t *          from the bit reservoir and at most 8*1440 bit from the current\n\t\t *          frame (320 kbps, 32 kHz), so 8*1951 bit is the largest possible\n\t\t *          value for MPEG-1 and -2)\n\t\t * \n\t\t *          maximum allowed granule/channel size times 4 = 8*2047 bits.,\n\t\t *          so this is the absolute maximum supported by the format.\n\t\t * \n\t\t * \n\t\t *      fullFrameBits:  maximum number of bits available for encoding\n\t\t *                      the current frame.\n\t\t * \n\t\t *      mean_bits:      target number of bits per granule.\n\t\t * \n\t\t *      frameLength:\n\t\t * \n\t\t *      gfc.ResvMax:   maximum allowed reservoir\n\t\t * \n\t\t *      gfc.ResvSize:  current reservoir size\n\t\t * \n\t\t *      l3_side.resvDrain_pre:\n\t\t *         ancillary data to be added to previous frame:\n\t\t *         (only usefull in VBR modes if it is possible to have\n\t\t *         maxmp3buf < fullFrameBits)).  Currently disabled,\n\t\t *         see #define NEW_DRAIN\n\t\t *         2010-02-13: RH now enabled, it seems to be needed for CBR too,\n\t\t *                     as there exists one example, where the FhG decoder\n\t\t *                     can't decode a -b320 CBR file anymore.\n\t\t * \n\t\t *      l3_side.resvDrain_post:\n\t\t *         ancillary data to be added to this frame:\n\t\t * \n\t\t * </PRE>\n\t\t */\n\n\t\t/* main_data_begin has 9 bits in MPEG-1, 8 bits MPEG-2 */\n\t\tvar resvLimit = (8 * 256) * gfc.mode_gr - 8;\n\n\t\t/*\n\t\t * maximum allowed frame size. dont use more than this number of bits,\n\t\t * even if the frame has the space for them:\n\t\t */\n\t\tif (gfp.brate > 320) {\n\t\t\t/* in freeformat the buffer is constant */\n\t\t\tmaxmp3buf = 8 * ((int) ((gfp.brate * 1000)\n\t\t\t\t\t/ (gfp.out_samplerate / 1152) / 8 + .5));\n\t\t} else {\n\t\t\t/*\n\t\t\t * all mp3 decoders should have enough buffer to handle this value:\n\t\t\t * size of a 320kbps 32kHz frame\n\t\t\t */\n\t\t\tmaxmp3buf = 8 * 1440;\n\n\t\t\t/*\n\t\t\t * Bouvigne suggests this more lax interpretation of the ISO doc\n\t\t\t * instead of using 8*960.\n\t\t\t */\n\n\t\t\tif (gfp.strict_ISO) {\n\t\t\t\tmaxmp3buf = 8 * ((int) (320000 / (gfp.out_samplerate / 1152) / 8 + .5));\n\t\t\t}\n\t\t}\n\n\t\tgfc.ResvMax = maxmp3buf - frameLength;\n\t\tif (gfc.ResvMax > resvLimit)\n\t\t\tgfc.ResvMax = resvLimit;\n\t\tif (gfc.ResvMax < 0 || gfp.disable_reservoir)\n\t\t\tgfc.ResvMax = 0;\n\n\t\tvar fullFrameBits = mean_bits.bits * gfc.mode_gr\n\t\t\t\t+ Math.min(gfc.ResvSize, gfc.ResvMax);\n\n\t\tif (fullFrameBits > maxmp3buf)\n\t\t\tfullFrameBits = maxmp3buf;\n\n\t\tassert (0 == gfc.ResvMax % 8);\n\t\tassert (gfc.ResvMax >= 0);\n\n\t\tl3_side.resvDrain_pre = 0;\n\n\t\t// frame analyzer code\n\t\tif (gfc.pinfo != null) {\n\t\t\t/*\n\t\t\t * expected bits per channel per granule [is this also right for\n\t\t\t * mono/stereo, MPEG-1/2 ?]\n\t\t\t */\n\t\t\tgfc.pinfo.mean_bits = mean_bits.bits / 2;\n\t\t\tgfc.pinfo.resvsize = gfc.ResvSize;\n\t\t}\n\n\t\treturn fullFrameBits;\n\t}\n\n\t/**\n\t * returns targ_bits: target number of bits to use for 1 granule<BR>\n\t * extra_bits: amount extra available from reservoir<BR>\n\t * Mark Taylor 4/99\n\t */\n\tthis.ResvMaxBits = function(gfp, mean_bits, targ_bits, cbr) {\n\t\tvar gfc = gfp.internal_flags;\n\t\tvar add_bits;\n        var ResvSize = gfc.ResvSize, ResvMax = gfc.ResvMax;\n\n\t\t/* compensate the saved bits used in the 1st granule */\n\t\tif (cbr != 0)\n\t\t\tResvSize += mean_bits;\n\n\t\tif ((gfc.substep_shaping & 1) != 0)\n\t\t\tResvMax *= 0.9;\n\n\t\ttarg_bits.bits = mean_bits;\n\n\t\t/* extra bits if the reservoir is almost full */\n\t\tif (ResvSize * 10 > ResvMax * 9) {\n\t\t\tadd_bits = ResvSize - (ResvMax * 9) / 10;\n\t\t\ttarg_bits.bits += add_bits;\n\t\t\tgfc.substep_shaping |= 0x80;\n\t\t} else {\n\t\t\tadd_bits = 0;\n\t\t\tgfc.substep_shaping &= 0x7f;\n\t\t\t/*\n\t\t\t * build up reservoir. this builds the reservoir a little slower\n\t\t\t * than FhG. It could simple be mean_bits/15, but this was rigged to\n\t\t\t * always produce 100 (the old value) at 128kbs\n\t\t\t */\n\t\t\tif (!gfp.disable_reservoir && 0 == (gfc.substep_shaping & 1))\n\t\t\t\ttarg_bits.bits -= .1 * mean_bits;\n\t\t}\n\n\t\t/* amount from the reservoir we are allowed to use. ISO says 6/10 */\n\t\tvar extra_bits = (ResvSize < (gfc.ResvMax * 6) / 10 ? ResvSize\n\t\t\t\t: (gfc.ResvMax * 6) / 10);\n\t\textra_bits -= add_bits;\n\n\t\tif (extra_bits < 0)\n\t\t\textra_bits = 0;\n\t\treturn extra_bits;\n\t}\n\n\t/**\n\t * Called after a granule's bit allocation. Readjusts the size of the\n\t * reservoir to reflect the granule's usage.\n\t */\n\tthis.ResvAdjust = function(gfc, gi) {\n\t\tgfc.ResvSize -= gi.part2_3_length + gi.part2_length;\n\t}\n\n\t/**\n\t * Called after all granules in a frame have been allocated. Makes sure that\n\t * the reservoir size is within limits, possibly by adding stuffing bits.\n\t */\n\tthis.ResvFrameEnd = function(gfc, mean_bits) {\n\t\tvar over_bits;\n\t\tvar l3_side = gfc.l3_side;\n\n\t\tgfc.ResvSize += mean_bits * gfc.mode_gr;\n\t\tvar stuffingBits = 0;\n\t\tl3_side.resvDrain_post = 0;\n\t\tl3_side.resvDrain_pre = 0;\n\n\t\t/* we must be byte aligned */\n\t\tif ((over_bits = gfc.ResvSize % 8) != 0)\n\t\t\tstuffingBits += over_bits;\n\n\t\tover_bits = (gfc.ResvSize - stuffingBits) - gfc.ResvMax;\n\t\tif (over_bits > 0) {\n\t\t\tassert (0 == over_bits % 8);\n\t\t\tassert (over_bits >= 0);\n\t\t\tstuffingBits += over_bits;\n\t\t}\n\n\t\t/*\n\t\t * NOTE: enabling the NEW_DRAIN code fixes some problems with FhG\n\t\t * decoder shipped with MS Windows operating systems. Using this, it is\n\t\t * even possible to use Gabriel's lax buffer consideration again, which\n\t\t * assumes, any decoder should have a buffer large enough for a 320 kbps\n\t\t * frame at 32 kHz sample rate.\n\t\t * \n\t\t * old drain code: lame -b320 BlackBird.wav --. does not play with\n\t\t * GraphEdit.exe using FhG decoder V1.5 Build 50\n\t\t * \n\t\t * new drain code: lame -b320 BlackBird.wav --. plays fine with\n\t\t * GraphEdit.exe using FhG decoder V1.5 Build 50\n\t\t * \n\t\t * Robert Hegemann, 2010-02-13.\n\t\t */\n\t\t/*\n\t\t * drain as many bits as possible into previous frame ancillary data In\n\t\t * particular, in VBR mode ResvMax may have changed, and we have to make\n\t\t * sure main_data_begin does not create a reservoir bigger than ResvMax\n\t\t * mt 4/00\n\t\t */\n\t\t{\n\t\t\tvar mdb_bytes = Math.min(l3_side.main_data_begin * 8, stuffingBits) / 8;\n\t\t\tl3_side.resvDrain_pre += 8 * mdb_bytes;\n\t\t\tstuffingBits -= 8 * mdb_bytes;\n\t\t\tgfc.ResvSize -= 8 * mdb_bytes;\n\t\t\tl3_side.main_data_begin -= mdb_bytes;\n\t\t}\n\t\t/* drain the rest into this frames ancillary data */\n\t\tl3_side.resvDrain_post += stuffingBits;\n\t\tgfc.ResvSize -= stuffingBits;\n\t}\n}\n\nmodule.exports = Reservoir;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL1Jlc2Vydm9pci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLCtFQUFhO0FBQ2xDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL1Jlc2Vydm9pci5qcz9mMTY5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiAgICAgIGJpdCByZXNlcnZvaXIgc291cmNlIGZpbGVcbiAqXG4gKiAgICAgIENvcHlyaWdodCAoYykgMTk5OS0yMDAwIE1hcmsgVGF5bG9yXG4gKlxuICogVGhpcyBsaWJyYXJ5IGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICogbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuICogTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbjsgZWl0aGVyXG4gKiB2ZXJzaW9uIDIgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4gKlxuICogVGhpcyBsaWJyYXJ5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlVcbiAqIExpYnJhcnkgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcbiAqIExpY2Vuc2UgYWxvbmcgd2l0aCB0aGlzIGxpYnJhcnk7IGlmIG5vdCwgd3JpdGUgdG8gdGhlXG4gKiBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCxcbiAqIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuICovXG5cbi8qICRJZDogUmVzZXJ2b2lyLmphdmEsdiAxLjkgMjAxMS8wNS8yNCAyMDo0ODowNiBrZW5jaGlzIEV4cCAkICovXG5cbi8vcGFja2FnZSBtcDM7XG5cbi8qKlxuICogUmVzdkZyYW1lQmVnaW46PEJSPlxuICogQ2FsbGVkIChyZXBlYXRlZGx5KSBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgZnJhbWUuIFVwZGF0ZXMgdGhlIG1heGltdW0gc2l6ZSBvZlxuICogdGhlIHJlc2Vydm9pciwgYW5kIGNoZWNrcyB0byBtYWtlIHN1cmUgbWFpbl9kYXRhX2JlZ2luIHdhcyBzZXQgcHJvcGVybHkgYnlcbiAqIHRoZSBmb3JtYXR0ZXI8QlI+XG4gKiBCYWNrZ3JvdW5kIGluZm9ybWF0aW9uOlxuICogXG4gKiBUaGlzIGlzIHRoZSBvcmlnaW5hbCB0ZXh0IGZyb20gdGhlIElTTyBzdGFuZGFyZC4gQmVjYXVzZSBvZiBzb29vIG1hbnkgYnVnc1xuICogYW5kIGlycml0YXRpb25zIGNvcnJlY3RpbmcgY29tbWVudHMgYXJlIGFkZGVkIGluIGJyYWNrZXRzIFtdLiBBICdeVycgbWVhbnNcbiAqIHlvdSBzaG91bGQgcmVtb3ZlIHRoZSBsYXN0IHdvcmQuXG4gKiBcbiAqIDxQUkU+XG4gKiAgMS4gVGhlIGZvbGxvd2luZyBydWxlIGNhbiBiZSB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgbWF4aW11bVxuICogICAgIG51bWJlciBvZiBiaXRzIHVzZWQgZm9yIG9uZSBncmFudWxlIFteVyBmcmFtZV06PEJSPlxuICogICAgIEF0IHRoZSBoaWdoZXN0IHBvc3NpYmxlIGJpdHJhdGUgb2YgTGF5ZXIgSUlJICgzMjAga2Jwc1xuICogICAgIHBlciBzdGVyZW8gc2lnbmFsIFteV15XXlddLCA0OCBrSHopIHRoZSBmcmFtZXMgbXVzdCBiZSBvZlxuICogICAgIFteV15XXlcgYXJlIGRlc2lnbmVkIHRvIGhhdmVdIGNvbnN0YW50IGxlbmd0aCwgaS5lLlxuICogICAgIG9uZSBidWZmZXIgW15XXlcgdGhlIGZyYW1lXSBsZW5ndGggaXM6PEJSPlxuICogXG4gKiAgICAgICAgIDMyMCBrYnBzICogMTE1Mi80OCBrSHogPSA3NjgwIGJpdCA9IDk2MCBieXRlXG4gKiBcbiAqICAgICBUaGlzIHZhbHVlIGlzIHVzZWQgYXMgdGhlIG1heGltdW0gYnVmZmVyIHBlciBjaGFubmVsIFteV15XXSBhdFxuICogICAgIGxvd2VyIGJpdHJhdGVzIFt0aGFuIDMyMCBrYnBzXS4gQXQgNjQga2JwcyBtb25vIG9yIDEyOCBrYnBzXG4gKiAgICAgc3RlcmVvIHRoZSBtYWluIGdyYW51bGUgbGVuZ3RoIGlzIDY0IGticHMgKiA1NzYvNDgga0h6ID0gNzY4IGJpdFxuICogICAgIFtwZXIgZ3JhbnVsZSBhbmQgY2hhbm5lbF0gYXQgNDgga0h6IHNhbXBsaW5nIGZyZXF1ZW5jeS5cbiAqICAgICBUaGlzIG1lYW5zIHRoYXQgdGhlcmUgaXMgYSBtYXhpbXVtIGRldmlhdGlvbiAoc2hvcnQgdGltZSBidWZmZXJcbiAqICAgICBbPSByZXNlcnZvaXJdKSBvZiA3NjgwIC0gMioyKjc2OCA9IDQ2MDggYml0cyBpcyBhbGxvd2VkIGF0IDY0IGticHMuXG4gKiAgICAgVGhlIGFjdHVhbCBkZXZpYXRpb24gaXMgZXF1YWwgdG8gdGhlIG51bWJlciBvZiBieXRlcyBbd2l0aCB0aGVcbiAqICAgICBtZWFuaW5nIG9mIG9jdGV0c10gZGVub3RlZCBieSB0aGUgbWFpbl9kYXRhX2VuZCBvZmZzZXQgcG9pbnRlci5cbiAqICAgICBUaGUgYWN0dWFsIG1heGltdW0gZGV2aWF0aW9uIGlzICgyXjktMSkqOCBiaXQgPSA0MDg4IGJpdHNcbiAqICAgICBbZm9yIE1QRUctMSBhbmQgKDJeOC0xKSo4IGJpdCBmb3IgTVBFRy0yLCBib3RoIGFyZSBoYXJkIGxpbWl0c10uXG4gKiAgICAgLi4uIFRoZSB4Y2hhbmdlIG9mIGJ1ZmZlciBiaXRzIGJldHdlZW4gdGhlIGxlZnQgYW5kIHJpZ2h0IGNoYW5uZWxcbiAqICAgICBpcyBhbGxvd2VkIHdpdGhvdXQgcmVzdHJpY3Rpb25zIFtleGNlcHRpb246IGR1YWwgY2hhbm5lbF0uXG4gKiAgICAgQmVjYXVzZSBvZiB0aGUgW2NvbnN0cnVjdGVkXSBjb25zdHJhaW50IG9uIHRoZSBidWZmZXIgc2l6ZVxuICogICAgIG1haW5fZGF0YV9lbmQgaXMgYWx3YXlzIHNldCB0byAwIGluIHRoZSBjYXNlIG9mIGJpdF9yYXRlX2luZGV4PT0xNCxcbiAqICAgICBpLmUuIGRhdGEgcmF0ZSAzMjAga2JwcyBwZXIgc3RlcmVvIHNpZ25hbCBbXldeV15XXS4gSW4gdGhpcyBjYXNlXG4gKiAgICAgYWxsIGRhdGEgYXJlIGFsbG9jYXRlZCBiZXR3ZWVuIGFkamFjZW50IGhlYWRlciBbXlcgc3luY10gd29yZHNcbiAqICAgICBbLCBpLmUuIHRoZXJlIGlzIG5vIGJ1ZmZlcmluZyBhdCBhbGxdLlxuICogPC9QUkU+XG4gKi9cblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uLmpzJyk7XG52YXIgYXNzZXJ0ID0gY29tbW9uLmFzc2VydDtcblxuZnVuY3Rpb24gUmVzZXJ2b2lyKCkge1xuXHR2YXIgYnM7XG5cblx0dGhpcy5zZXRNb2R1bGVzICA9IGZ1bmN0aW9uKF9icykge1xuXHRcdGJzID0gX2JzO1xuXHR9XG5cblx0dGhpcy5SZXN2RnJhbWVCZWdpbiA9IGZ1bmN0aW9uKGdmcCwgbWVhbl9iaXRzKSB7XG5cdFx0dmFyIGdmYyA9IGdmcC5pbnRlcm5hbF9mbGFncztcblx0XHR2YXIgbWF4bXAzYnVmO1xuXHRcdHZhciBsM19zaWRlID0gZ2ZjLmwzX3NpZGU7XG5cblx0XHR2YXIgZnJhbWVMZW5ndGggPSBicy5nZXRmcmFtZWJpdHMoZ2ZwKTtcblx0XHRtZWFuX2JpdHMuYml0cyA9IChmcmFtZUxlbmd0aCAtIGdmYy5zaWRlaW5mb19sZW4gKiA4KSAvIGdmYy5tb2RlX2dyO1xuXG5cdFx0LyoqXG5cdFx0ICogPFBSRT5cblx0XHQgKiAgTWVhbmluZyBvZiB0aGUgdmFyaWFibGVzOlxuXHRcdCAqICAgICAgcmVzdkxpbWl0OiAoMCwgOCwgLi4uLCA4KjI1NSAoTVBFRy0yKSwgOCo1MTEgKE1QRUctMSkpXG5cdFx0ICogICAgICAgICAgTnVtYmVyIG9mIGJpdHMgY2FuIGJlIHN0b3JlZCBpbiBwcmV2aW91cyBmcmFtZShzKSBkdWUgdG9cblx0XHQgKiAgICAgICAgICBjb3VudGVyIHNpemUgY29uc3RhaW50c1xuXHRcdCAqICAgICAgbWF4bXAzYnVmOiAoID8/PyAuLi4gOCoxOTUxIChNUEVHLTEgYW5kIDIpLCA4KjIwNDcgKE1QRUctMi41KSlcblx0XHQgKiAgICAgICAgICBOdW1iZXIgb2YgYml0cyBhbGxvd2VkIHRvIGVuY29kZSBvbmUgZnJhbWUgKHlvdSBjYW4gdGFrZSA4KjUxMSBiaXRcblx0XHQgKiAgICAgICAgICBmcm9tIHRoZSBiaXQgcmVzZXJ2b2lyIGFuZCBhdCBtb3N0IDgqMTQ0MCBiaXQgZnJvbSB0aGUgY3VycmVudFxuXHRcdCAqICAgICAgICAgIGZyYW1lICgzMjAga2JwcywgMzIga0h6KSwgc28gOCoxOTUxIGJpdCBpcyB0aGUgbGFyZ2VzdCBwb3NzaWJsZVxuXHRcdCAqICAgICAgICAgIHZhbHVlIGZvciBNUEVHLTEgYW5kIC0yKVxuXHRcdCAqIFxuXHRcdCAqICAgICAgICAgIG1heGltdW0gYWxsb3dlZCBncmFudWxlL2NoYW5uZWwgc2l6ZSB0aW1lcyA0ID0gOCoyMDQ3IGJpdHMuLFxuXHRcdCAqICAgICAgICAgIHNvIHRoaXMgaXMgdGhlIGFic29sdXRlIG1heGltdW0gc3VwcG9ydGVkIGJ5IHRoZSBmb3JtYXQuXG5cdFx0ICogXG5cdFx0ICogXG5cdFx0ICogICAgICBmdWxsRnJhbWVCaXRzOiAgbWF4aW11bSBudW1iZXIgb2YgYml0cyBhdmFpbGFibGUgZm9yIGVuY29kaW5nXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgdGhlIGN1cnJlbnQgZnJhbWUuXG5cdFx0ICogXG5cdFx0ICogICAgICBtZWFuX2JpdHM6ICAgICAgdGFyZ2V0IG51bWJlciBvZiBiaXRzIHBlciBncmFudWxlLlxuXHRcdCAqIFxuXHRcdCAqICAgICAgZnJhbWVMZW5ndGg6XG5cdFx0ICogXG5cdFx0ICogICAgICBnZmMuUmVzdk1heDogICBtYXhpbXVtIGFsbG93ZWQgcmVzZXJ2b2lyXG5cdFx0ICogXG5cdFx0ICogICAgICBnZmMuUmVzdlNpemU6ICBjdXJyZW50IHJlc2Vydm9pciBzaXplXG5cdFx0ICogXG5cdFx0ICogICAgICBsM19zaWRlLnJlc3ZEcmFpbl9wcmU6XG5cdFx0ICogICAgICAgICBhbmNpbGxhcnkgZGF0YSB0byBiZSBhZGRlZCB0byBwcmV2aW91cyBmcmFtZTpcblx0XHQgKiAgICAgICAgIChvbmx5IHVzZWZ1bGwgaW4gVkJSIG1vZGVzIGlmIGl0IGlzIHBvc3NpYmxlIHRvIGhhdmVcblx0XHQgKiAgICAgICAgIG1heG1wM2J1ZiA8IGZ1bGxGcmFtZUJpdHMpKS4gIEN1cnJlbnRseSBkaXNhYmxlZCxcblx0XHQgKiAgICAgICAgIHNlZSAjZGVmaW5lIE5FV19EUkFJTlxuXHRcdCAqICAgICAgICAgMjAxMC0wMi0xMzogUkggbm93IGVuYWJsZWQsIGl0IHNlZW1zIHRvIGJlIG5lZWRlZCBmb3IgQ0JSIHRvbyxcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgIGFzIHRoZXJlIGV4aXN0cyBvbmUgZXhhbXBsZSwgd2hlcmUgdGhlIEZoRyBkZWNvZGVyXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICBjYW4ndCBkZWNvZGUgYSAtYjMyMCBDQlIgZmlsZSBhbnltb3JlLlxuXHRcdCAqIFxuXHRcdCAqICAgICAgbDNfc2lkZS5yZXN2RHJhaW5fcG9zdDpcblx0XHQgKiAgICAgICAgIGFuY2lsbGFyeSBkYXRhIHRvIGJlIGFkZGVkIHRvIHRoaXMgZnJhbWU6XG5cdFx0ICogXG5cdFx0ICogPC9QUkU+XG5cdFx0ICovXG5cblx0XHQvKiBtYWluX2RhdGFfYmVnaW4gaGFzIDkgYml0cyBpbiBNUEVHLTEsIDggYml0cyBNUEVHLTIgKi9cblx0XHR2YXIgcmVzdkxpbWl0ID0gKDggKiAyNTYpICogZ2ZjLm1vZGVfZ3IgLSA4O1xuXG5cdFx0Lypcblx0XHQgKiBtYXhpbXVtIGFsbG93ZWQgZnJhbWUgc2l6ZS4gZG9udCB1c2UgbW9yZSB0aGFuIHRoaXMgbnVtYmVyIG9mIGJpdHMsXG5cdFx0ICogZXZlbiBpZiB0aGUgZnJhbWUgaGFzIHRoZSBzcGFjZSBmb3IgdGhlbTpcblx0XHQgKi9cblx0XHRpZiAoZ2ZwLmJyYXRlID4gMzIwKSB7XG5cdFx0XHQvKiBpbiBmcmVlZm9ybWF0IHRoZSBidWZmZXIgaXMgY29uc3RhbnQgKi9cblx0XHRcdG1heG1wM2J1ZiA9IDggKiAoKGludCkgKChnZnAuYnJhdGUgKiAxMDAwKVxuXHRcdFx0XHRcdC8gKGdmcC5vdXRfc2FtcGxlcmF0ZSAvIDExNTIpIC8gOCArIC41KSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8qXG5cdFx0XHQgKiBhbGwgbXAzIGRlY29kZXJzIHNob3VsZCBoYXZlIGVub3VnaCBidWZmZXIgdG8gaGFuZGxlIHRoaXMgdmFsdWU6XG5cdFx0XHQgKiBzaXplIG9mIGEgMzIwa2JwcyAzMmtIeiBmcmFtZVxuXHRcdFx0ICovXG5cdFx0XHRtYXhtcDNidWYgPSA4ICogMTQ0MDtcblxuXHRcdFx0Lypcblx0XHRcdCAqIEJvdXZpZ25lIHN1Z2dlc3RzIHRoaXMgbW9yZSBsYXggaW50ZXJwcmV0YXRpb24gb2YgdGhlIElTTyBkb2Ncblx0XHRcdCAqIGluc3RlYWQgb2YgdXNpbmcgOCo5NjAuXG5cdFx0XHQgKi9cblxuXHRcdFx0aWYgKGdmcC5zdHJpY3RfSVNPKSB7XG5cdFx0XHRcdG1heG1wM2J1ZiA9IDggKiAoKGludCkgKDMyMDAwMCAvIChnZnAub3V0X3NhbXBsZXJhdGUgLyAxMTUyKSAvIDggKyAuNSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGdmYy5SZXN2TWF4ID0gbWF4bXAzYnVmIC0gZnJhbWVMZW5ndGg7XG5cdFx0aWYgKGdmYy5SZXN2TWF4ID4gcmVzdkxpbWl0KVxuXHRcdFx0Z2ZjLlJlc3ZNYXggPSByZXN2TGltaXQ7XG5cdFx0aWYgKGdmYy5SZXN2TWF4IDwgMCB8fCBnZnAuZGlzYWJsZV9yZXNlcnZvaXIpXG5cdFx0XHRnZmMuUmVzdk1heCA9IDA7XG5cblx0XHR2YXIgZnVsbEZyYW1lQml0cyA9IG1lYW5fYml0cy5iaXRzICogZ2ZjLm1vZGVfZ3Jcblx0XHRcdFx0KyBNYXRoLm1pbihnZmMuUmVzdlNpemUsIGdmYy5SZXN2TWF4KTtcblxuXHRcdGlmIChmdWxsRnJhbWVCaXRzID4gbWF4bXAzYnVmKVxuXHRcdFx0ZnVsbEZyYW1lQml0cyA9IG1heG1wM2J1ZjtcblxuXHRcdGFzc2VydCAoMCA9PSBnZmMuUmVzdk1heCAlIDgpO1xuXHRcdGFzc2VydCAoZ2ZjLlJlc3ZNYXggPj0gMCk7XG5cblx0XHRsM19zaWRlLnJlc3ZEcmFpbl9wcmUgPSAwO1xuXG5cdFx0Ly8gZnJhbWUgYW5hbHl6ZXIgY29kZVxuXHRcdGlmIChnZmMucGluZm8gIT0gbnVsbCkge1xuXHRcdFx0Lypcblx0XHRcdCAqIGV4cGVjdGVkIGJpdHMgcGVyIGNoYW5uZWwgcGVyIGdyYW51bGUgW2lzIHRoaXMgYWxzbyByaWdodCBmb3Jcblx0XHRcdCAqIG1vbm8vc3RlcmVvLCBNUEVHLTEvMiA/XVxuXHRcdFx0ICovXG5cdFx0XHRnZmMucGluZm8ubWVhbl9iaXRzID0gbWVhbl9iaXRzLmJpdHMgLyAyO1xuXHRcdFx0Z2ZjLnBpbmZvLnJlc3ZzaXplID0gZ2ZjLlJlc3ZTaXplO1xuXHRcdH1cblxuXHRcdHJldHVybiBmdWxsRnJhbWVCaXRzO1xuXHR9XG5cblx0LyoqXG5cdCAqIHJldHVybnMgdGFyZ19iaXRzOiB0YXJnZXQgbnVtYmVyIG9mIGJpdHMgdG8gdXNlIGZvciAxIGdyYW51bGU8QlI+XG5cdCAqIGV4dHJhX2JpdHM6IGFtb3VudCBleHRyYSBhdmFpbGFibGUgZnJvbSByZXNlcnZvaXI8QlI+XG5cdCAqIE1hcmsgVGF5bG9yIDQvOTlcblx0ICovXG5cdHRoaXMuUmVzdk1heEJpdHMgPSBmdW5jdGlvbihnZnAsIG1lYW5fYml0cywgdGFyZ19iaXRzLCBjYnIpIHtcblx0XHR2YXIgZ2ZjID0gZ2ZwLmludGVybmFsX2ZsYWdzO1xuXHRcdHZhciBhZGRfYml0cztcbiAgICAgICAgdmFyIFJlc3ZTaXplID0gZ2ZjLlJlc3ZTaXplLCBSZXN2TWF4ID0gZ2ZjLlJlc3ZNYXg7XG5cblx0XHQvKiBjb21wZW5zYXRlIHRoZSBzYXZlZCBiaXRzIHVzZWQgaW4gdGhlIDFzdCBncmFudWxlICovXG5cdFx0aWYgKGNiciAhPSAwKVxuXHRcdFx0UmVzdlNpemUgKz0gbWVhbl9iaXRzO1xuXG5cdFx0aWYgKChnZmMuc3Vic3RlcF9zaGFwaW5nICYgMSkgIT0gMClcblx0XHRcdFJlc3ZNYXggKj0gMC45O1xuXG5cdFx0dGFyZ19iaXRzLmJpdHMgPSBtZWFuX2JpdHM7XG5cblx0XHQvKiBleHRyYSBiaXRzIGlmIHRoZSByZXNlcnZvaXIgaXMgYWxtb3N0IGZ1bGwgKi9cblx0XHRpZiAoUmVzdlNpemUgKiAxMCA+IFJlc3ZNYXggKiA5KSB7XG5cdFx0XHRhZGRfYml0cyA9IFJlc3ZTaXplIC0gKFJlc3ZNYXggKiA5KSAvIDEwO1xuXHRcdFx0dGFyZ19iaXRzLmJpdHMgKz0gYWRkX2JpdHM7XG5cdFx0XHRnZmMuc3Vic3RlcF9zaGFwaW5nIHw9IDB4ODA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFkZF9iaXRzID0gMDtcblx0XHRcdGdmYy5zdWJzdGVwX3NoYXBpbmcgJj0gMHg3Zjtcblx0XHRcdC8qXG5cdFx0XHQgKiBidWlsZCB1cCByZXNlcnZvaXIuIHRoaXMgYnVpbGRzIHRoZSByZXNlcnZvaXIgYSBsaXR0bGUgc2xvd2VyXG5cdFx0XHQgKiB0aGFuIEZoRy4gSXQgY291bGQgc2ltcGxlIGJlIG1lYW5fYml0cy8xNSwgYnV0IHRoaXMgd2FzIHJpZ2dlZCB0b1xuXHRcdFx0ICogYWx3YXlzIHByb2R1Y2UgMTAwICh0aGUgb2xkIHZhbHVlKSBhdCAxMjhrYnNcblx0XHRcdCAqL1xuXHRcdFx0aWYgKCFnZnAuZGlzYWJsZV9yZXNlcnZvaXIgJiYgMCA9PSAoZ2ZjLnN1YnN0ZXBfc2hhcGluZyAmIDEpKVxuXHRcdFx0XHR0YXJnX2JpdHMuYml0cyAtPSAuMSAqIG1lYW5fYml0cztcblx0XHR9XG5cblx0XHQvKiBhbW91bnQgZnJvbSB0aGUgcmVzZXJ2b2lyIHdlIGFyZSBhbGxvd2VkIHRvIHVzZS4gSVNPIHNheXMgNi8xMCAqL1xuXHRcdHZhciBleHRyYV9iaXRzID0gKFJlc3ZTaXplIDwgKGdmYy5SZXN2TWF4ICogNikgLyAxMCA/IFJlc3ZTaXplXG5cdFx0XHRcdDogKGdmYy5SZXN2TWF4ICogNikgLyAxMCk7XG5cdFx0ZXh0cmFfYml0cyAtPSBhZGRfYml0cztcblxuXHRcdGlmIChleHRyYV9iaXRzIDwgMClcblx0XHRcdGV4dHJhX2JpdHMgPSAwO1xuXHRcdHJldHVybiBleHRyYV9iaXRzO1xuXHR9XG5cblx0LyoqXG5cdCAqIENhbGxlZCBhZnRlciBhIGdyYW51bGUncyBiaXQgYWxsb2NhdGlvbi4gUmVhZGp1c3RzIHRoZSBzaXplIG9mIHRoZVxuXHQgKiByZXNlcnZvaXIgdG8gcmVmbGVjdCB0aGUgZ3JhbnVsZSdzIHVzYWdlLlxuXHQgKi9cblx0dGhpcy5SZXN2QWRqdXN0ID0gZnVuY3Rpb24oZ2ZjLCBnaSkge1xuXHRcdGdmYy5SZXN2U2l6ZSAtPSBnaS5wYXJ0Ml8zX2xlbmd0aCArIGdpLnBhcnQyX2xlbmd0aDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxsZWQgYWZ0ZXIgYWxsIGdyYW51bGVzIGluIGEgZnJhbWUgaGF2ZSBiZWVuIGFsbG9jYXRlZC4gTWFrZXMgc3VyZSB0aGF0XG5cdCAqIHRoZSByZXNlcnZvaXIgc2l6ZSBpcyB3aXRoaW4gbGltaXRzLCBwb3NzaWJseSBieSBhZGRpbmcgc3R1ZmZpbmcgYml0cy5cblx0ICovXG5cdHRoaXMuUmVzdkZyYW1lRW5kID0gZnVuY3Rpb24oZ2ZjLCBtZWFuX2JpdHMpIHtcblx0XHR2YXIgb3Zlcl9iaXRzO1xuXHRcdHZhciBsM19zaWRlID0gZ2ZjLmwzX3NpZGU7XG5cblx0XHRnZmMuUmVzdlNpemUgKz0gbWVhbl9iaXRzICogZ2ZjLm1vZGVfZ3I7XG5cdFx0dmFyIHN0dWZmaW5nQml0cyA9IDA7XG5cdFx0bDNfc2lkZS5yZXN2RHJhaW5fcG9zdCA9IDA7XG5cdFx0bDNfc2lkZS5yZXN2RHJhaW5fcHJlID0gMDtcblxuXHRcdC8qIHdlIG11c3QgYmUgYnl0ZSBhbGlnbmVkICovXG5cdFx0aWYgKChvdmVyX2JpdHMgPSBnZmMuUmVzdlNpemUgJSA4KSAhPSAwKVxuXHRcdFx0c3R1ZmZpbmdCaXRzICs9IG92ZXJfYml0cztcblxuXHRcdG92ZXJfYml0cyA9IChnZmMuUmVzdlNpemUgLSBzdHVmZmluZ0JpdHMpIC0gZ2ZjLlJlc3ZNYXg7XG5cdFx0aWYgKG92ZXJfYml0cyA+IDApIHtcblx0XHRcdGFzc2VydCAoMCA9PSBvdmVyX2JpdHMgJSA4KTtcblx0XHRcdGFzc2VydCAob3Zlcl9iaXRzID49IDApO1xuXHRcdFx0c3R1ZmZpbmdCaXRzICs9IG92ZXJfYml0cztcblx0XHR9XG5cblx0XHQvKlxuXHRcdCAqIE5PVEU6IGVuYWJsaW5nIHRoZSBORVdfRFJBSU4gY29kZSBmaXhlcyBzb21lIHByb2JsZW1zIHdpdGggRmhHXG5cdFx0ICogZGVjb2RlciBzaGlwcGVkIHdpdGggTVMgV2luZG93cyBvcGVyYXRpbmcgc3lzdGVtcy4gVXNpbmcgdGhpcywgaXQgaXNcblx0XHQgKiBldmVuIHBvc3NpYmxlIHRvIHVzZSBHYWJyaWVsJ3MgbGF4IGJ1ZmZlciBjb25zaWRlcmF0aW9uIGFnYWluLCB3aGljaFxuXHRcdCAqIGFzc3VtZXMsIGFueSBkZWNvZGVyIHNob3VsZCBoYXZlIGEgYnVmZmVyIGxhcmdlIGVub3VnaCBmb3IgYSAzMjAga2Jwc1xuXHRcdCAqIGZyYW1lIGF0IDMyIGtIeiBzYW1wbGUgcmF0ZS5cblx0XHQgKiBcblx0XHQgKiBvbGQgZHJhaW4gY29kZTogbGFtZSAtYjMyMCBCbGFja0JpcmQud2F2IC0tLiBkb2VzIG5vdCBwbGF5IHdpdGhcblx0XHQgKiBHcmFwaEVkaXQuZXhlIHVzaW5nIEZoRyBkZWNvZGVyIFYxLjUgQnVpbGQgNTBcblx0XHQgKiBcblx0XHQgKiBuZXcgZHJhaW4gY29kZTogbGFtZSAtYjMyMCBCbGFja0JpcmQud2F2IC0tLiBwbGF5cyBmaW5lIHdpdGhcblx0XHQgKiBHcmFwaEVkaXQuZXhlIHVzaW5nIEZoRyBkZWNvZGVyIFYxLjUgQnVpbGQgNTBcblx0XHQgKiBcblx0XHQgKiBSb2JlcnQgSGVnZW1hbm4sIDIwMTAtMDItMTMuXG5cdFx0ICovXG5cdFx0Lypcblx0XHQgKiBkcmFpbiBhcyBtYW55IGJpdHMgYXMgcG9zc2libGUgaW50byBwcmV2aW91cyBmcmFtZSBhbmNpbGxhcnkgZGF0YSBJblxuXHRcdCAqIHBhcnRpY3VsYXIsIGluIFZCUiBtb2RlIFJlc3ZNYXggbWF5IGhhdmUgY2hhbmdlZCwgYW5kIHdlIGhhdmUgdG8gbWFrZVxuXHRcdCAqIHN1cmUgbWFpbl9kYXRhX2JlZ2luIGRvZXMgbm90IGNyZWF0ZSBhIHJlc2Vydm9pciBiaWdnZXIgdGhhbiBSZXN2TWF4XG5cdFx0ICogbXQgNC8wMFxuXHRcdCAqL1xuXHRcdHtcblx0XHRcdHZhciBtZGJfYnl0ZXMgPSBNYXRoLm1pbihsM19zaWRlLm1haW5fZGF0YV9iZWdpbiAqIDgsIHN0dWZmaW5nQml0cykgLyA4O1xuXHRcdFx0bDNfc2lkZS5yZXN2RHJhaW5fcHJlICs9IDggKiBtZGJfYnl0ZXM7XG5cdFx0XHRzdHVmZmluZ0JpdHMgLT0gOCAqIG1kYl9ieXRlcztcblx0XHRcdGdmYy5SZXN2U2l6ZSAtPSA4ICogbWRiX2J5dGVzO1xuXHRcdFx0bDNfc2lkZS5tYWluX2RhdGFfYmVnaW4gLT0gbWRiX2J5dGVzO1xuXHRcdH1cblx0XHQvKiBkcmFpbiB0aGUgcmVzdCBpbnRvIHRoaXMgZnJhbWVzIGFuY2lsbGFyeSBkYXRhICovXG5cdFx0bDNfc2lkZS5yZXN2RHJhaW5fcG9zdCArPSBzdHVmZmluZ0JpdHM7XG5cdFx0Z2ZjLlJlc3ZTaXplIC09IHN0dWZmaW5nQml0cztcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlc2Vydm9pcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lamejs/src/js/Reservoir.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lamejs/src/js/ScaleFac.js":
/*!************************************************!*\
  !*** ./node_modules/lamejs/src/js/ScaleFac.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("//package mp3;\n\n/**\n * Layer III side information.\n *\n * @author Ken\n *\n */\n\nvar common = __webpack_require__(/*! ./common.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/common.js\");\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\nvar Encoder = __webpack_require__(/*! ./Encoder.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/Encoder.js\");\n\nfunction ScaleFac(arrL, arrS, arr21, arr12) {\n\n    this.l = new_int(1 + Encoder.SBMAX_l);\n    this.s = new_int(1 + Encoder.SBMAX_s);\n    this.psfb21 = new_int(1 + Encoder.PSFB21);\n    this.psfb12 = new_int(1 + Encoder.PSFB12);\n    var l = this.l;\n    var s = this.s;\n\n    if (arguments.length == 4) {\n        //public ScaleFac(final int[] arrL, final int[] arrS, final int[] arr21,\n        //    final int[] arr12) {\n        this.arrL = arguments[0];\n        this.arrS = arguments[1];\n        this.arr21 = arguments[2];\n        this.arr12 = arguments[3];\n\n        System.arraycopy(this.arrL, 0, l, 0, Math.min(this.arrL.length, this.l.length));\n        System.arraycopy(this.arrS, 0, s, 0, Math.min(this.arrS.length, this.s.length));\n        System.arraycopy(this.arr21, 0, this.psfb21, 0, Math.min(this.arr21.length, this.psfb21.length));\n        System.arraycopy(this.arr12, 0, this.psfb12, 0, Math.min(this.arr12.length, this.psfb12.length));\n    }\n}\n\nmodule.exports = ScaleFac;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL1NjYWxlRmFjLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsK0VBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLG1CQUFPLENBQUMsaUZBQWM7O0FBRXBDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xhbWVqcy9zcmMvanMvU2NhbGVGYWMuanM/ZmFhNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvL3BhY2thZ2UgbXAzO1xuXG4vKipcbiAqIExheWVyIElJSSBzaWRlIGluZm9ybWF0aW9uLlxuICpcbiAqIEBhdXRob3IgS2VuXG4gKlxuICovXG5cbnZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbi5qcycpO1xudmFyIFN5c3RlbSA9IGNvbW1vbi5TeXN0ZW07XG52YXIgVmJyTW9kZSA9IGNvbW1vbi5WYnJNb2RlO1xudmFyIEZsb2F0ID0gY29tbW9uLkZsb2F0O1xudmFyIFNob3J0QmxvY2sgPSBjb21tb24uU2hvcnRCbG9jaztcbnZhciBVdGlsID0gY29tbW9uLlV0aWw7XG52YXIgQXJyYXlzID0gY29tbW9uLkFycmF5cztcbnZhciBuZXdfYXJyYXlfbiA9IGNvbW1vbi5uZXdfYXJyYXlfbjtcbnZhciBuZXdfYnl0ZSA9IGNvbW1vbi5uZXdfYnl0ZTtcbnZhciBuZXdfZG91YmxlID0gY29tbW9uLm5ld19kb3VibGU7XG52YXIgbmV3X2Zsb2F0ID0gY29tbW9uLm5ld19mbG9hdDtcbnZhciBuZXdfZmxvYXRfbiA9IGNvbW1vbi5uZXdfZmxvYXRfbjtcbnZhciBuZXdfaW50ID0gY29tbW9uLm5ld19pbnQ7XG52YXIgbmV3X2ludF9uID0gY29tbW9uLm5ld19pbnRfbjtcbnZhciBhc3NlcnQgPSBjb21tb24uYXNzZXJ0O1xuXG52YXIgRW5jb2RlciA9IHJlcXVpcmUoJy4vRW5jb2Rlci5qcycpO1xuXG5mdW5jdGlvbiBTY2FsZUZhYyhhcnJMLCBhcnJTLCBhcnIyMSwgYXJyMTIpIHtcblxuICAgIHRoaXMubCA9IG5ld19pbnQoMSArIEVuY29kZXIuU0JNQVhfbCk7XG4gICAgdGhpcy5zID0gbmV3X2ludCgxICsgRW5jb2Rlci5TQk1BWF9zKTtcbiAgICB0aGlzLnBzZmIyMSA9IG5ld19pbnQoMSArIEVuY29kZXIuUFNGQjIxKTtcbiAgICB0aGlzLnBzZmIxMiA9IG5ld19pbnQoMSArIEVuY29kZXIuUFNGQjEyKTtcbiAgICB2YXIgbCA9IHRoaXMubDtcbiAgICB2YXIgcyA9IHRoaXMucztcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDQpIHtcbiAgICAgICAgLy9wdWJsaWMgU2NhbGVGYWMoZmluYWwgaW50W10gYXJyTCwgZmluYWwgaW50W10gYXJyUywgZmluYWwgaW50W10gYXJyMjEsXG4gICAgICAgIC8vICAgIGZpbmFsIGludFtdIGFycjEyKSB7XG4gICAgICAgIHRoaXMuYXJyTCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgdGhpcy5hcnJTID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB0aGlzLmFycjIxID0gYXJndW1lbnRzWzJdO1xuICAgICAgICB0aGlzLmFycjEyID0gYXJndW1lbnRzWzNdO1xuXG4gICAgICAgIFN5c3RlbS5hcnJheWNvcHkodGhpcy5hcnJMLCAwLCBsLCAwLCBNYXRoLm1pbih0aGlzLmFyckwubGVuZ3RoLCB0aGlzLmwubGVuZ3RoKSk7XG4gICAgICAgIFN5c3RlbS5hcnJheWNvcHkodGhpcy5hcnJTLCAwLCBzLCAwLCBNYXRoLm1pbih0aGlzLmFyclMubGVuZ3RoLCB0aGlzLnMubGVuZ3RoKSk7XG4gICAgICAgIFN5c3RlbS5hcnJheWNvcHkodGhpcy5hcnIyMSwgMCwgdGhpcy5wc2ZiMjEsIDAsIE1hdGgubWluKHRoaXMuYXJyMjEubGVuZ3RoLCB0aGlzLnBzZmIyMS5sZW5ndGgpKTtcbiAgICAgICAgU3lzdGVtLmFycmF5Y29weSh0aGlzLmFycjEyLCAwLCB0aGlzLnBzZmIxMiwgMCwgTWF0aC5taW4odGhpcy5hcnIxMi5sZW5ndGgsIHRoaXMucHNmYjEyLmxlbmd0aCkpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTY2FsZUZhYztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lamejs/src/js/ScaleFac.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lamejs/src/js/Tables.js":
/*!**********************************************!*\
  !*** ./node_modules/lamejs/src/js/Tables.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function HuffCodeTab(len, max, tab, hl) {\n    this.xlen = len;\n    this.linmax = max;\n    this.table = tab;\n    this.hlen = hl;\n}\n\nvar Tables = {};\n\n\nTables.t1HB = [\n    1, 1,\n    1, 0\n];\n\nTables.t2HB = [\n    1, 2, 1,\n    3, 1, 1,\n    3, 2, 0\n];\n\nTables.t3HB = [\n    3, 2, 1,\n    1, 1, 1,\n    3, 2, 0\n];\n\nTables.t5HB = [\n    1, 2, 6, 5,\n    3, 1, 4, 4,\n    7, 5, 7, 1,\n    6, 1, 1, 0\n];\n\nTables.t6HB = [\n    7, 3, 5, 1,\n    6, 2, 3, 2,\n    5, 4, 4, 1,\n    3, 3, 2, 0\n];\n\nTables.t7HB = [\n    1, 2, 10, 19, 16, 10,\n    3, 3, 7, 10, 5, 3,\n    11, 4, 13, 17, 8, 4,\n    12, 11, 18, 15, 11, 2,\n    7, 6, 9, 14, 3, 1,\n    6, 4, 5, 3, 2, 0\n];\n\nTables.t8HB = [\n    3, 4, 6, 18, 12, 5,\n    5, 1, 2, 16, 9, 3,\n    7, 3, 5, 14, 7, 3,\n    19, 17, 15, 13, 10, 4,\n    13, 5, 8, 11, 5, 1,\n    12, 4, 4, 1, 1, 0\n];\n\nTables.t9HB = [\n    7, 5, 9, 14, 15, 7,\n    6, 4, 5, 5, 6, 7,\n    7, 6, 8, 8, 8, 5,\n    15, 6, 9, 10, 5, 1,\n    11, 7, 9, 6, 4, 1,\n    14, 4, 6, 2, 6, 0\n];\n\nTables.t10HB = [\n    1, 2, 10, 23, 35, 30, 12, 17,\n    3, 3, 8, 12, 18, 21, 12, 7,\n    11, 9, 15, 21, 32, 40, 19, 6,\n    14, 13, 22, 34, 46, 23, 18, 7,\n    20, 19, 33, 47, 27, 22, 9, 3,\n    31, 22, 41, 26, 21, 20, 5, 3,\n    14, 13, 10, 11, 16, 6, 5, 1,\n    9, 8, 7, 8, 4, 4, 2, 0\n];\n\nTables.t11HB = [\n    3, 4, 10, 24, 34, 33, 21, 15,\n    5, 3, 4, 10, 32, 17, 11, 10,\n    11, 7, 13, 18, 30, 31, 20, 5,\n    25, 11, 19, 59, 27, 18, 12, 5,\n    35, 33, 31, 58, 30, 16, 7, 5,\n    28, 26, 32, 19, 17, 15, 8, 14,\n    14, 12, 9, 13, 14, 9, 4, 1,\n    11, 4, 6, 6, 6, 3, 2, 0\n];\n\nTables.t12HB = [\n    9, 6, 16, 33, 41, 39, 38, 26,\n    7, 5, 6, 9, 23, 16, 26, 11,\n    17, 7, 11, 14, 21, 30, 10, 7,\n    17, 10, 15, 12, 18, 28, 14, 5,\n    32, 13, 22, 19, 18, 16, 9, 5,\n    40, 17, 31, 29, 17, 13, 4, 2,\n    27, 12, 11, 15, 10, 7, 4, 1,\n    27, 12, 8, 12, 6, 3, 1, 0\n];\n\nTables.t13HB = [\n    1, 5, 14, 21, 34, 51, 46, 71, 42, 52, 68, 52, 67, 44, 43, 19,\n    3, 4, 12, 19, 31, 26, 44, 33, 31, 24, 32, 24, 31, 35, 22, 14,\n    15, 13, 23, 36, 59, 49, 77, 65, 29, 40, 30, 40, 27, 33, 42, 16,\n    22, 20, 37, 61, 56, 79, 73, 64, 43, 76, 56, 37, 26, 31, 25, 14,\n    35, 16, 60, 57, 97, 75, 114, 91, 54, 73, 55, 41, 48, 53, 23, 24,\n    58, 27, 50, 96, 76, 70, 93, 84, 77, 58, 79, 29, 74, 49, 41, 17,\n    47, 45, 78, 74, 115, 94, 90, 79, 69, 83, 71, 50, 59, 38, 36, 15,\n    72, 34, 56, 95, 92, 85, 91, 90, 86, 73, 77, 65, 51, 44, 43, 42,\n    43, 20, 30, 44, 55, 78, 72, 87, 78, 61, 46, 54, 37, 30, 20, 16,\n    53, 25, 41, 37, 44, 59, 54, 81, 66, 76, 57, 54, 37, 18, 39, 11,\n    35, 33, 31, 57, 42, 82, 72, 80, 47, 58, 55, 21, 22, 26, 38, 22,\n    53, 25, 23, 38, 70, 60, 51, 36, 55, 26, 34, 23, 27, 14, 9, 7,\n    34, 32, 28, 39, 49, 75, 30, 52, 48, 40, 52, 28, 18, 17, 9, 5,\n    45, 21, 34, 64, 56, 50, 49, 45, 31, 19, 12, 15, 10, 7, 6, 3,\n    48, 23, 20, 39, 36, 35, 53, 21, 16, 23, 13, 10, 6, 1, 4, 2,\n    16, 15, 17, 27, 25, 20, 29, 11, 17, 12, 16, 8, 1, 1, 0, 1\n];\n\nTables.t15HB = [\n    7, 12, 18, 53, 47, 76, 124, 108, 89, 123, 108, 119, 107, 81, 122, 63,\n    13, 5, 16, 27, 46, 36, 61, 51, 42, 70, 52, 83, 65, 41, 59, 36,\n    19, 17, 15, 24, 41, 34, 59, 48, 40, 64, 50, 78, 62, 80, 56, 33,\n    29, 28, 25, 43, 39, 63, 55, 93, 76, 59, 93, 72, 54, 75, 50, 29,\n    52, 22, 42, 40, 67, 57, 95, 79, 72, 57, 89, 69, 49, 66, 46, 27,\n    77, 37, 35, 66, 58, 52, 91, 74, 62, 48, 79, 63, 90, 62, 40, 38,\n    125, 32, 60, 56, 50, 92, 78, 65, 55, 87, 71, 51, 73, 51, 70, 30,\n    109, 53, 49, 94, 88, 75, 66, 122, 91, 73, 56, 42, 64, 44, 21, 25,\n    90, 43, 41, 77, 73, 63, 56, 92, 77, 66, 47, 67, 48, 53, 36, 20,\n    71, 34, 67, 60, 58, 49, 88, 76, 67, 106, 71, 54, 38, 39, 23, 15,\n    109, 53, 51, 47, 90, 82, 58, 57, 48, 72, 57, 41, 23, 27, 62, 9,\n    86, 42, 40, 37, 70, 64, 52, 43, 70, 55, 42, 25, 29, 18, 11, 11,\n    118, 68, 30, 55, 50, 46, 74, 65, 49, 39, 24, 16, 22, 13, 14, 7,\n    91, 44, 39, 38, 34, 63, 52, 45, 31, 52, 28, 19, 14, 8, 9, 3,\n    123, 60, 58, 53, 47, 43, 32, 22, 37, 24, 17, 12, 15, 10, 2, 1,\n    71, 37, 34, 30, 28, 20, 17, 26, 21, 16, 10, 6, 8, 6, 2, 0\n];\n\nTables.t16HB = [\n    1, 5, 14, 44, 74, 63, 110, 93, 172, 149, 138, 242, 225, 195, 376, 17,\n    3, 4, 12, 20, 35, 62, 53, 47, 83, 75, 68, 119, 201, 107, 207, 9,\n    15, 13, 23, 38, 67, 58, 103, 90, 161, 72, 127, 117, 110, 209, 206, 16,\n    45, 21, 39, 69, 64, 114, 99, 87, 158, 140, 252, 212, 199, 387, 365, 26,\n    75, 36, 68, 65, 115, 101, 179, 164, 155, 264, 246, 226, 395, 382, 362, 9,\n    66, 30, 59, 56, 102, 185, 173, 265, 142, 253, 232, 400, 388, 378, 445, 16,\n    111, 54, 52, 100, 184, 178, 160, 133, 257, 244, 228, 217, 385, 366, 715, 10,\n    98, 48, 91, 88, 165, 157, 148, 261, 248, 407, 397, 372, 380, 889, 884, 8,\n    85, 84, 81, 159, 156, 143, 260, 249, 427, 401, 392, 383, 727, 713, 708, 7,\n    154, 76, 73, 141, 131, 256, 245, 426, 406, 394, 384, 735, 359, 710, 352, 11,\n    139, 129, 67, 125, 247, 233, 229, 219, 393, 743, 737, 720, 885, 882, 439, 4,\n    243, 120, 118, 115, 227, 223, 396, 746, 742, 736, 721, 712, 706, 223, 436, 6,\n    202, 224, 222, 218, 216, 389, 386, 381, 364, 888, 443, 707, 440, 437, 1728, 4,\n    747, 211, 210, 208, 370, 379, 734, 723, 714, 1735, 883, 877, 876, 3459, 865, 2,\n    377, 369, 102, 187, 726, 722, 358, 711, 709, 866, 1734, 871, 3458, 870, 434, 0,\n    12, 10, 7, 11, 10, 17, 11, 9, 13, 12, 10, 7, 5, 3, 1, 3\n];\n\nTables.t24HB = [\n    15, 13, 46, 80, 146, 262, 248, 434, 426, 669, 653, 649, 621, 517, 1032, 88,\n    14, 12, 21, 38, 71, 130, 122, 216, 209, 198, 327, 345, 319, 297, 279, 42,\n    47, 22, 41, 74, 68, 128, 120, 221, 207, 194, 182, 340, 315, 295, 541, 18,\n    81, 39, 75, 70, 134, 125, 116, 220, 204, 190, 178, 325, 311, 293, 271, 16,\n    147, 72, 69, 135, 127, 118, 112, 210, 200, 188, 352, 323, 306, 285, 540, 14,\n    263, 66, 129, 126, 119, 114, 214, 202, 192, 180, 341, 317, 301, 281, 262, 12,\n    249, 123, 121, 117, 113, 215, 206, 195, 185, 347, 330, 308, 291, 272, 520, 10,\n    435, 115, 111, 109, 211, 203, 196, 187, 353, 332, 313, 298, 283, 531, 381, 17,\n    427, 212, 208, 205, 201, 193, 186, 177, 169, 320, 303, 286, 268, 514, 377, 16,\n    335, 199, 197, 191, 189, 181, 174, 333, 321, 305, 289, 275, 521, 379, 371, 11,\n    668, 184, 183, 179, 175, 344, 331, 314, 304, 290, 277, 530, 383, 373, 366, 10,\n    652, 346, 171, 168, 164, 318, 309, 299, 287, 276, 263, 513, 375, 368, 362, 6,\n    648, 322, 316, 312, 307, 302, 292, 284, 269, 261, 512, 376, 370, 364, 359, 4,\n    620, 300, 296, 294, 288, 282, 273, 266, 515, 380, 374, 369, 365, 361, 357, 2,\n    1033, 280, 278, 274, 267, 264, 259, 382, 378, 372, 367, 363, 360, 358, 356, 0,\n    43, 20, 19, 17, 15, 13, 11, 9, 7, 6, 4, 7, 5, 3, 1, 3\n];\n\nTables.t32HB = [\n    1 << 0, 5 << 1, 4 << 1, 5 << 2, 6 << 1, 5 << 2, 4 << 2, 4 << 3,\n    7 << 1, 3 << 2, 6 << 2, 0 << 3, 7 << 2, 2 << 3, 3 << 3, 1 << 4\n];\n\nTables.t33HB = [\n    15 << 0, 14 << 1, 13 << 1, 12 << 2, 11 << 1, 10 << 2, 9 << 2, 8 << 3,\n    7 << 1, 6 << 2, 5 << 2, 4 << 3, 3 << 2, 2 << 3, 1 << 3, 0 << 4\n];\n\nTables.t1l = [\n    1, 4,\n    3, 5\n];\n\nTables.t2l = [\n    1, 4, 7,\n    4, 5, 7,\n    6, 7, 8\n];\n\nTables.t3l = [\n    2, 3, 7,\n    4, 4, 7,\n    6, 7, 8\n];\n\nTables.t5l = [\n    1, 4, 7, 8,\n    4, 5, 8, 9,\n    7, 8, 9, 10,\n    8, 8, 9, 10\n];\n\nTables.t6l = [\n    3, 4, 6, 8,\n    4, 4, 6, 7,\n    5, 6, 7, 8,\n    7, 7, 8, 9\n];\n\nTables.t7l = [\n    1, 4, 7, 9, 9, 10,\n    4, 6, 8, 9, 9, 10,\n    7, 7, 9, 10, 10, 11,\n    8, 9, 10, 11, 11, 11,\n    8, 9, 10, 11, 11, 12,\n    9, 10, 11, 12, 12, 12\n];\n\nTables.t8l = [\n    2, 4, 7, 9, 9, 10,\n    4, 4, 6, 10, 10, 10,\n    7, 6, 8, 10, 10, 11,\n    9, 10, 10, 11, 11, 12,\n    9, 9, 10, 11, 12, 12,\n    10, 10, 11, 11, 13, 13\n];\n\nTables.t9l = [\n    3, 4, 6, 7, 9, 10,\n    4, 5, 6, 7, 8, 10,\n    5, 6, 7, 8, 9, 10,\n    7, 7, 8, 9, 9, 10,\n    8, 8, 9, 9, 10, 11,\n    9, 9, 10, 10, 11, 11\n];\n\nTables.t10l = [\n    1, 4, 7, 9, 10, 10, 10, 11,\n    4, 6, 8, 9, 10, 11, 10, 10,\n    7, 8, 9, 10, 11, 12, 11, 11,\n    8, 9, 10, 11, 12, 12, 11, 12,\n    9, 10, 11, 12, 12, 12, 12, 12,\n    10, 11, 12, 12, 13, 13, 12, 13,\n    9, 10, 11, 12, 12, 12, 13, 13,\n    10, 10, 11, 12, 12, 13, 13, 13\n];\n\nTables.t11l = [\n    2, 4, 6, 8, 9, 10, 9, 10,\n    4, 5, 6, 8, 10, 10, 9, 10,\n    6, 7, 8, 9, 10, 11, 10, 10,\n    8, 8, 9, 11, 10, 12, 10, 11,\n    9, 10, 10, 11, 11, 12, 11, 12,\n    9, 10, 11, 12, 12, 13, 12, 13,\n    9, 9, 9, 10, 11, 12, 12, 12,\n    9, 9, 10, 11, 12, 12, 12, 12\n];\n\nTables.t12l = [\n    4, 4, 6, 8, 9, 10, 10, 10,\n    4, 5, 6, 7, 9, 9, 10, 10,\n    6, 6, 7, 8, 9, 10, 9, 10,\n    7, 7, 8, 8, 9, 10, 10, 10,\n    8, 8, 9, 9, 10, 10, 10, 11,\n    9, 9, 10, 10, 10, 11, 10, 11,\n    9, 9, 9, 10, 10, 11, 11, 12,\n    10, 10, 10, 11, 11, 11, 11, 12\n];\n\nTables.t13l = [\n    1, 5, 7, 8, 9, 10, 10, 11, 10, 11, 12, 12, 13, 13, 14, 14,\n    4, 6, 8, 9, 10, 10, 11, 11, 11, 11, 12, 12, 13, 14, 14, 14,\n    7, 8, 9, 10, 11, 11, 12, 12, 11, 12, 12, 13, 13, 14, 15, 15,\n    8, 9, 10, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 15, 15,\n    9, 9, 11, 11, 12, 12, 13, 13, 12, 13, 13, 14, 14, 15, 15, 16,\n    10, 10, 11, 12, 12, 12, 13, 13, 13, 13, 14, 13, 15, 15, 16, 16,\n    10, 11, 12, 12, 13, 13, 13, 13, 13, 14, 14, 14, 15, 15, 16, 16,\n    11, 11, 12, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 16, 18, 18,\n    10, 10, 11, 12, 12, 13, 13, 14, 14, 14, 14, 15, 15, 16, 17, 17,\n    11, 11, 12, 12, 13, 13, 13, 15, 14, 15, 15, 16, 16, 16, 18, 17,\n    11, 12, 12, 13, 13, 14, 14, 15, 14, 15, 16, 15, 16, 17, 18, 19,\n    12, 12, 12, 13, 14, 14, 14, 14, 15, 15, 15, 16, 17, 17, 17, 18,\n    12, 13, 13, 14, 14, 15, 14, 15, 16, 16, 17, 17, 17, 18, 18, 18,\n    13, 13, 14, 15, 15, 15, 16, 16, 16, 16, 16, 17, 18, 17, 18, 18,\n    14, 14, 14, 15, 15, 15, 17, 16, 16, 19, 17, 17, 17, 19, 18, 18,\n    13, 14, 15, 16, 16, 16, 17, 16, 17, 17, 18, 18, 21, 20, 21, 18\n];\n\nTables.t15l = [\n    3, 5, 6, 8, 8, 9, 10, 10, 10, 11, 11, 12, 12, 12, 13, 14,\n    5, 5, 7, 8, 9, 9, 10, 10, 10, 11, 11, 12, 12, 12, 13, 13,\n    6, 7, 7, 8, 9, 9, 10, 10, 10, 11, 11, 12, 12, 13, 13, 13,\n    7, 8, 8, 9, 9, 10, 10, 11, 11, 11, 12, 12, 12, 13, 13, 13,\n    8, 8, 9, 9, 10, 10, 11, 11, 11, 11, 12, 12, 12, 13, 13, 13,\n    9, 9, 9, 10, 10, 10, 11, 11, 11, 11, 12, 12, 13, 13, 13, 14,\n    10, 9, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 13, 13, 14, 14,\n    10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 12, 13, 13, 13, 14,\n    10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 14, 14, 14,\n    10, 10, 11, 11, 11, 11, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14,\n    11, 11, 11, 11, 12, 12, 12, 12, 12, 13, 13, 13, 13, 14, 15, 14,\n    11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 15,\n    12, 12, 11, 12, 12, 12, 13, 13, 13, 13, 13, 13, 14, 14, 15, 15,\n    12, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15,\n    13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 14, 15,\n    13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 15, 15\n];\n\nTables.t16_5l = [\n    1, 5, 7, 9, 10, 10, 11, 11, 12, 12, 12, 13, 13, 13, 14, 11,\n    4, 6, 8, 9, 10, 11, 11, 11, 12, 12, 12, 13, 14, 13, 14, 11,\n    7, 8, 9, 10, 11, 11, 12, 12, 13, 12, 13, 13, 13, 14, 14, 12,\n    9, 9, 10, 11, 11, 12, 12, 12, 13, 13, 14, 14, 14, 15, 15, 13,\n    10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 12,\n    10, 10, 11, 11, 12, 13, 13, 14, 13, 14, 14, 15, 15, 15, 16, 13,\n    11, 11, 11, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 16, 13,\n    11, 11, 12, 12, 13, 13, 13, 14, 14, 15, 15, 15, 15, 17, 17, 13,\n    11, 12, 12, 13, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 13,\n    12, 12, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 15, 16, 15, 14,\n    12, 13, 12, 13, 14, 14, 14, 14, 15, 16, 16, 16, 17, 17, 16, 13,\n    13, 13, 13, 13, 14, 14, 15, 16, 16, 16, 16, 16, 16, 15, 16, 14,\n    13, 14, 14, 14, 14, 15, 15, 15, 15, 17, 16, 16, 16, 16, 18, 14,\n    15, 14, 14, 14, 15, 15, 16, 16, 16, 18, 17, 17, 17, 19, 17, 14,\n    14, 15, 13, 14, 16, 16, 15, 16, 16, 17, 18, 17, 19, 17, 16, 14,\n    11, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 12\n];\n\nTables.t16l = [\n    1, 5, 7, 9, 10, 10, 11, 11, 12, 12, 12, 13, 13, 13, 14, 10,\n    4, 6, 8, 9, 10, 11, 11, 11, 12, 12, 12, 13, 14, 13, 14, 10,\n    7, 8, 9, 10, 11, 11, 12, 12, 13, 12, 13, 13, 13, 14, 14, 11,\n    9, 9, 10, 11, 11, 12, 12, 12, 13, 13, 14, 14, 14, 15, 15, 12,\n    10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 11,\n    10, 10, 11, 11, 12, 13, 13, 14, 13, 14, 14, 15, 15, 15, 16, 12,\n    11, 11, 11, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 16, 12,\n    11, 11, 12, 12, 13, 13, 13, 14, 14, 15, 15, 15, 15, 17, 17, 12,\n    11, 12, 12, 13, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 12,\n    12, 12, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 15, 16, 15, 13,\n    12, 13, 12, 13, 14, 14, 14, 14, 15, 16, 16, 16, 17, 17, 16, 12,\n    13, 13, 13, 13, 14, 14, 15, 16, 16, 16, 16, 16, 16, 15, 16, 13,\n    13, 14, 14, 14, 14, 15, 15, 15, 15, 17, 16, 16, 16, 16, 18, 13,\n    15, 14, 14, 14, 15, 15, 16, 16, 16, 18, 17, 17, 17, 19, 17, 13,\n    14, 15, 13, 14, 16, 16, 15, 16, 16, 17, 18, 17, 19, 17, 16, 13,\n    10, 10, 10, 11, 11, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 10\n];\n\nTables.t24l = [\n    4, 5, 7, 8, 9, 10, 10, 11, 11, 12, 12, 12, 12, 12, 13, 10,\n    5, 6, 7, 8, 9, 10, 10, 11, 11, 11, 12, 12, 12, 12, 12, 10,\n    7, 7, 8, 9, 9, 10, 10, 11, 11, 11, 11, 12, 12, 12, 13, 9,\n    8, 8, 9, 9, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 9,\n    9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 12, 12, 12, 12, 13, 9,\n    10, 9, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 12, 9,\n    10, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 12, 13, 9,\n    11, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 12, 13, 13, 10,\n    11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 10,\n    11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 13, 13, 13, 10,\n    12, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 10,\n    12, 12, 11, 11, 11, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 10,\n    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 10,\n    12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 10,\n    13, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 10,\n    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 6\n];\n\nTables.t32l = [\n    1 + 0, 4 + 1, 4 + 1, 5 + 2, 4 + 1, 6 + 2, 5 + 2, 6 + 3,\n    4 + 1, 5 + 2, 5 + 2, 6 + 3, 5 + 2, 6 + 3, 6 + 3, 6 + 4\n];\n\nTables.t33l = [\n    4 + 0, 4 + 1, 4 + 1, 4 + 2, 4 + 1, 4 + 2, 4 + 2, 4 + 3,\n    4 + 1, 4 + 2, 4 + 2, 4 + 3, 4 + 2, 4 + 3, 4 + 3, 4 + 4\n];\n\nTables.ht = [\n    /* xlen, linmax, table, hlen */\n    new HuffCodeTab(0, 0, null, null),\n    new HuffCodeTab(2, 0, Tables.t1HB, Tables.t1l),\n    new HuffCodeTab(3, 0, Tables.t2HB, Tables.t2l),\n    new HuffCodeTab(3, 0, Tables.t3HB, Tables.t3l),\n    new HuffCodeTab(0, 0, null, null), /* Apparently not used */\n    new HuffCodeTab(4, 0, Tables.t5HB, Tables.t5l),\n    new HuffCodeTab(4, 0, Tables.t6HB, Tables.t6l),\n    new HuffCodeTab(6, 0, Tables.t7HB, Tables.t7l),\n    new HuffCodeTab(6, 0, Tables.t8HB, Tables.t8l),\n    new HuffCodeTab(6, 0, Tables.t9HB, Tables.t9l),\n    new HuffCodeTab(8, 0, Tables.t10HB, Tables.t10l),\n    new HuffCodeTab(8, 0, Tables.t11HB, Tables.t11l),\n    new HuffCodeTab(8, 0, Tables.t12HB, Tables.t12l),\n    new HuffCodeTab(16, 0, Tables.t13HB, Tables.t13l),\n    new HuffCodeTab(0, 0, null, Tables.t16_5l), /* Apparently not used */\n    new HuffCodeTab(16, 0, Tables.t15HB, Tables.t15l),\n\n    new HuffCodeTab(1, 1, Tables.t16HB, Tables.t16l),\n    new HuffCodeTab(2, 3, Tables.t16HB, Tables.t16l),\n    new HuffCodeTab(3, 7, Tables.t16HB, Tables.t16l),\n    new HuffCodeTab(4, 15, Tables.t16HB, Tables.t16l),\n    new HuffCodeTab(6, 63, Tables.t16HB, Tables.t16l),\n    new HuffCodeTab(8, 255, Tables.t16HB, Tables.t16l),\n    new HuffCodeTab(10, 1023, Tables.t16HB, Tables.t16l),\n    new HuffCodeTab(13, 8191, Tables.t16HB, Tables.t16l),\n\n    new HuffCodeTab(4, 15, Tables.t24HB, Tables.t24l),\n    new HuffCodeTab(5, 31, Tables.t24HB, Tables.t24l),\n    new HuffCodeTab(6, 63, Tables.t24HB, Tables.t24l),\n    new HuffCodeTab(7, 127, Tables.t24HB, Tables.t24l),\n    new HuffCodeTab(8, 255, Tables.t24HB, Tables.t24l),\n    new HuffCodeTab(9, 511, Tables.t24HB, Tables.t24l),\n    new HuffCodeTab(11, 2047, Tables.t24HB, Tables.t24l),\n    new HuffCodeTab(13, 8191, Tables.t24HB, Tables.t24l),\n\n    new HuffCodeTab(0, 0, Tables.t32HB, Tables.t32l),\n    new HuffCodeTab(0, 0, Tables.t33HB, Tables.t33l),\n];\n\n/**\n * <CODE>\n *  for (i = 0; i < 16*16; i++) [\n *      largetbl[i] = ((ht[16].hlen[i]) << 16) + ht[24].hlen[i];\n *  ]\n * </CODE>\n *\n */\nTables.largetbl = [\n    0x010004, 0x050005, 0x070007, 0x090008, 0x0a0009, 0x0a000a, 0x0b000a, 0x0b000b,\n    0x0c000b, 0x0c000c, 0x0c000c, 0x0d000c, 0x0d000c, 0x0d000c, 0x0e000d, 0x0a000a,\n    0x040005, 0x060006, 0x080007, 0x090008, 0x0a0009, 0x0b000a, 0x0b000a, 0x0b000b,\n    0x0c000b, 0x0c000b, 0x0c000c, 0x0d000c, 0x0e000c, 0x0d000c, 0x0e000c, 0x0a000a,\n    0x070007, 0x080007, 0x090008, 0x0a0009, 0x0b0009, 0x0b000a, 0x0c000a, 0x0c000b,\n    0x0d000b, 0x0c000b, 0x0d000b, 0x0d000c, 0x0d000c, 0x0e000c, 0x0e000d, 0x0b0009,\n    0x090008, 0x090008, 0x0a0009, 0x0b0009, 0x0b000a, 0x0c000a, 0x0c000a, 0x0c000b,\n    0x0d000b, 0x0d000b, 0x0e000b, 0x0e000c, 0x0e000c, 0x0f000c, 0x0f000c, 0x0c0009,\n    0x0a0009, 0x0a0009, 0x0b0009, 0x0b000a, 0x0c000a, 0x0c000a, 0x0d000a, 0x0d000b,\n    0x0d000b, 0x0e000b, 0x0e000c, 0x0e000c, 0x0f000c, 0x0f000c, 0x0f000d, 0x0b0009,\n    0x0a000a, 0x0a0009, 0x0b000a, 0x0b000a, 0x0c000a, 0x0d000a, 0x0d000b, 0x0e000b,\n    0x0d000b, 0x0e000b, 0x0e000c, 0x0f000c, 0x0f000c, 0x0f000c, 0x10000c, 0x0c0009,\n    0x0b000a, 0x0b000a, 0x0b000a, 0x0c000a, 0x0d000a, 0x0d000b, 0x0d000b, 0x0d000b,\n    0x0e000b, 0x0e000c, 0x0e000c, 0x0e000c, 0x0f000c, 0x0f000c, 0x10000d, 0x0c0009,\n    0x0b000b, 0x0b000a, 0x0c000a, 0x0c000a, 0x0d000b, 0x0d000b, 0x0d000b, 0x0e000b,\n    0x0e000c, 0x0f000c, 0x0f000c, 0x0f000c, 0x0f000c, 0x11000d, 0x11000d, 0x0c000a,\n    0x0b000b, 0x0c000b, 0x0c000b, 0x0d000b, 0x0d000b, 0x0d000b, 0x0e000b, 0x0e000b,\n    0x0f000b, 0x0f000c, 0x0f000c, 0x0f000c, 0x10000c, 0x10000d, 0x10000d, 0x0c000a,\n    0x0c000b, 0x0c000b, 0x0c000b, 0x0d000b, 0x0d000b, 0x0e000b, 0x0e000b, 0x0f000c,\n    0x0f000c, 0x0f000c, 0x0f000c, 0x10000c, 0x0f000d, 0x10000d, 0x0f000d, 0x0d000a,\n    0x0c000c, 0x0d000b, 0x0c000b, 0x0d000b, 0x0e000b, 0x0e000c, 0x0e000c, 0x0e000c,\n    0x0f000c, 0x10000c, 0x10000c, 0x10000d, 0x11000d, 0x11000d, 0x10000d, 0x0c000a,\n    0x0d000c, 0x0d000c, 0x0d000b, 0x0d000b, 0x0e000b, 0x0e000c, 0x0f000c, 0x10000c,\n    0x10000c, 0x10000c, 0x10000c, 0x10000d, 0x10000d, 0x0f000d, 0x10000d, 0x0d000a,\n    0x0d000c, 0x0e000c, 0x0e000c, 0x0e000c, 0x0e000c, 0x0f000c, 0x0f000c, 0x0f000c,\n    0x0f000c, 0x11000c, 0x10000d, 0x10000d, 0x10000d, 0x10000d, 0x12000d, 0x0d000a,\n    0x0f000c, 0x0e000c, 0x0e000c, 0x0e000c, 0x0f000c, 0x0f000c, 0x10000c, 0x10000c,\n    0x10000d, 0x12000d, 0x11000d, 0x11000d, 0x11000d, 0x13000d, 0x11000d, 0x0d000a,\n    0x0e000d, 0x0f000c, 0x0d000c, 0x0e000c, 0x10000c, 0x10000c, 0x0f000c, 0x10000d,\n    0x10000d, 0x11000d, 0x12000d, 0x11000d, 0x13000d, 0x11000d, 0x10000d, 0x0d000a,\n    0x0a0009, 0x0a0009, 0x0a0009, 0x0b0009, 0x0b0009, 0x0c0009, 0x0c0009, 0x0c0009,\n    0x0d0009, 0x0d0009, 0x0d0009, 0x0d000a, 0x0d000a, 0x0d000a, 0x0d000a, 0x0a0006\n];\n/**\n * <CODE>\n *  for (i = 0; i < 3*3; i++) [\n *      table23[i] = ((ht[2].hlen[i]) << 16) + ht[3].hlen[i];\n *  ]\n * </CODE>\n *\n */\nTables.table23 = [\n    0x010002, 0x040003, 0x070007,\n    0x040004, 0x050004, 0x070007,\n    0x060006, 0x070007, 0x080008\n];\n\n/**\n * <CODE>\n *  for (i = 0; i < 4*4; i++) [\n *       table56[i] = ((ht[5].hlen[i]) << 16) + ht[6].hlen[i];\n *   ]\n * </CODE>\n *\n */\nTables.table56 = [\n    0x010003, 0x040004, 0x070006, 0x080008, 0x040004, 0x050004, 0x080006, 0x090007,\n    0x070005, 0x080006, 0x090007, 0x0a0008, 0x080007, 0x080007, 0x090008, 0x0a0009\n];\n\nTables.bitrate_table = [\n    [0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160, -1], /* MPEG 2 */\n    [0, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, -1], /* MPEG 1 */\n    [0, 8, 16, 24, 32, 40, 48, 56, 64, -1, -1, -1, -1, -1, -1, -1], /* MPEG 2.5 */\n];\n\n/**\n * MPEG 2, MPEG 1, MPEG 2.5.\n */\nTables.samplerate_table = [\n    [22050, 24000, 16000, -1],\n    [44100, 48000, 32000, -1],\n    [11025, 12000, 8000, -1],\n];\n\n/**\n * This is the scfsi_band table from 2.4.2.7 of the IS.\n */\nTables.scfsi_band = [0, 6, 11, 16, 21];\n\nmodule.exports = Tables;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL1RhYmxlcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xhbWVqcy9zcmMvanMvVGFibGVzLmpzPzIyNjIiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gSHVmZkNvZGVUYWIobGVuLCBtYXgsIHRhYiwgaGwpIHtcbiAgICB0aGlzLnhsZW4gPSBsZW47XG4gICAgdGhpcy5saW5tYXggPSBtYXg7XG4gICAgdGhpcy50YWJsZSA9IHRhYjtcbiAgICB0aGlzLmhsZW4gPSBobDtcbn1cblxudmFyIFRhYmxlcyA9IHt9O1xuXG5cblRhYmxlcy50MUhCID0gW1xuICAgIDEsIDEsXG4gICAgMSwgMFxuXTtcblxuVGFibGVzLnQySEIgPSBbXG4gICAgMSwgMiwgMSxcbiAgICAzLCAxLCAxLFxuICAgIDMsIDIsIDBcbl07XG5cblRhYmxlcy50M0hCID0gW1xuICAgIDMsIDIsIDEsXG4gICAgMSwgMSwgMSxcbiAgICAzLCAyLCAwXG5dO1xuXG5UYWJsZXMudDVIQiA9IFtcbiAgICAxLCAyLCA2LCA1LFxuICAgIDMsIDEsIDQsIDQsXG4gICAgNywgNSwgNywgMSxcbiAgICA2LCAxLCAxLCAwXG5dO1xuXG5UYWJsZXMudDZIQiA9IFtcbiAgICA3LCAzLCA1LCAxLFxuICAgIDYsIDIsIDMsIDIsXG4gICAgNSwgNCwgNCwgMSxcbiAgICAzLCAzLCAyLCAwXG5dO1xuXG5UYWJsZXMudDdIQiA9IFtcbiAgICAxLCAyLCAxMCwgMTksIDE2LCAxMCxcbiAgICAzLCAzLCA3LCAxMCwgNSwgMyxcbiAgICAxMSwgNCwgMTMsIDE3LCA4LCA0LFxuICAgIDEyLCAxMSwgMTgsIDE1LCAxMSwgMixcbiAgICA3LCA2LCA5LCAxNCwgMywgMSxcbiAgICA2LCA0LCA1LCAzLCAyLCAwXG5dO1xuXG5UYWJsZXMudDhIQiA9IFtcbiAgICAzLCA0LCA2LCAxOCwgMTIsIDUsXG4gICAgNSwgMSwgMiwgMTYsIDksIDMsXG4gICAgNywgMywgNSwgMTQsIDcsIDMsXG4gICAgMTksIDE3LCAxNSwgMTMsIDEwLCA0LFxuICAgIDEzLCA1LCA4LCAxMSwgNSwgMSxcbiAgICAxMiwgNCwgNCwgMSwgMSwgMFxuXTtcblxuVGFibGVzLnQ5SEIgPSBbXG4gICAgNywgNSwgOSwgMTQsIDE1LCA3LFxuICAgIDYsIDQsIDUsIDUsIDYsIDcsXG4gICAgNywgNiwgOCwgOCwgOCwgNSxcbiAgICAxNSwgNiwgOSwgMTAsIDUsIDEsXG4gICAgMTEsIDcsIDksIDYsIDQsIDEsXG4gICAgMTQsIDQsIDYsIDIsIDYsIDBcbl07XG5cblRhYmxlcy50MTBIQiA9IFtcbiAgICAxLCAyLCAxMCwgMjMsIDM1LCAzMCwgMTIsIDE3LFxuICAgIDMsIDMsIDgsIDEyLCAxOCwgMjEsIDEyLCA3LFxuICAgIDExLCA5LCAxNSwgMjEsIDMyLCA0MCwgMTksIDYsXG4gICAgMTQsIDEzLCAyMiwgMzQsIDQ2LCAyMywgMTgsIDcsXG4gICAgMjAsIDE5LCAzMywgNDcsIDI3LCAyMiwgOSwgMyxcbiAgICAzMSwgMjIsIDQxLCAyNiwgMjEsIDIwLCA1LCAzLFxuICAgIDE0LCAxMywgMTAsIDExLCAxNiwgNiwgNSwgMSxcbiAgICA5LCA4LCA3LCA4LCA0LCA0LCAyLCAwXG5dO1xuXG5UYWJsZXMudDExSEIgPSBbXG4gICAgMywgNCwgMTAsIDI0LCAzNCwgMzMsIDIxLCAxNSxcbiAgICA1LCAzLCA0LCAxMCwgMzIsIDE3LCAxMSwgMTAsXG4gICAgMTEsIDcsIDEzLCAxOCwgMzAsIDMxLCAyMCwgNSxcbiAgICAyNSwgMTEsIDE5LCA1OSwgMjcsIDE4LCAxMiwgNSxcbiAgICAzNSwgMzMsIDMxLCA1OCwgMzAsIDE2LCA3LCA1LFxuICAgIDI4LCAyNiwgMzIsIDE5LCAxNywgMTUsIDgsIDE0LFxuICAgIDE0LCAxMiwgOSwgMTMsIDE0LCA5LCA0LCAxLFxuICAgIDExLCA0LCA2LCA2LCA2LCAzLCAyLCAwXG5dO1xuXG5UYWJsZXMudDEySEIgPSBbXG4gICAgOSwgNiwgMTYsIDMzLCA0MSwgMzksIDM4LCAyNixcbiAgICA3LCA1LCA2LCA5LCAyMywgMTYsIDI2LCAxMSxcbiAgICAxNywgNywgMTEsIDE0LCAyMSwgMzAsIDEwLCA3LFxuICAgIDE3LCAxMCwgMTUsIDEyLCAxOCwgMjgsIDE0LCA1LFxuICAgIDMyLCAxMywgMjIsIDE5LCAxOCwgMTYsIDksIDUsXG4gICAgNDAsIDE3LCAzMSwgMjksIDE3LCAxMywgNCwgMixcbiAgICAyNywgMTIsIDExLCAxNSwgMTAsIDcsIDQsIDEsXG4gICAgMjcsIDEyLCA4LCAxMiwgNiwgMywgMSwgMFxuXTtcblxuVGFibGVzLnQxM0hCID0gW1xuICAgIDEsIDUsIDE0LCAyMSwgMzQsIDUxLCA0NiwgNzEsIDQyLCA1MiwgNjgsIDUyLCA2NywgNDQsIDQzLCAxOSxcbiAgICAzLCA0LCAxMiwgMTksIDMxLCAyNiwgNDQsIDMzLCAzMSwgMjQsIDMyLCAyNCwgMzEsIDM1LCAyMiwgMTQsXG4gICAgMTUsIDEzLCAyMywgMzYsIDU5LCA0OSwgNzcsIDY1LCAyOSwgNDAsIDMwLCA0MCwgMjcsIDMzLCA0MiwgMTYsXG4gICAgMjIsIDIwLCAzNywgNjEsIDU2LCA3OSwgNzMsIDY0LCA0MywgNzYsIDU2LCAzNywgMjYsIDMxLCAyNSwgMTQsXG4gICAgMzUsIDE2LCA2MCwgNTcsIDk3LCA3NSwgMTE0LCA5MSwgNTQsIDczLCA1NSwgNDEsIDQ4LCA1MywgMjMsIDI0LFxuICAgIDU4LCAyNywgNTAsIDk2LCA3NiwgNzAsIDkzLCA4NCwgNzcsIDU4LCA3OSwgMjksIDc0LCA0OSwgNDEsIDE3LFxuICAgIDQ3LCA0NSwgNzgsIDc0LCAxMTUsIDk0LCA5MCwgNzksIDY5LCA4MywgNzEsIDUwLCA1OSwgMzgsIDM2LCAxNSxcbiAgICA3MiwgMzQsIDU2LCA5NSwgOTIsIDg1LCA5MSwgOTAsIDg2LCA3MywgNzcsIDY1LCA1MSwgNDQsIDQzLCA0MixcbiAgICA0MywgMjAsIDMwLCA0NCwgNTUsIDc4LCA3MiwgODcsIDc4LCA2MSwgNDYsIDU0LCAzNywgMzAsIDIwLCAxNixcbiAgICA1MywgMjUsIDQxLCAzNywgNDQsIDU5LCA1NCwgODEsIDY2LCA3NiwgNTcsIDU0LCAzNywgMTgsIDM5LCAxMSxcbiAgICAzNSwgMzMsIDMxLCA1NywgNDIsIDgyLCA3MiwgODAsIDQ3LCA1OCwgNTUsIDIxLCAyMiwgMjYsIDM4LCAyMixcbiAgICA1MywgMjUsIDIzLCAzOCwgNzAsIDYwLCA1MSwgMzYsIDU1LCAyNiwgMzQsIDIzLCAyNywgMTQsIDksIDcsXG4gICAgMzQsIDMyLCAyOCwgMzksIDQ5LCA3NSwgMzAsIDUyLCA0OCwgNDAsIDUyLCAyOCwgMTgsIDE3LCA5LCA1LFxuICAgIDQ1LCAyMSwgMzQsIDY0LCA1NiwgNTAsIDQ5LCA0NSwgMzEsIDE5LCAxMiwgMTUsIDEwLCA3LCA2LCAzLFxuICAgIDQ4LCAyMywgMjAsIDM5LCAzNiwgMzUsIDUzLCAyMSwgMTYsIDIzLCAxMywgMTAsIDYsIDEsIDQsIDIsXG4gICAgMTYsIDE1LCAxNywgMjcsIDI1LCAyMCwgMjksIDExLCAxNywgMTIsIDE2LCA4LCAxLCAxLCAwLCAxXG5dO1xuXG5UYWJsZXMudDE1SEIgPSBbXG4gICAgNywgMTIsIDE4LCA1MywgNDcsIDc2LCAxMjQsIDEwOCwgODksIDEyMywgMTA4LCAxMTksIDEwNywgODEsIDEyMiwgNjMsXG4gICAgMTMsIDUsIDE2LCAyNywgNDYsIDM2LCA2MSwgNTEsIDQyLCA3MCwgNTIsIDgzLCA2NSwgNDEsIDU5LCAzNixcbiAgICAxOSwgMTcsIDE1LCAyNCwgNDEsIDM0LCA1OSwgNDgsIDQwLCA2NCwgNTAsIDc4LCA2MiwgODAsIDU2LCAzMyxcbiAgICAyOSwgMjgsIDI1LCA0MywgMzksIDYzLCA1NSwgOTMsIDc2LCA1OSwgOTMsIDcyLCA1NCwgNzUsIDUwLCAyOSxcbiAgICA1MiwgMjIsIDQyLCA0MCwgNjcsIDU3LCA5NSwgNzksIDcyLCA1NywgODksIDY5LCA0OSwgNjYsIDQ2LCAyNyxcbiAgICA3NywgMzcsIDM1LCA2NiwgNTgsIDUyLCA5MSwgNzQsIDYyLCA0OCwgNzksIDYzLCA5MCwgNjIsIDQwLCAzOCxcbiAgICAxMjUsIDMyLCA2MCwgNTYsIDUwLCA5MiwgNzgsIDY1LCA1NSwgODcsIDcxLCA1MSwgNzMsIDUxLCA3MCwgMzAsXG4gICAgMTA5LCA1MywgNDksIDk0LCA4OCwgNzUsIDY2LCAxMjIsIDkxLCA3MywgNTYsIDQyLCA2NCwgNDQsIDIxLCAyNSxcbiAgICA5MCwgNDMsIDQxLCA3NywgNzMsIDYzLCA1NiwgOTIsIDc3LCA2NiwgNDcsIDY3LCA0OCwgNTMsIDM2LCAyMCxcbiAgICA3MSwgMzQsIDY3LCA2MCwgNTgsIDQ5LCA4OCwgNzYsIDY3LCAxMDYsIDcxLCA1NCwgMzgsIDM5LCAyMywgMTUsXG4gICAgMTA5LCA1MywgNTEsIDQ3LCA5MCwgODIsIDU4LCA1NywgNDgsIDcyLCA1NywgNDEsIDIzLCAyNywgNjIsIDksXG4gICAgODYsIDQyLCA0MCwgMzcsIDcwLCA2NCwgNTIsIDQzLCA3MCwgNTUsIDQyLCAyNSwgMjksIDE4LCAxMSwgMTEsXG4gICAgMTE4LCA2OCwgMzAsIDU1LCA1MCwgNDYsIDc0LCA2NSwgNDksIDM5LCAyNCwgMTYsIDIyLCAxMywgMTQsIDcsXG4gICAgOTEsIDQ0LCAzOSwgMzgsIDM0LCA2MywgNTIsIDQ1LCAzMSwgNTIsIDI4LCAxOSwgMTQsIDgsIDksIDMsXG4gICAgMTIzLCA2MCwgNTgsIDUzLCA0NywgNDMsIDMyLCAyMiwgMzcsIDI0LCAxNywgMTIsIDE1LCAxMCwgMiwgMSxcbiAgICA3MSwgMzcsIDM0LCAzMCwgMjgsIDIwLCAxNywgMjYsIDIxLCAxNiwgMTAsIDYsIDgsIDYsIDIsIDBcbl07XG5cblRhYmxlcy50MTZIQiA9IFtcbiAgICAxLCA1LCAxNCwgNDQsIDc0LCA2MywgMTEwLCA5MywgMTcyLCAxNDksIDEzOCwgMjQyLCAyMjUsIDE5NSwgMzc2LCAxNyxcbiAgICAzLCA0LCAxMiwgMjAsIDM1LCA2MiwgNTMsIDQ3LCA4MywgNzUsIDY4LCAxMTksIDIwMSwgMTA3LCAyMDcsIDksXG4gICAgMTUsIDEzLCAyMywgMzgsIDY3LCA1OCwgMTAzLCA5MCwgMTYxLCA3MiwgMTI3LCAxMTcsIDExMCwgMjA5LCAyMDYsIDE2LFxuICAgIDQ1LCAyMSwgMzksIDY5LCA2NCwgMTE0LCA5OSwgODcsIDE1OCwgMTQwLCAyNTIsIDIxMiwgMTk5LCAzODcsIDM2NSwgMjYsXG4gICAgNzUsIDM2LCA2OCwgNjUsIDExNSwgMTAxLCAxNzksIDE2NCwgMTU1LCAyNjQsIDI0NiwgMjI2LCAzOTUsIDM4MiwgMzYyLCA5LFxuICAgIDY2LCAzMCwgNTksIDU2LCAxMDIsIDE4NSwgMTczLCAyNjUsIDE0MiwgMjUzLCAyMzIsIDQwMCwgMzg4LCAzNzgsIDQ0NSwgMTYsXG4gICAgMTExLCA1NCwgNTIsIDEwMCwgMTg0LCAxNzgsIDE2MCwgMTMzLCAyNTcsIDI0NCwgMjI4LCAyMTcsIDM4NSwgMzY2LCA3MTUsIDEwLFxuICAgIDk4LCA0OCwgOTEsIDg4LCAxNjUsIDE1NywgMTQ4LCAyNjEsIDI0OCwgNDA3LCAzOTcsIDM3MiwgMzgwLCA4ODksIDg4NCwgOCxcbiAgICA4NSwgODQsIDgxLCAxNTksIDE1NiwgMTQzLCAyNjAsIDI0OSwgNDI3LCA0MDEsIDM5MiwgMzgzLCA3MjcsIDcxMywgNzA4LCA3LFxuICAgIDE1NCwgNzYsIDczLCAxNDEsIDEzMSwgMjU2LCAyNDUsIDQyNiwgNDA2LCAzOTQsIDM4NCwgNzM1LCAzNTksIDcxMCwgMzUyLCAxMSxcbiAgICAxMzksIDEyOSwgNjcsIDEyNSwgMjQ3LCAyMzMsIDIyOSwgMjE5LCAzOTMsIDc0MywgNzM3LCA3MjAsIDg4NSwgODgyLCA0MzksIDQsXG4gICAgMjQzLCAxMjAsIDExOCwgMTE1LCAyMjcsIDIyMywgMzk2LCA3NDYsIDc0MiwgNzM2LCA3MjEsIDcxMiwgNzA2LCAyMjMsIDQzNiwgNixcbiAgICAyMDIsIDIyNCwgMjIyLCAyMTgsIDIxNiwgMzg5LCAzODYsIDM4MSwgMzY0LCA4ODgsIDQ0MywgNzA3LCA0NDAsIDQzNywgMTcyOCwgNCxcbiAgICA3NDcsIDIxMSwgMjEwLCAyMDgsIDM3MCwgMzc5LCA3MzQsIDcyMywgNzE0LCAxNzM1LCA4ODMsIDg3NywgODc2LCAzNDU5LCA4NjUsIDIsXG4gICAgMzc3LCAzNjksIDEwMiwgMTg3LCA3MjYsIDcyMiwgMzU4LCA3MTEsIDcwOSwgODY2LCAxNzM0LCA4NzEsIDM0NTgsIDg3MCwgNDM0LCAwLFxuICAgIDEyLCAxMCwgNywgMTEsIDEwLCAxNywgMTEsIDksIDEzLCAxMiwgMTAsIDcsIDUsIDMsIDEsIDNcbl07XG5cblRhYmxlcy50MjRIQiA9IFtcbiAgICAxNSwgMTMsIDQ2LCA4MCwgMTQ2LCAyNjIsIDI0OCwgNDM0LCA0MjYsIDY2OSwgNjUzLCA2NDksIDYyMSwgNTE3LCAxMDMyLCA4OCxcbiAgICAxNCwgMTIsIDIxLCAzOCwgNzEsIDEzMCwgMTIyLCAyMTYsIDIwOSwgMTk4LCAzMjcsIDM0NSwgMzE5LCAyOTcsIDI3OSwgNDIsXG4gICAgNDcsIDIyLCA0MSwgNzQsIDY4LCAxMjgsIDEyMCwgMjIxLCAyMDcsIDE5NCwgMTgyLCAzNDAsIDMxNSwgMjk1LCA1NDEsIDE4LFxuICAgIDgxLCAzOSwgNzUsIDcwLCAxMzQsIDEyNSwgMTE2LCAyMjAsIDIwNCwgMTkwLCAxNzgsIDMyNSwgMzExLCAyOTMsIDI3MSwgMTYsXG4gICAgMTQ3LCA3MiwgNjksIDEzNSwgMTI3LCAxMTgsIDExMiwgMjEwLCAyMDAsIDE4OCwgMzUyLCAzMjMsIDMwNiwgMjg1LCA1NDAsIDE0LFxuICAgIDI2MywgNjYsIDEyOSwgMTI2LCAxMTksIDExNCwgMjE0LCAyMDIsIDE5MiwgMTgwLCAzNDEsIDMxNywgMzAxLCAyODEsIDI2MiwgMTIsXG4gICAgMjQ5LCAxMjMsIDEyMSwgMTE3LCAxMTMsIDIxNSwgMjA2LCAxOTUsIDE4NSwgMzQ3LCAzMzAsIDMwOCwgMjkxLCAyNzIsIDUyMCwgMTAsXG4gICAgNDM1LCAxMTUsIDExMSwgMTA5LCAyMTEsIDIwMywgMTk2LCAxODcsIDM1MywgMzMyLCAzMTMsIDI5OCwgMjgzLCA1MzEsIDM4MSwgMTcsXG4gICAgNDI3LCAyMTIsIDIwOCwgMjA1LCAyMDEsIDE5MywgMTg2LCAxNzcsIDE2OSwgMzIwLCAzMDMsIDI4NiwgMjY4LCA1MTQsIDM3NywgMTYsXG4gICAgMzM1LCAxOTksIDE5NywgMTkxLCAxODksIDE4MSwgMTc0LCAzMzMsIDMyMSwgMzA1LCAyODksIDI3NSwgNTIxLCAzNzksIDM3MSwgMTEsXG4gICAgNjY4LCAxODQsIDE4MywgMTc5LCAxNzUsIDM0NCwgMzMxLCAzMTQsIDMwNCwgMjkwLCAyNzcsIDUzMCwgMzgzLCAzNzMsIDM2NiwgMTAsXG4gICAgNjUyLCAzNDYsIDE3MSwgMTY4LCAxNjQsIDMxOCwgMzA5LCAyOTksIDI4NywgMjc2LCAyNjMsIDUxMywgMzc1LCAzNjgsIDM2MiwgNixcbiAgICA2NDgsIDMyMiwgMzE2LCAzMTIsIDMwNywgMzAyLCAyOTIsIDI4NCwgMjY5LCAyNjEsIDUxMiwgMzc2LCAzNzAsIDM2NCwgMzU5LCA0LFxuICAgIDYyMCwgMzAwLCAyOTYsIDI5NCwgMjg4LCAyODIsIDI3MywgMjY2LCA1MTUsIDM4MCwgMzc0LCAzNjksIDM2NSwgMzYxLCAzNTcsIDIsXG4gICAgMTAzMywgMjgwLCAyNzgsIDI3NCwgMjY3LCAyNjQsIDI1OSwgMzgyLCAzNzgsIDM3MiwgMzY3LCAzNjMsIDM2MCwgMzU4LCAzNTYsIDAsXG4gICAgNDMsIDIwLCAxOSwgMTcsIDE1LCAxMywgMTEsIDksIDcsIDYsIDQsIDcsIDUsIDMsIDEsIDNcbl07XG5cblRhYmxlcy50MzJIQiA9IFtcbiAgICAxIDw8IDAsIDUgPDwgMSwgNCA8PCAxLCA1IDw8IDIsIDYgPDwgMSwgNSA8PCAyLCA0IDw8IDIsIDQgPDwgMyxcbiAgICA3IDw8IDEsIDMgPDwgMiwgNiA8PCAyLCAwIDw8IDMsIDcgPDwgMiwgMiA8PCAzLCAzIDw8IDMsIDEgPDwgNFxuXTtcblxuVGFibGVzLnQzM0hCID0gW1xuICAgIDE1IDw8IDAsIDE0IDw8IDEsIDEzIDw8IDEsIDEyIDw8IDIsIDExIDw8IDEsIDEwIDw8IDIsIDkgPDwgMiwgOCA8PCAzLFxuICAgIDcgPDwgMSwgNiA8PCAyLCA1IDw8IDIsIDQgPDwgMywgMyA8PCAyLCAyIDw8IDMsIDEgPDwgMywgMCA8PCA0XG5dO1xuXG5UYWJsZXMudDFsID0gW1xuICAgIDEsIDQsXG4gICAgMywgNVxuXTtcblxuVGFibGVzLnQybCA9IFtcbiAgICAxLCA0LCA3LFxuICAgIDQsIDUsIDcsXG4gICAgNiwgNywgOFxuXTtcblxuVGFibGVzLnQzbCA9IFtcbiAgICAyLCAzLCA3LFxuICAgIDQsIDQsIDcsXG4gICAgNiwgNywgOFxuXTtcblxuVGFibGVzLnQ1bCA9IFtcbiAgICAxLCA0LCA3LCA4LFxuICAgIDQsIDUsIDgsIDksXG4gICAgNywgOCwgOSwgMTAsXG4gICAgOCwgOCwgOSwgMTBcbl07XG5cblRhYmxlcy50NmwgPSBbXG4gICAgMywgNCwgNiwgOCxcbiAgICA0LCA0LCA2LCA3LFxuICAgIDUsIDYsIDcsIDgsXG4gICAgNywgNywgOCwgOVxuXTtcblxuVGFibGVzLnQ3bCA9IFtcbiAgICAxLCA0LCA3LCA5LCA5LCAxMCxcbiAgICA0LCA2LCA4LCA5LCA5LCAxMCxcbiAgICA3LCA3LCA5LCAxMCwgMTAsIDExLFxuICAgIDgsIDksIDEwLCAxMSwgMTEsIDExLFxuICAgIDgsIDksIDEwLCAxMSwgMTEsIDEyLFxuICAgIDksIDEwLCAxMSwgMTIsIDEyLCAxMlxuXTtcblxuVGFibGVzLnQ4bCA9IFtcbiAgICAyLCA0LCA3LCA5LCA5LCAxMCxcbiAgICA0LCA0LCA2LCAxMCwgMTAsIDEwLFxuICAgIDcsIDYsIDgsIDEwLCAxMCwgMTEsXG4gICAgOSwgMTAsIDEwLCAxMSwgMTEsIDEyLFxuICAgIDksIDksIDEwLCAxMSwgMTIsIDEyLFxuICAgIDEwLCAxMCwgMTEsIDExLCAxMywgMTNcbl07XG5cblRhYmxlcy50OWwgPSBbXG4gICAgMywgNCwgNiwgNywgOSwgMTAsXG4gICAgNCwgNSwgNiwgNywgOCwgMTAsXG4gICAgNSwgNiwgNywgOCwgOSwgMTAsXG4gICAgNywgNywgOCwgOSwgOSwgMTAsXG4gICAgOCwgOCwgOSwgOSwgMTAsIDExLFxuICAgIDksIDksIDEwLCAxMCwgMTEsIDExXG5dO1xuXG5UYWJsZXMudDEwbCA9IFtcbiAgICAxLCA0LCA3LCA5LCAxMCwgMTAsIDEwLCAxMSxcbiAgICA0LCA2LCA4LCA5LCAxMCwgMTEsIDEwLCAxMCxcbiAgICA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMSwgMTEsXG4gICAgOCwgOSwgMTAsIDExLCAxMiwgMTIsIDExLCAxMixcbiAgICA5LCAxMCwgMTEsIDEyLCAxMiwgMTIsIDEyLCAxMixcbiAgICAxMCwgMTEsIDEyLCAxMiwgMTMsIDEzLCAxMiwgMTMsXG4gICAgOSwgMTAsIDExLCAxMiwgMTIsIDEyLCAxMywgMTMsXG4gICAgMTAsIDEwLCAxMSwgMTIsIDEyLCAxMywgMTMsIDEzXG5dO1xuXG5UYWJsZXMudDExbCA9IFtcbiAgICAyLCA0LCA2LCA4LCA5LCAxMCwgOSwgMTAsXG4gICAgNCwgNSwgNiwgOCwgMTAsIDEwLCA5LCAxMCxcbiAgICA2LCA3LCA4LCA5LCAxMCwgMTEsIDEwLCAxMCxcbiAgICA4LCA4LCA5LCAxMSwgMTAsIDEyLCAxMCwgMTEsXG4gICAgOSwgMTAsIDEwLCAxMSwgMTEsIDEyLCAxMSwgMTIsXG4gICAgOSwgMTAsIDExLCAxMiwgMTIsIDEzLCAxMiwgMTMsXG4gICAgOSwgOSwgOSwgMTAsIDExLCAxMiwgMTIsIDEyLFxuICAgIDksIDksIDEwLCAxMSwgMTIsIDEyLCAxMiwgMTJcbl07XG5cblRhYmxlcy50MTJsID0gW1xuICAgIDQsIDQsIDYsIDgsIDksIDEwLCAxMCwgMTAsXG4gICAgNCwgNSwgNiwgNywgOSwgOSwgMTAsIDEwLFxuICAgIDYsIDYsIDcsIDgsIDksIDEwLCA5LCAxMCxcbiAgICA3LCA3LCA4LCA4LCA5LCAxMCwgMTAsIDEwLFxuICAgIDgsIDgsIDksIDksIDEwLCAxMCwgMTAsIDExLFxuICAgIDksIDksIDEwLCAxMCwgMTAsIDExLCAxMCwgMTEsXG4gICAgOSwgOSwgOSwgMTAsIDEwLCAxMSwgMTEsIDEyLFxuICAgIDEwLCAxMCwgMTAsIDExLCAxMSwgMTEsIDExLCAxMlxuXTtcblxuVGFibGVzLnQxM2wgPSBbXG4gICAgMSwgNSwgNywgOCwgOSwgMTAsIDEwLCAxMSwgMTAsIDExLCAxMiwgMTIsIDEzLCAxMywgMTQsIDE0LFxuICAgIDQsIDYsIDgsIDksIDEwLCAxMCwgMTEsIDExLCAxMSwgMTEsIDEyLCAxMiwgMTMsIDE0LCAxNCwgMTQsXG4gICAgNywgOCwgOSwgMTAsIDExLCAxMSwgMTIsIDEyLCAxMSwgMTIsIDEyLCAxMywgMTMsIDE0LCAxNSwgMTUsXG4gICAgOCwgOSwgMTAsIDExLCAxMSwgMTIsIDEyLCAxMiwgMTIsIDEzLCAxMywgMTMsIDEzLCAxNCwgMTUsIDE1LFxuICAgIDksIDksIDExLCAxMSwgMTIsIDEyLCAxMywgMTMsIDEyLCAxMywgMTMsIDE0LCAxNCwgMTUsIDE1LCAxNixcbiAgICAxMCwgMTAsIDExLCAxMiwgMTIsIDEyLCAxMywgMTMsIDEzLCAxMywgMTQsIDEzLCAxNSwgMTUsIDE2LCAxNixcbiAgICAxMCwgMTEsIDEyLCAxMiwgMTMsIDEzLCAxMywgMTMsIDEzLCAxNCwgMTQsIDE0LCAxNSwgMTUsIDE2LCAxNixcbiAgICAxMSwgMTEsIDEyLCAxMywgMTMsIDEzLCAxNCwgMTQsIDE0LCAxNCwgMTUsIDE1LCAxNSwgMTYsIDE4LCAxOCxcbiAgICAxMCwgMTAsIDExLCAxMiwgMTIsIDEzLCAxMywgMTQsIDE0LCAxNCwgMTQsIDE1LCAxNSwgMTYsIDE3LCAxNyxcbiAgICAxMSwgMTEsIDEyLCAxMiwgMTMsIDEzLCAxMywgMTUsIDE0LCAxNSwgMTUsIDE2LCAxNiwgMTYsIDE4LCAxNyxcbiAgICAxMSwgMTIsIDEyLCAxMywgMTMsIDE0LCAxNCwgMTUsIDE0LCAxNSwgMTYsIDE1LCAxNiwgMTcsIDE4LCAxOSxcbiAgICAxMiwgMTIsIDEyLCAxMywgMTQsIDE0LCAxNCwgMTQsIDE1LCAxNSwgMTUsIDE2LCAxNywgMTcsIDE3LCAxOCxcbiAgICAxMiwgMTMsIDEzLCAxNCwgMTQsIDE1LCAxNCwgMTUsIDE2LCAxNiwgMTcsIDE3LCAxNywgMTgsIDE4LCAxOCxcbiAgICAxMywgMTMsIDE0LCAxNSwgMTUsIDE1LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE3LCAxOCwgMTcsIDE4LCAxOCxcbiAgICAxNCwgMTQsIDE0LCAxNSwgMTUsIDE1LCAxNywgMTYsIDE2LCAxOSwgMTcsIDE3LCAxNywgMTksIDE4LCAxOCxcbiAgICAxMywgMTQsIDE1LCAxNiwgMTYsIDE2LCAxNywgMTYsIDE3LCAxNywgMTgsIDE4LCAyMSwgMjAsIDIxLCAxOFxuXTtcblxuVGFibGVzLnQxNWwgPSBbXG4gICAgMywgNSwgNiwgOCwgOCwgOSwgMTAsIDEwLCAxMCwgMTEsIDExLCAxMiwgMTIsIDEyLCAxMywgMTQsXG4gICAgNSwgNSwgNywgOCwgOSwgOSwgMTAsIDEwLCAxMCwgMTEsIDExLCAxMiwgMTIsIDEyLCAxMywgMTMsXG4gICAgNiwgNywgNywgOCwgOSwgOSwgMTAsIDEwLCAxMCwgMTEsIDExLCAxMiwgMTIsIDEzLCAxMywgMTMsXG4gICAgNywgOCwgOCwgOSwgOSwgMTAsIDEwLCAxMSwgMTEsIDExLCAxMiwgMTIsIDEyLCAxMywgMTMsIDEzLFxuICAgIDgsIDgsIDksIDksIDEwLCAxMCwgMTEsIDExLCAxMSwgMTEsIDEyLCAxMiwgMTIsIDEzLCAxMywgMTMsXG4gICAgOSwgOSwgOSwgMTAsIDEwLCAxMCwgMTEsIDExLCAxMSwgMTEsIDEyLCAxMiwgMTMsIDEzLCAxMywgMTQsXG4gICAgMTAsIDksIDEwLCAxMCwgMTAsIDExLCAxMSwgMTEsIDExLCAxMiwgMTIsIDEyLCAxMywgMTMsIDE0LCAxNCxcbiAgICAxMCwgMTAsIDEwLCAxMSwgMTEsIDExLCAxMSwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMywgMTMsIDEzLCAxNCxcbiAgICAxMCwgMTAsIDEwLCAxMSwgMTEsIDExLCAxMSwgMTIsIDEyLCAxMiwgMTIsIDEzLCAxMywgMTQsIDE0LCAxNCxcbiAgICAxMCwgMTAsIDExLCAxMSwgMTEsIDExLCAxMiwgMTIsIDEyLCAxMywgMTMsIDEzLCAxMywgMTQsIDE0LCAxNCxcbiAgICAxMSwgMTEsIDExLCAxMSwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMywgMTMsIDEzLCAxMywgMTQsIDE1LCAxNCxcbiAgICAxMSwgMTEsIDExLCAxMSwgMTIsIDEyLCAxMiwgMTIsIDEzLCAxMywgMTMsIDEzLCAxNCwgMTQsIDE0LCAxNSxcbiAgICAxMiwgMTIsIDExLCAxMiwgMTIsIDEyLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxNCwgMTQsIDE1LCAxNSxcbiAgICAxMiwgMTIsIDEyLCAxMiwgMTIsIDEzLCAxMywgMTMsIDEzLCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE1LCAxNSxcbiAgICAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDE0LCAxNCwgMTQsIDE0LCAxNSwgMTUsIDE0LCAxNSxcbiAgICAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNSwgMTUsIDE1LCAxNVxuXTtcblxuVGFibGVzLnQxNl81bCA9IFtcbiAgICAxLCA1LCA3LCA5LCAxMCwgMTAsIDExLCAxMSwgMTIsIDEyLCAxMiwgMTMsIDEzLCAxMywgMTQsIDExLFxuICAgIDQsIDYsIDgsIDksIDEwLCAxMSwgMTEsIDExLCAxMiwgMTIsIDEyLCAxMywgMTQsIDEzLCAxNCwgMTEsXG4gICAgNywgOCwgOSwgMTAsIDExLCAxMSwgMTIsIDEyLCAxMywgMTIsIDEzLCAxMywgMTMsIDE0LCAxNCwgMTIsXG4gICAgOSwgOSwgMTAsIDExLCAxMSwgMTIsIDEyLCAxMiwgMTMsIDEzLCAxNCwgMTQsIDE0LCAxNSwgMTUsIDEzLFxuICAgIDEwLCAxMCwgMTEsIDExLCAxMiwgMTIsIDEzLCAxMywgMTMsIDE0LCAxNCwgMTQsIDE1LCAxNSwgMTUsIDEyLFxuICAgIDEwLCAxMCwgMTEsIDExLCAxMiwgMTMsIDEzLCAxNCwgMTMsIDE0LCAxNCwgMTUsIDE1LCAxNSwgMTYsIDEzLFxuICAgIDExLCAxMSwgMTEsIDEyLCAxMywgMTMsIDEzLCAxMywgMTQsIDE0LCAxNCwgMTQsIDE1LCAxNSwgMTYsIDEzLFxuICAgIDExLCAxMSwgMTIsIDEyLCAxMywgMTMsIDEzLCAxNCwgMTQsIDE1LCAxNSwgMTUsIDE1LCAxNywgMTcsIDEzLFxuICAgIDExLCAxMiwgMTIsIDEzLCAxMywgMTMsIDE0LCAxNCwgMTUsIDE1LCAxNSwgMTUsIDE2LCAxNiwgMTYsIDEzLFxuICAgIDEyLCAxMiwgMTIsIDEzLCAxMywgMTQsIDE0LCAxNSwgMTUsIDE1LCAxNSwgMTYsIDE1LCAxNiwgMTUsIDE0LFxuICAgIDEyLCAxMywgMTIsIDEzLCAxNCwgMTQsIDE0LCAxNCwgMTUsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTYsIDEzLFxuICAgIDEzLCAxMywgMTMsIDEzLCAxNCwgMTQsIDE1LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNSwgMTYsIDE0LFxuICAgIDEzLCAxNCwgMTQsIDE0LCAxNCwgMTUsIDE1LCAxNSwgMTUsIDE3LCAxNiwgMTYsIDE2LCAxNiwgMTgsIDE0LFxuICAgIDE1LCAxNCwgMTQsIDE0LCAxNSwgMTUsIDE2LCAxNiwgMTYsIDE4LCAxNywgMTcsIDE3LCAxOSwgMTcsIDE0LFxuICAgIDE0LCAxNSwgMTMsIDE0LCAxNiwgMTYsIDE1LCAxNiwgMTYsIDE3LCAxOCwgMTcsIDE5LCAxNywgMTYsIDE0LFxuICAgIDExLCAxMSwgMTEsIDEyLCAxMiwgMTMsIDEzLCAxMywgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDEyXG5dO1xuXG5UYWJsZXMudDE2bCA9IFtcbiAgICAxLCA1LCA3LCA5LCAxMCwgMTAsIDExLCAxMSwgMTIsIDEyLCAxMiwgMTMsIDEzLCAxMywgMTQsIDEwLFxuICAgIDQsIDYsIDgsIDksIDEwLCAxMSwgMTEsIDExLCAxMiwgMTIsIDEyLCAxMywgMTQsIDEzLCAxNCwgMTAsXG4gICAgNywgOCwgOSwgMTAsIDExLCAxMSwgMTIsIDEyLCAxMywgMTIsIDEzLCAxMywgMTMsIDE0LCAxNCwgMTEsXG4gICAgOSwgOSwgMTAsIDExLCAxMSwgMTIsIDEyLCAxMiwgMTMsIDEzLCAxNCwgMTQsIDE0LCAxNSwgMTUsIDEyLFxuICAgIDEwLCAxMCwgMTEsIDExLCAxMiwgMTIsIDEzLCAxMywgMTMsIDE0LCAxNCwgMTQsIDE1LCAxNSwgMTUsIDExLFxuICAgIDEwLCAxMCwgMTEsIDExLCAxMiwgMTMsIDEzLCAxNCwgMTMsIDE0LCAxNCwgMTUsIDE1LCAxNSwgMTYsIDEyLFxuICAgIDExLCAxMSwgMTEsIDEyLCAxMywgMTMsIDEzLCAxMywgMTQsIDE0LCAxNCwgMTQsIDE1LCAxNSwgMTYsIDEyLFxuICAgIDExLCAxMSwgMTIsIDEyLCAxMywgMTMsIDEzLCAxNCwgMTQsIDE1LCAxNSwgMTUsIDE1LCAxNywgMTcsIDEyLFxuICAgIDExLCAxMiwgMTIsIDEzLCAxMywgMTMsIDE0LCAxNCwgMTUsIDE1LCAxNSwgMTUsIDE2LCAxNiwgMTYsIDEyLFxuICAgIDEyLCAxMiwgMTIsIDEzLCAxMywgMTQsIDE0LCAxNSwgMTUsIDE1LCAxNSwgMTYsIDE1LCAxNiwgMTUsIDEzLFxuICAgIDEyLCAxMywgMTIsIDEzLCAxNCwgMTQsIDE0LCAxNCwgMTUsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTYsIDEyLFxuICAgIDEzLCAxMywgMTMsIDEzLCAxNCwgMTQsIDE1LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNSwgMTYsIDEzLFxuICAgIDEzLCAxNCwgMTQsIDE0LCAxNCwgMTUsIDE1LCAxNSwgMTUsIDE3LCAxNiwgMTYsIDE2LCAxNiwgMTgsIDEzLFxuICAgIDE1LCAxNCwgMTQsIDE0LCAxNSwgMTUsIDE2LCAxNiwgMTYsIDE4LCAxNywgMTcsIDE3LCAxOSwgMTcsIDEzLFxuICAgIDE0LCAxNSwgMTMsIDE0LCAxNiwgMTYsIDE1LCAxNiwgMTYsIDE3LCAxOCwgMTcsIDE5LCAxNywgMTYsIDEzLFxuICAgIDEwLCAxMCwgMTAsIDExLCAxMSwgMTIsIDEyLCAxMiwgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEwXG5dO1xuXG5UYWJsZXMudDI0bCA9IFtcbiAgICA0LCA1LCA3LCA4LCA5LCAxMCwgMTAsIDExLCAxMSwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMywgMTAsXG4gICAgNSwgNiwgNywgOCwgOSwgMTAsIDEwLCAxMSwgMTEsIDExLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEwLFxuICAgIDcsIDcsIDgsIDksIDksIDEwLCAxMCwgMTEsIDExLCAxMSwgMTEsIDEyLCAxMiwgMTIsIDEzLCA5LFxuICAgIDgsIDgsIDksIDksIDEwLCAxMCwgMTAsIDExLCAxMSwgMTEsIDExLCAxMiwgMTIsIDEyLCAxMiwgOSxcbiAgICA5LCA5LCA5LCAxMCwgMTAsIDEwLCAxMCwgMTEsIDExLCAxMSwgMTIsIDEyLCAxMiwgMTIsIDEzLCA5LFxuICAgIDEwLCA5LCAxMCwgMTAsIDEwLCAxMCwgMTEsIDExLCAxMSwgMTEsIDEyLCAxMiwgMTIsIDEyLCAxMiwgOSxcbiAgICAxMCwgMTAsIDEwLCAxMCwgMTAsIDExLCAxMSwgMTEsIDExLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEzLCA5LFxuICAgIDExLCAxMCwgMTAsIDEwLCAxMSwgMTEsIDExLCAxMSwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMywgMTMsIDEwLFxuICAgIDExLCAxMSwgMTEsIDExLCAxMSwgMTEsIDExLCAxMSwgMTEsIDEyLCAxMiwgMTIsIDEyLCAxMywgMTMsIDEwLFxuICAgIDExLCAxMSwgMTEsIDExLCAxMSwgMTEsIDExLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEzLCAxMywgMTMsIDEwLFxuICAgIDEyLCAxMSwgMTEsIDExLCAxMSwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTMsIDEzLCAxMywgMTMsIDEwLFxuICAgIDEyLCAxMiwgMTEsIDExLCAxMSwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTMsIDEzLCAxMywgMTMsIDEwLFxuICAgIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMywgMTMsIDEzLCAxMywgMTMsIDEwLFxuICAgIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEwLFxuICAgIDEzLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEwLFxuICAgIDksIDksIDksIDksIDksIDksIDksIDksIDksIDksIDksIDEwLCAxMCwgMTAsIDEwLCA2XG5dO1xuXG5UYWJsZXMudDMybCA9IFtcbiAgICAxICsgMCwgNCArIDEsIDQgKyAxLCA1ICsgMiwgNCArIDEsIDYgKyAyLCA1ICsgMiwgNiArIDMsXG4gICAgNCArIDEsIDUgKyAyLCA1ICsgMiwgNiArIDMsIDUgKyAyLCA2ICsgMywgNiArIDMsIDYgKyA0XG5dO1xuXG5UYWJsZXMudDMzbCA9IFtcbiAgICA0ICsgMCwgNCArIDEsIDQgKyAxLCA0ICsgMiwgNCArIDEsIDQgKyAyLCA0ICsgMiwgNCArIDMsXG4gICAgNCArIDEsIDQgKyAyLCA0ICsgMiwgNCArIDMsIDQgKyAyLCA0ICsgMywgNCArIDMsIDQgKyA0XG5dO1xuXG5UYWJsZXMuaHQgPSBbXG4gICAgLyogeGxlbiwgbGlubWF4LCB0YWJsZSwgaGxlbiAqL1xuICAgIG5ldyBIdWZmQ29kZVRhYigwLCAwLCBudWxsLCBudWxsKSxcbiAgICBuZXcgSHVmZkNvZGVUYWIoMiwgMCwgVGFibGVzLnQxSEIsIFRhYmxlcy50MWwpLFxuICAgIG5ldyBIdWZmQ29kZVRhYigzLCAwLCBUYWJsZXMudDJIQiwgVGFibGVzLnQybCksXG4gICAgbmV3IEh1ZmZDb2RlVGFiKDMsIDAsIFRhYmxlcy50M0hCLCBUYWJsZXMudDNsKSxcbiAgICBuZXcgSHVmZkNvZGVUYWIoMCwgMCwgbnVsbCwgbnVsbCksIC8qIEFwcGFyZW50bHkgbm90IHVzZWQgKi9cbiAgICBuZXcgSHVmZkNvZGVUYWIoNCwgMCwgVGFibGVzLnQ1SEIsIFRhYmxlcy50NWwpLFxuICAgIG5ldyBIdWZmQ29kZVRhYig0LCAwLCBUYWJsZXMudDZIQiwgVGFibGVzLnQ2bCksXG4gICAgbmV3IEh1ZmZDb2RlVGFiKDYsIDAsIFRhYmxlcy50N0hCLCBUYWJsZXMudDdsKSxcbiAgICBuZXcgSHVmZkNvZGVUYWIoNiwgMCwgVGFibGVzLnQ4SEIsIFRhYmxlcy50OGwpLFxuICAgIG5ldyBIdWZmQ29kZVRhYig2LCAwLCBUYWJsZXMudDlIQiwgVGFibGVzLnQ5bCksXG4gICAgbmV3IEh1ZmZDb2RlVGFiKDgsIDAsIFRhYmxlcy50MTBIQiwgVGFibGVzLnQxMGwpLFxuICAgIG5ldyBIdWZmQ29kZVRhYig4LCAwLCBUYWJsZXMudDExSEIsIFRhYmxlcy50MTFsKSxcbiAgICBuZXcgSHVmZkNvZGVUYWIoOCwgMCwgVGFibGVzLnQxMkhCLCBUYWJsZXMudDEybCksXG4gICAgbmV3IEh1ZmZDb2RlVGFiKDE2LCAwLCBUYWJsZXMudDEzSEIsIFRhYmxlcy50MTNsKSxcbiAgICBuZXcgSHVmZkNvZGVUYWIoMCwgMCwgbnVsbCwgVGFibGVzLnQxNl81bCksIC8qIEFwcGFyZW50bHkgbm90IHVzZWQgKi9cbiAgICBuZXcgSHVmZkNvZGVUYWIoMTYsIDAsIFRhYmxlcy50MTVIQiwgVGFibGVzLnQxNWwpLFxuXG4gICAgbmV3IEh1ZmZDb2RlVGFiKDEsIDEsIFRhYmxlcy50MTZIQiwgVGFibGVzLnQxNmwpLFxuICAgIG5ldyBIdWZmQ29kZVRhYigyLCAzLCBUYWJsZXMudDE2SEIsIFRhYmxlcy50MTZsKSxcbiAgICBuZXcgSHVmZkNvZGVUYWIoMywgNywgVGFibGVzLnQxNkhCLCBUYWJsZXMudDE2bCksXG4gICAgbmV3IEh1ZmZDb2RlVGFiKDQsIDE1LCBUYWJsZXMudDE2SEIsIFRhYmxlcy50MTZsKSxcbiAgICBuZXcgSHVmZkNvZGVUYWIoNiwgNjMsIFRhYmxlcy50MTZIQiwgVGFibGVzLnQxNmwpLFxuICAgIG5ldyBIdWZmQ29kZVRhYig4LCAyNTUsIFRhYmxlcy50MTZIQiwgVGFibGVzLnQxNmwpLFxuICAgIG5ldyBIdWZmQ29kZVRhYigxMCwgMTAyMywgVGFibGVzLnQxNkhCLCBUYWJsZXMudDE2bCksXG4gICAgbmV3IEh1ZmZDb2RlVGFiKDEzLCA4MTkxLCBUYWJsZXMudDE2SEIsIFRhYmxlcy50MTZsKSxcblxuICAgIG5ldyBIdWZmQ29kZVRhYig0LCAxNSwgVGFibGVzLnQyNEhCLCBUYWJsZXMudDI0bCksXG4gICAgbmV3IEh1ZmZDb2RlVGFiKDUsIDMxLCBUYWJsZXMudDI0SEIsIFRhYmxlcy50MjRsKSxcbiAgICBuZXcgSHVmZkNvZGVUYWIoNiwgNjMsIFRhYmxlcy50MjRIQiwgVGFibGVzLnQyNGwpLFxuICAgIG5ldyBIdWZmQ29kZVRhYig3LCAxMjcsIFRhYmxlcy50MjRIQiwgVGFibGVzLnQyNGwpLFxuICAgIG5ldyBIdWZmQ29kZVRhYig4LCAyNTUsIFRhYmxlcy50MjRIQiwgVGFibGVzLnQyNGwpLFxuICAgIG5ldyBIdWZmQ29kZVRhYig5LCA1MTEsIFRhYmxlcy50MjRIQiwgVGFibGVzLnQyNGwpLFxuICAgIG5ldyBIdWZmQ29kZVRhYigxMSwgMjA0NywgVGFibGVzLnQyNEhCLCBUYWJsZXMudDI0bCksXG4gICAgbmV3IEh1ZmZDb2RlVGFiKDEzLCA4MTkxLCBUYWJsZXMudDI0SEIsIFRhYmxlcy50MjRsKSxcblxuICAgIG5ldyBIdWZmQ29kZVRhYigwLCAwLCBUYWJsZXMudDMySEIsIFRhYmxlcy50MzJsKSxcbiAgICBuZXcgSHVmZkNvZGVUYWIoMCwgMCwgVGFibGVzLnQzM0hCLCBUYWJsZXMudDMzbCksXG5dO1xuXG4vKipcbiAqIDxDT0RFPlxuICogIGZvciAoaSA9IDA7IGkgPCAxNioxNjsgaSsrKSBbXG4gKiAgICAgIGxhcmdldGJsW2ldID0gKChodFsxNl0uaGxlbltpXSkgPDwgMTYpICsgaHRbMjRdLmhsZW5baV07XG4gKiAgXVxuICogPC9DT0RFPlxuICpcbiAqL1xuVGFibGVzLmxhcmdldGJsID0gW1xuICAgIDB4MDEwMDA0LCAweDA1MDAwNSwgMHgwNzAwMDcsIDB4MDkwMDA4LCAweDBhMDAwOSwgMHgwYTAwMGEsIDB4MGIwMDBhLCAweDBiMDAwYixcbiAgICAweDBjMDAwYiwgMHgwYzAwMGMsIDB4MGMwMDBjLCAweDBkMDAwYywgMHgwZDAwMGMsIDB4MGQwMDBjLCAweDBlMDAwZCwgMHgwYTAwMGEsXG4gICAgMHgwNDAwMDUsIDB4MDYwMDA2LCAweDA4MDAwNywgMHgwOTAwMDgsIDB4MGEwMDA5LCAweDBiMDAwYSwgMHgwYjAwMGEsIDB4MGIwMDBiLFxuICAgIDB4MGMwMDBiLCAweDBjMDAwYiwgMHgwYzAwMGMsIDB4MGQwMDBjLCAweDBlMDAwYywgMHgwZDAwMGMsIDB4MGUwMDBjLCAweDBhMDAwYSxcbiAgICAweDA3MDAwNywgMHgwODAwMDcsIDB4MDkwMDA4LCAweDBhMDAwOSwgMHgwYjAwMDksIDB4MGIwMDBhLCAweDBjMDAwYSwgMHgwYzAwMGIsXG4gICAgMHgwZDAwMGIsIDB4MGMwMDBiLCAweDBkMDAwYiwgMHgwZDAwMGMsIDB4MGQwMDBjLCAweDBlMDAwYywgMHgwZTAwMGQsIDB4MGIwMDA5LFxuICAgIDB4MDkwMDA4LCAweDA5MDAwOCwgMHgwYTAwMDksIDB4MGIwMDA5LCAweDBiMDAwYSwgMHgwYzAwMGEsIDB4MGMwMDBhLCAweDBjMDAwYixcbiAgICAweDBkMDAwYiwgMHgwZDAwMGIsIDB4MGUwMDBiLCAweDBlMDAwYywgMHgwZTAwMGMsIDB4MGYwMDBjLCAweDBmMDAwYywgMHgwYzAwMDksXG4gICAgMHgwYTAwMDksIDB4MGEwMDA5LCAweDBiMDAwOSwgMHgwYjAwMGEsIDB4MGMwMDBhLCAweDBjMDAwYSwgMHgwZDAwMGEsIDB4MGQwMDBiLFxuICAgIDB4MGQwMDBiLCAweDBlMDAwYiwgMHgwZTAwMGMsIDB4MGUwMDBjLCAweDBmMDAwYywgMHgwZjAwMGMsIDB4MGYwMDBkLCAweDBiMDAwOSxcbiAgICAweDBhMDAwYSwgMHgwYTAwMDksIDB4MGIwMDBhLCAweDBiMDAwYSwgMHgwYzAwMGEsIDB4MGQwMDBhLCAweDBkMDAwYiwgMHgwZTAwMGIsXG4gICAgMHgwZDAwMGIsIDB4MGUwMDBiLCAweDBlMDAwYywgMHgwZjAwMGMsIDB4MGYwMDBjLCAweDBmMDAwYywgMHgxMDAwMGMsIDB4MGMwMDA5LFxuICAgIDB4MGIwMDBhLCAweDBiMDAwYSwgMHgwYjAwMGEsIDB4MGMwMDBhLCAweDBkMDAwYSwgMHgwZDAwMGIsIDB4MGQwMDBiLCAweDBkMDAwYixcbiAgICAweDBlMDAwYiwgMHgwZTAwMGMsIDB4MGUwMDBjLCAweDBlMDAwYywgMHgwZjAwMGMsIDB4MGYwMDBjLCAweDEwMDAwZCwgMHgwYzAwMDksXG4gICAgMHgwYjAwMGIsIDB4MGIwMDBhLCAweDBjMDAwYSwgMHgwYzAwMGEsIDB4MGQwMDBiLCAweDBkMDAwYiwgMHgwZDAwMGIsIDB4MGUwMDBiLFxuICAgIDB4MGUwMDBjLCAweDBmMDAwYywgMHgwZjAwMGMsIDB4MGYwMDBjLCAweDBmMDAwYywgMHgxMTAwMGQsIDB4MTEwMDBkLCAweDBjMDAwYSxcbiAgICAweDBiMDAwYiwgMHgwYzAwMGIsIDB4MGMwMDBiLCAweDBkMDAwYiwgMHgwZDAwMGIsIDB4MGQwMDBiLCAweDBlMDAwYiwgMHgwZTAwMGIsXG4gICAgMHgwZjAwMGIsIDB4MGYwMDBjLCAweDBmMDAwYywgMHgwZjAwMGMsIDB4MTAwMDBjLCAweDEwMDAwZCwgMHgxMDAwMGQsIDB4MGMwMDBhLFxuICAgIDB4MGMwMDBiLCAweDBjMDAwYiwgMHgwYzAwMGIsIDB4MGQwMDBiLCAweDBkMDAwYiwgMHgwZTAwMGIsIDB4MGUwMDBiLCAweDBmMDAwYyxcbiAgICAweDBmMDAwYywgMHgwZjAwMGMsIDB4MGYwMDBjLCAweDEwMDAwYywgMHgwZjAwMGQsIDB4MTAwMDBkLCAweDBmMDAwZCwgMHgwZDAwMGEsXG4gICAgMHgwYzAwMGMsIDB4MGQwMDBiLCAweDBjMDAwYiwgMHgwZDAwMGIsIDB4MGUwMDBiLCAweDBlMDAwYywgMHgwZTAwMGMsIDB4MGUwMDBjLFxuICAgIDB4MGYwMDBjLCAweDEwMDAwYywgMHgxMDAwMGMsIDB4MTAwMDBkLCAweDExMDAwZCwgMHgxMTAwMGQsIDB4MTAwMDBkLCAweDBjMDAwYSxcbiAgICAweDBkMDAwYywgMHgwZDAwMGMsIDB4MGQwMDBiLCAweDBkMDAwYiwgMHgwZTAwMGIsIDB4MGUwMDBjLCAweDBmMDAwYywgMHgxMDAwMGMsXG4gICAgMHgxMDAwMGMsIDB4MTAwMDBjLCAweDEwMDAwYywgMHgxMDAwMGQsIDB4MTAwMDBkLCAweDBmMDAwZCwgMHgxMDAwMGQsIDB4MGQwMDBhLFxuICAgIDB4MGQwMDBjLCAweDBlMDAwYywgMHgwZTAwMGMsIDB4MGUwMDBjLCAweDBlMDAwYywgMHgwZjAwMGMsIDB4MGYwMDBjLCAweDBmMDAwYyxcbiAgICAweDBmMDAwYywgMHgxMTAwMGMsIDB4MTAwMDBkLCAweDEwMDAwZCwgMHgxMDAwMGQsIDB4MTAwMDBkLCAweDEyMDAwZCwgMHgwZDAwMGEsXG4gICAgMHgwZjAwMGMsIDB4MGUwMDBjLCAweDBlMDAwYywgMHgwZTAwMGMsIDB4MGYwMDBjLCAweDBmMDAwYywgMHgxMDAwMGMsIDB4MTAwMDBjLFxuICAgIDB4MTAwMDBkLCAweDEyMDAwZCwgMHgxMTAwMGQsIDB4MTEwMDBkLCAweDExMDAwZCwgMHgxMzAwMGQsIDB4MTEwMDBkLCAweDBkMDAwYSxcbiAgICAweDBlMDAwZCwgMHgwZjAwMGMsIDB4MGQwMDBjLCAweDBlMDAwYywgMHgxMDAwMGMsIDB4MTAwMDBjLCAweDBmMDAwYywgMHgxMDAwMGQsXG4gICAgMHgxMDAwMGQsIDB4MTEwMDBkLCAweDEyMDAwZCwgMHgxMTAwMGQsIDB4MTMwMDBkLCAweDExMDAwZCwgMHgxMDAwMGQsIDB4MGQwMDBhLFxuICAgIDB4MGEwMDA5LCAweDBhMDAwOSwgMHgwYTAwMDksIDB4MGIwMDA5LCAweDBiMDAwOSwgMHgwYzAwMDksIDB4MGMwMDA5LCAweDBjMDAwOSxcbiAgICAweDBkMDAwOSwgMHgwZDAwMDksIDB4MGQwMDA5LCAweDBkMDAwYSwgMHgwZDAwMGEsIDB4MGQwMDBhLCAweDBkMDAwYSwgMHgwYTAwMDZcbl07XG4vKipcbiAqIDxDT0RFPlxuICogIGZvciAoaSA9IDA7IGkgPCAzKjM7IGkrKykgW1xuICogICAgICB0YWJsZTIzW2ldID0gKChodFsyXS5obGVuW2ldKSA8PCAxNikgKyBodFszXS5obGVuW2ldO1xuICogIF1cbiAqIDwvQ09ERT5cbiAqXG4gKi9cblRhYmxlcy50YWJsZTIzID0gW1xuICAgIDB4MDEwMDAyLCAweDA0MDAwMywgMHgwNzAwMDcsXG4gICAgMHgwNDAwMDQsIDB4MDUwMDA0LCAweDA3MDAwNyxcbiAgICAweDA2MDAwNiwgMHgwNzAwMDcsIDB4MDgwMDA4XG5dO1xuXG4vKipcbiAqIDxDT0RFPlxuICogIGZvciAoaSA9IDA7IGkgPCA0KjQ7IGkrKykgW1xuICogICAgICAgdGFibGU1NltpXSA9ICgoaHRbNV0uaGxlbltpXSkgPDwgMTYpICsgaHRbNl0uaGxlbltpXTtcbiAqICAgXVxuICogPC9DT0RFPlxuICpcbiAqL1xuVGFibGVzLnRhYmxlNTYgPSBbXG4gICAgMHgwMTAwMDMsIDB4MDQwMDA0LCAweDA3MDAwNiwgMHgwODAwMDgsIDB4MDQwMDA0LCAweDA1MDAwNCwgMHgwODAwMDYsIDB4MDkwMDA3LFxuICAgIDB4MDcwMDA1LCAweDA4MDAwNiwgMHgwOTAwMDcsIDB4MGEwMDA4LCAweDA4MDAwNywgMHgwODAwMDcsIDB4MDkwMDA4LCAweDBhMDAwOVxuXTtcblxuVGFibGVzLmJpdHJhdGVfdGFibGUgPSBbXG4gICAgWzAsIDgsIDE2LCAyNCwgMzIsIDQwLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNDQsIDE2MCwgLTFdLCAvKiBNUEVHIDIgKi9cbiAgICBbMCwgMzIsIDQwLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNjAsIDE5MiwgMjI0LCAyNTYsIDMyMCwgLTFdLCAvKiBNUEVHIDEgKi9cbiAgICBbMCwgOCwgMTYsIDI0LCAzMiwgNDAsIDQ4LCA1NiwgNjQsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSwgLyogTVBFRyAyLjUgKi9cbl07XG5cbi8qKlxuICogTVBFRyAyLCBNUEVHIDEsIE1QRUcgMi41LlxuICovXG5UYWJsZXMuc2FtcGxlcmF0ZV90YWJsZSA9IFtcbiAgICBbMjIwNTAsIDI0MDAwLCAxNjAwMCwgLTFdLFxuICAgIFs0NDEwMCwgNDgwMDAsIDMyMDAwLCAtMV0sXG4gICAgWzExMDI1LCAxMjAwMCwgODAwMCwgLTFdLFxuXTtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBzY2ZzaV9iYW5kIHRhYmxlIGZyb20gMi40LjIuNyBvZiB0aGUgSVMuXG4gKi9cblRhYmxlcy5zY2ZzaV9iYW5kID0gWzAsIDYsIDExLCAxNiwgMjFdO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRhYmxlcztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lamejs/src/js/Tables.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lamejs/src/js/Takehiro.js":
/*!************************************************!*\
  !*** ./node_modules/lamejs/src/js/Takehiro.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/*\n *\tMP3 huffman table selecting and bit counting\n *\n *\tCopyright (c) 1999-2005 Takehiro TOMINAGA\n *\tCopyright (c) 2002-2005 Gabriel Bouvigne\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */\n\n/* $Id: Takehiro.java,v 1.26 2011/05/24 20:48:06 kenchis Exp $ */\n\n//package mp3;\n\n//import java.util.Arrays;\nvar common = __webpack_require__(/*! ./common.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/common.js\");\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\nvar Encoder = __webpack_require__(/*! ./Encoder.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/Encoder.js\");\nvar Tables = __webpack_require__(/*! ./Tables.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/Tables.js\");\nvar GrInfo = __webpack_require__(/*! ./GrInfo.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/GrInfo.js\");\nvar QuantizePVT = __webpack_require__(/*! ./QuantizePVT.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/QuantizePVT.js\");\n\n\nfunction Takehiro() {\n\n    var qupvt = null;\n    this.qupvt = null;\n\n    this.setModules = function (_qupvt) {\n        this.qupvt = _qupvt;\n        qupvt = _qupvt;\n    }\n\n    function Bits(b) {\n        this.bits = 0 | b;\n    }\n\n    var subdv_table = [[0, 0], /* 0 bands */\n        [0, 0], /* 1 bands */\n        [0, 0], /* 2 bands */\n        [0, 0], /* 3 bands */\n        [0, 0], /* 4 bands */\n        [0, 1], /* 5 bands */\n        [1, 1], /* 6 bands */\n        [1, 1], /* 7 bands */\n        [1, 2], /* 8 bands */\n        [2, 2], /* 9 bands */\n        [2, 3], /* 10 bands */\n        [2, 3], /* 11 bands */\n        [3, 4], /* 12 bands */\n        [3, 4], /* 13 bands */\n        [3, 4], /* 14 bands */\n        [4, 5], /* 15 bands */\n        [4, 5], /* 16 bands */\n        [4, 6], /* 17 bands */\n        [5, 6], /* 18 bands */\n        [5, 6], /* 19 bands */\n        [5, 7], /* 20 bands */\n        [6, 7], /* 21 bands */\n        [6, 7], /* 22 bands */\n    ];\n\n    /**\n     * nonlinear quantization of xr More accurate formula than the ISO formula.\n     * Takes into account the fact that we are quantizing xr . ix, but we want\n     * ix^4/3 to be as close as possible to x^4/3. (taking the nearest int would\n     * mean ix is as close as possible to xr, which is different.)\n     *\n     * From Segher Boessenkool <segher@eastsite.nl> 11/1999\n     *\n     * 09/2000: ASM code removed in favor of IEEE754 hack by Takehiro Tominaga.\n     * If you need the ASM code, check CVS circa Aug 2000.\n     *\n     * 01/2004: Optimizations by Gabriel Bouvigne\n     */\n    function quantize_lines_xrpow_01(l, istep, xr, xrPos, ix, ixPos) {\n        var compareval0 = (1.0 - 0.4054) / istep;\n\n        assert(l > 0);\n        l = l >> 1;\n        while ((l--) != 0) {\n            ix[ixPos++] = (compareval0 > xr[xrPos++]) ? 0 : 1;\n            ix[ixPos++] = (compareval0 > xr[xrPos++]) ? 0 : 1;\n        }\n    }\n\n    /**\n     * XRPOW_FTOI is a macro to convert floats to ints.<BR>\n     * if XRPOW_FTOI(x) = nearest_int(x), then QUANTFAC(x)=adj43asm[x]<BR>\n     * ROUNDFAC= -0.0946<BR>\n     *\n     * if XRPOW_FTOI(x) = floor(x), then QUANTFAC(x)=asj43[x]<BR>\n     * ROUNDFAC=0.4054<BR>\n     *\n     * Note: using floor() or 0| is extremely slow. On machines where the\n     * TAKEHIRO_IEEE754_HACK code above does not work, it is worthwile to write\n     * some ASM for XRPOW_FTOI().\n     */\n    function quantize_lines_xrpow(l, istep, xr, xrPos, ix, ixPos) {\n        assert(l > 0);\n\n        l = l >> 1;\n        var remaining = l % 2;\n        l = l >> 1;\n        while (l-- != 0) {\n            var x0, x1, x2, x3;\n            var rx0, rx1, rx2, rx3;\n\n            x0 = xr[xrPos++] * istep;\n            x1 = xr[xrPos++] * istep;\n            rx0 = 0 | x0;\n            x2 = xr[xrPos++] * istep;\n            rx1 = 0 | x1;\n            x3 = xr[xrPos++] * istep;\n            rx2 = 0 | x2;\n            x0 += qupvt.adj43[rx0];\n            rx3 = 0 | x3;\n            x1 += qupvt.adj43[rx1];\n            ix[ixPos++] = 0 | x0;\n            x2 += qupvt.adj43[rx2];\n            ix[ixPos++] = 0 | x1;\n            x3 += qupvt.adj43[rx3];\n            ix[ixPos++] = 0 | x2;\n            ix[ixPos++] = 0 | x3;\n        }\n        if (remaining != 0) {\n            var x0, x1;\n            var rx0, rx1;\n\n            x0 = xr[xrPos++] * istep;\n            x1 = xr[xrPos++] * istep;\n            rx0 = 0 | x0;\n            rx1 = 0 | x1;\n            x0 += qupvt.adj43[rx0];\n            x1 += qupvt.adj43[rx1];\n            ix[ixPos++] = 0 | x0;\n            ix[ixPos++] = 0 | x1;\n        }\n    }\n\n    /**\n     * Quantization function This function will select which lines to quantize\n     * and call the proper quantization function\n     */\n    function quantize_xrpow(xp, pi, istep, codInfo, prevNoise) {\n        /* quantize on xr^(3/4) instead of xr */\n        var sfb;\n        var sfbmax;\n        var j = 0;\n        var prev_data_use;\n        var accumulate = 0;\n        var accumulate01 = 0;\n        var xpPos = 0;\n        var iData = pi;\n        var iDataPos = 0;\n        var acc_iData = iData;\n        var acc_iDataPos = 0;\n        var acc_xp = xp;\n        var acc_xpPos = 0;\n\n        /*\n         * Reusing previously computed data does not seems to work if global\n         * gain is changed. Finding why it behaves this way would allow to use a\n         * cache of previously computed values (let's 10 cached values per sfb)\n         * that would probably provide a noticeable speedup\n         */\n        prev_data_use = (prevNoise != null && (codInfo.global_gain == prevNoise.global_gain));\n\n        if (codInfo.block_type == Encoder.SHORT_TYPE)\n            sfbmax = 38;\n        else\n            sfbmax = 21;\n\n        for (sfb = 0; sfb <= sfbmax; sfb++) {\n            var step = -1;\n\n            if (prev_data_use || codInfo.block_type == Encoder.NORM_TYPE) {\n                step = codInfo.global_gain\n                    - ((codInfo.scalefac[sfb] + (codInfo.preflag != 0 ? qupvt.pretab[sfb]\n                        : 0)) << (codInfo.scalefac_scale + 1))\n                    - codInfo.subblock_gain[codInfo.window[sfb]] * 8;\n            }\n            assert(codInfo.width[sfb] >= 0);\n            if (prev_data_use && (prevNoise.step[sfb] == step)) {\n                /*\n                 * do not recompute this part, but compute accumulated lines\n                 */\n                if (accumulate != 0) {\n                    quantize_lines_xrpow(accumulate, istep, acc_xp, acc_xpPos,\n                        acc_iData, acc_iDataPos);\n                    accumulate = 0;\n                }\n                if (accumulate01 != 0) {\n                    quantize_lines_xrpow_01(accumulate01, istep, acc_xp,\n                        acc_xpPos, acc_iData, acc_iDataPos);\n                    accumulate01 = 0;\n                }\n            } else { /* should compute this part */\n                var l = codInfo.width[sfb];\n\n                if ((j + codInfo.width[sfb]) > codInfo.max_nonzero_coeff) {\n                    /* do not compute upper zero part */\n                    var usefullsize;\n                    usefullsize = codInfo.max_nonzero_coeff - j + 1;\n                    Arrays.fill(pi, codInfo.max_nonzero_coeff, 576, 0);\n                    l = usefullsize;\n\n                    if (l < 0) {\n                        l = 0;\n                    }\n\n                    /* no need to compute higher sfb values */\n                    sfb = sfbmax + 1;\n                }\n\n                /* accumulate lines to quantize */\n                if (0 == accumulate && 0 == accumulate01) {\n                    acc_iData = iData;\n                    acc_iDataPos = iDataPos;\n                    acc_xp = xp;\n                    acc_xpPos = xpPos;\n                }\n                if (prevNoise != null && prevNoise.sfb_count1 > 0\n                    && sfb >= prevNoise.sfb_count1\n                    && prevNoise.step[sfb] > 0\n                    && step >= prevNoise.step[sfb]) {\n\n                    if (accumulate != 0) {\n                        quantize_lines_xrpow(accumulate, istep, acc_xp,\n                            acc_xpPos, acc_iData, acc_iDataPos);\n                        accumulate = 0;\n                        acc_iData = iData;\n                        acc_iDataPos = iDataPos;\n                        acc_xp = xp;\n                        acc_xpPos = xpPos;\n                    }\n                    accumulate01 += l;\n                } else {\n                    if (accumulate01 != 0) {\n                        quantize_lines_xrpow_01(accumulate01, istep, acc_xp,\n                            acc_xpPos, acc_iData, acc_iDataPos);\n                        accumulate01 = 0;\n                        acc_iData = iData;\n                        acc_iDataPos = iDataPos;\n                        acc_xp = xp;\n                        acc_xpPos = xpPos;\n                    }\n                    accumulate += l;\n                }\n\n                if (l <= 0) {\n                    /*\n                     * rh: 20040215 may happen due to \"prev_data_use\"\n                     * optimization\n                     */\n                    if (accumulate01 != 0) {\n                        quantize_lines_xrpow_01(accumulate01, istep, acc_xp,\n                            acc_xpPos, acc_iData, acc_iDataPos);\n                        accumulate01 = 0;\n                    }\n                    if (accumulate != 0) {\n                        quantize_lines_xrpow(accumulate, istep, acc_xp,\n                            acc_xpPos, acc_iData, acc_iDataPos);\n                        accumulate = 0;\n                    }\n\n                    break;\n                    /* ends for-loop */\n                }\n            }\n            if (sfb <= sfbmax) {\n                iDataPos += codInfo.width[sfb];\n                xpPos += codInfo.width[sfb];\n                j += codInfo.width[sfb];\n            }\n        }\n        if (accumulate != 0) { /* last data part */\n            quantize_lines_xrpow(accumulate, istep, acc_xp, acc_xpPos,\n                acc_iData, acc_iDataPos);\n            accumulate = 0;\n        }\n        if (accumulate01 != 0) { /* last data part */\n            quantize_lines_xrpow_01(accumulate01, istep, acc_xp, acc_xpPos,\n                acc_iData, acc_iDataPos);\n            accumulate01 = 0;\n        }\n\n    }\n\n    /**\n     * ix_max\n     */\n    function ix_max(ix, ixPos, endPos) {\n        var max1 = 0, max2 = 0;\n\n        do {\n            var x1 = ix[ixPos++];\n            var x2 = ix[ixPos++];\n            if (max1 < x1)\n                max1 = x1;\n\n            if (max2 < x2)\n                max2 = x2;\n        } while (ixPos < endPos);\n        if (max1 < max2)\n            max1 = max2;\n        return max1;\n    }\n\n    function count_bit_ESC(ix, ixPos, end, t1, t2, s) {\n        /* ESC-table is used */\n        var linbits = Tables.ht[t1].xlen * 65536 + Tables.ht[t2].xlen;\n        var sum = 0, sum2;\n\n        do {\n            var x = ix[ixPos++];\n            var y = ix[ixPos++];\n\n            if (x != 0) {\n                if (x > 14) {\n                    x = 15;\n                    sum += linbits;\n                }\n                x *= 16;\n            }\n\n            if (y != 0) {\n                if (y > 14) {\n                    y = 15;\n                    sum += linbits;\n                }\n                x += y;\n            }\n\n            sum += Tables.largetbl[x];\n        } while (ixPos < end);\n\n        sum2 = sum & 0xffff;\n        sum >>= 16;\n\n        if (sum > sum2) {\n            sum = sum2;\n            t1 = t2;\n        }\n\n        s.bits += sum;\n        return t1;\n    }\n\n    function count_bit_noESC(ix, ixPos, end, s) {\n        /* No ESC-words */\n        var sum1 = 0;\n        var hlen1 = Tables.ht[1].hlen;\n\n        do {\n            var x = ix[ixPos + 0] * 2 + ix[ixPos + 1];\n            ixPos += 2;\n            sum1 += hlen1[x];\n        } while (ixPos < end);\n\n        s.bits += sum1;\n        return 1;\n    }\n\n    function count_bit_noESC_from2(ix, ixPos, end, t1, s) {\n        /* No ESC-words */\n        var sum = 0, sum2;\n        var xlen = Tables.ht[t1].xlen;\n        var hlen;\n        if (t1 == 2)\n            hlen = Tables.table23;\n        else\n            hlen = Tables.table56;\n\n        do {\n            var x = ix[ixPos + 0] * xlen + ix[ixPos + 1];\n            ixPos += 2;\n            sum += hlen[x];\n        } while (ixPos < end);\n\n        sum2 = sum & 0xffff;\n        sum >>= 16;\n\n        if (sum > sum2) {\n            sum = sum2;\n            t1++;\n        }\n\n        s.bits += sum;\n        return t1;\n    }\n\n    function count_bit_noESC_from3(ix, ixPos, end, t1, s) {\n        /* No ESC-words */\n        var sum1 = 0;\n        var sum2 = 0;\n        var sum3 = 0;\n        var xlen = Tables.ht[t1].xlen;\n        var hlen1 = Tables.ht[t1].hlen;\n        var hlen2 = Tables.ht[t1 + 1].hlen;\n        var hlen3 = Tables.ht[t1 + 2].hlen;\n\n        do {\n            var x = ix[ixPos + 0] * xlen + ix[ixPos + 1];\n            ixPos += 2;\n            sum1 += hlen1[x];\n            sum2 += hlen2[x];\n            sum3 += hlen3[x];\n        } while (ixPos < end);\n        var t = t1;\n        if (sum1 > sum2) {\n            sum1 = sum2;\n            t++;\n        }\n        if (sum1 > sum3) {\n            sum1 = sum3;\n            t = t1 + 2;\n        }\n        s.bits += sum1;\n\n        return t;\n    }\n\n    /*************************************************************************/\n    /* choose table */\n    /*************************************************************************/\n\n    var huf_tbl_noESC = [1, 2, 5, 7, 7, 10, 10, 13, 13,\n        13, 13, 13, 13, 13, 13];\n\n    /**\n     * Choose the Huffman table that will encode ix[begin..end] with the fewest\n     * bits.\n     *\n     * Note: This code contains knowledge about the sizes and characteristics of\n     * the Huffman tables as defined in the IS (Table B.7), and will not work\n     * with any arbitrary tables.\n     */\n    function choose_table(ix, ixPos, endPos, s) {\n        var max = ix_max(ix, ixPos, endPos);\n\n        switch (max) {\n            case 0:\n                return max;\n\n            case 1:\n                return count_bit_noESC(ix, ixPos, endPos, s);\n\n            case 2:\n            case 3:\n                return count_bit_noESC_from2(ix, ixPos, endPos,\n                    huf_tbl_noESC[max - 1], s);\n\n            case 4:\n            case 5:\n            case 6:\n            case 7:\n            case 8:\n            case 9:\n            case 10:\n            case 11:\n            case 12:\n            case 13:\n            case 14:\n            case 15:\n                return count_bit_noESC_from3(ix, ixPos, endPos,\n                    huf_tbl_noESC[max - 1], s);\n\n            default:\n                /* try tables with linbits */\n                if (max > QuantizePVT.IXMAX_VAL) {\n                    s.bits = QuantizePVT.LARGE_BITS;\n                    return -1;\n                }\n                max -= 15;\n                var choice2;\n                for (choice2 = 24; choice2 < 32; choice2++) {\n                    if (Tables.ht[choice2].linmax >= max) {\n                        break;\n                    }\n                }\n                var choice;\n                for (choice = choice2 - 8; choice < 24; choice++) {\n                    if (Tables.ht[choice].linmax >= max) {\n                        break;\n                    }\n                }\n                return count_bit_ESC(ix, ixPos, endPos, choice, choice2, s);\n        }\n    }\n\n    /**\n     * count_bit\n     */\n    this.noquant_count_bits = function (gfc, gi, prev_noise) {\n        var ix = gi.l3_enc;\n        var i = Math.min(576, ((gi.max_nonzero_coeff + 2) >> 1) << 1);\n\n        if (prev_noise != null)\n            prev_noise.sfb_count1 = 0;\n\n        /* Determine count1 region */\n        for (; i > 1; i -= 2)\n            if ((ix[i - 1] | ix[i - 2]) != 0)\n                break;\n        gi.count1 = i;\n\n        /* Determines the number of bits to encode the quadruples. */\n        var a1 = 0;\n        var a2 = 0;\n        for (; i > 3; i -= 4) {\n            var p;\n            /* hack to check if all values <= 1 */\n            //throw \"TODO: HACK         if ((((long) ix[i - 1] | (long) ix[i - 2] | (long) ix[i - 3] | (long) ix[i - 4]) & 0xffffffffL) > 1L        \"\n            //if (true) {\n            if (((ix[i - 1] | ix[i - 2] | ix[i - 3] | ix[i - 4]) & 0x7fffffff) > 1) {\n                break;\n            }\n            p = ((ix[i - 4] * 2 + ix[i - 3]) * 2 + ix[i - 2]) * 2 + ix[i - 1];\n            a1 += Tables.t32l[p];\n            a2 += Tables.t33l[p];\n        }\n        var bits = a1;\n        gi.count1table_select = 0;\n        if (a1 > a2) {\n            bits = a2;\n            gi.count1table_select = 1;\n        }\n\n        gi.count1bits = bits;\n        gi.big_values = i;\n        if (i == 0)\n            return bits;\n\n        if (gi.block_type == Encoder.SHORT_TYPE) {\n            a1 = 3 * gfc.scalefac_band.s[3];\n            if (a1 > gi.big_values)\n                a1 = gi.big_values;\n            a2 = gi.big_values;\n\n        } else if (gi.block_type == Encoder.NORM_TYPE) {\n            assert(i <= 576);\n            /* bv_scf has 576 entries (0..575) */\n            a1 = gi.region0_count = gfc.bv_scf[i - 2];\n            a2 = gi.region1_count = gfc.bv_scf[i - 1];\n\n            assert(a1 + a2 + 2 < Encoder.SBPSY_l);\n            a2 = gfc.scalefac_band.l[a1 + a2 + 2];\n            a1 = gfc.scalefac_band.l[a1 + 1];\n            if (a2 < i) {\n                var bi = new Bits(bits);\n                gi.table_select[2] = choose_table(ix, a2, i, bi);\n                bits = bi.bits;\n            }\n        } else {\n            gi.region0_count = 7;\n            /* gi.region1_count = SBPSY_l - 7 - 1; */\n            gi.region1_count = Encoder.SBMAX_l - 1 - 7 - 1;\n            a1 = gfc.scalefac_band.l[7 + 1];\n            a2 = i;\n            if (a1 > a2) {\n                a1 = a2;\n            }\n        }\n\n        /* have to allow for the case when bigvalues < region0 < region1 */\n        /* (and region0, region1 are ignored) */\n        a1 = Math.min(a1, i);\n        a2 = Math.min(a2, i);\n\n        assert(a1 >= 0);\n        assert(a2 >= 0);\n\n        /* Count the number of bits necessary to code the bigvalues region. */\n        if (0 < a1) {\n            var bi = new Bits(bits);\n            gi.table_select[0] = choose_table(ix, 0, a1, bi);\n            bits = bi.bits;\n        }\n        if (a1 < a2) {\n            var bi = new Bits(bits);\n            gi.table_select[1] = choose_table(ix, a1, a2, bi);\n            bits = bi.bits;\n        }\n        if (gfc.use_best_huffman == 2) {\n            gi.part2_3_length = bits;\n            best_huffman_divide(gfc, gi);\n            bits = gi.part2_3_length;\n        }\n\n        if (prev_noise != null) {\n            if (gi.block_type == Encoder.NORM_TYPE) {\n                var sfb = 0;\n                while (gfc.scalefac_band.l[sfb] < gi.big_values) {\n                    sfb++;\n                }\n                prev_noise.sfb_count1 = sfb;\n            }\n        }\n\n        return bits;\n    }\n\n    this.count_bits = function (gfc, xr, gi, prev_noise) {\n        var ix = gi.l3_enc;\n\n        /* since quantize_xrpow uses table lookup, we need to check this first: */\n        var w = (QuantizePVT.IXMAX_VAL) / qupvt.IPOW20(gi.global_gain);\n\n        if (gi.xrpow_max > w)\n            return QuantizePVT.LARGE_BITS;\n\n        quantize_xrpow(xr, ix, qupvt.IPOW20(gi.global_gain), gi, prev_noise);\n\n        if ((gfc.substep_shaping & 2) != 0) {\n            var j = 0;\n            /* 0.634521682242439 = 0.5946*2**(.5*0.1875) */\n            var gain = gi.global_gain + gi.scalefac_scale;\n            var roundfac = 0.634521682242439 / qupvt.IPOW20(gain);\n            for (var sfb = 0; sfb < gi.sfbmax; sfb++) {\n                var width = gi.width[sfb];\n                assert(width >= 0);\n                if (0 == gfc.pseudohalf[sfb]) {\n                    j += width;\n                } else {\n                    var k;\n                    for (k = j, j += width; k < j; ++k) {\n                        ix[k] = (xr[k] >= roundfac) ? ix[k] : 0;\n                    }\n                }\n            }\n        }\n        return this.noquant_count_bits(gfc, gi, prev_noise);\n    }\n\n    /**\n     * re-calculate the best scalefac_compress using scfsi the saved bits are\n     * kept in the bit reservoir.\n     */\n    function recalc_divide_init(gfc, cod_info, ix, r01_bits, r01_div, r0_tbl, r1_tbl) {\n        var bigv = cod_info.big_values;\n\n        for (var r0 = 0; r0 <= 7 + 15; r0++) {\n            r01_bits[r0] = QuantizePVT.LARGE_BITS;\n        }\n\n        for (var r0 = 0; r0 < 16; r0++) {\n            var a1 = gfc.scalefac_band.l[r0 + 1];\n            if (a1 >= bigv)\n                break;\n            var r0bits = 0;\n            var bi = new Bits(r0bits);\n            var r0t = choose_table(ix, 0, a1, bi);\n            r0bits = bi.bits;\n\n            for (var r1 = 0; r1 < 8; r1++) {\n                var a2 = gfc.scalefac_band.l[r0 + r1 + 2];\n                if (a2 >= bigv)\n                    break;\n                var bits = r0bits;\n                bi = new Bits(bits);\n                var r1t = choose_table(ix, a1, a2, bi);\n                bits = bi.bits;\n                if (r01_bits[r0 + r1] > bits) {\n                    r01_bits[r0 + r1] = bits;\n                    r01_div[r0 + r1] = r0;\n                    r0_tbl[r0 + r1] = r0t;\n                    r1_tbl[r0 + r1] = r1t;\n                }\n            }\n        }\n    }\n\n    function recalc_divide_sub(gfc, cod_info2, gi, ix, r01_bits, r01_div, r0_tbl, r1_tbl) {\n        var bigv = cod_info2.big_values;\n\n        for (var r2 = 2; r2 < Encoder.SBMAX_l + 1; r2++) {\n            var a2 = gfc.scalefac_band.l[r2];\n            if (a2 >= bigv)\n                break;\n            var bits = r01_bits[r2 - 2] + cod_info2.count1bits;\n            if (gi.part2_3_length <= bits)\n                break;\n\n            var bi = new Bits(bits);\n            var r2t = choose_table(ix, a2, bigv, bi);\n            bits = bi.bits;\n            if (gi.part2_3_length <= bits)\n                continue;\n\n            gi.assign(cod_info2);\n            gi.part2_3_length = bits;\n            gi.region0_count = r01_div[r2 - 2];\n            gi.region1_count = r2 - 2 - r01_div[r2 - 2];\n            gi.table_select[0] = r0_tbl[r2 - 2];\n            gi.table_select[1] = r1_tbl[r2 - 2];\n            gi.table_select[2] = r2t;\n        }\n    }\n\n    this.best_huffman_divide = function (gfc, gi) {\n        var cod_info2 = new GrInfo();\n        var ix = gi.l3_enc;\n        var r01_bits = new_int(7 + 15 + 1);\n        var r01_div = new_int(7 + 15 + 1);\n        var r0_tbl = new_int(7 + 15 + 1);\n        var r1_tbl = new_int(7 + 15 + 1);\n\n        /* SHORT BLOCK stuff fails for MPEG2 */\n        if (gi.block_type == Encoder.SHORT_TYPE && gfc.mode_gr == 1)\n            return;\n\n        cod_info2.assign(gi);\n        if (gi.block_type == Encoder.NORM_TYPE) {\n            recalc_divide_init(gfc, gi, ix, r01_bits, r01_div, r0_tbl, r1_tbl);\n            recalc_divide_sub(gfc, cod_info2, gi, ix, r01_bits, r01_div,\n                r0_tbl, r1_tbl);\n        }\n        var i = cod_info2.big_values;\n        if (i == 0 || (ix[i - 2] | ix[i - 1]) > 1)\n            return;\n\n        i = gi.count1 + 2;\n        if (i > 576)\n            return;\n\n        /* Determines the number of bits to encode the quadruples. */\n        cod_info2.assign(gi);\n        cod_info2.count1 = i;\n        var a1 = 0;\n        var a2 = 0;\n\n        assert(i <= 576);\n\n        for (; i > cod_info2.big_values; i -= 4) {\n            var p = ((ix[i - 4] * 2 + ix[i - 3]) * 2 + ix[i - 2]) * 2\n                + ix[i - 1];\n            a1 += Tables.t32l[p];\n            a2 += Tables.t33l[p];\n        }\n        cod_info2.big_values = i;\n\n        cod_info2.count1table_select = 0;\n        if (a1 > a2) {\n            a1 = a2;\n            cod_info2.count1table_select = 1;\n        }\n\n        cod_info2.count1bits = a1;\n\n        if (cod_info2.block_type == Encoder.NORM_TYPE)\n            recalc_divide_sub(gfc, cod_info2, gi, ix, r01_bits, r01_div,\n                r0_tbl, r1_tbl);\n        else {\n            /* Count the number of bits necessary to code the bigvalues region. */\n            cod_info2.part2_3_length = a1;\n            a1 = gfc.scalefac_band.l[7 + 1];\n            if (a1 > i) {\n                a1 = i;\n            }\n            if (a1 > 0) {\n                var bi = new Bits(cod_info2.part2_3_length);\n                cod_info2.table_select[0] = choose_table(ix, 0, a1, bi);\n                cod_info2.part2_3_length = bi.bits;\n            }\n            if (i > a1) {\n                var bi = new Bits(cod_info2.part2_3_length);\n                cod_info2.table_select[1] = choose_table(ix, a1, i, bi);\n                cod_info2.part2_3_length = bi.bits;\n            }\n            if (gi.part2_3_length > cod_info2.part2_3_length)\n                gi.assign(cod_info2);\n        }\n    }\n\n    var slen1_n = [1, 1, 1, 1, 8, 2, 2, 2, 4, 4, 4, 8, 8, 8, 16, 16];\n    var slen2_n = [1, 2, 4, 8, 1, 2, 4, 8, 2, 4, 8, 2, 4, 8, 4, 8];\n    var slen1_tab = [0, 0, 0, 0, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4];\n    var slen2_tab = [0, 1, 2, 3, 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 2, 3];\n    Takehiro.slen1_tab = slen1_tab;\n    Takehiro.slen2_tab = slen2_tab;\n\n    function scfsi_calc(ch, l3_side) {\n        var sfb;\n        var gi = l3_side.tt[1][ch];\n        var g0 = l3_side.tt[0][ch];\n\n        for (var i = 0; i < Tables.scfsi_band.length - 1; i++) {\n            for (sfb = Tables.scfsi_band[i]; sfb < Tables.scfsi_band[i + 1]; sfb++) {\n                if (g0.scalefac[sfb] != gi.scalefac[sfb]\n                    && gi.scalefac[sfb] >= 0)\n                    break;\n            }\n            if (sfb == Tables.scfsi_band[i + 1]) {\n                for (sfb = Tables.scfsi_band[i]; sfb < Tables.scfsi_band[i + 1]; sfb++) {\n                    gi.scalefac[sfb] = -1;\n                }\n                l3_side.scfsi[ch][i] = 1;\n            }\n        }\n        var s1 = 0;\n        var c1 = 0;\n        for (sfb = 0; sfb < 11; sfb++) {\n            if (gi.scalefac[sfb] == -1)\n                continue;\n            c1++;\n            if (s1 < gi.scalefac[sfb])\n                s1 = gi.scalefac[sfb];\n        }\n        var s2 = 0;\n        var c2 = 0;\n        for (; sfb < Encoder.SBPSY_l; sfb++) {\n            if (gi.scalefac[sfb] == -1)\n                continue;\n            c2++;\n            if (s2 < gi.scalefac[sfb])\n                s2 = gi.scalefac[sfb];\n        }\n\n        for (var i = 0; i < 16; i++) {\n            if (s1 < slen1_n[i] && s2 < slen2_n[i]) {\n                var c = slen1_tab[i] * c1 + slen2_tab[i] * c2;\n                if (gi.part2_length > c) {\n                    gi.part2_length = c;\n                    gi.scalefac_compress = i;\n                }\n            }\n        }\n    }\n\n    /**\n     * Find the optimal way to store the scalefactors. Only call this routine\n     * after final scalefactors have been chosen and the channel/granule will\n     * not be re-encoded.\n     */\n    this.best_scalefac_store = function (gfc, gr, ch, l3_side) {\n        /* use scalefac_scale if we can */\n        var gi = l3_side.tt[gr][ch];\n        var sfb, i, j, l;\n        var recalc = 0;\n\n        /*\n         * remove scalefacs from bands with ix=0. This idea comes from the AAC\n         * ISO docs. added mt 3/00\n         */\n        /* check if l3_enc=0 */\n        j = 0;\n        for (sfb = 0; sfb < gi.sfbmax; sfb++) {\n            var width = gi.width[sfb];\n            assert(width >= 0);\n            j += width;\n            for (l = -width; l < 0; l++) {\n                if (gi.l3_enc[l + j] != 0)\n                    break;\n            }\n            if (l == 0)\n                gi.scalefac[sfb] = recalc = -2;\n            /* anything goes. */\n            /*\n             * only best_scalefac_store and calc_scfsi know--and only they\n             * should know--about the magic number -2.\n             */\n        }\n\n        if (0 == gi.scalefac_scale && 0 == gi.preflag) {\n            var s = 0;\n            for (sfb = 0; sfb < gi.sfbmax; sfb++)\n                if (gi.scalefac[sfb] > 0)\n                    s |= gi.scalefac[sfb];\n\n            if (0 == (s & 1) && s != 0) {\n                for (sfb = 0; sfb < gi.sfbmax; sfb++)\n                    if (gi.scalefac[sfb] > 0)\n                        gi.scalefac[sfb] >>= 1;\n\n                gi.scalefac_scale = recalc = 1;\n            }\n        }\n\n        if (0 == gi.preflag && gi.block_type != Encoder.SHORT_TYPE\n            && gfc.mode_gr == 2) {\n            for (sfb = 11; sfb < Encoder.SBPSY_l; sfb++)\n                if (gi.scalefac[sfb] < qupvt.pretab[sfb]\n                    && gi.scalefac[sfb] != -2)\n                    break;\n            if (sfb == Encoder.SBPSY_l) {\n                for (sfb = 11; sfb < Encoder.SBPSY_l; sfb++)\n                    if (gi.scalefac[sfb] > 0)\n                        gi.scalefac[sfb] -= qupvt.pretab[sfb];\n\n                gi.preflag = recalc = 1;\n            }\n        }\n\n        for (i = 0; i < 4; i++)\n            l3_side.scfsi[ch][i] = 0;\n\n        if (gfc.mode_gr == 2 && gr == 1\n            && l3_side.tt[0][ch].block_type != Encoder.SHORT_TYPE\n            && l3_side.tt[1][ch].block_type != Encoder.SHORT_TYPE) {\n            scfsi_calc(ch, l3_side);\n            recalc = 0;\n        }\n        for (sfb = 0; sfb < gi.sfbmax; sfb++) {\n            if (gi.scalefac[sfb] == -2) {\n                gi.scalefac[sfb] = 0;\n                /* if anything goes, then 0 is a good choice */\n            }\n        }\n        if (recalc != 0) {\n            if (gfc.mode_gr == 2) {\n                this.scale_bitcount(gi);\n            } else {\n                this.scale_bitcount_lsf(gfc, gi);\n            }\n        }\n    }\n\n    function all_scalefactors_not_negative(scalefac, n) {\n        for (var i = 0; i < n; ++i) {\n            if (scalefac[i] < 0)\n                return false;\n        }\n        return true;\n    }\n\n    /**\n     * number of bits used to encode scalefacs.\n     *\n     * 18*slen1_tab[i] + 18*slen2_tab[i]\n     */\n    var scale_short = [0, 18, 36, 54, 54, 36, 54, 72,\n        54, 72, 90, 72, 90, 108, 108, 126];\n\n    /**\n     * number of bits used to encode scalefacs.\n     *\n     * 17*slen1_tab[i] + 18*slen2_tab[i]\n     */\n    var scale_mixed = [0, 18, 36, 54, 51, 35, 53, 71,\n        52, 70, 88, 69, 87, 105, 104, 122];\n\n    /**\n     * number of bits used to encode scalefacs.\n     *\n     * 11*slen1_tab[i] + 10*slen2_tab[i]\n     */\n    var scale_long = [0, 10, 20, 30, 33, 21, 31, 41, 32, 42,\n        52, 43, 53, 63, 64, 74];\n\n    /**\n     * Also calculates the number of bits necessary to code the scalefactors.\n     */\n    this.scale_bitcount = function (cod_info) {\n        var k, sfb, max_slen1 = 0, max_slen2 = 0;\n\n        /* maximum values */\n        var tab;\n        var scalefac = cod_info.scalefac;\n\n        assert(all_scalefactors_not_negative(scalefac, cod_info.sfbmax));\n\n        if (cod_info.block_type == Encoder.SHORT_TYPE) {\n            tab = scale_short;\n            if (cod_info.mixed_block_flag != 0)\n                tab = scale_mixed;\n        } else { /* block_type == 1,2,or 3 */\n            tab = scale_long;\n            if (0 == cod_info.preflag) {\n                for (sfb = 11; sfb < Encoder.SBPSY_l; sfb++)\n                    if (scalefac[sfb] < qupvt.pretab[sfb])\n                        break;\n\n                if (sfb == Encoder.SBPSY_l) {\n                    cod_info.preflag = 1;\n                    for (sfb = 11; sfb < Encoder.SBPSY_l; sfb++)\n                        scalefac[sfb] -= qupvt.pretab[sfb];\n                }\n            }\n        }\n\n        for (sfb = 0; sfb < cod_info.sfbdivide; sfb++)\n            if (max_slen1 < scalefac[sfb])\n                max_slen1 = scalefac[sfb];\n\n        for (; sfb < cod_info.sfbmax; sfb++)\n            if (max_slen2 < scalefac[sfb])\n                max_slen2 = scalefac[sfb];\n\n        /*\n         * from Takehiro TOMINAGA <tominaga@isoternet.org> 10/99 loop over *all*\n         * posible values of scalefac_compress to find the one which uses the\n         * smallest number of bits. ISO would stop at first valid index\n         */\n        cod_info.part2_length = QuantizePVT.LARGE_BITS;\n        for (k = 0; k < 16; k++) {\n            if (max_slen1 < slen1_n[k] && max_slen2 < slen2_n[k]\n                && cod_info.part2_length > tab[k]) {\n                cod_info.part2_length = tab[k];\n                cod_info.scalefac_compress = k;\n            }\n        }\n        return cod_info.part2_length == QuantizePVT.LARGE_BITS;\n    }\n\n    /**\n     * table of largest scalefactor values for MPEG2\n     */\n    var max_range_sfac_tab = [[15, 15, 7, 7],\n        [15, 15, 7, 0], [7, 3, 0, 0], [15, 31, 31, 0],\n        [7, 7, 7, 0], [3, 3, 0, 0]];\n\n    /**\n     * Also counts the number of bits to encode the scalefacs but for MPEG 2\n     * Lower sampling frequencies (24, 22.05 and 16 kHz.)\n     *\n     * This is reverse-engineered from section 2.4.3.2 of the MPEG2 IS,\n     * \"Audio Decoding Layer III\"\n     */\n    this.scale_bitcount_lsf = function (gfc, cod_info) {\n        var table_number, row_in_table, partition, nr_sfb, window;\n        var over;\n        var i, sfb;\n        var max_sfac = new_int(4);\n//var partition_table;\n        var scalefac = cod_info.scalefac;\n\n        /*\n         * Set partition table. Note that should try to use table one, but do\n         * not yet...\n         */\n        if (cod_info.preflag != 0)\n            table_number = 2;\n        else\n            table_number = 0;\n\n        for (i = 0; i < 4; i++)\n            max_sfac[i] = 0;\n\n        if (cod_info.block_type == Encoder.SHORT_TYPE) {\n            row_in_table = 1;\n            var partition_table = qupvt.nr_of_sfb_block[table_number][row_in_table];\n            for (sfb = 0, partition = 0; partition < 4; partition++) {\n                nr_sfb = partition_table[partition] / 3;\n                for (i = 0; i < nr_sfb; i++, sfb++)\n                    for (window = 0; window < 3; window++)\n                        if (scalefac[sfb * 3 + window] > max_sfac[partition])\n                            max_sfac[partition] = scalefac[sfb * 3 + window];\n            }\n        } else {\n            row_in_table = 0;\n            var partition_table = qupvt.nr_of_sfb_block[table_number][row_in_table];\n            for (sfb = 0, partition = 0; partition < 4; partition++) {\n                nr_sfb = partition_table[partition];\n                for (i = 0; i < nr_sfb; i++, sfb++)\n                    if (scalefac[sfb] > max_sfac[partition])\n                        max_sfac[partition] = scalefac[sfb];\n            }\n        }\n\n        for (over = false, partition = 0; partition < 4; partition++) {\n            if (max_sfac[partition] > max_range_sfac_tab[table_number][partition])\n                over = true;\n        }\n        if (!over) {\n            var slen1, slen2, slen3, slen4;\n\n            cod_info.sfb_partition_table = qupvt.nr_of_sfb_block[table_number][row_in_table];\n            for (partition = 0; partition < 4; partition++)\n                cod_info.slen[partition] = log2tab[max_sfac[partition]];\n\n            /* set scalefac_compress */\n            slen1 = cod_info.slen[0];\n            slen2 = cod_info.slen[1];\n            slen3 = cod_info.slen[2];\n            slen4 = cod_info.slen[3];\n\n            switch (table_number) {\n                case 0:\n                    cod_info.scalefac_compress = (((slen1 * 5) + slen2) << 4)\n                        + (slen3 << 2) + slen4;\n                    break;\n\n                case 1:\n                    cod_info.scalefac_compress = 400 + (((slen1 * 5) + slen2) << 2)\n                        + slen3;\n                    break;\n\n                case 2:\n                    cod_info.scalefac_compress = 500 + (slen1 * 3) + slen2;\n                    break;\n\n                default:\n                    System.err.printf(\"intensity stereo not implemented yet\\n\");\n                    break;\n            }\n        }\n        if (!over) {\n            assert(cod_info.sfb_partition_table != null);\n            cod_info.part2_length = 0;\n            for (partition = 0; partition < 4; partition++)\n                cod_info.part2_length += cod_info.slen[partition]\n                    * cod_info.sfb_partition_table[partition];\n        }\n        return over;\n    }\n\n    /*\n     * Since no bands have been over-amplified, we can set scalefac_compress and\n     * slen[] for the formatter\n     */\n    var log2tab = [0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4,\n        4, 4, 4, 4];\n\n    this.huffman_init = function (gfc) {\n        for (var i = 2; i <= 576; i += 2) {\n            var scfb_anz = 0, bv_index;\n            while (gfc.scalefac_band.l[++scfb_anz] < i)\n                ;\n\n            bv_index = subdv_table[scfb_anz][0]; // .region0_count\n            while (gfc.scalefac_band.l[bv_index + 1] > i)\n                bv_index--;\n\n            if (bv_index < 0) {\n                /*\n                 * this is an indication that everything is going to be encoded\n                 * as region0: bigvalues < region0 < region1 so lets set\n                 * region0, region1 to some value larger than bigvalues\n                 */\n                bv_index = subdv_table[scfb_anz][0]; // .region0_count\n            }\n\n            gfc.bv_scf[i - 2] = bv_index;\n\n            bv_index = subdv_table[scfb_anz][1]; // .region1_count\n            while (gfc.scalefac_band.l[bv_index + gfc.bv_scf[i - 2] + 2] > i)\n                bv_index--;\n\n            if (bv_index < 0) {\n                bv_index = subdv_table[scfb_anz][1]; // .region1_count\n            }\n\n            gfc.bv_scf[i - 1] = bv_index;\n        }\n    }\n}\n\nmodule.exports = Takehiro;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL1Rha2VoaXJvLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLCtFQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxtQkFBTyxDQUFDLGlGQUFjO0FBQ3BDLGFBQWEsbUJBQU8sQ0FBQywrRUFBYTtBQUNsQyxhQUFhLG1CQUFPLENBQUMsK0VBQWE7QUFDbEMsa0JBQWtCLG1CQUFPLENBQUMseUZBQWtCOzs7QUFHNUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixlQUFlO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsY0FBYztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGFBQWE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlCQUFpQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsY0FBYztBQUN2QztBQUNBOztBQUVBLHlCQUF5QixTQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUJBQXlCLDBCQUEwQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxlQUFlLDBCQUEwQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixrQ0FBa0M7QUFDMUQsNkNBQTZDLGdDQUFnQztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdDQUFnQztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixVQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE9BQU87QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBOztBQUVBO0FBQ0EsOEJBQThCLGlCQUFpQjtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLHVCQUF1QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix1QkFBdUI7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLE9BQU87QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0EsK0JBQStCLHVCQUF1QjtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsdUJBQXVCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQiwwQkFBMEI7QUFDaEQ7QUFDQTs7QUFFQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsT0FBTztBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZUFBZTtBQUN4RDtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDLHFDQUFxQyxZQUFZO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EseUNBQXlDLGVBQWU7QUFDeEQ7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsZUFBZTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLGVBQWU7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGVBQWU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0E7O0FBRUEsaURBQWlEO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBOztBQUVBLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL1Rha2VoaXJvLmpzPzE5MGMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqXHRNUDMgaHVmZm1hbiB0YWJsZSBzZWxlY3RpbmcgYW5kIGJpdCBjb3VudGluZ1xuICpcbiAqXHRDb3B5cmlnaHQgKGMpIDE5OTktMjAwNSBUYWtlaGlybyBUT01JTkFHQVxuICpcdENvcHlyaWdodCAoYykgMjAwMi0yMDA1IEdhYnJpZWwgQm91dmlnbmVcbiAqXG4gKiBUaGlzIGxpYnJhcnkgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gKiBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG4gKiBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uOyBlaXRoZXJcbiAqIHZlcnNpb24gMiBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiAqXG4gKiBUaGlzIGxpYnJhcnkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuXHQgU2VlIHRoZSBHTlVcbiAqIExpYnJhcnkgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcbiAqIExpY2Vuc2UgYWxvbmcgd2l0aCB0aGlzIGxpYnJhcnk7IGlmIG5vdCwgd3JpdGUgdG8gdGhlXG4gKiBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCxcbiAqIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuICovXG5cbi8qICRJZDogVGFrZWhpcm8uamF2YSx2IDEuMjYgMjAxMS8wNS8yNCAyMDo0ODowNiBrZW5jaGlzIEV4cCAkICovXG5cbi8vcGFja2FnZSBtcDM7XG5cbi8vaW1wb3J0IGphdmEudXRpbC5BcnJheXM7XG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24uanMnKTtcbnZhciBTeXN0ZW0gPSBjb21tb24uU3lzdGVtO1xudmFyIFZick1vZGUgPSBjb21tb24uVmJyTW9kZTtcbnZhciBGbG9hdCA9IGNvbW1vbi5GbG9hdDtcbnZhciBTaG9ydEJsb2NrID0gY29tbW9uLlNob3J0QmxvY2s7XG52YXIgVXRpbCA9IGNvbW1vbi5VdGlsO1xudmFyIEFycmF5cyA9IGNvbW1vbi5BcnJheXM7XG52YXIgbmV3X2FycmF5X24gPSBjb21tb24ubmV3X2FycmF5X247XG52YXIgbmV3X2J5dGUgPSBjb21tb24ubmV3X2J5dGU7XG52YXIgbmV3X2RvdWJsZSA9IGNvbW1vbi5uZXdfZG91YmxlO1xudmFyIG5ld19mbG9hdCA9IGNvbW1vbi5uZXdfZmxvYXQ7XG52YXIgbmV3X2Zsb2F0X24gPSBjb21tb24ubmV3X2Zsb2F0X247XG52YXIgbmV3X2ludCA9IGNvbW1vbi5uZXdfaW50O1xudmFyIG5ld19pbnRfbiA9IGNvbW1vbi5uZXdfaW50X247XG52YXIgYXNzZXJ0ID0gY29tbW9uLmFzc2VydDtcblxudmFyIEVuY29kZXIgPSByZXF1aXJlKCcuL0VuY29kZXIuanMnKTtcbnZhciBUYWJsZXMgPSByZXF1aXJlKCcuL1RhYmxlcy5qcycpO1xudmFyIEdySW5mbyA9IHJlcXVpcmUoJy4vR3JJbmZvLmpzJyk7XG52YXIgUXVhbnRpemVQVlQgPSByZXF1aXJlKCcuL1F1YW50aXplUFZULmpzJyk7XG5cblxuZnVuY3Rpb24gVGFrZWhpcm8oKSB7XG5cbiAgICB2YXIgcXVwdnQgPSBudWxsO1xuICAgIHRoaXMucXVwdnQgPSBudWxsO1xuXG4gICAgdGhpcy5zZXRNb2R1bGVzID0gZnVuY3Rpb24gKF9xdXB2dCkge1xuICAgICAgICB0aGlzLnF1cHZ0ID0gX3F1cHZ0O1xuICAgICAgICBxdXB2dCA9IF9xdXB2dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBCaXRzKGIpIHtcbiAgICAgICAgdGhpcy5iaXRzID0gMCB8IGI7XG4gICAgfVxuXG4gICAgdmFyIHN1YmR2X3RhYmxlID0gW1swLCAwXSwgLyogMCBiYW5kcyAqL1xuICAgICAgICBbMCwgMF0sIC8qIDEgYmFuZHMgKi9cbiAgICAgICAgWzAsIDBdLCAvKiAyIGJhbmRzICovXG4gICAgICAgIFswLCAwXSwgLyogMyBiYW5kcyAqL1xuICAgICAgICBbMCwgMF0sIC8qIDQgYmFuZHMgKi9cbiAgICAgICAgWzAsIDFdLCAvKiA1IGJhbmRzICovXG4gICAgICAgIFsxLCAxXSwgLyogNiBiYW5kcyAqL1xuICAgICAgICBbMSwgMV0sIC8qIDcgYmFuZHMgKi9cbiAgICAgICAgWzEsIDJdLCAvKiA4IGJhbmRzICovXG4gICAgICAgIFsyLCAyXSwgLyogOSBiYW5kcyAqL1xuICAgICAgICBbMiwgM10sIC8qIDEwIGJhbmRzICovXG4gICAgICAgIFsyLCAzXSwgLyogMTEgYmFuZHMgKi9cbiAgICAgICAgWzMsIDRdLCAvKiAxMiBiYW5kcyAqL1xuICAgICAgICBbMywgNF0sIC8qIDEzIGJhbmRzICovXG4gICAgICAgIFszLCA0XSwgLyogMTQgYmFuZHMgKi9cbiAgICAgICAgWzQsIDVdLCAvKiAxNSBiYW5kcyAqL1xuICAgICAgICBbNCwgNV0sIC8qIDE2IGJhbmRzICovXG4gICAgICAgIFs0LCA2XSwgLyogMTcgYmFuZHMgKi9cbiAgICAgICAgWzUsIDZdLCAvKiAxOCBiYW5kcyAqL1xuICAgICAgICBbNSwgNl0sIC8qIDE5IGJhbmRzICovXG4gICAgICAgIFs1LCA3XSwgLyogMjAgYmFuZHMgKi9cbiAgICAgICAgWzYsIDddLCAvKiAyMSBiYW5kcyAqL1xuICAgICAgICBbNiwgN10sIC8qIDIyIGJhbmRzICovXG4gICAgXTtcblxuICAgIC8qKlxuICAgICAqIG5vbmxpbmVhciBxdWFudGl6YXRpb24gb2YgeHIgTW9yZSBhY2N1cmF0ZSBmb3JtdWxhIHRoYW4gdGhlIElTTyBmb3JtdWxhLlxuICAgICAqIFRha2VzIGludG8gYWNjb3VudCB0aGUgZmFjdCB0aGF0IHdlIGFyZSBxdWFudGl6aW5nIHhyIC4gaXgsIGJ1dCB3ZSB3YW50XG4gICAgICogaXheNC8zIHRvIGJlIGFzIGNsb3NlIGFzIHBvc3NpYmxlIHRvIHheNC8zLiAodGFraW5nIHRoZSBuZWFyZXN0IGludCB3b3VsZFxuICAgICAqIG1lYW4gaXggaXMgYXMgY2xvc2UgYXMgcG9zc2libGUgdG8geHIsIHdoaWNoIGlzIGRpZmZlcmVudC4pXG4gICAgICpcbiAgICAgKiBGcm9tIFNlZ2hlciBCb2Vzc2Vua29vbCA8c2VnaGVyQGVhc3RzaXRlLm5sPiAxMS8xOTk5XG4gICAgICpcbiAgICAgKiAwOS8yMDAwOiBBU00gY29kZSByZW1vdmVkIGluIGZhdm9yIG9mIElFRUU3NTQgaGFjayBieSBUYWtlaGlybyBUb21pbmFnYS5cbiAgICAgKiBJZiB5b3UgbmVlZCB0aGUgQVNNIGNvZGUsIGNoZWNrIENWUyBjaXJjYSBBdWcgMjAwMC5cbiAgICAgKlxuICAgICAqIDAxLzIwMDQ6IE9wdGltaXphdGlvbnMgYnkgR2FicmllbCBCb3V2aWduZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1YW50aXplX2xpbmVzX3hycG93XzAxKGwsIGlzdGVwLCB4ciwgeHJQb3MsIGl4LCBpeFBvcykge1xuICAgICAgICB2YXIgY29tcGFyZXZhbDAgPSAoMS4wIC0gMC40MDU0KSAvIGlzdGVwO1xuXG4gICAgICAgIGFzc2VydChsID4gMCk7XG4gICAgICAgIGwgPSBsID4+IDE7XG4gICAgICAgIHdoaWxlICgobC0tKSAhPSAwKSB7XG4gICAgICAgICAgICBpeFtpeFBvcysrXSA9IChjb21wYXJldmFsMCA+IHhyW3hyUG9zKytdKSA/IDAgOiAxO1xuICAgICAgICAgICAgaXhbaXhQb3MrK10gPSAoY29tcGFyZXZhbDAgPiB4clt4clBvcysrXSkgPyAwIDogMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFhSUE9XX0ZUT0kgaXMgYSBtYWNybyB0byBjb252ZXJ0IGZsb2F0cyB0byBpbnRzLjxCUj5cbiAgICAgKiBpZiBYUlBPV19GVE9JKHgpID0gbmVhcmVzdF9pbnQoeCksIHRoZW4gUVVBTlRGQUMoeCk9YWRqNDNhc21beF08QlI+XG4gICAgICogUk9VTkRGQUM9IC0wLjA5NDY8QlI+XG4gICAgICpcbiAgICAgKiBpZiBYUlBPV19GVE9JKHgpID0gZmxvb3IoeCksIHRoZW4gUVVBTlRGQUMoeCk9YXNqNDNbeF08QlI+XG4gICAgICogUk9VTkRGQUM9MC40MDU0PEJSPlxuICAgICAqXG4gICAgICogTm90ZTogdXNpbmcgZmxvb3IoKSBvciAwfCBpcyBleHRyZW1lbHkgc2xvdy4gT24gbWFjaGluZXMgd2hlcmUgdGhlXG4gICAgICogVEFLRUhJUk9fSUVFRTc1NF9IQUNLIGNvZGUgYWJvdmUgZG9lcyBub3Qgd29yaywgaXQgaXMgd29ydGh3aWxlIHRvIHdyaXRlXG4gICAgICogc29tZSBBU00gZm9yIFhSUE9XX0ZUT0koKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBxdWFudGl6ZV9saW5lc194cnBvdyhsLCBpc3RlcCwgeHIsIHhyUG9zLCBpeCwgaXhQb3MpIHtcbiAgICAgICAgYXNzZXJ0KGwgPiAwKTtcblxuICAgICAgICBsID0gbCA+PiAxO1xuICAgICAgICB2YXIgcmVtYWluaW5nID0gbCAlIDI7XG4gICAgICAgIGwgPSBsID4+IDE7XG4gICAgICAgIHdoaWxlIChsLS0gIT0gMCkge1xuICAgICAgICAgICAgdmFyIHgwLCB4MSwgeDIsIHgzO1xuICAgICAgICAgICAgdmFyIHJ4MCwgcngxLCByeDIsIHJ4MztcblxuICAgICAgICAgICAgeDAgPSB4clt4clBvcysrXSAqIGlzdGVwO1xuICAgICAgICAgICAgeDEgPSB4clt4clBvcysrXSAqIGlzdGVwO1xuICAgICAgICAgICAgcngwID0gMCB8IHgwO1xuICAgICAgICAgICAgeDIgPSB4clt4clBvcysrXSAqIGlzdGVwO1xuICAgICAgICAgICAgcngxID0gMCB8IHgxO1xuICAgICAgICAgICAgeDMgPSB4clt4clBvcysrXSAqIGlzdGVwO1xuICAgICAgICAgICAgcngyID0gMCB8IHgyO1xuICAgICAgICAgICAgeDAgKz0gcXVwdnQuYWRqNDNbcngwXTtcbiAgICAgICAgICAgIHJ4MyA9IDAgfCB4MztcbiAgICAgICAgICAgIHgxICs9IHF1cHZ0LmFkajQzW3J4MV07XG4gICAgICAgICAgICBpeFtpeFBvcysrXSA9IDAgfCB4MDtcbiAgICAgICAgICAgIHgyICs9IHF1cHZ0LmFkajQzW3J4Ml07XG4gICAgICAgICAgICBpeFtpeFBvcysrXSA9IDAgfCB4MTtcbiAgICAgICAgICAgIHgzICs9IHF1cHZ0LmFkajQzW3J4M107XG4gICAgICAgICAgICBpeFtpeFBvcysrXSA9IDAgfCB4MjtcbiAgICAgICAgICAgIGl4W2l4UG9zKytdID0gMCB8IHgzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZW1haW5pbmcgIT0gMCkge1xuICAgICAgICAgICAgdmFyIHgwLCB4MTtcbiAgICAgICAgICAgIHZhciByeDAsIHJ4MTtcblxuICAgICAgICAgICAgeDAgPSB4clt4clBvcysrXSAqIGlzdGVwO1xuICAgICAgICAgICAgeDEgPSB4clt4clBvcysrXSAqIGlzdGVwO1xuICAgICAgICAgICAgcngwID0gMCB8IHgwO1xuICAgICAgICAgICAgcngxID0gMCB8IHgxO1xuICAgICAgICAgICAgeDAgKz0gcXVwdnQuYWRqNDNbcngwXTtcbiAgICAgICAgICAgIHgxICs9IHF1cHZ0LmFkajQzW3J4MV07XG4gICAgICAgICAgICBpeFtpeFBvcysrXSA9IDAgfCB4MDtcbiAgICAgICAgICAgIGl4W2l4UG9zKytdID0gMCB8IHgxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUXVhbnRpemF0aW9uIGZ1bmN0aW9uIFRoaXMgZnVuY3Rpb24gd2lsbCBzZWxlY3Qgd2hpY2ggbGluZXMgdG8gcXVhbnRpemVcbiAgICAgKiBhbmQgY2FsbCB0aGUgcHJvcGVyIHF1YW50aXphdGlvbiBmdW5jdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1YW50aXplX3hycG93KHhwLCBwaSwgaXN0ZXAsIGNvZEluZm8sIHByZXZOb2lzZSkge1xuICAgICAgICAvKiBxdWFudGl6ZSBvbiB4cl4oMy80KSBpbnN0ZWFkIG9mIHhyICovXG4gICAgICAgIHZhciBzZmI7XG4gICAgICAgIHZhciBzZmJtYXg7XG4gICAgICAgIHZhciBqID0gMDtcbiAgICAgICAgdmFyIHByZXZfZGF0YV91c2U7XG4gICAgICAgIHZhciBhY2N1bXVsYXRlID0gMDtcbiAgICAgICAgdmFyIGFjY3VtdWxhdGUwMSA9IDA7XG4gICAgICAgIHZhciB4cFBvcyA9IDA7XG4gICAgICAgIHZhciBpRGF0YSA9IHBpO1xuICAgICAgICB2YXIgaURhdGFQb3MgPSAwO1xuICAgICAgICB2YXIgYWNjX2lEYXRhID0gaURhdGE7XG4gICAgICAgIHZhciBhY2NfaURhdGFQb3MgPSAwO1xuICAgICAgICB2YXIgYWNjX3hwID0geHA7XG4gICAgICAgIHZhciBhY2NfeHBQb3MgPSAwO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFJldXNpbmcgcHJldmlvdXNseSBjb21wdXRlZCBkYXRhIGRvZXMgbm90IHNlZW1zIHRvIHdvcmsgaWYgZ2xvYmFsXG4gICAgICAgICAqIGdhaW4gaXMgY2hhbmdlZC4gRmluZGluZyB3aHkgaXQgYmVoYXZlcyB0aGlzIHdheSB3b3VsZCBhbGxvdyB0byB1c2UgYVxuICAgICAgICAgKiBjYWNoZSBvZiBwcmV2aW91c2x5IGNvbXB1dGVkIHZhbHVlcyAobGV0J3MgMTAgY2FjaGVkIHZhbHVlcyBwZXIgc2ZiKVxuICAgICAgICAgKiB0aGF0IHdvdWxkIHByb2JhYmx5IHByb3ZpZGUgYSBub3RpY2VhYmxlIHNwZWVkdXBcbiAgICAgICAgICovXG4gICAgICAgIHByZXZfZGF0YV91c2UgPSAocHJldk5vaXNlICE9IG51bGwgJiYgKGNvZEluZm8uZ2xvYmFsX2dhaW4gPT0gcHJldk5vaXNlLmdsb2JhbF9nYWluKSk7XG5cbiAgICAgICAgaWYgKGNvZEluZm8uYmxvY2tfdHlwZSA9PSBFbmNvZGVyLlNIT1JUX1RZUEUpXG4gICAgICAgICAgICBzZmJtYXggPSAzODtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgc2ZibWF4ID0gMjE7XG5cbiAgICAgICAgZm9yIChzZmIgPSAwOyBzZmIgPD0gc2ZibWF4OyBzZmIrKykge1xuICAgICAgICAgICAgdmFyIHN0ZXAgPSAtMTtcblxuICAgICAgICAgICAgaWYgKHByZXZfZGF0YV91c2UgfHwgY29kSW5mby5ibG9ja190eXBlID09IEVuY29kZXIuTk9STV9UWVBFKSB7XG4gICAgICAgICAgICAgICAgc3RlcCA9IGNvZEluZm8uZ2xvYmFsX2dhaW5cbiAgICAgICAgICAgICAgICAgICAgLSAoKGNvZEluZm8uc2NhbGVmYWNbc2ZiXSArIChjb2RJbmZvLnByZWZsYWcgIT0gMCA/IHF1cHZ0LnByZXRhYltzZmJdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IDApKSA8PCAoY29kSW5mby5zY2FsZWZhY19zY2FsZSArIDEpKVxuICAgICAgICAgICAgICAgICAgICAtIGNvZEluZm8uc3ViYmxvY2tfZ2Fpbltjb2RJbmZvLndpbmRvd1tzZmJdXSAqIDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnQoY29kSW5mby53aWR0aFtzZmJdID49IDApO1xuICAgICAgICAgICAgaWYgKHByZXZfZGF0YV91c2UgJiYgKHByZXZOb2lzZS5zdGVwW3NmYl0gPT0gc3RlcCkpIHtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIGRvIG5vdCByZWNvbXB1dGUgdGhpcyBwYXJ0LCBidXQgY29tcHV0ZSBhY2N1bXVsYXRlZCBsaW5lc1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmIChhY2N1bXVsYXRlICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcXVhbnRpemVfbGluZXNfeHJwb3coYWNjdW11bGF0ZSwgaXN0ZXAsIGFjY194cCwgYWNjX3hwUG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWNjX2lEYXRhLCBhY2NfaURhdGFQb3MpO1xuICAgICAgICAgICAgICAgICAgICBhY2N1bXVsYXRlID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFjY3VtdWxhdGUwMSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1YW50aXplX2xpbmVzX3hycG93XzAxKGFjY3VtdWxhdGUwMSwgaXN0ZXAsIGFjY194cCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY194cFBvcywgYWNjX2lEYXRhLCBhY2NfaURhdGFQb3MpO1xuICAgICAgICAgICAgICAgICAgICBhY2N1bXVsYXRlMDEgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7IC8qIHNob3VsZCBjb21wdXRlIHRoaXMgcGFydCAqL1xuICAgICAgICAgICAgICAgIHZhciBsID0gY29kSW5mby53aWR0aFtzZmJdO1xuXG4gICAgICAgICAgICAgICAgaWYgKChqICsgY29kSW5mby53aWR0aFtzZmJdKSA+IGNvZEluZm8ubWF4X25vbnplcm9fY29lZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogZG8gbm90IGNvbXB1dGUgdXBwZXIgemVybyBwYXJ0ICovXG4gICAgICAgICAgICAgICAgICAgIHZhciB1c2VmdWxsc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgdXNlZnVsbHNpemUgPSBjb2RJbmZvLm1heF9ub256ZXJvX2NvZWZmIC0gaiArIDE7XG4gICAgICAgICAgICAgICAgICAgIEFycmF5cy5maWxsKHBpLCBjb2RJbmZvLm1heF9ub256ZXJvX2NvZWZmLCA1NzYsIDApO1xuICAgICAgICAgICAgICAgICAgICBsID0gdXNlZnVsbHNpemU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGwgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qIG5vIG5lZWQgdG8gY29tcHV0ZSBoaWdoZXIgc2ZiIHZhbHVlcyAqL1xuICAgICAgICAgICAgICAgICAgICBzZmIgPSBzZmJtYXggKyAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8qIGFjY3VtdWxhdGUgbGluZXMgdG8gcXVhbnRpemUgKi9cbiAgICAgICAgICAgICAgICBpZiAoMCA9PSBhY2N1bXVsYXRlICYmIDAgPT0gYWNjdW11bGF0ZTAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY19pRGF0YSA9IGlEYXRhO1xuICAgICAgICAgICAgICAgICAgICBhY2NfaURhdGFQb3MgPSBpRGF0YVBvcztcbiAgICAgICAgICAgICAgICAgICAgYWNjX3hwID0geHA7XG4gICAgICAgICAgICAgICAgICAgIGFjY194cFBvcyA9IHhwUG9zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJldk5vaXNlICE9IG51bGwgJiYgcHJldk5vaXNlLnNmYl9jb3VudDEgPiAwXG4gICAgICAgICAgICAgICAgICAgICYmIHNmYiA+PSBwcmV2Tm9pc2Uuc2ZiX2NvdW50MVxuICAgICAgICAgICAgICAgICAgICAmJiBwcmV2Tm9pc2Uuc3RlcFtzZmJdID4gMFxuICAgICAgICAgICAgICAgICAgICAmJiBzdGVwID49IHByZXZOb2lzZS5zdGVwW3NmYl0pIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoYWNjdW11bGF0ZSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl6ZV9saW5lc194cnBvdyhhY2N1bXVsYXRlLCBpc3RlcCwgYWNjX3hwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY194cFBvcywgYWNjX2lEYXRhLCBhY2NfaURhdGFQb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjdW11bGF0ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NfaURhdGEgPSBpRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY19pRGF0YVBvcyA9IGlEYXRhUG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjX3hwID0geHA7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NfeHBQb3MgPSB4cFBvcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhY2N1bXVsYXRlMDEgKz0gbDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWNjdW11bGF0ZTAxICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXplX2xpbmVzX3hycG93XzAxKGFjY3VtdWxhdGUwMSwgaXN0ZXAsIGFjY194cCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NfeHBQb3MsIGFjY19pRGF0YSwgYWNjX2lEYXRhUG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY3VtdWxhdGUwMSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NfaURhdGEgPSBpRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY19pRGF0YVBvcyA9IGlEYXRhUG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjX3hwID0geHA7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NfeHBQb3MgPSB4cFBvcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhY2N1bXVsYXRlICs9IGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGwgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgKiByaDogMjAwNDAyMTUgbWF5IGhhcHBlbiBkdWUgdG8gXCJwcmV2X2RhdGFfdXNlXCJcbiAgICAgICAgICAgICAgICAgICAgICogb3B0aW1pemF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWNjdW11bGF0ZTAxICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXplX2xpbmVzX3hycG93XzAxKGFjY3VtdWxhdGUwMSwgaXN0ZXAsIGFjY194cCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NfeHBQb3MsIGFjY19pRGF0YSwgYWNjX2lEYXRhUG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY3VtdWxhdGUwMSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjY3VtdWxhdGUgIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpemVfbGluZXNfeHJwb3coYWNjdW11bGF0ZSwgaXN0ZXAsIGFjY194cCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NfeHBQb3MsIGFjY19pRGF0YSwgYWNjX2lEYXRhUG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY3VtdWxhdGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8qIGVuZHMgZm9yLWxvb3AgKi9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2ZiIDw9IHNmYm1heCkge1xuICAgICAgICAgICAgICAgIGlEYXRhUG9zICs9IGNvZEluZm8ud2lkdGhbc2ZiXTtcbiAgICAgICAgICAgICAgICB4cFBvcyArPSBjb2RJbmZvLndpZHRoW3NmYl07XG4gICAgICAgICAgICAgICAgaiArPSBjb2RJbmZvLndpZHRoW3NmYl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjY3VtdWxhdGUgIT0gMCkgeyAvKiBsYXN0IGRhdGEgcGFydCAqL1xuICAgICAgICAgICAgcXVhbnRpemVfbGluZXNfeHJwb3coYWNjdW11bGF0ZSwgaXN0ZXAsIGFjY194cCwgYWNjX3hwUG9zLFxuICAgICAgICAgICAgICAgIGFjY19pRGF0YSwgYWNjX2lEYXRhUG9zKTtcbiAgICAgICAgICAgIGFjY3VtdWxhdGUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhY2N1bXVsYXRlMDEgIT0gMCkgeyAvKiBsYXN0IGRhdGEgcGFydCAqL1xuICAgICAgICAgICAgcXVhbnRpemVfbGluZXNfeHJwb3dfMDEoYWNjdW11bGF0ZTAxLCBpc3RlcCwgYWNjX3hwLCBhY2NfeHBQb3MsXG4gICAgICAgICAgICAgICAgYWNjX2lEYXRhLCBhY2NfaURhdGFQb3MpO1xuICAgICAgICAgICAgYWNjdW11bGF0ZTAxID0gMDtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaXhfbWF4XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXhfbWF4KGl4LCBpeFBvcywgZW5kUG9zKSB7XG4gICAgICAgIHZhciBtYXgxID0gMCwgbWF4MiA9IDA7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdmFyIHgxID0gaXhbaXhQb3MrK107XG4gICAgICAgICAgICB2YXIgeDIgPSBpeFtpeFBvcysrXTtcbiAgICAgICAgICAgIGlmIChtYXgxIDwgeDEpXG4gICAgICAgICAgICAgICAgbWF4MSA9IHgxO1xuXG4gICAgICAgICAgICBpZiAobWF4MiA8IHgyKVxuICAgICAgICAgICAgICAgIG1heDIgPSB4MjtcbiAgICAgICAgfSB3aGlsZSAoaXhQb3MgPCBlbmRQb3MpO1xuICAgICAgICBpZiAobWF4MSA8IG1heDIpXG4gICAgICAgICAgICBtYXgxID0gbWF4MjtcbiAgICAgICAgcmV0dXJuIG1heDE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY291bnRfYml0X0VTQyhpeCwgaXhQb3MsIGVuZCwgdDEsIHQyLCBzKSB7XG4gICAgICAgIC8qIEVTQy10YWJsZSBpcyB1c2VkICovXG4gICAgICAgIHZhciBsaW5iaXRzID0gVGFibGVzLmh0W3QxXS54bGVuICogNjU1MzYgKyBUYWJsZXMuaHRbdDJdLnhsZW47XG4gICAgICAgIHZhciBzdW0gPSAwLCBzdW0yO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHZhciB4ID0gaXhbaXhQb3MrK107XG4gICAgICAgICAgICB2YXIgeSA9IGl4W2l4UG9zKytdO1xuXG4gICAgICAgICAgICBpZiAoeCAhPSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHggPiAxNCkge1xuICAgICAgICAgICAgICAgICAgICB4ID0gMTU7XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBsaW5iaXRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB4ICo9IDE2O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoeSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHkgPiAxNCkge1xuICAgICAgICAgICAgICAgICAgICB5ID0gMTU7XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBsaW5iaXRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB4ICs9IHk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN1bSArPSBUYWJsZXMubGFyZ2V0YmxbeF07XG4gICAgICAgIH0gd2hpbGUgKGl4UG9zIDwgZW5kKTtcblxuICAgICAgICBzdW0yID0gc3VtICYgMHhmZmZmO1xuICAgICAgICBzdW0gPj49IDE2O1xuXG4gICAgICAgIGlmIChzdW0gPiBzdW0yKSB7XG4gICAgICAgICAgICBzdW0gPSBzdW0yO1xuICAgICAgICAgICAgdDEgPSB0MjtcbiAgICAgICAgfVxuXG4gICAgICAgIHMuYml0cyArPSBzdW07XG4gICAgICAgIHJldHVybiB0MTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb3VudF9iaXRfbm9FU0MoaXgsIGl4UG9zLCBlbmQsIHMpIHtcbiAgICAgICAgLyogTm8gRVNDLXdvcmRzICovXG4gICAgICAgIHZhciBzdW0xID0gMDtcbiAgICAgICAgdmFyIGhsZW4xID0gVGFibGVzLmh0WzFdLmhsZW47XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdmFyIHggPSBpeFtpeFBvcyArIDBdICogMiArIGl4W2l4UG9zICsgMV07XG4gICAgICAgICAgICBpeFBvcyArPSAyO1xuICAgICAgICAgICAgc3VtMSArPSBobGVuMVt4XTtcbiAgICAgICAgfSB3aGlsZSAoaXhQb3MgPCBlbmQpO1xuXG4gICAgICAgIHMuYml0cyArPSBzdW0xO1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb3VudF9iaXRfbm9FU0NfZnJvbTIoaXgsIGl4UG9zLCBlbmQsIHQxLCBzKSB7XG4gICAgICAgIC8qIE5vIEVTQy13b3JkcyAqL1xuICAgICAgICB2YXIgc3VtID0gMCwgc3VtMjtcbiAgICAgICAgdmFyIHhsZW4gPSBUYWJsZXMuaHRbdDFdLnhsZW47XG4gICAgICAgIHZhciBobGVuO1xuICAgICAgICBpZiAodDEgPT0gMilcbiAgICAgICAgICAgIGhsZW4gPSBUYWJsZXMudGFibGUyMztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgaGxlbiA9IFRhYmxlcy50YWJsZTU2O1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHZhciB4ID0gaXhbaXhQb3MgKyAwXSAqIHhsZW4gKyBpeFtpeFBvcyArIDFdO1xuICAgICAgICAgICAgaXhQb3MgKz0gMjtcbiAgICAgICAgICAgIHN1bSArPSBobGVuW3hdO1xuICAgICAgICB9IHdoaWxlIChpeFBvcyA8IGVuZCk7XG5cbiAgICAgICAgc3VtMiA9IHN1bSAmIDB4ZmZmZjtcbiAgICAgICAgc3VtID4+PSAxNjtcblxuICAgICAgICBpZiAoc3VtID4gc3VtMikge1xuICAgICAgICAgICAgc3VtID0gc3VtMjtcbiAgICAgICAgICAgIHQxKys7XG4gICAgICAgIH1cblxuICAgICAgICBzLmJpdHMgKz0gc3VtO1xuICAgICAgICByZXR1cm4gdDE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY291bnRfYml0X25vRVNDX2Zyb20zKGl4LCBpeFBvcywgZW5kLCB0MSwgcykge1xuICAgICAgICAvKiBObyBFU0Mtd29yZHMgKi9cbiAgICAgICAgdmFyIHN1bTEgPSAwO1xuICAgICAgICB2YXIgc3VtMiA9IDA7XG4gICAgICAgIHZhciBzdW0zID0gMDtcbiAgICAgICAgdmFyIHhsZW4gPSBUYWJsZXMuaHRbdDFdLnhsZW47XG4gICAgICAgIHZhciBobGVuMSA9IFRhYmxlcy5odFt0MV0uaGxlbjtcbiAgICAgICAgdmFyIGhsZW4yID0gVGFibGVzLmh0W3QxICsgMV0uaGxlbjtcbiAgICAgICAgdmFyIGhsZW4zID0gVGFibGVzLmh0W3QxICsgMl0uaGxlbjtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgICB2YXIgeCA9IGl4W2l4UG9zICsgMF0gKiB4bGVuICsgaXhbaXhQb3MgKyAxXTtcbiAgICAgICAgICAgIGl4UG9zICs9IDI7XG4gICAgICAgICAgICBzdW0xICs9IGhsZW4xW3hdO1xuICAgICAgICAgICAgc3VtMiArPSBobGVuMlt4XTtcbiAgICAgICAgICAgIHN1bTMgKz0gaGxlbjNbeF07XG4gICAgICAgIH0gd2hpbGUgKGl4UG9zIDwgZW5kKTtcbiAgICAgICAgdmFyIHQgPSB0MTtcbiAgICAgICAgaWYgKHN1bTEgPiBzdW0yKSB7XG4gICAgICAgICAgICBzdW0xID0gc3VtMjtcbiAgICAgICAgICAgIHQrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3VtMSA+IHN1bTMpIHtcbiAgICAgICAgICAgIHN1bTEgPSBzdW0zO1xuICAgICAgICAgICAgdCA9IHQxICsgMjtcbiAgICAgICAgfVxuICAgICAgICBzLmJpdHMgKz0gc3VtMTtcblxuICAgICAgICByZXR1cm4gdDtcbiAgICB9XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAvKiBjaG9vc2UgdGFibGUgKi9cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIHZhciBodWZfdGJsX25vRVNDID0gWzEsIDIsIDUsIDcsIDcsIDEwLCAxMCwgMTMsIDEzLFxuICAgICAgICAxMywgMTMsIDEzLCAxMywgMTMsIDEzXTtcblxuICAgIC8qKlxuICAgICAqIENob29zZSB0aGUgSHVmZm1hbiB0YWJsZSB0aGF0IHdpbGwgZW5jb2RlIGl4W2JlZ2luLi5lbmRdIHdpdGggdGhlIGZld2VzdFxuICAgICAqIGJpdHMuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIGNvZGUgY29udGFpbnMga25vd2xlZGdlIGFib3V0IHRoZSBzaXplcyBhbmQgY2hhcmFjdGVyaXN0aWNzIG9mXG4gICAgICogdGhlIEh1ZmZtYW4gdGFibGVzIGFzIGRlZmluZWQgaW4gdGhlIElTIChUYWJsZSBCLjcpLCBhbmQgd2lsbCBub3Qgd29ya1xuICAgICAqIHdpdGggYW55IGFyYml0cmFyeSB0YWJsZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hvb3NlX3RhYmxlKGl4LCBpeFBvcywgZW5kUG9zLCBzKSB7XG4gICAgICAgIHZhciBtYXggPSBpeF9tYXgoaXgsIGl4UG9zLCBlbmRQb3MpO1xuXG4gICAgICAgIHN3aXRjaCAobWF4KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1heDtcblxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiBjb3VudF9iaXRfbm9FU0MoaXgsIGl4UG9zLCBlbmRQb3MsIHMpO1xuXG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvdW50X2JpdF9ub0VTQ19mcm9tMihpeCwgaXhQb3MsIGVuZFBvcyxcbiAgICAgICAgICAgICAgICAgICAgaHVmX3RibF9ub0VTQ1ttYXggLSAxXSwgcyk7XG5cbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICByZXR1cm4gY291bnRfYml0X25vRVNDX2Zyb20zKGl4LCBpeFBvcywgZW5kUG9zLFxuICAgICAgICAgICAgICAgICAgICBodWZfdGJsX25vRVNDW21heCAtIDFdLCBzKTtcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvKiB0cnkgdGFibGVzIHdpdGggbGluYml0cyAqL1xuICAgICAgICAgICAgICAgIGlmIChtYXggPiBRdWFudGl6ZVBWVC5JWE1BWF9WQUwpIHtcbiAgICAgICAgICAgICAgICAgICAgcy5iaXRzID0gUXVhbnRpemVQVlQuTEFSR0VfQklUUztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXggLT0gMTU7XG4gICAgICAgICAgICAgICAgdmFyIGNob2ljZTI7XG4gICAgICAgICAgICAgICAgZm9yIChjaG9pY2UyID0gMjQ7IGNob2ljZTIgPCAzMjsgY2hvaWNlMisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChUYWJsZXMuaHRbY2hvaWNlMl0ubGlubWF4ID49IG1heCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNob2ljZTtcbiAgICAgICAgICAgICAgICBmb3IgKGNob2ljZSA9IGNob2ljZTIgLSA4OyBjaG9pY2UgPCAyNDsgY2hvaWNlKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFRhYmxlcy5odFtjaG9pY2VdLmxpbm1heCA+PSBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb3VudF9iaXRfRVNDKGl4LCBpeFBvcywgZW5kUG9zLCBjaG9pY2UsIGNob2ljZTIsIHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY291bnRfYml0XG4gICAgICovXG4gICAgdGhpcy5ub3F1YW50X2NvdW50X2JpdHMgPSBmdW5jdGlvbiAoZ2ZjLCBnaSwgcHJldl9ub2lzZSkge1xuICAgICAgICB2YXIgaXggPSBnaS5sM19lbmM7XG4gICAgICAgIHZhciBpID0gTWF0aC5taW4oNTc2LCAoKGdpLm1heF9ub256ZXJvX2NvZWZmICsgMikgPj4gMSkgPDwgMSk7XG5cbiAgICAgICAgaWYgKHByZXZfbm9pc2UgIT0gbnVsbClcbiAgICAgICAgICAgIHByZXZfbm9pc2Uuc2ZiX2NvdW50MSA9IDA7XG5cbiAgICAgICAgLyogRGV0ZXJtaW5lIGNvdW50MSByZWdpb24gKi9cbiAgICAgICAgZm9yICg7IGkgPiAxOyBpIC09IDIpXG4gICAgICAgICAgICBpZiAoKGl4W2kgLSAxXSB8IGl4W2kgLSAyXSkgIT0gMClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgZ2kuY291bnQxID0gaTtcblxuICAgICAgICAvKiBEZXRlcm1pbmVzIHRoZSBudW1iZXIgb2YgYml0cyB0byBlbmNvZGUgdGhlIHF1YWRydXBsZXMuICovXG4gICAgICAgIHZhciBhMSA9IDA7XG4gICAgICAgIHZhciBhMiA9IDA7XG4gICAgICAgIGZvciAoOyBpID4gMzsgaSAtPSA0KSB7XG4gICAgICAgICAgICB2YXIgcDtcbiAgICAgICAgICAgIC8qIGhhY2sgdG8gY2hlY2sgaWYgYWxsIHZhbHVlcyA8PSAxICovXG4gICAgICAgICAgICAvL3Rocm93IFwiVE9ETzogSEFDSyAgICAgICAgIGlmICgoKChsb25nKSBpeFtpIC0gMV0gfCAobG9uZykgaXhbaSAtIDJdIHwgKGxvbmcpIGl4W2kgLSAzXSB8IChsb25nKSBpeFtpIC0gNF0pICYgMHhmZmZmZmZmZkwpID4gMUwgICAgICAgIFwiXG4gICAgICAgICAgICAvL2lmICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAoKChpeFtpIC0gMV0gfCBpeFtpIC0gMl0gfCBpeFtpIC0gM10gfCBpeFtpIC0gNF0pICYgMHg3ZmZmZmZmZikgPiAxKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwID0gKChpeFtpIC0gNF0gKiAyICsgaXhbaSAtIDNdKSAqIDIgKyBpeFtpIC0gMl0pICogMiArIGl4W2kgLSAxXTtcbiAgICAgICAgICAgIGExICs9IFRhYmxlcy50MzJsW3BdO1xuICAgICAgICAgICAgYTIgKz0gVGFibGVzLnQzM2xbcF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJpdHMgPSBhMTtcbiAgICAgICAgZ2kuY291bnQxdGFibGVfc2VsZWN0ID0gMDtcbiAgICAgICAgaWYgKGExID4gYTIpIHtcbiAgICAgICAgICAgIGJpdHMgPSBhMjtcbiAgICAgICAgICAgIGdpLmNvdW50MXRhYmxlX3NlbGVjdCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBnaS5jb3VudDFiaXRzID0gYml0cztcbiAgICAgICAgZ2kuYmlnX3ZhbHVlcyA9IGk7XG4gICAgICAgIGlmIChpID09IDApXG4gICAgICAgICAgICByZXR1cm4gYml0cztcblxuICAgICAgICBpZiAoZ2kuYmxvY2tfdHlwZSA9PSBFbmNvZGVyLlNIT1JUX1RZUEUpIHtcbiAgICAgICAgICAgIGExID0gMyAqIGdmYy5zY2FsZWZhY19iYW5kLnNbM107XG4gICAgICAgICAgICBpZiAoYTEgPiBnaS5iaWdfdmFsdWVzKVxuICAgICAgICAgICAgICAgIGExID0gZ2kuYmlnX3ZhbHVlcztcbiAgICAgICAgICAgIGEyID0gZ2kuYmlnX3ZhbHVlcztcblxuICAgICAgICB9IGVsc2UgaWYgKGdpLmJsb2NrX3R5cGUgPT0gRW5jb2Rlci5OT1JNX1RZUEUpIHtcbiAgICAgICAgICAgIGFzc2VydChpIDw9IDU3Nik7XG4gICAgICAgICAgICAvKiBidl9zY2YgaGFzIDU3NiBlbnRyaWVzICgwLi41NzUpICovXG4gICAgICAgICAgICBhMSA9IGdpLnJlZ2lvbjBfY291bnQgPSBnZmMuYnZfc2NmW2kgLSAyXTtcbiAgICAgICAgICAgIGEyID0gZ2kucmVnaW9uMV9jb3VudCA9IGdmYy5idl9zY2ZbaSAtIDFdO1xuXG4gICAgICAgICAgICBhc3NlcnQoYTEgKyBhMiArIDIgPCBFbmNvZGVyLlNCUFNZX2wpO1xuICAgICAgICAgICAgYTIgPSBnZmMuc2NhbGVmYWNfYmFuZC5sW2ExICsgYTIgKyAyXTtcbiAgICAgICAgICAgIGExID0gZ2ZjLnNjYWxlZmFjX2JhbmQubFthMSArIDFdO1xuICAgICAgICAgICAgaWYgKGEyIDwgaSkge1xuICAgICAgICAgICAgICAgIHZhciBiaSA9IG5ldyBCaXRzKGJpdHMpO1xuICAgICAgICAgICAgICAgIGdpLnRhYmxlX3NlbGVjdFsyXSA9IGNob29zZV90YWJsZShpeCwgYTIsIGksIGJpKTtcbiAgICAgICAgICAgICAgICBiaXRzID0gYmkuYml0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdpLnJlZ2lvbjBfY291bnQgPSA3O1xuICAgICAgICAgICAgLyogZ2kucmVnaW9uMV9jb3VudCA9IFNCUFNZX2wgLSA3IC0gMTsgKi9cbiAgICAgICAgICAgIGdpLnJlZ2lvbjFfY291bnQgPSBFbmNvZGVyLlNCTUFYX2wgLSAxIC0gNyAtIDE7XG4gICAgICAgICAgICBhMSA9IGdmYy5zY2FsZWZhY19iYW5kLmxbNyArIDFdO1xuICAgICAgICAgICAgYTIgPSBpO1xuICAgICAgICAgICAgaWYgKGExID4gYTIpIHtcbiAgICAgICAgICAgICAgICBhMSA9IGEyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyogaGF2ZSB0byBhbGxvdyBmb3IgdGhlIGNhc2Ugd2hlbiBiaWd2YWx1ZXMgPCByZWdpb24wIDwgcmVnaW9uMSAqL1xuICAgICAgICAvKiAoYW5kIHJlZ2lvbjAsIHJlZ2lvbjEgYXJlIGlnbm9yZWQpICovXG4gICAgICAgIGExID0gTWF0aC5taW4oYTEsIGkpO1xuICAgICAgICBhMiA9IE1hdGgubWluKGEyLCBpKTtcblxuICAgICAgICBhc3NlcnQoYTEgPj0gMCk7XG4gICAgICAgIGFzc2VydChhMiA+PSAwKTtcblxuICAgICAgICAvKiBDb3VudCB0aGUgbnVtYmVyIG9mIGJpdHMgbmVjZXNzYXJ5IHRvIGNvZGUgdGhlIGJpZ3ZhbHVlcyByZWdpb24uICovXG4gICAgICAgIGlmICgwIDwgYTEpIHtcbiAgICAgICAgICAgIHZhciBiaSA9IG5ldyBCaXRzKGJpdHMpO1xuICAgICAgICAgICAgZ2kudGFibGVfc2VsZWN0WzBdID0gY2hvb3NlX3RhYmxlKGl4LCAwLCBhMSwgYmkpO1xuICAgICAgICAgICAgYml0cyA9IGJpLmJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGExIDwgYTIpIHtcbiAgICAgICAgICAgIHZhciBiaSA9IG5ldyBCaXRzKGJpdHMpO1xuICAgICAgICAgICAgZ2kudGFibGVfc2VsZWN0WzFdID0gY2hvb3NlX3RhYmxlKGl4LCBhMSwgYTIsIGJpKTtcbiAgICAgICAgICAgIGJpdHMgPSBiaS5iaXRzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZmMudXNlX2Jlc3RfaHVmZm1hbiA9PSAyKSB7XG4gICAgICAgICAgICBnaS5wYXJ0Ml8zX2xlbmd0aCA9IGJpdHM7XG4gICAgICAgICAgICBiZXN0X2h1ZmZtYW5fZGl2aWRlKGdmYywgZ2kpO1xuICAgICAgICAgICAgYml0cyA9IGdpLnBhcnQyXzNfbGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZXZfbm9pc2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGdpLmJsb2NrX3R5cGUgPT0gRW5jb2Rlci5OT1JNX1RZUEUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2ZiID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZ2ZjLnNjYWxlZmFjX2JhbmQubFtzZmJdIDwgZ2kuYmlnX3ZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICBzZmIrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldl9ub2lzZS5zZmJfY291bnQxID0gc2ZiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgfVxuXG4gICAgdGhpcy5jb3VudF9iaXRzID0gZnVuY3Rpb24gKGdmYywgeHIsIGdpLCBwcmV2X25vaXNlKSB7XG4gICAgICAgIHZhciBpeCA9IGdpLmwzX2VuYztcblxuICAgICAgICAvKiBzaW5jZSBxdWFudGl6ZV94cnBvdyB1c2VzIHRhYmxlIGxvb2t1cCwgd2UgbmVlZCB0byBjaGVjayB0aGlzIGZpcnN0OiAqL1xuICAgICAgICB2YXIgdyA9IChRdWFudGl6ZVBWVC5JWE1BWF9WQUwpIC8gcXVwdnQuSVBPVzIwKGdpLmdsb2JhbF9nYWluKTtcblxuICAgICAgICBpZiAoZ2kueHJwb3dfbWF4ID4gdylcbiAgICAgICAgICAgIHJldHVybiBRdWFudGl6ZVBWVC5MQVJHRV9CSVRTO1xuXG4gICAgICAgIHF1YW50aXplX3hycG93KHhyLCBpeCwgcXVwdnQuSVBPVzIwKGdpLmdsb2JhbF9nYWluKSwgZ2ksIHByZXZfbm9pc2UpO1xuXG4gICAgICAgIGlmICgoZ2ZjLnN1YnN0ZXBfc2hhcGluZyAmIDIpICE9IDApIHtcbiAgICAgICAgICAgIHZhciBqID0gMDtcbiAgICAgICAgICAgIC8qIDAuNjM0NTIxNjgyMjQyNDM5ID0gMC41OTQ2KjIqKiguNSowLjE4NzUpICovXG4gICAgICAgICAgICB2YXIgZ2FpbiA9IGdpLmdsb2JhbF9nYWluICsgZ2kuc2NhbGVmYWNfc2NhbGU7XG4gICAgICAgICAgICB2YXIgcm91bmRmYWMgPSAwLjYzNDUyMTY4MjI0MjQzOSAvIHF1cHZ0LklQT1cyMChnYWluKTtcbiAgICAgICAgICAgIGZvciAodmFyIHNmYiA9IDA7IHNmYiA8IGdpLnNmYm1heDsgc2ZiKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBnaS53aWR0aFtzZmJdO1xuICAgICAgICAgICAgICAgIGFzc2VydCh3aWR0aCA+PSAwKTtcbiAgICAgICAgICAgICAgICBpZiAoMCA9PSBnZmMucHNldWRvaGFsZltzZmJdKSB7XG4gICAgICAgICAgICAgICAgICAgIGogKz0gd2lkdGg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGs7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoayA9IGosIGogKz0gd2lkdGg7IGsgPCBqOyArK2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl4W2tdID0gKHhyW2tdID49IHJvdW5kZmFjKSA/IGl4W2tdIDogMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ub3F1YW50X2NvdW50X2JpdHMoZ2ZjLCBnaSwgcHJldl9ub2lzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmUtY2FsY3VsYXRlIHRoZSBiZXN0IHNjYWxlZmFjX2NvbXByZXNzIHVzaW5nIHNjZnNpIHRoZSBzYXZlZCBiaXRzIGFyZVxuICAgICAqIGtlcHQgaW4gdGhlIGJpdCByZXNlcnZvaXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVjYWxjX2RpdmlkZV9pbml0KGdmYywgY29kX2luZm8sIGl4LCByMDFfYml0cywgcjAxX2RpdiwgcjBfdGJsLCByMV90YmwpIHtcbiAgICAgICAgdmFyIGJpZ3YgPSBjb2RfaW5mby5iaWdfdmFsdWVzO1xuXG4gICAgICAgIGZvciAodmFyIHIwID0gMDsgcjAgPD0gNyArIDE1OyByMCsrKSB7XG4gICAgICAgICAgICByMDFfYml0c1tyMF0gPSBRdWFudGl6ZVBWVC5MQVJHRV9CSVRTO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgcjAgPSAwOyByMCA8IDE2OyByMCsrKSB7XG4gICAgICAgICAgICB2YXIgYTEgPSBnZmMuc2NhbGVmYWNfYmFuZC5sW3IwICsgMV07XG4gICAgICAgICAgICBpZiAoYTEgPj0gYmlndilcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHZhciByMGJpdHMgPSAwO1xuICAgICAgICAgICAgdmFyIGJpID0gbmV3IEJpdHMocjBiaXRzKTtcbiAgICAgICAgICAgIHZhciByMHQgPSBjaG9vc2VfdGFibGUoaXgsIDAsIGExLCBiaSk7XG4gICAgICAgICAgICByMGJpdHMgPSBiaS5iaXRzO1xuXG4gICAgICAgICAgICBmb3IgKHZhciByMSA9IDA7IHIxIDwgODsgcjErKykge1xuICAgICAgICAgICAgICAgIHZhciBhMiA9IGdmYy5zY2FsZWZhY19iYW5kLmxbcjAgKyByMSArIDJdO1xuICAgICAgICAgICAgICAgIGlmIChhMiA+PSBiaWd2KVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB2YXIgYml0cyA9IHIwYml0cztcbiAgICAgICAgICAgICAgICBiaSA9IG5ldyBCaXRzKGJpdHMpO1xuICAgICAgICAgICAgICAgIHZhciByMXQgPSBjaG9vc2VfdGFibGUoaXgsIGExLCBhMiwgYmkpO1xuICAgICAgICAgICAgICAgIGJpdHMgPSBiaS5iaXRzO1xuICAgICAgICAgICAgICAgIGlmIChyMDFfYml0c1tyMCArIHIxXSA+IGJpdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcjAxX2JpdHNbcjAgKyByMV0gPSBiaXRzO1xuICAgICAgICAgICAgICAgICAgICByMDFfZGl2W3IwICsgcjFdID0gcjA7XG4gICAgICAgICAgICAgICAgICAgIHIwX3RibFtyMCArIHIxXSA9IHIwdDtcbiAgICAgICAgICAgICAgICAgICAgcjFfdGJsW3IwICsgcjFdID0gcjF0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlY2FsY19kaXZpZGVfc3ViKGdmYywgY29kX2luZm8yLCBnaSwgaXgsIHIwMV9iaXRzLCByMDFfZGl2LCByMF90YmwsIHIxX3RibCkge1xuICAgICAgICB2YXIgYmlndiA9IGNvZF9pbmZvMi5iaWdfdmFsdWVzO1xuXG4gICAgICAgIGZvciAodmFyIHIyID0gMjsgcjIgPCBFbmNvZGVyLlNCTUFYX2wgKyAxOyByMisrKSB7XG4gICAgICAgICAgICB2YXIgYTIgPSBnZmMuc2NhbGVmYWNfYmFuZC5sW3IyXTtcbiAgICAgICAgICAgIGlmIChhMiA+PSBiaWd2KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdmFyIGJpdHMgPSByMDFfYml0c1tyMiAtIDJdICsgY29kX2luZm8yLmNvdW50MWJpdHM7XG4gICAgICAgICAgICBpZiAoZ2kucGFydDJfM19sZW5ndGggPD0gYml0cylcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgdmFyIGJpID0gbmV3IEJpdHMoYml0cyk7XG4gICAgICAgICAgICB2YXIgcjJ0ID0gY2hvb3NlX3RhYmxlKGl4LCBhMiwgYmlndiwgYmkpO1xuICAgICAgICAgICAgYml0cyA9IGJpLmJpdHM7XG4gICAgICAgICAgICBpZiAoZ2kucGFydDJfM19sZW5ndGggPD0gYml0cylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgZ2kuYXNzaWduKGNvZF9pbmZvMik7XG4gICAgICAgICAgICBnaS5wYXJ0Ml8zX2xlbmd0aCA9IGJpdHM7XG4gICAgICAgICAgICBnaS5yZWdpb24wX2NvdW50ID0gcjAxX2RpdltyMiAtIDJdO1xuICAgICAgICAgICAgZ2kucmVnaW9uMV9jb3VudCA9IHIyIC0gMiAtIHIwMV9kaXZbcjIgLSAyXTtcbiAgICAgICAgICAgIGdpLnRhYmxlX3NlbGVjdFswXSA9IHIwX3RibFtyMiAtIDJdO1xuICAgICAgICAgICAgZ2kudGFibGVfc2VsZWN0WzFdID0gcjFfdGJsW3IyIC0gMl07XG4gICAgICAgICAgICBnaS50YWJsZV9zZWxlY3RbMl0gPSByMnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmJlc3RfaHVmZm1hbl9kaXZpZGUgPSBmdW5jdGlvbiAoZ2ZjLCBnaSkge1xuICAgICAgICB2YXIgY29kX2luZm8yID0gbmV3IEdySW5mbygpO1xuICAgICAgICB2YXIgaXggPSBnaS5sM19lbmM7XG4gICAgICAgIHZhciByMDFfYml0cyA9IG5ld19pbnQoNyArIDE1ICsgMSk7XG4gICAgICAgIHZhciByMDFfZGl2ID0gbmV3X2ludCg3ICsgMTUgKyAxKTtcbiAgICAgICAgdmFyIHIwX3RibCA9IG5ld19pbnQoNyArIDE1ICsgMSk7XG4gICAgICAgIHZhciByMV90YmwgPSBuZXdfaW50KDcgKyAxNSArIDEpO1xuXG4gICAgICAgIC8qIFNIT1JUIEJMT0NLIHN0dWZmIGZhaWxzIGZvciBNUEVHMiAqL1xuICAgICAgICBpZiAoZ2kuYmxvY2tfdHlwZSA9PSBFbmNvZGVyLlNIT1JUX1RZUEUgJiYgZ2ZjLm1vZGVfZ3IgPT0gMSlcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBjb2RfaW5mbzIuYXNzaWduKGdpKTtcbiAgICAgICAgaWYgKGdpLmJsb2NrX3R5cGUgPT0gRW5jb2Rlci5OT1JNX1RZUEUpIHtcbiAgICAgICAgICAgIHJlY2FsY19kaXZpZGVfaW5pdChnZmMsIGdpLCBpeCwgcjAxX2JpdHMsIHIwMV9kaXYsIHIwX3RibCwgcjFfdGJsKTtcbiAgICAgICAgICAgIHJlY2FsY19kaXZpZGVfc3ViKGdmYywgY29kX2luZm8yLCBnaSwgaXgsIHIwMV9iaXRzLCByMDFfZGl2LFxuICAgICAgICAgICAgICAgIHIwX3RibCwgcjFfdGJsKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaSA9IGNvZF9pbmZvMi5iaWdfdmFsdWVzO1xuICAgICAgICBpZiAoaSA9PSAwIHx8IChpeFtpIC0gMl0gfCBpeFtpIC0gMV0pID4gMSlcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBpID0gZ2kuY291bnQxICsgMjtcbiAgICAgICAgaWYgKGkgPiA1NzYpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgLyogRGV0ZXJtaW5lcyB0aGUgbnVtYmVyIG9mIGJpdHMgdG8gZW5jb2RlIHRoZSBxdWFkcnVwbGVzLiAqL1xuICAgICAgICBjb2RfaW5mbzIuYXNzaWduKGdpKTtcbiAgICAgICAgY29kX2luZm8yLmNvdW50MSA9IGk7XG4gICAgICAgIHZhciBhMSA9IDA7XG4gICAgICAgIHZhciBhMiA9IDA7XG5cbiAgICAgICAgYXNzZXJ0KGkgPD0gNTc2KTtcblxuICAgICAgICBmb3IgKDsgaSA+IGNvZF9pbmZvMi5iaWdfdmFsdWVzOyBpIC09IDQpIHtcbiAgICAgICAgICAgIHZhciBwID0gKChpeFtpIC0gNF0gKiAyICsgaXhbaSAtIDNdKSAqIDIgKyBpeFtpIC0gMl0pICogMlxuICAgICAgICAgICAgICAgICsgaXhbaSAtIDFdO1xuICAgICAgICAgICAgYTEgKz0gVGFibGVzLnQzMmxbcF07XG4gICAgICAgICAgICBhMiArPSBUYWJsZXMudDMzbFtwXTtcbiAgICAgICAgfVxuICAgICAgICBjb2RfaW5mbzIuYmlnX3ZhbHVlcyA9IGk7XG5cbiAgICAgICAgY29kX2luZm8yLmNvdW50MXRhYmxlX3NlbGVjdCA9IDA7XG4gICAgICAgIGlmIChhMSA+IGEyKSB7XG4gICAgICAgICAgICBhMSA9IGEyO1xuICAgICAgICAgICAgY29kX2luZm8yLmNvdW50MXRhYmxlX3NlbGVjdCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBjb2RfaW5mbzIuY291bnQxYml0cyA9IGExO1xuXG4gICAgICAgIGlmIChjb2RfaW5mbzIuYmxvY2tfdHlwZSA9PSBFbmNvZGVyLk5PUk1fVFlQRSlcbiAgICAgICAgICAgIHJlY2FsY19kaXZpZGVfc3ViKGdmYywgY29kX2luZm8yLCBnaSwgaXgsIHIwMV9iaXRzLCByMDFfZGl2LFxuICAgICAgICAgICAgICAgIHIwX3RibCwgcjFfdGJsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKiBDb3VudCB0aGUgbnVtYmVyIG9mIGJpdHMgbmVjZXNzYXJ5IHRvIGNvZGUgdGhlIGJpZ3ZhbHVlcyByZWdpb24uICovXG4gICAgICAgICAgICBjb2RfaW5mbzIucGFydDJfM19sZW5ndGggPSBhMTtcbiAgICAgICAgICAgIGExID0gZ2ZjLnNjYWxlZmFjX2JhbmQubFs3ICsgMV07XG4gICAgICAgICAgICBpZiAoYTEgPiBpKSB7XG4gICAgICAgICAgICAgICAgYTEgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGExID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBiaSA9IG5ldyBCaXRzKGNvZF9pbmZvMi5wYXJ0Ml8zX2xlbmd0aCk7XG4gICAgICAgICAgICAgICAgY29kX2luZm8yLnRhYmxlX3NlbGVjdFswXSA9IGNob29zZV90YWJsZShpeCwgMCwgYTEsIGJpKTtcbiAgICAgICAgICAgICAgICBjb2RfaW5mbzIucGFydDJfM19sZW5ndGggPSBiaS5iaXRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPiBhMSkge1xuICAgICAgICAgICAgICAgIHZhciBiaSA9IG5ldyBCaXRzKGNvZF9pbmZvMi5wYXJ0Ml8zX2xlbmd0aCk7XG4gICAgICAgICAgICAgICAgY29kX2luZm8yLnRhYmxlX3NlbGVjdFsxXSA9IGNob29zZV90YWJsZShpeCwgYTEsIGksIGJpKTtcbiAgICAgICAgICAgICAgICBjb2RfaW5mbzIucGFydDJfM19sZW5ndGggPSBiaS5iaXRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdpLnBhcnQyXzNfbGVuZ3RoID4gY29kX2luZm8yLnBhcnQyXzNfbGVuZ3RoKVxuICAgICAgICAgICAgICAgIGdpLmFzc2lnbihjb2RfaW5mbzIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNsZW4xX24gPSBbMSwgMSwgMSwgMSwgOCwgMiwgMiwgMiwgNCwgNCwgNCwgOCwgOCwgOCwgMTYsIDE2XTtcbiAgICB2YXIgc2xlbjJfbiA9IFsxLCAyLCA0LCA4LCAxLCAyLCA0LCA4LCAyLCA0LCA4LCAyLCA0LCA4LCA0LCA4XTtcbiAgICB2YXIgc2xlbjFfdGFiID0gWzAsIDAsIDAsIDAsIDMsIDEsIDEsIDEsIDIsIDIsIDIsIDMsIDMsIDMsIDQsIDRdO1xuICAgIHZhciBzbGVuMl90YWIgPSBbMCwgMSwgMiwgMywgMCwgMSwgMiwgMywgMSwgMiwgMywgMSwgMiwgMywgMiwgM107XG4gICAgVGFrZWhpcm8uc2xlbjFfdGFiID0gc2xlbjFfdGFiO1xuICAgIFRha2VoaXJvLnNsZW4yX3RhYiA9IHNsZW4yX3RhYjtcblxuICAgIGZ1bmN0aW9uIHNjZnNpX2NhbGMoY2gsIGwzX3NpZGUpIHtcbiAgICAgICAgdmFyIHNmYjtcbiAgICAgICAgdmFyIGdpID0gbDNfc2lkZS50dFsxXVtjaF07XG4gICAgICAgIHZhciBnMCA9IGwzX3NpZGUudHRbMF1bY2hdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgVGFibGVzLnNjZnNpX2JhbmQubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKHNmYiA9IFRhYmxlcy5zY2ZzaV9iYW5kW2ldOyBzZmIgPCBUYWJsZXMuc2Nmc2lfYmFuZFtpICsgMV07IHNmYisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGcwLnNjYWxlZmFjW3NmYl0gIT0gZ2kuc2NhbGVmYWNbc2ZiXVxuICAgICAgICAgICAgICAgICAgICAmJiBnaS5zY2FsZWZhY1tzZmJdID49IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNmYiA9PSBUYWJsZXMuc2Nmc2lfYmFuZFtpICsgMV0pIHtcbiAgICAgICAgICAgICAgICBmb3IgKHNmYiA9IFRhYmxlcy5zY2ZzaV9iYW5kW2ldOyBzZmIgPCBUYWJsZXMuc2Nmc2lfYmFuZFtpICsgMV07IHNmYisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGdpLnNjYWxlZmFjW3NmYl0gPSAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbDNfc2lkZS5zY2ZzaVtjaF1baV0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBzMSA9IDA7XG4gICAgICAgIHZhciBjMSA9IDA7XG4gICAgICAgIGZvciAoc2ZiID0gMDsgc2ZiIDwgMTE7IHNmYisrKSB7XG4gICAgICAgICAgICBpZiAoZ2kuc2NhbGVmYWNbc2ZiXSA9PSAtMSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGMxKys7XG4gICAgICAgICAgICBpZiAoczEgPCBnaS5zY2FsZWZhY1tzZmJdKVxuICAgICAgICAgICAgICAgIHMxID0gZ2kuc2NhbGVmYWNbc2ZiXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgczIgPSAwO1xuICAgICAgICB2YXIgYzIgPSAwO1xuICAgICAgICBmb3IgKDsgc2ZiIDwgRW5jb2Rlci5TQlBTWV9sOyBzZmIrKykge1xuICAgICAgICAgICAgaWYgKGdpLnNjYWxlZmFjW3NmYl0gPT0gLTEpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjMisrO1xuICAgICAgICAgICAgaWYgKHMyIDwgZ2kuc2NhbGVmYWNbc2ZiXSlcbiAgICAgICAgICAgICAgICBzMiA9IGdpLnNjYWxlZmFjW3NmYl07XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICAgIGlmIChzMSA8IHNsZW4xX25baV0gJiYgczIgPCBzbGVuMl9uW2ldKSB7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBzbGVuMV90YWJbaV0gKiBjMSArIHNsZW4yX3RhYltpXSAqIGMyO1xuICAgICAgICAgICAgICAgIGlmIChnaS5wYXJ0Ml9sZW5ndGggPiBjKSB7XG4gICAgICAgICAgICAgICAgICAgIGdpLnBhcnQyX2xlbmd0aCA9IGM7XG4gICAgICAgICAgICAgICAgICAgIGdpLnNjYWxlZmFjX2NvbXByZXNzID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBvcHRpbWFsIHdheSB0byBzdG9yZSB0aGUgc2NhbGVmYWN0b3JzLiBPbmx5IGNhbGwgdGhpcyByb3V0aW5lXG4gICAgICogYWZ0ZXIgZmluYWwgc2NhbGVmYWN0b3JzIGhhdmUgYmVlbiBjaG9zZW4gYW5kIHRoZSBjaGFubmVsL2dyYW51bGUgd2lsbFxuICAgICAqIG5vdCBiZSByZS1lbmNvZGVkLlxuICAgICAqL1xuICAgIHRoaXMuYmVzdF9zY2FsZWZhY19zdG9yZSA9IGZ1bmN0aW9uIChnZmMsIGdyLCBjaCwgbDNfc2lkZSkge1xuICAgICAgICAvKiB1c2Ugc2NhbGVmYWNfc2NhbGUgaWYgd2UgY2FuICovXG4gICAgICAgIHZhciBnaSA9IGwzX3NpZGUudHRbZ3JdW2NoXTtcbiAgICAgICAgdmFyIHNmYiwgaSwgaiwgbDtcbiAgICAgICAgdmFyIHJlY2FsYyA9IDA7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogcmVtb3ZlIHNjYWxlZmFjcyBmcm9tIGJhbmRzIHdpdGggaXg9MC4gVGhpcyBpZGVhIGNvbWVzIGZyb20gdGhlIEFBQ1xuICAgICAgICAgKiBJU08gZG9jcy4gYWRkZWQgbXQgMy8wMFxuICAgICAgICAgKi9cbiAgICAgICAgLyogY2hlY2sgaWYgbDNfZW5jPTAgKi9cbiAgICAgICAgaiA9IDA7XG4gICAgICAgIGZvciAoc2ZiID0gMDsgc2ZiIDwgZ2kuc2ZibWF4OyBzZmIrKykge1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gZ2kud2lkdGhbc2ZiXTtcbiAgICAgICAgICAgIGFzc2VydCh3aWR0aCA+PSAwKTtcbiAgICAgICAgICAgIGogKz0gd2lkdGg7XG4gICAgICAgICAgICBmb3IgKGwgPSAtd2lkdGg7IGwgPCAwOyBsKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2kubDNfZW5jW2wgKyBqXSAhPSAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsID09IDApXG4gICAgICAgICAgICAgICAgZ2kuc2NhbGVmYWNbc2ZiXSA9IHJlY2FsYyA9IC0yO1xuICAgICAgICAgICAgLyogYW55dGhpbmcgZ29lcy4gKi9cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBvbmx5IGJlc3Rfc2NhbGVmYWNfc3RvcmUgYW5kIGNhbGNfc2Nmc2kga25vdy0tYW5kIG9ubHkgdGhleVxuICAgICAgICAgICAgICogc2hvdWxkIGtub3ctLWFib3V0IHRoZSBtYWdpYyBudW1iZXIgLTIuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgwID09IGdpLnNjYWxlZmFjX3NjYWxlICYmIDAgPT0gZ2kucHJlZmxhZykge1xuICAgICAgICAgICAgdmFyIHMgPSAwO1xuICAgICAgICAgICAgZm9yIChzZmIgPSAwOyBzZmIgPCBnaS5zZmJtYXg7IHNmYisrKVxuICAgICAgICAgICAgICAgIGlmIChnaS5zY2FsZWZhY1tzZmJdID4gMClcbiAgICAgICAgICAgICAgICAgICAgcyB8PSBnaS5zY2FsZWZhY1tzZmJdO1xuXG4gICAgICAgICAgICBpZiAoMCA9PSAocyAmIDEpICYmIHMgIT0gMCkge1xuICAgICAgICAgICAgICAgIGZvciAoc2ZiID0gMDsgc2ZiIDwgZ2kuc2ZibWF4OyBzZmIrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdpLnNjYWxlZmFjW3NmYl0gPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2kuc2NhbGVmYWNbc2ZiXSA+Pj0gMTtcblxuICAgICAgICAgICAgICAgIGdpLnNjYWxlZmFjX3NjYWxlID0gcmVjYWxjID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgwID09IGdpLnByZWZsYWcgJiYgZ2kuYmxvY2tfdHlwZSAhPSBFbmNvZGVyLlNIT1JUX1RZUEVcbiAgICAgICAgICAgICYmIGdmYy5tb2RlX2dyID09IDIpIHtcbiAgICAgICAgICAgIGZvciAoc2ZiID0gMTE7IHNmYiA8IEVuY29kZXIuU0JQU1lfbDsgc2ZiKyspXG4gICAgICAgICAgICAgICAgaWYgKGdpLnNjYWxlZmFjW3NmYl0gPCBxdXB2dC5wcmV0YWJbc2ZiXVxuICAgICAgICAgICAgICAgICAgICAmJiBnaS5zY2FsZWZhY1tzZmJdICE9IC0yKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChzZmIgPT0gRW5jb2Rlci5TQlBTWV9sKSB7XG4gICAgICAgICAgICAgICAgZm9yIChzZmIgPSAxMTsgc2ZiIDwgRW5jb2Rlci5TQlBTWV9sOyBzZmIrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdpLnNjYWxlZmFjW3NmYl0gPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2kuc2NhbGVmYWNbc2ZiXSAtPSBxdXB2dC5wcmV0YWJbc2ZiXTtcblxuICAgICAgICAgICAgICAgIGdpLnByZWZsYWcgPSByZWNhbGMgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDQ7IGkrKylcbiAgICAgICAgICAgIGwzX3NpZGUuc2Nmc2lbY2hdW2ldID0gMDtcblxuICAgICAgICBpZiAoZ2ZjLm1vZGVfZ3IgPT0gMiAmJiBnciA9PSAxXG4gICAgICAgICAgICAmJiBsM19zaWRlLnR0WzBdW2NoXS5ibG9ja190eXBlICE9IEVuY29kZXIuU0hPUlRfVFlQRVxuICAgICAgICAgICAgJiYgbDNfc2lkZS50dFsxXVtjaF0uYmxvY2tfdHlwZSAhPSBFbmNvZGVyLlNIT1JUX1RZUEUpIHtcbiAgICAgICAgICAgIHNjZnNpX2NhbGMoY2gsIGwzX3NpZGUpO1xuICAgICAgICAgICAgcmVjYWxjID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHNmYiA9IDA7IHNmYiA8IGdpLnNmYm1heDsgc2ZiKyspIHtcbiAgICAgICAgICAgIGlmIChnaS5zY2FsZWZhY1tzZmJdID09IC0yKSB7XG4gICAgICAgICAgICAgICAgZ2kuc2NhbGVmYWNbc2ZiXSA9IDA7XG4gICAgICAgICAgICAgICAgLyogaWYgYW55dGhpbmcgZ29lcywgdGhlbiAwIGlzIGEgZ29vZCBjaG9pY2UgKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVjYWxjICE9IDApIHtcbiAgICAgICAgICAgIGlmIChnZmMubW9kZV9nciA9PSAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsZV9iaXRjb3VudChnaSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NhbGVfYml0Y291bnRfbHNmKGdmYywgZ2kpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWxsX3NjYWxlZmFjdG9yc19ub3RfbmVnYXRpdmUoc2NhbGVmYWMsIG4pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChzY2FsZWZhY1tpXSA8IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG51bWJlciBvZiBiaXRzIHVzZWQgdG8gZW5jb2RlIHNjYWxlZmFjcy5cbiAgICAgKlxuICAgICAqIDE4KnNsZW4xX3RhYltpXSArIDE4KnNsZW4yX3RhYltpXVxuICAgICAqL1xuICAgIHZhciBzY2FsZV9zaG9ydCA9IFswLCAxOCwgMzYsIDU0LCA1NCwgMzYsIDU0LCA3MixcbiAgICAgICAgNTQsIDcyLCA5MCwgNzIsIDkwLCAxMDgsIDEwOCwgMTI2XTtcblxuICAgIC8qKlxuICAgICAqIG51bWJlciBvZiBiaXRzIHVzZWQgdG8gZW5jb2RlIHNjYWxlZmFjcy5cbiAgICAgKlxuICAgICAqIDE3KnNsZW4xX3RhYltpXSArIDE4KnNsZW4yX3RhYltpXVxuICAgICAqL1xuICAgIHZhciBzY2FsZV9taXhlZCA9IFswLCAxOCwgMzYsIDU0LCA1MSwgMzUsIDUzLCA3MSxcbiAgICAgICAgNTIsIDcwLCA4OCwgNjksIDg3LCAxMDUsIDEwNCwgMTIyXTtcblxuICAgIC8qKlxuICAgICAqIG51bWJlciBvZiBiaXRzIHVzZWQgdG8gZW5jb2RlIHNjYWxlZmFjcy5cbiAgICAgKlxuICAgICAqIDExKnNsZW4xX3RhYltpXSArIDEwKnNsZW4yX3RhYltpXVxuICAgICAqL1xuICAgIHZhciBzY2FsZV9sb25nID0gWzAsIDEwLCAyMCwgMzAsIDMzLCAyMSwgMzEsIDQxLCAzMiwgNDIsXG4gICAgICAgIDUyLCA0MywgNTMsIDYzLCA2NCwgNzRdO1xuXG4gICAgLyoqXG4gICAgICogQWxzbyBjYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgYml0cyBuZWNlc3NhcnkgdG8gY29kZSB0aGUgc2NhbGVmYWN0b3JzLlxuICAgICAqL1xuICAgIHRoaXMuc2NhbGVfYml0Y291bnQgPSBmdW5jdGlvbiAoY29kX2luZm8pIHtcbiAgICAgICAgdmFyIGssIHNmYiwgbWF4X3NsZW4xID0gMCwgbWF4X3NsZW4yID0gMDtcblxuICAgICAgICAvKiBtYXhpbXVtIHZhbHVlcyAqL1xuICAgICAgICB2YXIgdGFiO1xuICAgICAgICB2YXIgc2NhbGVmYWMgPSBjb2RfaW5mby5zY2FsZWZhYztcblxuICAgICAgICBhc3NlcnQoYWxsX3NjYWxlZmFjdG9yc19ub3RfbmVnYXRpdmUoc2NhbGVmYWMsIGNvZF9pbmZvLnNmYm1heCkpO1xuXG4gICAgICAgIGlmIChjb2RfaW5mby5ibG9ja190eXBlID09IEVuY29kZXIuU0hPUlRfVFlQRSkge1xuICAgICAgICAgICAgdGFiID0gc2NhbGVfc2hvcnQ7XG4gICAgICAgICAgICBpZiAoY29kX2luZm8ubWl4ZWRfYmxvY2tfZmxhZyAhPSAwKVxuICAgICAgICAgICAgICAgIHRhYiA9IHNjYWxlX21peGVkO1xuICAgICAgICB9IGVsc2UgeyAvKiBibG9ja190eXBlID09IDEsMixvciAzICovXG4gICAgICAgICAgICB0YWIgPSBzY2FsZV9sb25nO1xuICAgICAgICAgICAgaWYgKDAgPT0gY29kX2luZm8ucHJlZmxhZykge1xuICAgICAgICAgICAgICAgIGZvciAoc2ZiID0gMTE7IHNmYiA8IEVuY29kZXIuU0JQU1lfbDsgc2ZiKyspXG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2FsZWZhY1tzZmJdIDwgcXVwdnQucHJldGFiW3NmYl0pXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGlmIChzZmIgPT0gRW5jb2Rlci5TQlBTWV9sKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZF9pbmZvLnByZWZsYWcgPSAxO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHNmYiA9IDExOyBzZmIgPCBFbmNvZGVyLlNCUFNZX2w7IHNmYisrKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVmYWNbc2ZiXSAtPSBxdXB2dC5wcmV0YWJbc2ZiXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHNmYiA9IDA7IHNmYiA8IGNvZF9pbmZvLnNmYmRpdmlkZTsgc2ZiKyspXG4gICAgICAgICAgICBpZiAobWF4X3NsZW4xIDwgc2NhbGVmYWNbc2ZiXSlcbiAgICAgICAgICAgICAgICBtYXhfc2xlbjEgPSBzY2FsZWZhY1tzZmJdO1xuXG4gICAgICAgIGZvciAoOyBzZmIgPCBjb2RfaW5mby5zZmJtYXg7IHNmYisrKVxuICAgICAgICAgICAgaWYgKG1heF9zbGVuMiA8IHNjYWxlZmFjW3NmYl0pXG4gICAgICAgICAgICAgICAgbWF4X3NsZW4yID0gc2NhbGVmYWNbc2ZiXTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBmcm9tIFRha2VoaXJvIFRPTUlOQUdBIDx0b21pbmFnYUBpc290ZXJuZXQub3JnPiAxMC85OSBsb29wIG92ZXIgKmFsbCpcbiAgICAgICAgICogcG9zaWJsZSB2YWx1ZXMgb2Ygc2NhbGVmYWNfY29tcHJlc3MgdG8gZmluZCB0aGUgb25lIHdoaWNoIHVzZXMgdGhlXG4gICAgICAgICAqIHNtYWxsZXN0IG51bWJlciBvZiBiaXRzLiBJU08gd291bGQgc3RvcCBhdCBmaXJzdCB2YWxpZCBpbmRleFxuICAgICAgICAgKi9cbiAgICAgICAgY29kX2luZm8ucGFydDJfbGVuZ3RoID0gUXVhbnRpemVQVlQuTEFSR0VfQklUUztcbiAgICAgICAgZm9yIChrID0gMDsgayA8IDE2OyBrKyspIHtcbiAgICAgICAgICAgIGlmIChtYXhfc2xlbjEgPCBzbGVuMV9uW2tdICYmIG1heF9zbGVuMiA8IHNsZW4yX25ba11cbiAgICAgICAgICAgICAgICAmJiBjb2RfaW5mby5wYXJ0Ml9sZW5ndGggPiB0YWJba10pIHtcbiAgICAgICAgICAgICAgICBjb2RfaW5mby5wYXJ0Ml9sZW5ndGggPSB0YWJba107XG4gICAgICAgICAgICAgICAgY29kX2luZm8uc2NhbGVmYWNfY29tcHJlc3MgPSBrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RfaW5mby5wYXJ0Ml9sZW5ndGggPT0gUXVhbnRpemVQVlQuTEFSR0VfQklUUztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0YWJsZSBvZiBsYXJnZXN0IHNjYWxlZmFjdG9yIHZhbHVlcyBmb3IgTVBFRzJcbiAgICAgKi9cbiAgICB2YXIgbWF4X3JhbmdlX3NmYWNfdGFiID0gW1sxNSwgMTUsIDcsIDddLFxuICAgICAgICBbMTUsIDE1LCA3LCAwXSwgWzcsIDMsIDAsIDBdLCBbMTUsIDMxLCAzMSwgMF0sXG4gICAgICAgIFs3LCA3LCA3LCAwXSwgWzMsIDMsIDAsIDBdXTtcblxuICAgIC8qKlxuICAgICAqIEFsc28gY291bnRzIHRoZSBudW1iZXIgb2YgYml0cyB0byBlbmNvZGUgdGhlIHNjYWxlZmFjcyBidXQgZm9yIE1QRUcgMlxuICAgICAqIExvd2VyIHNhbXBsaW5nIGZyZXF1ZW5jaWVzICgyNCwgMjIuMDUgYW5kIDE2IGtIei4pXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHJldmVyc2UtZW5naW5lZXJlZCBmcm9tIHNlY3Rpb24gMi40LjMuMiBvZiB0aGUgTVBFRzIgSVMsXG4gICAgICogXCJBdWRpbyBEZWNvZGluZyBMYXllciBJSUlcIlxuICAgICAqL1xuICAgIHRoaXMuc2NhbGVfYml0Y291bnRfbHNmID0gZnVuY3Rpb24gKGdmYywgY29kX2luZm8pIHtcbiAgICAgICAgdmFyIHRhYmxlX251bWJlciwgcm93X2luX3RhYmxlLCBwYXJ0aXRpb24sIG5yX3NmYiwgd2luZG93O1xuICAgICAgICB2YXIgb3ZlcjtcbiAgICAgICAgdmFyIGksIHNmYjtcbiAgICAgICAgdmFyIG1heF9zZmFjID0gbmV3X2ludCg0KTtcbi8vdmFyIHBhcnRpdGlvbl90YWJsZTtcbiAgICAgICAgdmFyIHNjYWxlZmFjID0gY29kX2luZm8uc2NhbGVmYWM7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogU2V0IHBhcnRpdGlvbiB0YWJsZS4gTm90ZSB0aGF0IHNob3VsZCB0cnkgdG8gdXNlIHRhYmxlIG9uZSwgYnV0IGRvXG4gICAgICAgICAqIG5vdCB5ZXQuLi5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChjb2RfaW5mby5wcmVmbGFnICE9IDApXG4gICAgICAgICAgICB0YWJsZV9udW1iZXIgPSAyO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0YWJsZV9udW1iZXIgPSAwO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA0OyBpKyspXG4gICAgICAgICAgICBtYXhfc2ZhY1tpXSA9IDA7XG5cbiAgICAgICAgaWYgKGNvZF9pbmZvLmJsb2NrX3R5cGUgPT0gRW5jb2Rlci5TSE9SVF9UWVBFKSB7XG4gICAgICAgICAgICByb3dfaW5fdGFibGUgPSAxO1xuICAgICAgICAgICAgdmFyIHBhcnRpdGlvbl90YWJsZSA9IHF1cHZ0Lm5yX29mX3NmYl9ibG9ja1t0YWJsZV9udW1iZXJdW3Jvd19pbl90YWJsZV07XG4gICAgICAgICAgICBmb3IgKHNmYiA9IDAsIHBhcnRpdGlvbiA9IDA7IHBhcnRpdGlvbiA8IDQ7IHBhcnRpdGlvbisrKSB7XG4gICAgICAgICAgICAgICAgbnJfc2ZiID0gcGFydGl0aW9uX3RhYmxlW3BhcnRpdGlvbl0gLyAzO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBucl9zZmI7IGkrKywgc2ZiKyspXG4gICAgICAgICAgICAgICAgICAgIGZvciAod2luZG93ID0gMDsgd2luZG93IDwgMzsgd2luZG93KyspXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NhbGVmYWNbc2ZiICogMyArIHdpbmRvd10gPiBtYXhfc2ZhY1twYXJ0aXRpb25dKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heF9zZmFjW3BhcnRpdGlvbl0gPSBzY2FsZWZhY1tzZmIgKiAzICsgd2luZG93XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJvd19pbl90YWJsZSA9IDA7XG4gICAgICAgICAgICB2YXIgcGFydGl0aW9uX3RhYmxlID0gcXVwdnQubnJfb2Zfc2ZiX2Jsb2NrW3RhYmxlX251bWJlcl1bcm93X2luX3RhYmxlXTtcbiAgICAgICAgICAgIGZvciAoc2ZiID0gMCwgcGFydGl0aW9uID0gMDsgcGFydGl0aW9uIDwgNDsgcGFydGl0aW9uKyspIHtcbiAgICAgICAgICAgICAgICBucl9zZmIgPSBwYXJ0aXRpb25fdGFibGVbcGFydGl0aW9uXTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnJfc2ZiOyBpKyssIHNmYisrKVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2NhbGVmYWNbc2ZiXSA+IG1heF9zZmFjW3BhcnRpdGlvbl0pXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhfc2ZhY1twYXJ0aXRpb25dID0gc2NhbGVmYWNbc2ZiXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAob3ZlciA9IGZhbHNlLCBwYXJ0aXRpb24gPSAwOyBwYXJ0aXRpb24gPCA0OyBwYXJ0aXRpb24rKykge1xuICAgICAgICAgICAgaWYgKG1heF9zZmFjW3BhcnRpdGlvbl0gPiBtYXhfcmFuZ2Vfc2ZhY190YWJbdGFibGVfbnVtYmVyXVtwYXJ0aXRpb25dKVxuICAgICAgICAgICAgICAgIG92ZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3Zlcikge1xuICAgICAgICAgICAgdmFyIHNsZW4xLCBzbGVuMiwgc2xlbjMsIHNsZW40O1xuXG4gICAgICAgICAgICBjb2RfaW5mby5zZmJfcGFydGl0aW9uX3RhYmxlID0gcXVwdnQubnJfb2Zfc2ZiX2Jsb2NrW3RhYmxlX251bWJlcl1bcm93X2luX3RhYmxlXTtcbiAgICAgICAgICAgIGZvciAocGFydGl0aW9uID0gMDsgcGFydGl0aW9uIDwgNDsgcGFydGl0aW9uKyspXG4gICAgICAgICAgICAgICAgY29kX2luZm8uc2xlbltwYXJ0aXRpb25dID0gbG9nMnRhYlttYXhfc2ZhY1twYXJ0aXRpb25dXTtcblxuICAgICAgICAgICAgLyogc2V0IHNjYWxlZmFjX2NvbXByZXNzICovXG4gICAgICAgICAgICBzbGVuMSA9IGNvZF9pbmZvLnNsZW5bMF07XG4gICAgICAgICAgICBzbGVuMiA9IGNvZF9pbmZvLnNsZW5bMV07XG4gICAgICAgICAgICBzbGVuMyA9IGNvZF9pbmZvLnNsZW5bMl07XG4gICAgICAgICAgICBzbGVuNCA9IGNvZF9pbmZvLnNsZW5bM107XG5cbiAgICAgICAgICAgIHN3aXRjaCAodGFibGVfbnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBjb2RfaW5mby5zY2FsZWZhY19jb21wcmVzcyA9ICgoKHNsZW4xICogNSkgKyBzbGVuMikgPDwgNClcbiAgICAgICAgICAgICAgICAgICAgICAgICsgKHNsZW4zIDw8IDIpICsgc2xlbjQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBjb2RfaW5mby5zY2FsZWZhY19jb21wcmVzcyA9IDQwMCArICgoKHNsZW4xICogNSkgKyBzbGVuMikgPDwgMilcbiAgICAgICAgICAgICAgICAgICAgICAgICsgc2xlbjM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBjb2RfaW5mby5zY2FsZWZhY19jb21wcmVzcyA9IDUwMCArIChzbGVuMSAqIDMpICsgc2xlbjI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgU3lzdGVtLmVyci5wcmludGYoXCJpbnRlbnNpdHkgc3RlcmVvIG5vdCBpbXBsZW1lbnRlZCB5ZXRcXG5cIik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghb3Zlcikge1xuICAgICAgICAgICAgYXNzZXJ0KGNvZF9pbmZvLnNmYl9wYXJ0aXRpb25fdGFibGUgIT0gbnVsbCk7XG4gICAgICAgICAgICBjb2RfaW5mby5wYXJ0Ml9sZW5ndGggPSAwO1xuICAgICAgICAgICAgZm9yIChwYXJ0aXRpb24gPSAwOyBwYXJ0aXRpb24gPCA0OyBwYXJ0aXRpb24rKylcbiAgICAgICAgICAgICAgICBjb2RfaW5mby5wYXJ0Ml9sZW5ndGggKz0gY29kX2luZm8uc2xlbltwYXJ0aXRpb25dXG4gICAgICAgICAgICAgICAgICAgICogY29kX2luZm8uc2ZiX3BhcnRpdGlvbl90YWJsZVtwYXJ0aXRpb25dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdmVyO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogU2luY2Ugbm8gYmFuZHMgaGF2ZSBiZWVuIG92ZXItYW1wbGlmaWVkLCB3ZSBjYW4gc2V0IHNjYWxlZmFjX2NvbXByZXNzIGFuZFxuICAgICAqIHNsZW5bXSBmb3IgdGhlIGZvcm1hdHRlclxuICAgICAqL1xuICAgIHZhciBsb2cydGFiID0gWzAsIDEsIDIsIDIsIDMsIDMsIDMsIDMsIDQsIDQsIDQsIDQsXG4gICAgICAgIDQsIDQsIDQsIDRdO1xuXG4gICAgdGhpcy5odWZmbWFuX2luaXQgPSBmdW5jdGlvbiAoZ2ZjKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAyOyBpIDw9IDU3NjsgaSArPSAyKSB7XG4gICAgICAgICAgICB2YXIgc2NmYl9hbnogPSAwLCBidl9pbmRleDtcbiAgICAgICAgICAgIHdoaWxlIChnZmMuc2NhbGVmYWNfYmFuZC5sWysrc2NmYl9hbnpdIDwgaSlcbiAgICAgICAgICAgICAgICA7XG5cbiAgICAgICAgICAgIGJ2X2luZGV4ID0gc3ViZHZfdGFibGVbc2NmYl9hbnpdWzBdOyAvLyAucmVnaW9uMF9jb3VudFxuICAgICAgICAgICAgd2hpbGUgKGdmYy5zY2FsZWZhY19iYW5kLmxbYnZfaW5kZXggKyAxXSA+IGkpXG4gICAgICAgICAgICAgICAgYnZfaW5kZXgtLTtcblxuICAgICAgICAgICAgaWYgKGJ2X2luZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogdGhpcyBpcyBhbiBpbmRpY2F0aW9uIHRoYXQgZXZlcnl0aGluZyBpcyBnb2luZyB0byBiZSBlbmNvZGVkXG4gICAgICAgICAgICAgICAgICogYXMgcmVnaW9uMDogYmlndmFsdWVzIDwgcmVnaW9uMCA8IHJlZ2lvbjEgc28gbGV0cyBzZXRcbiAgICAgICAgICAgICAgICAgKiByZWdpb24wLCByZWdpb24xIHRvIHNvbWUgdmFsdWUgbGFyZ2VyIHRoYW4gYmlndmFsdWVzXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgYnZfaW5kZXggPSBzdWJkdl90YWJsZVtzY2ZiX2Fuel1bMF07IC8vIC5yZWdpb24wX2NvdW50XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdmYy5idl9zY2ZbaSAtIDJdID0gYnZfaW5kZXg7XG5cbiAgICAgICAgICAgIGJ2X2luZGV4ID0gc3ViZHZfdGFibGVbc2NmYl9hbnpdWzFdOyAvLyAucmVnaW9uMV9jb3VudFxuICAgICAgICAgICAgd2hpbGUgKGdmYy5zY2FsZWZhY19iYW5kLmxbYnZfaW5kZXggKyBnZmMuYnZfc2NmW2kgLSAyXSArIDJdID4gaSlcbiAgICAgICAgICAgICAgICBidl9pbmRleC0tO1xuXG4gICAgICAgICAgICBpZiAoYnZfaW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgYnZfaW5kZXggPSBzdWJkdl90YWJsZVtzY2ZiX2Fuel1bMV07IC8vIC5yZWdpb24xX2NvdW50XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdmYy5idl9zY2ZbaSAtIDFdID0gYnZfaW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVGFrZWhpcm87XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lamejs/src/js/Takehiro.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lamejs/src/js/VBRQuantize.js":
/*!***************************************************!*\
  !*** ./node_modules/lamejs/src/js/VBRQuantize.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function VBRQuantize() {\n    var qupvt;\n    var tak;\n\n    this.setModules = function (_qupvt, _tk) {\n        qupvt = _qupvt;\n        tak = _tk;\n    }\n    //TODO\n\n}\n\nmodule.exports = VBRQuantize;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL1ZCUlF1YW50aXplLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL1ZCUlF1YW50aXplLmpzPzI3MTYiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gVkJSUXVhbnRpemUoKSB7XG4gICAgdmFyIHF1cHZ0O1xuICAgIHZhciB0YWs7XG5cbiAgICB0aGlzLnNldE1vZHVsZXMgPSBmdW5jdGlvbiAoX3F1cHZ0LCBfdGspIHtcbiAgICAgICAgcXVwdnQgPSBfcXVwdnQ7XG4gICAgICAgIHRhayA9IF90aztcbiAgICB9XG4gICAgLy9UT0RPXG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBWQlJRdWFudGl6ZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lamejs/src/js/VBRQuantize.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lamejs/src/js/VBRSeekInfo.js":
/*!***************************************************!*\
  !*** ./node_modules/lamejs/src/js/VBRSeekInfo.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("//package mp3;\n\nfunction VBRSeekInfo() {\n    /**\n     * What we have seen so far.\n     */\n    this.sum = 0;\n    /**\n     * How many frames we have seen in this chunk.\n     */\n    this.seen = 0;\n    /**\n     * How many frames we want to collect into one chunk.\n     */\n    this.want = 0;\n    /**\n     * Actual position in our bag.\n     */\n    this.pos = 0;\n    /**\n     * Size of our bag.\n     */\n    this.size = 0;\n    /**\n     * Pointer to our bag.\n     */\n    this.bag = null;\n    this.nVbrNumFrames = 0;\n    this.nBytesWritten = 0;\n    /* VBR tag data */\n    this.TotalFrameSize = 0;\n}\n\nmodule.exports = VBRSeekInfo;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL1ZCUlNlZWtJbmZvLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbGFtZWpzL3NyYy9qcy9WQlJTZWVrSW5mby5qcz8xMTdlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vcGFja2FnZSBtcDM7XG5cbmZ1bmN0aW9uIFZCUlNlZWtJbmZvKCkge1xuICAgIC8qKlxuICAgICAqIFdoYXQgd2UgaGF2ZSBzZWVuIHNvIGZhci5cbiAgICAgKi9cbiAgICB0aGlzLnN1bSA9IDA7XG4gICAgLyoqXG4gICAgICogSG93IG1hbnkgZnJhbWVzIHdlIGhhdmUgc2VlbiBpbiB0aGlzIGNodW5rLlxuICAgICAqL1xuICAgIHRoaXMuc2VlbiA9IDA7XG4gICAgLyoqXG4gICAgICogSG93IG1hbnkgZnJhbWVzIHdlIHdhbnQgdG8gY29sbGVjdCBpbnRvIG9uZSBjaHVuay5cbiAgICAgKi9cbiAgICB0aGlzLndhbnQgPSAwO1xuICAgIC8qKlxuICAgICAqIEFjdHVhbCBwb3NpdGlvbiBpbiBvdXIgYmFnLlxuICAgICAqL1xuICAgIHRoaXMucG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBTaXplIG9mIG91ciBiYWcuXG4gICAgICovXG4gICAgdGhpcy5zaXplID0gMDtcbiAgICAvKipcbiAgICAgKiBQb2ludGVyIHRvIG91ciBiYWcuXG4gICAgICovXG4gICAgdGhpcy5iYWcgPSBudWxsO1xuICAgIHRoaXMublZick51bUZyYW1lcyA9IDA7XG4gICAgdGhpcy5uQnl0ZXNXcml0dGVuID0gMDtcbiAgICAvKiBWQlIgdGFnIGRhdGEgKi9cbiAgICB0aGlzLlRvdGFsRnJhbWVTaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBWQlJTZWVrSW5mbztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lamejs/src/js/VBRSeekInfo.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lamejs/src/js/VBRTag.js":
/*!**********************************************!*\
  !*** ./node_modules/lamejs/src/js/VBRTag.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var common = __webpack_require__(/*! ./common.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/common.js\");\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\n/**\n * A Vbr header may be present in the ancillary data field of the first frame of\n * an mp3 bitstream<BR>\n * The Vbr header (optionally) contains\n * <UL>\n * <LI>frames total number of audio frames in the bitstream\n * <LI>bytes total number of bytes in the bitstream\n * <LI>toc table of contents\n * </UL>\n *\n * toc (table of contents) gives seek points for random access.<BR>\n * The ith entry determines the seek point for i-percent duration.<BR>\n * seek point in bytes = (toc[i]/256.0) * total_bitstream_bytes<BR>\n * e.g. half duration seek point = (toc[50]/256.0) * total_bitstream_bytes\n */\nVBRTag.NUMTOCENTRIES = 100;\nVBRTag.MAXFRAMESIZE = 2880;\n\nfunction VBRTag() {\n\n    var lame;\n    var bs;\n    var v;\n\n    this.setModules = function (_lame, _bs, _v) {\n        lame = _lame;\n        bs = _bs;\n        v = _v;\n    };\n\n    var FRAMES_FLAG = 0x0001;\n    var BYTES_FLAG = 0x0002;\n    var TOC_FLAG = 0x0004;\n    var VBR_SCALE_FLAG = 0x0008;\n\n    var NUMTOCENTRIES = VBRTag.NUMTOCENTRIES;\n\n    /**\n     * (0xB40) the max freeformat 640 32kHz framesize.\n     */\n    var MAXFRAMESIZE = VBRTag.MAXFRAMESIZE;\n\n    /**\n     * <PRE>\n     *    4 bytes for Header Tag\n     *    4 bytes for Header Flags\n     *  100 bytes for entry (toc)\n     *    4 bytes for frame size\n     *    4 bytes for stream size\n     *    4 bytes for VBR scale. a VBR quality indicator: 0=best 100=worst\n     *   20 bytes for LAME tag.  for example, \"LAME3.12 (beta 6)\"\n     * ___________\n     *  140 bytes\n     * </PRE>\n     */\n    var VBRHEADERSIZE = (NUMTOCENTRIES + 4 + 4 + 4 + 4 + 4);\n\n    var LAMEHEADERSIZE = (VBRHEADERSIZE + 9 + 1 + 1 + 8\n    + 1 + 1 + 3 + 1 + 1 + 2 + 4 + 2 + 2);\n\n    /**\n     * The size of the Xing header MPEG-1, bit rate in kbps.\n     */\n    var XING_BITRATE1 = 128;\n    /**\n     * The size of the Xing header MPEG-2, bit rate in kbps.\n     */\n    var XING_BITRATE2 = 64;\n    /**\n     * The size of the Xing header MPEG-2.5, bit rate in kbps.\n     */\n    var XING_BITRATE25 = 32;\n\n    /**\n     * ISO-8859-1 charset for byte to string operations.\n     */\n    var ISO_8859_1 = null; //Charset.forName(\"ISO-8859-1\");\n\n    /**\n     * VBR header magic string.\n     */\n    var VBRTag0 = \"Xing\";\n    /**\n     * VBR header magic string (VBR == VBRMode.vbr_off).\n     */\n    var VBRTag1 = \"Info\";\n\n    /**\n     * Lookup table for fast CRC-16 computation. Uses the polynomial\n     * x^16+x^15+x^2+1\n     */\n    var crc16Lookup = [0x0000, 0xC0C1, 0xC181, 0x0140,\n        0xC301, 0x03C0, 0x0280, 0xC241, 0xC601, 0x06C0, 0x0780, 0xC741,\n        0x0500, 0xC5C1, 0xC481, 0x0440, 0xCC01, 0x0CC0, 0x0D80, 0xCD41,\n        0x0F00, 0xCFC1, 0xCE81, 0x0E40, 0x0A00, 0xCAC1, 0xCB81, 0x0B40,\n        0xC901, 0x09C0, 0x0880, 0xC841, 0xD801, 0x18C0, 0x1980, 0xD941,\n        0x1B00, 0xDBC1, 0xDA81, 0x1A40, 0x1E00, 0xDEC1, 0xDF81, 0x1F40,\n        0xDD01, 0x1DC0, 0x1C80, 0xDC41, 0x1400, 0xD4C1, 0xD581, 0x1540,\n        0xD701, 0x17C0, 0x1680, 0xD641, 0xD201, 0x12C0, 0x1380, 0xD341,\n        0x1100, 0xD1C1, 0xD081, 0x1040, 0xF001, 0x30C0, 0x3180, 0xF141,\n        0x3300, 0xF3C1, 0xF281, 0x3240, 0x3600, 0xF6C1, 0xF781, 0x3740,\n        0xF501, 0x35C0, 0x3480, 0xF441, 0x3C00, 0xFCC1, 0xFD81, 0x3D40,\n        0xFF01, 0x3FC0, 0x3E80, 0xFE41, 0xFA01, 0x3AC0, 0x3B80, 0xFB41,\n        0x3900, 0xF9C1, 0xF881, 0x3840, 0x2800, 0xE8C1, 0xE981, 0x2940,\n        0xEB01, 0x2BC0, 0x2A80, 0xEA41, 0xEE01, 0x2EC0, 0x2F80, 0xEF41,\n        0x2D00, 0xEDC1, 0xEC81, 0x2C40, 0xE401, 0x24C0, 0x2580, 0xE541,\n        0x2700, 0xE7C1, 0xE681, 0x2640, 0x2200, 0xE2C1, 0xE381, 0x2340,\n        0xE101, 0x21C0, 0x2080, 0xE041, 0xA001, 0x60C0, 0x6180, 0xA141,\n        0x6300, 0xA3C1, 0xA281, 0x6240, 0x6600, 0xA6C1, 0xA781, 0x6740,\n        0xA501, 0x65C0, 0x6480, 0xA441, 0x6C00, 0xACC1, 0xAD81, 0x6D40,\n        0xAF01, 0x6FC0, 0x6E80, 0xAE41, 0xAA01, 0x6AC0, 0x6B80, 0xAB41,\n        0x6900, 0xA9C1, 0xA881, 0x6840, 0x7800, 0xB8C1, 0xB981, 0x7940,\n        0xBB01, 0x7BC0, 0x7A80, 0xBA41, 0xBE01, 0x7EC0, 0x7F80, 0xBF41,\n        0x7D00, 0xBDC1, 0xBC81, 0x7C40, 0xB401, 0x74C0, 0x7580, 0xB541,\n        0x7700, 0xB7C1, 0xB681, 0x7640, 0x7200, 0xB2C1, 0xB381, 0x7340,\n        0xB101, 0x71C0, 0x7080, 0xB041, 0x5000, 0x90C1, 0x9181, 0x5140,\n        0x9301, 0x53C0, 0x5280, 0x9241, 0x9601, 0x56C0, 0x5780, 0x9741,\n        0x5500, 0x95C1, 0x9481, 0x5440, 0x9C01, 0x5CC0, 0x5D80, 0x9D41,\n        0x5F00, 0x9FC1, 0x9E81, 0x5E40, 0x5A00, 0x9AC1, 0x9B81, 0x5B40,\n        0x9901, 0x59C0, 0x5880, 0x9841, 0x8801, 0x48C0, 0x4980, 0x8941,\n        0x4B00, 0x8BC1, 0x8A81, 0x4A40, 0x4E00, 0x8EC1, 0x8F81, 0x4F40,\n        0x8D01, 0x4DC0, 0x4C80, 0x8C41, 0x4400, 0x84C1, 0x8581, 0x4540,\n        0x8701, 0x47C0, 0x4680, 0x8641, 0x8201, 0x42C0, 0x4380, 0x8341,\n        0x4100, 0x81C1, 0x8081, 0x4040];\n\n    /***********************************************************************\n     * Robert Hegemann 2001-01-17\n     ***********************************************************************/\n\n    function addVbr(v, bitrate) {\n        v.nVbrNumFrames++;\n        v.sum += bitrate;\n        v.seen++;\n\n        if (v.seen < v.want) {\n            return;\n        }\n\n        if (v.pos < v.size) {\n            v.bag[v.pos] = v.sum;\n            v.pos++;\n            v.seen = 0;\n        }\n        if (v.pos == v.size) {\n            for (var i = 1; i < v.size; i += 2) {\n                v.bag[i / 2] = v.bag[i];\n            }\n            v.want *= 2;\n            v.pos /= 2;\n        }\n    }\n\n    function xingSeekTable(v, t) {\n        if (v.pos <= 0)\n            return;\n\n        for (var i = 1; i < NUMTOCENTRIES; ++i) {\n            var j = i / NUMTOCENTRIES, act, sum;\n            var indx = 0 | (Math.floor(j * v.pos));\n            if (indx > v.pos - 1)\n                indx = v.pos - 1;\n            act = v.bag[indx];\n            sum = v.sum;\n            var seek_point = 0 | (256. * act / sum);\n            if (seek_point > 255)\n                seek_point = 255;\n            t[i] = 0xff & seek_point;\n        }\n    }\n\n    /**\n     * Add VBR entry, used to fill the VBR TOC entries.\n     *\n     * @param gfp\n     *            global flags\n     */\n    this.addVbrFrame = function (gfp) {\n        var gfc = gfp.internal_flags;\n        var kbps = Tables.bitrate_table[gfp.version][gfc.bitrate_index];\n        assert(gfc.VBR_seek_table.bag != null);\n        addVbr(gfc.VBR_seek_table, kbps);\n    }\n\n    /**\n     * Read big endian integer (4-bytes) from header.\n     *\n     * @param buf\n     *            header containing the integer\n     * @param bufPos\n     *            offset into the header\n     * @return extracted integer\n     */\n    function extractInteger(buf, bufPos) {\n        var x = buf[bufPos + 0] & 0xff;\n        x <<= 8;\n        x |= buf[bufPos + 1] & 0xff;\n        x <<= 8;\n        x |= buf[bufPos + 2] & 0xff;\n        x <<= 8;\n        x |= buf[bufPos + 3] & 0xff;\n        return x;\n    }\n\n    /**\n     * Write big endian integer (4-bytes) in the header.\n     *\n     * @param buf\n     *            header to write the integer into\n     * @param bufPos\n     *            offset into the header\n     * @param value\n     *            integer value to write\n     */\n    function createInteger(buf, bufPos, value) {\n        buf[bufPos + 0] = 0xff & ((value >> 24) & 0xff);\n        buf[bufPos + 1] = 0xff & ((value >> 16) & 0xff);\n        buf[bufPos + 2] = 0xff & ((value >> 8) & 0xff);\n        buf[bufPos + 3] = 0xff & (value & 0xff);\n    }\n\n    /**\n     * Write big endian short (2-bytes) in the header.\n     *\n     * @param buf\n     *            header to write the integer into\n     * @param bufPos\n     *            offset into the header\n     * @param value\n     *            integer value to write\n     */\n    function createShort(buf, bufPos, value) {\n        buf[bufPos + 0] = 0xff & ((value >> 8) & 0xff);\n        buf[bufPos + 1] = 0xff & (value & 0xff);\n    }\n\n    /**\n     * Check for magic strings (Xing/Info).\n     *\n     * @param buf\n     *            header to check\n     * @param bufPos\n     *            header offset to check\n     * @return magic string found\n     */\n    function isVbrTag(buf, bufPos) {\n        return new String(buf, bufPos, VBRTag0.length(), ISO_8859_1)\n                .equals(VBRTag0)\n            || new String(buf, bufPos, VBRTag1.length(), ISO_8859_1)\n                .equals(VBRTag1);\n    }\n\n    function shiftInBitsValue(x, n, v) {\n        return 0xff & ((x << n) | (v & ~(-1 << n)));\n    }\n\n    /**\n     * Construct the MP3 header using the settings of the global flags.\n     *\n     * <img src=\"1000px-Mp3filestructure.svg.png\">\n     *\n     * @param gfp\n     *            global flags\n     * @param buffer\n     *            header\n     */\n    function setLameTagFrameHeader(gfp, buffer) {\n        var gfc = gfp.internal_flags;\n\n        // MP3 Sync Word\n        buffer[0] = shiftInBitsValue(buffer[0], 8, 0xff);\n\n        buffer[1] = shiftInBitsValue(buffer[1], 3, 7);\n        buffer[1] = shiftInBitsValue(buffer[1], 1,\n            (gfp.out_samplerate < 16000) ? 0 : 1);\n        // Version\n        buffer[1] = shiftInBitsValue(buffer[1], 1, gfp.version);\n        // 01 == Layer 3\n        buffer[1] = shiftInBitsValue(buffer[1], 2, 4 - 3);\n        // Error protection\n        buffer[1] = shiftInBitsValue(buffer[1], 1, (!gfp.error_protection) ? 1\n            : 0);\n\n        // Bit rate\n        buffer[2] = shiftInBitsValue(buffer[2], 4, gfc.bitrate_index);\n        // Frequency\n        buffer[2] = shiftInBitsValue(buffer[2], 2, gfc.samplerate_index);\n        // Pad. Bit\n        buffer[2] = shiftInBitsValue(buffer[2], 1, 0);\n        // Priv. Bit\n        buffer[2] = shiftInBitsValue(buffer[2], 1, gfp.extension);\n\n        // Mode\n        buffer[3] = shiftInBitsValue(buffer[3], 2, gfp.mode.ordinal());\n        // Mode extension (Used with Joint Stereo)\n        buffer[3] = shiftInBitsValue(buffer[3], 2, gfc.mode_ext);\n        // Copy\n        buffer[3] = shiftInBitsValue(buffer[3], 1, gfp.copyright);\n        // Original\n        buffer[3] = shiftInBitsValue(buffer[3], 1, gfp.original);\n        // Emphasis\n        buffer[3] = shiftInBitsValue(buffer[3], 2, gfp.emphasis);\n\n        /* the default VBR header. 48 kbps layer III, no padding, no crc */\n        /* but sampling freq, mode and copyright/copy protection taken */\n        /* from first valid frame */\n        buffer[0] = 0xff;\n        var abyte = 0xff & (buffer[1] & 0xf1);\n        var bitrate;\n        if (1 == gfp.version) {\n            bitrate = XING_BITRATE1;\n        } else {\n            if (gfp.out_samplerate < 16000)\n                bitrate = XING_BITRATE25;\n            else\n                bitrate = XING_BITRATE2;\n        }\n\n        if (gfp.VBR == VbrMode.vbr_off)\n            bitrate = gfp.brate;\n\n        var bbyte;\n        if (gfp.free_format)\n            bbyte = 0x00;\n        else\n            bbyte = 0xff & (16 * lame.BitrateIndex(bitrate, gfp.version,\n                    gfp.out_samplerate));\n\n        /*\n         * Use as much of the info from the real frames in the Xing header:\n         * samplerate, channels, crc, etc...\n         */\n        if (gfp.version == 1) {\n            /* MPEG1 */\n            buffer[1] = 0xff & (abyte | 0x0a);\n            /* was 0x0b; */\n            abyte = 0xff & (buffer[2] & 0x0d);\n            /* AF keep also private bit */\n            buffer[2] = 0xff & (bbyte | abyte);\n            /* 64kbs MPEG1 frame */\n        } else {\n            /* MPEG2 */\n            buffer[1] = 0xff & (abyte | 0x02);\n            /* was 0x03; */\n            abyte = 0xff & (buffer[2] & 0x0d);\n            /* AF keep also private bit */\n            buffer[2] = 0xff & (bbyte | abyte);\n            /* 64kbs MPEG2 frame */\n        }\n    }\n\n    /**\n     * Get VBR tag information\n     *\n     * @param buf\n     *            header to analyze\n     * @param bufPos\n     *            offset into the header\n     * @return VBR tag data\n     */\n    this.getVbrTag = function (buf) {\n        var pTagData = new VBRTagData();\n        var bufPos = 0;\n\n        /* get Vbr header data */\n        pTagData.flags = 0;\n\n        /* get selected MPEG header data */\n        var hId = (buf[bufPos + 1] >> 3) & 1;\n        var hSrIndex = (buf[bufPos + 2] >> 2) & 3;\n        var hMode = (buf[bufPos + 3] >> 6) & 3;\n        var hBitrate = ((buf[bufPos + 2] >> 4) & 0xf);\n        hBitrate = Tables.bitrate_table[hId][hBitrate];\n\n        /* check for FFE syncword */\n        if ((buf[bufPos + 1] >> 4) == 0xE)\n            pTagData.samprate = Tables.samplerate_table[2][hSrIndex];\n        else\n            pTagData.samprate = Tables.samplerate_table[hId][hSrIndex];\n\n        /* determine offset of header */\n        if (hId != 0) {\n            /* mpeg1 */\n            if (hMode != 3)\n                bufPos += (32 + 4);\n            else\n                bufPos += (17 + 4);\n        } else {\n            /* mpeg2 */\n            if (hMode != 3)\n                bufPos += (17 + 4);\n            else\n                bufPos += (9 + 4);\n        }\n\n        if (!isVbrTag(buf, bufPos))\n            return null;\n\n        bufPos += 4;\n\n        pTagData.hId = hId;\n\n        /* get flags */\n        var head_flags = pTagData.flags = extractInteger(buf, bufPos);\n        bufPos += 4;\n\n        if ((head_flags & FRAMES_FLAG) != 0) {\n            pTagData.frames = extractInteger(buf, bufPos);\n            bufPos += 4;\n        }\n\n        if ((head_flags & BYTES_FLAG) != 0) {\n            pTagData.bytes = extractInteger(buf, bufPos);\n            bufPos += 4;\n        }\n\n        if ((head_flags & TOC_FLAG) != 0) {\n            if (pTagData.toc != null) {\n                for (var i = 0; i < NUMTOCENTRIES; i++)\n                    pTagData.toc[i] = buf[bufPos + i];\n            }\n            bufPos += NUMTOCENTRIES;\n        }\n\n        pTagData.vbrScale = -1;\n\n        if ((head_flags & VBR_SCALE_FLAG) != 0) {\n            pTagData.vbrScale = extractInteger(buf, bufPos);\n            bufPos += 4;\n        }\n\n        pTagData.headersize = ((hId + 1) * 72000 * hBitrate)\n            / pTagData.samprate;\n\n        bufPos += 21;\n        var encDelay = buf[bufPos + 0] << 4;\n        encDelay += buf[bufPos + 1] >> 4;\n        var encPadding = (buf[bufPos + 1] & 0x0F) << 8;\n        encPadding += buf[bufPos + 2] & 0xff;\n        /* check for reasonable values (this may be an old Xing header, */\n        /* not a INFO tag) */\n        if (encDelay < 0 || encDelay > 3000)\n            encDelay = -1;\n        if (encPadding < 0 || encPadding > 3000)\n            encPadding = -1;\n\n        pTagData.encDelay = encDelay;\n        pTagData.encPadding = encPadding;\n\n        /* success */\n        return pTagData;\n    }\n\n    /**\n     * Initializes the header\n     *\n     * @param gfp\n     *            global flags\n     */\n    this.InitVbrTag = function (gfp) {\n        var gfc = gfp.internal_flags;\n\n        /**\n         * <PRE>\n         * Xing VBR pretends to be a 48kbs layer III frame.  (at 44.1kHz).\n         * (at 48kHz they use 56kbs since 48kbs frame not big enough for\n         * table of contents)\n         * let's always embed Xing header inside a 64kbs layer III frame.\n         * this gives us enough room for a LAME version string too.\n         * size determined by sampling frequency (MPEG1)\n         * 32kHz:    216 bytes@48kbs    288bytes@ 64kbs\n         * 44.1kHz:  156 bytes          208bytes@64kbs     (+1 if padding = 1)\n         * 48kHz:    144 bytes          192\n         *\n         * MPEG 2 values are the same since the framesize and samplerate\n         * are each reduced by a factor of 2.\n         * </PRE>\n         */\n        var kbps_header;\n        if (1 == gfp.version) {\n            kbps_header = XING_BITRATE1;\n        } else {\n            if (gfp.out_samplerate < 16000)\n                kbps_header = XING_BITRATE25;\n            else\n                kbps_header = XING_BITRATE2;\n        }\n\n        if (gfp.VBR == VbrMode.vbr_off)\n            kbps_header = gfp.brate;\n\n        // make sure LAME Header fits into Frame\n        var totalFrameSize = ((gfp.version + 1) * 72000 * kbps_header)\n            / gfp.out_samplerate;\n        var headerSize = (gfc.sideinfo_len + LAMEHEADERSIZE);\n        gfc.VBR_seek_table.TotalFrameSize = totalFrameSize;\n        if (totalFrameSize < headerSize || totalFrameSize > MAXFRAMESIZE) {\n            /* disable tag, it wont fit */\n            gfp.bWriteVbrTag = false;\n            return;\n        }\n\n        gfc.VBR_seek_table.nVbrNumFrames = 0;\n        gfc.VBR_seek_table.nBytesWritten = 0;\n        gfc.VBR_seek_table.sum = 0;\n\n        gfc.VBR_seek_table.seen = 0;\n        gfc.VBR_seek_table.want = 1;\n        gfc.VBR_seek_table.pos = 0;\n\n        if (gfc.VBR_seek_table.bag == null) {\n            gfc.VBR_seek_table.bag = new int[400];\n            gfc.VBR_seek_table.size = 400;\n        }\n\n        // write dummy VBR tag of all 0's into bitstream\n        var buffer = new_byte(MAXFRAMESIZE);\n\n        setLameTagFrameHeader(gfp, buffer);\n        var n = gfc.VBR_seek_table.TotalFrameSize;\n        for (var i = 0; i < n; ++i) {\n            bs.add_dummy_byte(gfp, buffer[i] & 0xff, 1);\n        }\n    }\n\n    /**\n     * Fast CRC-16 computation (uses table crc16Lookup).\n     *\n     * @param value\n     * @param crc\n     * @return\n     */\n    function crcUpdateLookup(value, crc) {\n        var tmp = crc ^ value;\n        crc = (crc >> 8) ^ crc16Lookup[tmp & 0xff];\n        return crc;\n    }\n\n    this.updateMusicCRC = function (crc, buffer, bufferPos, size) {\n        for (var i = 0; i < size; ++i)\n            crc[0] = crcUpdateLookup(buffer[bufferPos + i], crc[0]);\n    }\n\n    /**\n     * Write LAME info: mini version + info on various switches used (Jonathan\n     * Dee 2001/08/31).\n     *\n     * @param gfp\n     *            global flags\n     * @param musicLength\n     *            music length\n     * @param streamBuffer\n     *            pointer to output buffer\n     * @param streamBufferPos\n     *            offset into the output buffer\n     * @param crc\n     *            computation of CRC-16 of Lame Tag so far (starting at frame\n     *            sync)\n     * @return number of bytes written to the stream\n     */\n    function putLameVBR(gfp, musicLength, streamBuffer, streamBufferPos, crc) {\n        var gfc = gfp.internal_flags;\n        var bytesWritten = 0;\n\n        /* encoder delay */\n        var encDelay = gfp.encoder_delay;\n        /* encoder padding */\n        var encPadding = gfp.encoder_padding;\n\n        /* recall: gfp.VBR_q is for example set by the switch -V */\n        /* gfp.quality by -q, -h, -f, etc */\n        var quality = (100 - 10 * gfp.VBR_q - gfp.quality);\n\n        var version = v.getLameVeryShortVersion();\n        var vbr;\n        var revision = 0x00;\n        var revMethod;\n        // numbering different in vbr_mode vs. Lame tag\n        var vbrTypeTranslator = [1, 5, 3, 2, 4, 0, 3];\n        var lowpass = 0 | (((gfp.lowpassfreq / 100.0) + .5) > 255 ? 255\n                : (gfp.lowpassfreq / 100.0) + .5);\n        var peakSignalAmplitude = 0;\n        var radioReplayGain = 0;\n        var audiophileReplayGain = 0;\n        var noiseShaping = gfp.internal_flags.noise_shaping;\n        var stereoMode = 0;\n        var nonOptimal = 0;\n        var sourceFreq = 0;\n        var misc = 0;\n        var musicCRC = 0;\n\n        // psy model type: Gpsycho or NsPsytune\n        var expNPsyTune = (gfp.exp_nspsytune & 1) != 0;\n        var safeJoint = (gfp.exp_nspsytune & 2) != 0;\n        var noGapMore = false;\n        var noGapPrevious = false;\n        var noGapCount = gfp.internal_flags.nogap_total;\n        var noGapCurr = gfp.internal_flags.nogap_current;\n\n        // 4 bits\n        var athType = gfp.ATHtype;\n        var flags = 0;\n\n        // vbr modes\n        var abrBitrate;\n        switch (gfp.VBR) {\n            case vbr_abr:\n                abrBitrate = gfp.VBR_mean_bitrate_kbps;\n                break;\n            case vbr_off:\n                abrBitrate = gfp.brate;\n                break;\n            default:\n                abrBitrate = gfp.VBR_min_bitrate_kbps;\n        }\n\n        // revision and vbr method\n        if (gfp.VBR.ordinal() < vbrTypeTranslator.length)\n            vbr = vbrTypeTranslator[gfp.VBR.ordinal()];\n        else\n            vbr = 0x00; // unknown\n\n        revMethod = 0x10 * revision + vbr;\n\n        // ReplayGain\n        if (gfc.findReplayGain) {\n            if (gfc.RadioGain > 0x1FE)\n                gfc.RadioGain = 0x1FE;\n            if (gfc.RadioGain < -0x1FE)\n                gfc.RadioGain = -0x1FE;\n\n            // set name code\n            radioReplayGain = 0x2000;\n            // set originator code to `determined automatically'\n            radioReplayGain |= 0xC00;\n\n            if (gfc.RadioGain >= 0) {\n                // set gain adjustment\n                radioReplayGain |= gfc.RadioGain;\n            } else {\n                // set the sign bit\n                radioReplayGain |= 0x200;\n                // set gain adjustment\n                radioReplayGain |= -gfc.RadioGain;\n            }\n        }\n\n        // peak sample\n        if (gfc.findPeakSample)\n            peakSignalAmplitude = Math\n                .abs(0 | ((( gfc.PeakSample) / 32767.0) * Math.pow(2, 23) + .5));\n\n        // nogap\n        if (noGapCount != -1) {\n            if (noGapCurr > 0)\n                noGapPrevious = true;\n\n            if (noGapCurr < noGapCount - 1)\n                noGapMore = true;\n        }\n\n        // flags\n        flags = athType + ((expNPsyTune ? 1 : 0) << 4)\n            + ((safeJoint ? 1 : 0) << 5) + ((noGapMore ? 1 : 0) << 6)\n            + ((noGapPrevious ? 1 : 0) << 7);\n\n        if (quality < 0)\n            quality = 0;\n\n        // stereo mode field (Intensity stereo is not implemented)\n        switch (gfp.mode) {\n            case MONO:\n                stereoMode = 0;\n                break;\n            case STEREO:\n                stereoMode = 1;\n                break;\n            case DUAL_CHANNEL:\n                stereoMode = 2;\n                break;\n            case JOINT_STEREO:\n                if (gfp.force_ms)\n                    stereoMode = 4;\n                else\n                    stereoMode = 3;\n                break;\n            case NOT_SET:\n            //$FALL-THROUGH$\n            default:\n                stereoMode = 7;\n                break;\n        }\n\n        if (gfp.in_samplerate <= 32000)\n            sourceFreq = 0x00;\n        else if (gfp.in_samplerate == 48000)\n            sourceFreq = 0x02;\n        else if (gfp.in_samplerate > 48000)\n            sourceFreq = 0x03;\n        else {\n            // default is 44100Hz\n            sourceFreq = 0x01;\n        }\n\n        // Check if the user overrided the default LAME behavior with some\n        // nasty options\n        if (gfp.short_blocks == ShortBlock.short_block_forced\n            || gfp.short_blocks == ShortBlock.short_block_dispensed\n            || ((gfp.lowpassfreq == -1) && (gfp.highpassfreq == -1)) || /* \"-k\" */\n            (gfp.scale_left < gfp.scale_right)\n            || (gfp.scale_left > gfp.scale_right)\n            || (gfp.disable_reservoir && gfp.brate < 320) || gfp.noATH\n            || gfp.ATHonly || (athType == 0) || gfp.in_samplerate <= 32000)\n            nonOptimal = 1;\n\n        misc = noiseShaping + (stereoMode << 2) + (nonOptimal << 5)\n            + (sourceFreq << 6);\n\n        musicCRC = gfc.nMusicCRC;\n\n        // Write all this information into the stream\n\n        createInteger(streamBuffer, streamBufferPos + bytesWritten, quality);\n        bytesWritten += 4;\n\n        for (var j = 0; j < 9; j++) {\n            streamBuffer[streamBufferPos + bytesWritten + j] = 0xff & version .charAt(j);\n        }\n        bytesWritten += 9;\n\n        streamBuffer[streamBufferPos + bytesWritten] = 0xff & revMethod;\n        bytesWritten++;\n\n        streamBuffer[streamBufferPos + bytesWritten] = 0xff & lowpass;\n        bytesWritten++;\n\n        createInteger(streamBuffer, streamBufferPos + bytesWritten,\n            peakSignalAmplitude);\n        bytesWritten += 4;\n\n        createShort(streamBuffer, streamBufferPos + bytesWritten,\n            radioReplayGain);\n        bytesWritten += 2;\n\n        createShort(streamBuffer, streamBufferPos + bytesWritten,\n            audiophileReplayGain);\n        bytesWritten += 2;\n\n        streamBuffer[streamBufferPos + bytesWritten] = 0xff & flags;\n        bytesWritten++;\n\n        if (abrBitrate >= 255)\n            streamBuffer[streamBufferPos + bytesWritten] = 0xFF;\n        else\n            streamBuffer[streamBufferPos + bytesWritten] = 0xff & abrBitrate;\n        bytesWritten++;\n\n        streamBuffer[streamBufferPos + bytesWritten] = 0xff & (encDelay >> 4);\n        streamBuffer[streamBufferPos + bytesWritten + 1] = 0xff & ((encDelay << 4) + (encPadding >> 8));\n        streamBuffer[streamBufferPos + bytesWritten + 2] = 0xff & encPadding;\n\n        bytesWritten += 3;\n\n        streamBuffer[streamBufferPos + bytesWritten] = 0xff & misc;\n        bytesWritten++;\n\n        // unused in rev0\n        streamBuffer[streamBufferPos + bytesWritten++] = 0;\n\n        createShort(streamBuffer, streamBufferPos + bytesWritten, gfp.preset);\n        bytesWritten += 2;\n\n        createInteger(streamBuffer, streamBufferPos + bytesWritten, musicLength);\n        bytesWritten += 4;\n\n        createShort(streamBuffer, streamBufferPos + bytesWritten, musicCRC);\n        bytesWritten += 2;\n\n        // Calculate tag CRC.... must be done here, since it includes previous\n        // information\n\n        for (var i = 0; i < bytesWritten; i++)\n            crc = crcUpdateLookup(streamBuffer[streamBufferPos + i], crc);\n\n        createShort(streamBuffer, streamBufferPos + bytesWritten, crc);\n        bytesWritten += 2;\n\n        return bytesWritten;\n    }\n\n    function skipId3v2(fpStream) {\n        // seek to the beginning of the stream\n        fpStream.seek(0);\n        // read 10 bytes in case there's an ID3 version 2 header here\n        var id3v2Header = new_byte(10);\n        fpStream.readFully(id3v2Header);\n        /* does the stream begin with the ID3 version 2 file identifier? */\n        var id3v2TagSize;\n        if (!new String(id3v2Header, \"ISO-8859-1\").startsWith(\"ID3\")) {\n            /*\n             * the tag size (minus the 10-byte header) is encoded into four\n             * bytes where the most significant bit is clear in each byte\n             */\n            id3v2TagSize = (((id3v2Header[6] & 0x7f) << 21)\n                | ((id3v2Header[7] & 0x7f) << 14)\n                | ((id3v2Header[8] & 0x7f) << 7) | (id3v2Header[9] & 0x7f))\n                + id3v2Header.length;\n        } else {\n            /* no ID3 version 2 tag in this stream */\n            id3v2TagSize = 0;\n        }\n        return id3v2TagSize;\n    }\n\n    this.getLameTagFrame = function (gfp, buffer) {\n        var gfc = gfp.internal_flags;\n\n        if (!gfp.bWriteVbrTag) {\n            return 0;\n        }\n        if (gfc.Class_ID != Lame.LAME_ID) {\n            return 0;\n        }\n        if (gfc.VBR_seek_table.pos <= 0) {\n            return 0;\n        }\n        if (buffer.length < gfc.VBR_seek_table.TotalFrameSize) {\n            return gfc.VBR_seek_table.TotalFrameSize;\n        }\n\n        Arrays.fill(buffer, 0, gfc.VBR_seek_table.TotalFrameSize, 0);\n\n        // 4 bytes frame header\n        setLameTagFrameHeader(gfp, buffer);\n\n        // Create TOC entries\n        var toc = new_byte(NUMTOCENTRIES);\n\n        if (gfp.free_format) {\n            for (var i = 1; i < NUMTOCENTRIES; ++i)\n                toc[i] = 0xff & (255 * i / 100);\n        } else {\n            xingSeekTable(gfc.VBR_seek_table, toc);\n        }\n\n        // Start writing the tag after the zero frame\n        var streamIndex = gfc.sideinfo_len;\n        /**\n         * Note: Xing header specifies that Xing data goes in the ancillary data\n         * with NO ERROR PROTECTION. If error protecton in enabled, the Xing\n         * data still starts at the same offset, and now it is in sideinfo data\n         * block, and thus will not decode correctly by non-Xing tag aware\n         * players\n         */\n        if (gfp.error_protection)\n            streamIndex -= 2;\n\n        // Put Vbr tag\n        if (gfp.VBR == VbrMode.vbr_off) {\n            buffer[streamIndex++] = 0xff & VBRTag1.charAt(0);\n            buffer[streamIndex++] = 0xff & VBRTag1.charAt(1);\n            buffer[streamIndex++] = 0xff & VBRTag1.charAt(2);\n            buffer[streamIndex++] = 0xff & VBRTag1.charAt(3);\n\n        } else {\n            buffer[streamIndex++] = 0xff & VBRTag0.charAt(0);\n            buffer[streamIndex++] = 0xff & VBRTag0.charAt(1);\n            buffer[streamIndex++] = 0xff & VBRTag0.charAt(2);\n            buffer[streamIndex++] = 0xff & VBRTag0.charAt(3);\n        }\n\n        // Put header flags\n        createInteger(buffer, streamIndex, FRAMES_FLAG + BYTES_FLAG + TOC_FLAG\n            + VBR_SCALE_FLAG);\n        streamIndex += 4;\n\n        // Put Total Number of frames\n        createInteger(buffer, streamIndex, gfc.VBR_seek_table.nVbrNumFrames);\n        streamIndex += 4;\n\n        // Put total audio stream size, including Xing/LAME Header\n        var streamSize = (gfc.VBR_seek_table.nBytesWritten + gfc.VBR_seek_table.TotalFrameSize);\n        createInteger(buffer, streamIndex, 0 | streamSize);\n        streamIndex += 4;\n\n        /* Put TOC */\n        System.arraycopy(toc, 0, buffer, streamIndex, toc.length);\n        streamIndex += toc.length;\n\n        if (gfp.error_protection) {\n            // (jo) error_protection: add crc16 information to header\n            bs.CRC_writeheader(gfc, buffer);\n        }\n\n        // work out CRC so far: initially crc = 0\n        var crc = 0x00;\n        for (var i = 0; i < streamIndex; i++)\n            crc = crcUpdateLookup(buffer[i], crc);\n        // Put LAME VBR info\n        streamIndex += putLameVBR(gfp, streamSize, buffer, streamIndex, crc);\n\n        return gfc.VBR_seek_table.TotalFrameSize;\n    }\n\n    /**\n     * Write final VBR tag to the file.\n     *\n     * @param gfp\n     *            global flags\n     * @param stream\n     *            stream to add the VBR tag to\n     * @return 0 (OK), -1 else\n     * @throws IOException\n     *             I/O error\n     */\n    this.putVbrTag = function (gfp, stream) {\n        var gfc = gfp.internal_flags;\n\n        if (gfc.VBR_seek_table.pos <= 0)\n            return -1;\n\n        // Seek to end of file\n        stream.seek(stream.length());\n\n        // Get file size, abort if file has zero length.\n        if (stream.length() == 0)\n            return -1;\n\n        // The VBR tag may NOT be located at the beginning of the stream. If an\n        // ID3 version 2 tag was added, then it must be skipped to write the VBR\n        // tag data.\n        var id3v2TagSize = skipId3v2(stream);\n\n        // Seek to the beginning of the stream\n        stream.seek(id3v2TagSize);\n\n        var buffer = new_byte(MAXFRAMESIZE);\n        var bytes = getLameTagFrame(gfp, buffer);\n        if (bytes > buffer.length) {\n            return -1;\n        }\n\n        if (bytes < 1) {\n            return 0;\n        }\n\n        // Put it all to disk again\n        stream.write(buffer, 0, bytes);\n        // success\n        return 0;\n    }\n\n}\n\nmodule.exports = VBRTag;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL1ZCUlRhZy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsK0VBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLG1CQUFtQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0Isa0JBQWtCO0FBQzFDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xhbWVqcy9zcmMvanMvVkJSVGFnLmpzPzExMjkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uLmpzJyk7XG52YXIgU3lzdGVtID0gY29tbW9uLlN5c3RlbTtcbnZhciBWYnJNb2RlID0gY29tbW9uLlZick1vZGU7XG52YXIgRmxvYXQgPSBjb21tb24uRmxvYXQ7XG52YXIgU2hvcnRCbG9jayA9IGNvbW1vbi5TaG9ydEJsb2NrO1xudmFyIFV0aWwgPSBjb21tb24uVXRpbDtcbnZhciBBcnJheXMgPSBjb21tb24uQXJyYXlzO1xudmFyIG5ld19hcnJheV9uID0gY29tbW9uLm5ld19hcnJheV9uO1xudmFyIG5ld19ieXRlID0gY29tbW9uLm5ld19ieXRlO1xudmFyIG5ld19kb3VibGUgPSBjb21tb24ubmV3X2RvdWJsZTtcbnZhciBuZXdfZmxvYXQgPSBjb21tb24ubmV3X2Zsb2F0O1xudmFyIG5ld19mbG9hdF9uID0gY29tbW9uLm5ld19mbG9hdF9uO1xudmFyIG5ld19pbnQgPSBjb21tb24ubmV3X2ludDtcbnZhciBuZXdfaW50X24gPSBjb21tb24ubmV3X2ludF9uO1xudmFyIGFzc2VydCA9IGNvbW1vbi5hc3NlcnQ7XG5cbi8qKlxuICogQSBWYnIgaGVhZGVyIG1heSBiZSBwcmVzZW50IGluIHRoZSBhbmNpbGxhcnkgZGF0YSBmaWVsZCBvZiB0aGUgZmlyc3QgZnJhbWUgb2ZcbiAqIGFuIG1wMyBiaXRzdHJlYW08QlI+XG4gKiBUaGUgVmJyIGhlYWRlciAob3B0aW9uYWxseSkgY29udGFpbnNcbiAqIDxVTD5cbiAqIDxMST5mcmFtZXMgdG90YWwgbnVtYmVyIG9mIGF1ZGlvIGZyYW1lcyBpbiB0aGUgYml0c3RyZWFtXG4gKiA8TEk+Ynl0ZXMgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIGluIHRoZSBiaXRzdHJlYW1cbiAqIDxMST50b2MgdGFibGUgb2YgY29udGVudHNcbiAqIDwvVUw+XG4gKlxuICogdG9jICh0YWJsZSBvZiBjb250ZW50cykgZ2l2ZXMgc2VlayBwb2ludHMgZm9yIHJhbmRvbSBhY2Nlc3MuPEJSPlxuICogVGhlIGl0aCBlbnRyeSBkZXRlcm1pbmVzIHRoZSBzZWVrIHBvaW50IGZvciBpLXBlcmNlbnQgZHVyYXRpb24uPEJSPlxuICogc2VlayBwb2ludCBpbiBieXRlcyA9ICh0b2NbaV0vMjU2LjApICogdG90YWxfYml0c3RyZWFtX2J5dGVzPEJSPlxuICogZS5nLiBoYWxmIGR1cmF0aW9uIHNlZWsgcG9pbnQgPSAodG9jWzUwXS8yNTYuMCkgKiB0b3RhbF9iaXRzdHJlYW1fYnl0ZXNcbiAqL1xuVkJSVGFnLk5VTVRPQ0VOVFJJRVMgPSAxMDA7XG5WQlJUYWcuTUFYRlJBTUVTSVpFID0gMjg4MDtcblxuZnVuY3Rpb24gVkJSVGFnKCkge1xuXG4gICAgdmFyIGxhbWU7XG4gICAgdmFyIGJzO1xuICAgIHZhciB2O1xuXG4gICAgdGhpcy5zZXRNb2R1bGVzID0gZnVuY3Rpb24gKF9sYW1lLCBfYnMsIF92KSB7XG4gICAgICAgIGxhbWUgPSBfbGFtZTtcbiAgICAgICAgYnMgPSBfYnM7XG4gICAgICAgIHYgPSBfdjtcbiAgICB9O1xuXG4gICAgdmFyIEZSQU1FU19GTEFHID0gMHgwMDAxO1xuICAgIHZhciBCWVRFU19GTEFHID0gMHgwMDAyO1xuICAgIHZhciBUT0NfRkxBRyA9IDB4MDAwNDtcbiAgICB2YXIgVkJSX1NDQUxFX0ZMQUcgPSAweDAwMDg7XG5cbiAgICB2YXIgTlVNVE9DRU5UUklFUyA9IFZCUlRhZy5OVU1UT0NFTlRSSUVTO1xuXG4gICAgLyoqXG4gICAgICogKDB4QjQwKSB0aGUgbWF4IGZyZWVmb3JtYXQgNjQwIDMya0h6IGZyYW1lc2l6ZS5cbiAgICAgKi9cbiAgICB2YXIgTUFYRlJBTUVTSVpFID0gVkJSVGFnLk1BWEZSQU1FU0laRTtcblxuICAgIC8qKlxuICAgICAqIDxQUkU+XG4gICAgICogICAgNCBieXRlcyBmb3IgSGVhZGVyIFRhZ1xuICAgICAqICAgIDQgYnl0ZXMgZm9yIEhlYWRlciBGbGFnc1xuICAgICAqICAxMDAgYnl0ZXMgZm9yIGVudHJ5ICh0b2MpXG4gICAgICogICAgNCBieXRlcyBmb3IgZnJhbWUgc2l6ZVxuICAgICAqICAgIDQgYnl0ZXMgZm9yIHN0cmVhbSBzaXplXG4gICAgICogICAgNCBieXRlcyBmb3IgVkJSIHNjYWxlLiBhIFZCUiBxdWFsaXR5IGluZGljYXRvcjogMD1iZXN0IDEwMD13b3JzdFxuICAgICAqICAgMjAgYnl0ZXMgZm9yIExBTUUgdGFnLiAgZm9yIGV4YW1wbGUsIFwiTEFNRTMuMTIgKGJldGEgNilcIlxuICAgICAqIF9fX19fX19fX19fXG4gICAgICogIDE0MCBieXRlc1xuICAgICAqIDwvUFJFPlxuICAgICAqL1xuICAgIHZhciBWQlJIRUFERVJTSVpFID0gKE5VTVRPQ0VOVFJJRVMgKyA0ICsgNCArIDQgKyA0ICsgNCk7XG5cbiAgICB2YXIgTEFNRUhFQURFUlNJWkUgPSAoVkJSSEVBREVSU0laRSArIDkgKyAxICsgMSArIDhcbiAgICArIDEgKyAxICsgMyArIDEgKyAxICsgMiArIDQgKyAyICsgMik7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2l6ZSBvZiB0aGUgWGluZyBoZWFkZXIgTVBFRy0xLCBiaXQgcmF0ZSBpbiBrYnBzLlxuICAgICAqL1xuICAgIHZhciBYSU5HX0JJVFJBVEUxID0gMTI4O1xuICAgIC8qKlxuICAgICAqIFRoZSBzaXplIG9mIHRoZSBYaW5nIGhlYWRlciBNUEVHLTIsIGJpdCByYXRlIGluIGticHMuXG4gICAgICovXG4gICAgdmFyIFhJTkdfQklUUkFURTIgPSA2NDtcbiAgICAvKipcbiAgICAgKiBUaGUgc2l6ZSBvZiB0aGUgWGluZyBoZWFkZXIgTVBFRy0yLjUsIGJpdCByYXRlIGluIGticHMuXG4gICAgICovXG4gICAgdmFyIFhJTkdfQklUUkFURTI1ID0gMzI7XG5cbiAgICAvKipcbiAgICAgKiBJU08tODg1OS0xIGNoYXJzZXQgZm9yIGJ5dGUgdG8gc3RyaW5nIG9wZXJhdGlvbnMuXG4gICAgICovXG4gICAgdmFyIElTT184ODU5XzEgPSBudWxsOyAvL0NoYXJzZXQuZm9yTmFtZShcIklTTy04ODU5LTFcIik7XG5cbiAgICAvKipcbiAgICAgKiBWQlIgaGVhZGVyIG1hZ2ljIHN0cmluZy5cbiAgICAgKi9cbiAgICB2YXIgVkJSVGFnMCA9IFwiWGluZ1wiO1xuICAgIC8qKlxuICAgICAqIFZCUiBoZWFkZXIgbWFnaWMgc3RyaW5nIChWQlIgPT0gVkJSTW9kZS52YnJfb2ZmKS5cbiAgICAgKi9cbiAgICB2YXIgVkJSVGFnMSA9IFwiSW5mb1wiO1xuXG4gICAgLyoqXG4gICAgICogTG9va3VwIHRhYmxlIGZvciBmYXN0IENSQy0xNiBjb21wdXRhdGlvbi4gVXNlcyB0aGUgcG9seW5vbWlhbFxuICAgICAqIHheMTYreF4xNSt4XjIrMVxuICAgICAqL1xuICAgIHZhciBjcmMxNkxvb2t1cCA9IFsweDAwMDAsIDB4QzBDMSwgMHhDMTgxLCAweDAxNDAsXG4gICAgICAgIDB4QzMwMSwgMHgwM0MwLCAweDAyODAsIDB4QzI0MSwgMHhDNjAxLCAweDA2QzAsIDB4MDc4MCwgMHhDNzQxLFxuICAgICAgICAweDA1MDAsIDB4QzVDMSwgMHhDNDgxLCAweDA0NDAsIDB4Q0MwMSwgMHgwQ0MwLCAweDBEODAsIDB4Q0Q0MSxcbiAgICAgICAgMHgwRjAwLCAweENGQzEsIDB4Q0U4MSwgMHgwRTQwLCAweDBBMDAsIDB4Q0FDMSwgMHhDQjgxLCAweDBCNDAsXG4gICAgICAgIDB4QzkwMSwgMHgwOUMwLCAweDA4ODAsIDB4Qzg0MSwgMHhEODAxLCAweDE4QzAsIDB4MTk4MCwgMHhEOTQxLFxuICAgICAgICAweDFCMDAsIDB4REJDMSwgMHhEQTgxLCAweDFBNDAsIDB4MUUwMCwgMHhERUMxLCAweERGODEsIDB4MUY0MCxcbiAgICAgICAgMHhERDAxLCAweDFEQzAsIDB4MUM4MCwgMHhEQzQxLCAweDE0MDAsIDB4RDRDMSwgMHhENTgxLCAweDE1NDAsXG4gICAgICAgIDB4RDcwMSwgMHgxN0MwLCAweDE2ODAsIDB4RDY0MSwgMHhEMjAxLCAweDEyQzAsIDB4MTM4MCwgMHhEMzQxLFxuICAgICAgICAweDExMDAsIDB4RDFDMSwgMHhEMDgxLCAweDEwNDAsIDB4RjAwMSwgMHgzMEMwLCAweDMxODAsIDB4RjE0MSxcbiAgICAgICAgMHgzMzAwLCAweEYzQzEsIDB4RjI4MSwgMHgzMjQwLCAweDM2MDAsIDB4RjZDMSwgMHhGNzgxLCAweDM3NDAsXG4gICAgICAgIDB4RjUwMSwgMHgzNUMwLCAweDM0ODAsIDB4RjQ0MSwgMHgzQzAwLCAweEZDQzEsIDB4RkQ4MSwgMHgzRDQwLFxuICAgICAgICAweEZGMDEsIDB4M0ZDMCwgMHgzRTgwLCAweEZFNDEsIDB4RkEwMSwgMHgzQUMwLCAweDNCODAsIDB4RkI0MSxcbiAgICAgICAgMHgzOTAwLCAweEY5QzEsIDB4Rjg4MSwgMHgzODQwLCAweDI4MDAsIDB4RThDMSwgMHhFOTgxLCAweDI5NDAsXG4gICAgICAgIDB4RUIwMSwgMHgyQkMwLCAweDJBODAsIDB4RUE0MSwgMHhFRTAxLCAweDJFQzAsIDB4MkY4MCwgMHhFRjQxLFxuICAgICAgICAweDJEMDAsIDB4RURDMSwgMHhFQzgxLCAweDJDNDAsIDB4RTQwMSwgMHgyNEMwLCAweDI1ODAsIDB4RTU0MSxcbiAgICAgICAgMHgyNzAwLCAweEU3QzEsIDB4RTY4MSwgMHgyNjQwLCAweDIyMDAsIDB4RTJDMSwgMHhFMzgxLCAweDIzNDAsXG4gICAgICAgIDB4RTEwMSwgMHgyMUMwLCAweDIwODAsIDB4RTA0MSwgMHhBMDAxLCAweDYwQzAsIDB4NjE4MCwgMHhBMTQxLFxuICAgICAgICAweDYzMDAsIDB4QTNDMSwgMHhBMjgxLCAweDYyNDAsIDB4NjYwMCwgMHhBNkMxLCAweEE3ODEsIDB4Njc0MCxcbiAgICAgICAgMHhBNTAxLCAweDY1QzAsIDB4NjQ4MCwgMHhBNDQxLCAweDZDMDAsIDB4QUNDMSwgMHhBRDgxLCAweDZENDAsXG4gICAgICAgIDB4QUYwMSwgMHg2RkMwLCAweDZFODAsIDB4QUU0MSwgMHhBQTAxLCAweDZBQzAsIDB4NkI4MCwgMHhBQjQxLFxuICAgICAgICAweDY5MDAsIDB4QTlDMSwgMHhBODgxLCAweDY4NDAsIDB4NzgwMCwgMHhCOEMxLCAweEI5ODEsIDB4Nzk0MCxcbiAgICAgICAgMHhCQjAxLCAweDdCQzAsIDB4N0E4MCwgMHhCQTQxLCAweEJFMDEsIDB4N0VDMCwgMHg3RjgwLCAweEJGNDEsXG4gICAgICAgIDB4N0QwMCwgMHhCREMxLCAweEJDODEsIDB4N0M0MCwgMHhCNDAxLCAweDc0QzAsIDB4NzU4MCwgMHhCNTQxLFxuICAgICAgICAweDc3MDAsIDB4QjdDMSwgMHhCNjgxLCAweDc2NDAsIDB4NzIwMCwgMHhCMkMxLCAweEIzODEsIDB4NzM0MCxcbiAgICAgICAgMHhCMTAxLCAweDcxQzAsIDB4NzA4MCwgMHhCMDQxLCAweDUwMDAsIDB4OTBDMSwgMHg5MTgxLCAweDUxNDAsXG4gICAgICAgIDB4OTMwMSwgMHg1M0MwLCAweDUyODAsIDB4OTI0MSwgMHg5NjAxLCAweDU2QzAsIDB4NTc4MCwgMHg5NzQxLFxuICAgICAgICAweDU1MDAsIDB4OTVDMSwgMHg5NDgxLCAweDU0NDAsIDB4OUMwMSwgMHg1Q0MwLCAweDVEODAsIDB4OUQ0MSxcbiAgICAgICAgMHg1RjAwLCAweDlGQzEsIDB4OUU4MSwgMHg1RTQwLCAweDVBMDAsIDB4OUFDMSwgMHg5QjgxLCAweDVCNDAsXG4gICAgICAgIDB4OTkwMSwgMHg1OUMwLCAweDU4ODAsIDB4OTg0MSwgMHg4ODAxLCAweDQ4QzAsIDB4NDk4MCwgMHg4OTQxLFxuICAgICAgICAweDRCMDAsIDB4OEJDMSwgMHg4QTgxLCAweDRBNDAsIDB4NEUwMCwgMHg4RUMxLCAweDhGODEsIDB4NEY0MCxcbiAgICAgICAgMHg4RDAxLCAweDREQzAsIDB4NEM4MCwgMHg4QzQxLCAweDQ0MDAsIDB4ODRDMSwgMHg4NTgxLCAweDQ1NDAsXG4gICAgICAgIDB4ODcwMSwgMHg0N0MwLCAweDQ2ODAsIDB4ODY0MSwgMHg4MjAxLCAweDQyQzAsIDB4NDM4MCwgMHg4MzQxLFxuICAgICAgICAweDQxMDAsIDB4ODFDMSwgMHg4MDgxLCAweDQwNDBdO1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICogUm9iZXJ0IEhlZ2VtYW5uIDIwMDEtMDEtMTdcbiAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICBmdW5jdGlvbiBhZGRWYnIodiwgYml0cmF0ZSkge1xuICAgICAgICB2Lm5WYnJOdW1GcmFtZXMrKztcbiAgICAgICAgdi5zdW0gKz0gYml0cmF0ZTtcbiAgICAgICAgdi5zZWVuKys7XG5cbiAgICAgICAgaWYgKHYuc2VlbiA8IHYud2FudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHYucG9zIDwgdi5zaXplKSB7XG4gICAgICAgICAgICB2LmJhZ1t2LnBvc10gPSB2LnN1bTtcbiAgICAgICAgICAgIHYucG9zKys7XG4gICAgICAgICAgICB2LnNlZW4gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2LnBvcyA9PSB2LnNpemUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdi5zaXplOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICB2LmJhZ1tpIC8gMl0gPSB2LmJhZ1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHYud2FudCAqPSAyO1xuICAgICAgICAgICAgdi5wb3MgLz0gMjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHhpbmdTZWVrVGFibGUodiwgdCkge1xuICAgICAgICBpZiAodi5wb3MgPD0gMClcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IE5VTVRPQ0VOVFJJRVM7ICsraSkge1xuICAgICAgICAgICAgdmFyIGogPSBpIC8gTlVNVE9DRU5UUklFUywgYWN0LCBzdW07XG4gICAgICAgICAgICB2YXIgaW5keCA9IDAgfCAoTWF0aC5mbG9vcihqICogdi5wb3MpKTtcbiAgICAgICAgICAgIGlmIChpbmR4ID4gdi5wb3MgLSAxKVxuICAgICAgICAgICAgICAgIGluZHggPSB2LnBvcyAtIDE7XG4gICAgICAgICAgICBhY3QgPSB2LmJhZ1tpbmR4XTtcbiAgICAgICAgICAgIHN1bSA9IHYuc3VtO1xuICAgICAgICAgICAgdmFyIHNlZWtfcG9pbnQgPSAwIHwgKDI1Ni4gKiBhY3QgLyBzdW0pO1xuICAgICAgICAgICAgaWYgKHNlZWtfcG9pbnQgPiAyNTUpXG4gICAgICAgICAgICAgICAgc2Vla19wb2ludCA9IDI1NTtcbiAgICAgICAgICAgIHRbaV0gPSAweGZmICYgc2Vla19wb2ludDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBWQlIgZW50cnksIHVzZWQgdG8gZmlsbCB0aGUgVkJSIFRPQyBlbnRyaWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGdmcFxuICAgICAqICAgICAgICAgICAgZ2xvYmFsIGZsYWdzXG4gICAgICovXG4gICAgdGhpcy5hZGRWYnJGcmFtZSA9IGZ1bmN0aW9uIChnZnApIHtcbiAgICAgICAgdmFyIGdmYyA9IGdmcC5pbnRlcm5hbF9mbGFncztcbiAgICAgICAgdmFyIGticHMgPSBUYWJsZXMuYml0cmF0ZV90YWJsZVtnZnAudmVyc2lvbl1bZ2ZjLmJpdHJhdGVfaW5kZXhdO1xuICAgICAgICBhc3NlcnQoZ2ZjLlZCUl9zZWVrX3RhYmxlLmJhZyAhPSBudWxsKTtcbiAgICAgICAgYWRkVmJyKGdmYy5WQlJfc2Vla190YWJsZSwga2Jwcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVhZCBiaWcgZW5kaWFuIGludGVnZXIgKDQtYnl0ZXMpIGZyb20gaGVhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJ1ZlxuICAgICAqICAgICAgICAgICAgaGVhZGVyIGNvbnRhaW5pbmcgdGhlIGludGVnZXJcbiAgICAgKiBAcGFyYW0gYnVmUG9zXG4gICAgICogICAgICAgICAgICBvZmZzZXQgaW50byB0aGUgaGVhZGVyXG4gICAgICogQHJldHVybiBleHRyYWN0ZWQgaW50ZWdlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV4dHJhY3RJbnRlZ2VyKGJ1ZiwgYnVmUG9zKSB7XG4gICAgICAgIHZhciB4ID0gYnVmW2J1ZlBvcyArIDBdICYgMHhmZjtcbiAgICAgICAgeCA8PD0gODtcbiAgICAgICAgeCB8PSBidWZbYnVmUG9zICsgMV0gJiAweGZmO1xuICAgICAgICB4IDw8PSA4O1xuICAgICAgICB4IHw9IGJ1ZltidWZQb3MgKyAyXSAmIDB4ZmY7XG4gICAgICAgIHggPDw9IDg7XG4gICAgICAgIHggfD0gYnVmW2J1ZlBvcyArIDNdICYgMHhmZjtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV3JpdGUgYmlnIGVuZGlhbiBpbnRlZ2VyICg0LWJ5dGVzKSBpbiB0aGUgaGVhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJ1ZlxuICAgICAqICAgICAgICAgICAgaGVhZGVyIHRvIHdyaXRlIHRoZSBpbnRlZ2VyIGludG9cbiAgICAgKiBAcGFyYW0gYnVmUG9zXG4gICAgICogICAgICAgICAgICBvZmZzZXQgaW50byB0aGUgaGVhZGVyXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogICAgICAgICAgICBpbnRlZ2VyIHZhbHVlIHRvIHdyaXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlSW50ZWdlcihidWYsIGJ1ZlBvcywgdmFsdWUpIHtcbiAgICAgICAgYnVmW2J1ZlBvcyArIDBdID0gMHhmZiAmICgodmFsdWUgPj4gMjQpICYgMHhmZik7XG4gICAgICAgIGJ1ZltidWZQb3MgKyAxXSA9IDB4ZmYgJiAoKHZhbHVlID4+IDE2KSAmIDB4ZmYpO1xuICAgICAgICBidWZbYnVmUG9zICsgMl0gPSAweGZmICYgKCh2YWx1ZSA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICBidWZbYnVmUG9zICsgM10gPSAweGZmICYgKHZhbHVlICYgMHhmZik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV3JpdGUgYmlnIGVuZGlhbiBzaG9ydCAoMi1ieXRlcykgaW4gdGhlIGhlYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBidWZcbiAgICAgKiAgICAgICAgICAgIGhlYWRlciB0byB3cml0ZSB0aGUgaW50ZWdlciBpbnRvXG4gICAgICogQHBhcmFtIGJ1ZlBvc1xuICAgICAqICAgICAgICAgICAgb2Zmc2V0IGludG8gdGhlIGhlYWRlclxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqICAgICAgICAgICAgaW50ZWdlciB2YWx1ZSB0byB3cml0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVNob3J0KGJ1ZiwgYnVmUG9zLCB2YWx1ZSkge1xuICAgICAgICBidWZbYnVmUG9zICsgMF0gPSAweGZmICYgKCh2YWx1ZSA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICBidWZbYnVmUG9zICsgMV0gPSAweGZmICYgKHZhbHVlICYgMHhmZik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgZm9yIG1hZ2ljIHN0cmluZ3MgKFhpbmcvSW5mbykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYnVmXG4gICAgICogICAgICAgICAgICBoZWFkZXIgdG8gY2hlY2tcbiAgICAgKiBAcGFyYW0gYnVmUG9zXG4gICAgICogICAgICAgICAgICBoZWFkZXIgb2Zmc2V0IHRvIGNoZWNrXG4gICAgICogQHJldHVybiBtYWdpYyBzdHJpbmcgZm91bmRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1ZiclRhZyhidWYsIGJ1ZlBvcykge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmluZyhidWYsIGJ1ZlBvcywgVkJSVGFnMC5sZW5ndGgoKSwgSVNPXzg4NTlfMSlcbiAgICAgICAgICAgICAgICAuZXF1YWxzKFZCUlRhZzApXG4gICAgICAgICAgICB8fCBuZXcgU3RyaW5nKGJ1ZiwgYnVmUG9zLCBWQlJUYWcxLmxlbmd0aCgpLCBJU09fODg1OV8xKVxuICAgICAgICAgICAgICAgIC5lcXVhbHMoVkJSVGFnMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hpZnRJbkJpdHNWYWx1ZSh4LCBuLCB2KSB7XG4gICAgICAgIHJldHVybiAweGZmICYgKCh4IDw8IG4pIHwgKHYgJiB+KC0xIDw8IG4pKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IHRoZSBNUDMgaGVhZGVyIHVzaW5nIHRoZSBzZXR0aW5ncyBvZiB0aGUgZ2xvYmFsIGZsYWdzLlxuICAgICAqXG4gICAgICogPGltZyBzcmM9XCIxMDAwcHgtTXAzZmlsZXN0cnVjdHVyZS5zdmcucG5nXCI+XG4gICAgICpcbiAgICAgKiBAcGFyYW0gZ2ZwXG4gICAgICogICAgICAgICAgICBnbG9iYWwgZmxhZ3NcbiAgICAgKiBAcGFyYW0gYnVmZmVyXG4gICAgICogICAgICAgICAgICBoZWFkZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRMYW1lVGFnRnJhbWVIZWFkZXIoZ2ZwLCBidWZmZXIpIHtcbiAgICAgICAgdmFyIGdmYyA9IGdmcC5pbnRlcm5hbF9mbGFncztcblxuICAgICAgICAvLyBNUDMgU3luYyBXb3JkXG4gICAgICAgIGJ1ZmZlclswXSA9IHNoaWZ0SW5CaXRzVmFsdWUoYnVmZmVyWzBdLCA4LCAweGZmKTtcblxuICAgICAgICBidWZmZXJbMV0gPSBzaGlmdEluQml0c1ZhbHVlKGJ1ZmZlclsxXSwgMywgNyk7XG4gICAgICAgIGJ1ZmZlclsxXSA9IHNoaWZ0SW5CaXRzVmFsdWUoYnVmZmVyWzFdLCAxLFxuICAgICAgICAgICAgKGdmcC5vdXRfc2FtcGxlcmF0ZSA8IDE2MDAwKSA/IDAgOiAxKTtcbiAgICAgICAgLy8gVmVyc2lvblxuICAgICAgICBidWZmZXJbMV0gPSBzaGlmdEluQml0c1ZhbHVlKGJ1ZmZlclsxXSwgMSwgZ2ZwLnZlcnNpb24pO1xuICAgICAgICAvLyAwMSA9PSBMYXllciAzXG4gICAgICAgIGJ1ZmZlclsxXSA9IHNoaWZ0SW5CaXRzVmFsdWUoYnVmZmVyWzFdLCAyLCA0IC0gMyk7XG4gICAgICAgIC8vIEVycm9yIHByb3RlY3Rpb25cbiAgICAgICAgYnVmZmVyWzFdID0gc2hpZnRJbkJpdHNWYWx1ZShidWZmZXJbMV0sIDEsICghZ2ZwLmVycm9yX3Byb3RlY3Rpb24pID8gMVxuICAgICAgICAgICAgOiAwKTtcblxuICAgICAgICAvLyBCaXQgcmF0ZVxuICAgICAgICBidWZmZXJbMl0gPSBzaGlmdEluQml0c1ZhbHVlKGJ1ZmZlclsyXSwgNCwgZ2ZjLmJpdHJhdGVfaW5kZXgpO1xuICAgICAgICAvLyBGcmVxdWVuY3lcbiAgICAgICAgYnVmZmVyWzJdID0gc2hpZnRJbkJpdHNWYWx1ZShidWZmZXJbMl0sIDIsIGdmYy5zYW1wbGVyYXRlX2luZGV4KTtcbiAgICAgICAgLy8gUGFkLiBCaXRcbiAgICAgICAgYnVmZmVyWzJdID0gc2hpZnRJbkJpdHNWYWx1ZShidWZmZXJbMl0sIDEsIDApO1xuICAgICAgICAvLyBQcml2LiBCaXRcbiAgICAgICAgYnVmZmVyWzJdID0gc2hpZnRJbkJpdHNWYWx1ZShidWZmZXJbMl0sIDEsIGdmcC5leHRlbnNpb24pO1xuXG4gICAgICAgIC8vIE1vZGVcbiAgICAgICAgYnVmZmVyWzNdID0gc2hpZnRJbkJpdHNWYWx1ZShidWZmZXJbM10sIDIsIGdmcC5tb2RlLm9yZGluYWwoKSk7XG4gICAgICAgIC8vIE1vZGUgZXh0ZW5zaW9uIChVc2VkIHdpdGggSm9pbnQgU3RlcmVvKVxuICAgICAgICBidWZmZXJbM10gPSBzaGlmdEluQml0c1ZhbHVlKGJ1ZmZlclszXSwgMiwgZ2ZjLm1vZGVfZXh0KTtcbiAgICAgICAgLy8gQ29weVxuICAgICAgICBidWZmZXJbM10gPSBzaGlmdEluQml0c1ZhbHVlKGJ1ZmZlclszXSwgMSwgZ2ZwLmNvcHlyaWdodCk7XG4gICAgICAgIC8vIE9yaWdpbmFsXG4gICAgICAgIGJ1ZmZlclszXSA9IHNoaWZ0SW5CaXRzVmFsdWUoYnVmZmVyWzNdLCAxLCBnZnAub3JpZ2luYWwpO1xuICAgICAgICAvLyBFbXBoYXNpc1xuICAgICAgICBidWZmZXJbM10gPSBzaGlmdEluQml0c1ZhbHVlKGJ1ZmZlclszXSwgMiwgZ2ZwLmVtcGhhc2lzKTtcblxuICAgICAgICAvKiB0aGUgZGVmYXVsdCBWQlIgaGVhZGVyLiA0OCBrYnBzIGxheWVyIElJSSwgbm8gcGFkZGluZywgbm8gY3JjICovXG4gICAgICAgIC8qIGJ1dCBzYW1wbGluZyBmcmVxLCBtb2RlIGFuZCBjb3B5cmlnaHQvY29weSBwcm90ZWN0aW9uIHRha2VuICovXG4gICAgICAgIC8qIGZyb20gZmlyc3QgdmFsaWQgZnJhbWUgKi9cbiAgICAgICAgYnVmZmVyWzBdID0gMHhmZjtcbiAgICAgICAgdmFyIGFieXRlID0gMHhmZiAmIChidWZmZXJbMV0gJiAweGYxKTtcbiAgICAgICAgdmFyIGJpdHJhdGU7XG4gICAgICAgIGlmICgxID09IGdmcC52ZXJzaW9uKSB7XG4gICAgICAgICAgICBiaXRyYXRlID0gWElOR19CSVRSQVRFMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChnZnAub3V0X3NhbXBsZXJhdGUgPCAxNjAwMClcbiAgICAgICAgICAgICAgICBiaXRyYXRlID0gWElOR19CSVRSQVRFMjU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYml0cmF0ZSA9IFhJTkdfQklUUkFURTI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2ZwLlZCUiA9PSBWYnJNb2RlLnZicl9vZmYpXG4gICAgICAgICAgICBiaXRyYXRlID0gZ2ZwLmJyYXRlO1xuXG4gICAgICAgIHZhciBiYnl0ZTtcbiAgICAgICAgaWYgKGdmcC5mcmVlX2Zvcm1hdClcbiAgICAgICAgICAgIGJieXRlID0gMHgwMDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYmJ5dGUgPSAweGZmICYgKDE2ICogbGFtZS5CaXRyYXRlSW5kZXgoYml0cmF0ZSwgZ2ZwLnZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgIGdmcC5vdXRfc2FtcGxlcmF0ZSkpO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFVzZSBhcyBtdWNoIG9mIHRoZSBpbmZvIGZyb20gdGhlIHJlYWwgZnJhbWVzIGluIHRoZSBYaW5nIGhlYWRlcjpcbiAgICAgICAgICogc2FtcGxlcmF0ZSwgY2hhbm5lbHMsIGNyYywgZXRjLi4uXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoZ2ZwLnZlcnNpb24gPT0gMSkge1xuICAgICAgICAgICAgLyogTVBFRzEgKi9cbiAgICAgICAgICAgIGJ1ZmZlclsxXSA9IDB4ZmYgJiAoYWJ5dGUgfCAweDBhKTtcbiAgICAgICAgICAgIC8qIHdhcyAweDBiOyAqL1xuICAgICAgICAgICAgYWJ5dGUgPSAweGZmICYgKGJ1ZmZlclsyXSAmIDB4MGQpO1xuICAgICAgICAgICAgLyogQUYga2VlcCBhbHNvIHByaXZhdGUgYml0ICovXG4gICAgICAgICAgICBidWZmZXJbMl0gPSAweGZmICYgKGJieXRlIHwgYWJ5dGUpO1xuICAgICAgICAgICAgLyogNjRrYnMgTVBFRzEgZnJhbWUgKi9cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8qIE1QRUcyICovXG4gICAgICAgICAgICBidWZmZXJbMV0gPSAweGZmICYgKGFieXRlIHwgMHgwMik7XG4gICAgICAgICAgICAvKiB3YXMgMHgwMzsgKi9cbiAgICAgICAgICAgIGFieXRlID0gMHhmZiAmIChidWZmZXJbMl0gJiAweDBkKTtcbiAgICAgICAgICAgIC8qIEFGIGtlZXAgYWxzbyBwcml2YXRlIGJpdCAqL1xuICAgICAgICAgICAgYnVmZmVyWzJdID0gMHhmZiAmIChiYnl0ZSB8IGFieXRlKTtcbiAgICAgICAgICAgIC8qIDY0a2JzIE1QRUcyIGZyYW1lICovXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgVkJSIHRhZyBpbmZvcm1hdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIGJ1ZlxuICAgICAqICAgICAgICAgICAgaGVhZGVyIHRvIGFuYWx5emVcbiAgICAgKiBAcGFyYW0gYnVmUG9zXG4gICAgICogICAgICAgICAgICBvZmZzZXQgaW50byB0aGUgaGVhZGVyXG4gICAgICogQHJldHVybiBWQlIgdGFnIGRhdGFcbiAgICAgKi9cbiAgICB0aGlzLmdldFZiclRhZyA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICAgICAgdmFyIHBUYWdEYXRhID0gbmV3IFZCUlRhZ0RhdGEoKTtcbiAgICAgICAgdmFyIGJ1ZlBvcyA9IDA7XG5cbiAgICAgICAgLyogZ2V0IFZiciBoZWFkZXIgZGF0YSAqL1xuICAgICAgICBwVGFnRGF0YS5mbGFncyA9IDA7XG5cbiAgICAgICAgLyogZ2V0IHNlbGVjdGVkIE1QRUcgaGVhZGVyIGRhdGEgKi9cbiAgICAgICAgdmFyIGhJZCA9IChidWZbYnVmUG9zICsgMV0gPj4gMykgJiAxO1xuICAgICAgICB2YXIgaFNySW5kZXggPSAoYnVmW2J1ZlBvcyArIDJdID4+IDIpICYgMztcbiAgICAgICAgdmFyIGhNb2RlID0gKGJ1ZltidWZQb3MgKyAzXSA+PiA2KSAmIDM7XG4gICAgICAgIHZhciBoQml0cmF0ZSA9ICgoYnVmW2J1ZlBvcyArIDJdID4+IDQpICYgMHhmKTtcbiAgICAgICAgaEJpdHJhdGUgPSBUYWJsZXMuYml0cmF0ZV90YWJsZVtoSWRdW2hCaXRyYXRlXTtcblxuICAgICAgICAvKiBjaGVjayBmb3IgRkZFIHN5bmN3b3JkICovXG4gICAgICAgIGlmICgoYnVmW2J1ZlBvcyArIDFdID4+IDQpID09IDB4RSlcbiAgICAgICAgICAgIHBUYWdEYXRhLnNhbXByYXRlID0gVGFibGVzLnNhbXBsZXJhdGVfdGFibGVbMl1baFNySW5kZXhdO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBwVGFnRGF0YS5zYW1wcmF0ZSA9IFRhYmxlcy5zYW1wbGVyYXRlX3RhYmxlW2hJZF1baFNySW5kZXhdO1xuXG4gICAgICAgIC8qIGRldGVybWluZSBvZmZzZXQgb2YgaGVhZGVyICovXG4gICAgICAgIGlmIChoSWQgIT0gMCkge1xuICAgICAgICAgICAgLyogbXBlZzEgKi9cbiAgICAgICAgICAgIGlmIChoTW9kZSAhPSAzKVxuICAgICAgICAgICAgICAgIGJ1ZlBvcyArPSAoMzIgKyA0KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBidWZQb3MgKz0gKDE3ICsgNCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvKiBtcGVnMiAqL1xuICAgICAgICAgICAgaWYgKGhNb2RlICE9IDMpXG4gICAgICAgICAgICAgICAgYnVmUG9zICs9ICgxNyArIDQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJ1ZlBvcyArPSAoOSArIDQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1ZiclRhZyhidWYsIGJ1ZlBvcykpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICBidWZQb3MgKz0gNDtcblxuICAgICAgICBwVGFnRGF0YS5oSWQgPSBoSWQ7XG5cbiAgICAgICAgLyogZ2V0IGZsYWdzICovXG4gICAgICAgIHZhciBoZWFkX2ZsYWdzID0gcFRhZ0RhdGEuZmxhZ3MgPSBleHRyYWN0SW50ZWdlcihidWYsIGJ1ZlBvcyk7XG4gICAgICAgIGJ1ZlBvcyArPSA0O1xuXG4gICAgICAgIGlmICgoaGVhZF9mbGFncyAmIEZSQU1FU19GTEFHKSAhPSAwKSB7XG4gICAgICAgICAgICBwVGFnRGF0YS5mcmFtZXMgPSBleHRyYWN0SW50ZWdlcihidWYsIGJ1ZlBvcyk7XG4gICAgICAgICAgICBidWZQb3MgKz0gNDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoaGVhZF9mbGFncyAmIEJZVEVTX0ZMQUcpICE9IDApIHtcbiAgICAgICAgICAgIHBUYWdEYXRhLmJ5dGVzID0gZXh0cmFjdEludGVnZXIoYnVmLCBidWZQb3MpO1xuICAgICAgICAgICAgYnVmUG9zICs9IDQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKGhlYWRfZmxhZ3MgJiBUT0NfRkxBRykgIT0gMCkge1xuICAgICAgICAgICAgaWYgKHBUYWdEYXRhLnRvYyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOVU1UT0NFTlRSSUVTOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIHBUYWdEYXRhLnRvY1tpXSA9IGJ1ZltidWZQb3MgKyBpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZlBvcyArPSBOVU1UT0NFTlRSSUVTO1xuICAgICAgICB9XG5cbiAgICAgICAgcFRhZ0RhdGEudmJyU2NhbGUgPSAtMTtcblxuICAgICAgICBpZiAoKGhlYWRfZmxhZ3MgJiBWQlJfU0NBTEVfRkxBRykgIT0gMCkge1xuICAgICAgICAgICAgcFRhZ0RhdGEudmJyU2NhbGUgPSBleHRyYWN0SW50ZWdlcihidWYsIGJ1ZlBvcyk7XG4gICAgICAgICAgICBidWZQb3MgKz0gNDtcbiAgICAgICAgfVxuXG4gICAgICAgIHBUYWdEYXRhLmhlYWRlcnNpemUgPSAoKGhJZCArIDEpICogNzIwMDAgKiBoQml0cmF0ZSlcbiAgICAgICAgICAgIC8gcFRhZ0RhdGEuc2FtcHJhdGU7XG5cbiAgICAgICAgYnVmUG9zICs9IDIxO1xuICAgICAgICB2YXIgZW5jRGVsYXkgPSBidWZbYnVmUG9zICsgMF0gPDwgNDtcbiAgICAgICAgZW5jRGVsYXkgKz0gYnVmW2J1ZlBvcyArIDFdID4+IDQ7XG4gICAgICAgIHZhciBlbmNQYWRkaW5nID0gKGJ1ZltidWZQb3MgKyAxXSAmIDB4MEYpIDw8IDg7XG4gICAgICAgIGVuY1BhZGRpbmcgKz0gYnVmW2J1ZlBvcyArIDJdICYgMHhmZjtcbiAgICAgICAgLyogY2hlY2sgZm9yIHJlYXNvbmFibGUgdmFsdWVzICh0aGlzIG1heSBiZSBhbiBvbGQgWGluZyBoZWFkZXIsICovXG4gICAgICAgIC8qIG5vdCBhIElORk8gdGFnKSAqL1xuICAgICAgICBpZiAoZW5jRGVsYXkgPCAwIHx8IGVuY0RlbGF5ID4gMzAwMClcbiAgICAgICAgICAgIGVuY0RlbGF5ID0gLTE7XG4gICAgICAgIGlmIChlbmNQYWRkaW5nIDwgMCB8fCBlbmNQYWRkaW5nID4gMzAwMClcbiAgICAgICAgICAgIGVuY1BhZGRpbmcgPSAtMTtcblxuICAgICAgICBwVGFnRGF0YS5lbmNEZWxheSA9IGVuY0RlbGF5O1xuICAgICAgICBwVGFnRGF0YS5lbmNQYWRkaW5nID0gZW5jUGFkZGluZztcblxuICAgICAgICAvKiBzdWNjZXNzICovXG4gICAgICAgIHJldHVybiBwVGFnRGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgaGVhZGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZ2ZwXG4gICAgICogICAgICAgICAgICBnbG9iYWwgZmxhZ3NcbiAgICAgKi9cbiAgICB0aGlzLkluaXRWYnJUYWcgPSBmdW5jdGlvbiAoZ2ZwKSB7XG4gICAgICAgIHZhciBnZmMgPSBnZnAuaW50ZXJuYWxfZmxhZ3M7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxQUkU+XG4gICAgICAgICAqIFhpbmcgVkJSIHByZXRlbmRzIHRvIGJlIGEgNDhrYnMgbGF5ZXIgSUlJIGZyYW1lLiAgKGF0IDQ0LjFrSHopLlxuICAgICAgICAgKiAoYXQgNDhrSHogdGhleSB1c2UgNTZrYnMgc2luY2UgNDhrYnMgZnJhbWUgbm90IGJpZyBlbm91Z2ggZm9yXG4gICAgICAgICAqIHRhYmxlIG9mIGNvbnRlbnRzKVxuICAgICAgICAgKiBsZXQncyBhbHdheXMgZW1iZWQgWGluZyBoZWFkZXIgaW5zaWRlIGEgNjRrYnMgbGF5ZXIgSUlJIGZyYW1lLlxuICAgICAgICAgKiB0aGlzIGdpdmVzIHVzIGVub3VnaCByb29tIGZvciBhIExBTUUgdmVyc2lvbiBzdHJpbmcgdG9vLlxuICAgICAgICAgKiBzaXplIGRldGVybWluZWQgYnkgc2FtcGxpbmcgZnJlcXVlbmN5IChNUEVHMSlcbiAgICAgICAgICogMzJrSHo6ICAgIDIxNiBieXRlc0A0OGticyAgICAyODhieXRlc0AgNjRrYnNcbiAgICAgICAgICogNDQuMWtIejogIDE1NiBieXRlcyAgICAgICAgICAyMDhieXRlc0A2NGticyAgICAgKCsxIGlmIHBhZGRpbmcgPSAxKVxuICAgICAgICAgKiA0OGtIejogICAgMTQ0IGJ5dGVzICAgICAgICAgIDE5MlxuICAgICAgICAgKlxuICAgICAgICAgKiBNUEVHIDIgdmFsdWVzIGFyZSB0aGUgc2FtZSBzaW5jZSB0aGUgZnJhbWVzaXplIGFuZCBzYW1wbGVyYXRlXG4gICAgICAgICAqIGFyZSBlYWNoIHJlZHVjZWQgYnkgYSBmYWN0b3Igb2YgMi5cbiAgICAgICAgICogPC9QUkU+XG4gICAgICAgICAqL1xuICAgICAgICB2YXIga2Jwc19oZWFkZXI7XG4gICAgICAgIGlmICgxID09IGdmcC52ZXJzaW9uKSB7XG4gICAgICAgICAgICBrYnBzX2hlYWRlciA9IFhJTkdfQklUUkFURTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZ2ZwLm91dF9zYW1wbGVyYXRlIDwgMTYwMDApXG4gICAgICAgICAgICAgICAga2Jwc19oZWFkZXIgPSBYSU5HX0JJVFJBVEUyNTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBrYnBzX2hlYWRlciA9IFhJTkdfQklUUkFURTI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2ZwLlZCUiA9PSBWYnJNb2RlLnZicl9vZmYpXG4gICAgICAgICAgICBrYnBzX2hlYWRlciA9IGdmcC5icmF0ZTtcblxuICAgICAgICAvLyBtYWtlIHN1cmUgTEFNRSBIZWFkZXIgZml0cyBpbnRvIEZyYW1lXG4gICAgICAgIHZhciB0b3RhbEZyYW1lU2l6ZSA9ICgoZ2ZwLnZlcnNpb24gKyAxKSAqIDcyMDAwICoga2Jwc19oZWFkZXIpXG4gICAgICAgICAgICAvIGdmcC5vdXRfc2FtcGxlcmF0ZTtcbiAgICAgICAgdmFyIGhlYWRlclNpemUgPSAoZ2ZjLnNpZGVpbmZvX2xlbiArIExBTUVIRUFERVJTSVpFKTtcbiAgICAgICAgZ2ZjLlZCUl9zZWVrX3RhYmxlLlRvdGFsRnJhbWVTaXplID0gdG90YWxGcmFtZVNpemU7XG4gICAgICAgIGlmICh0b3RhbEZyYW1lU2l6ZSA8IGhlYWRlclNpemUgfHwgdG90YWxGcmFtZVNpemUgPiBNQVhGUkFNRVNJWkUpIHtcbiAgICAgICAgICAgIC8qIGRpc2FibGUgdGFnLCBpdCB3b250IGZpdCAqL1xuICAgICAgICAgICAgZ2ZwLmJXcml0ZVZiclRhZyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2ZjLlZCUl9zZWVrX3RhYmxlLm5WYnJOdW1GcmFtZXMgPSAwO1xuICAgICAgICBnZmMuVkJSX3NlZWtfdGFibGUubkJ5dGVzV3JpdHRlbiA9IDA7XG4gICAgICAgIGdmYy5WQlJfc2Vla190YWJsZS5zdW0gPSAwO1xuXG4gICAgICAgIGdmYy5WQlJfc2Vla190YWJsZS5zZWVuID0gMDtcbiAgICAgICAgZ2ZjLlZCUl9zZWVrX3RhYmxlLndhbnQgPSAxO1xuICAgICAgICBnZmMuVkJSX3NlZWtfdGFibGUucG9zID0gMDtcblxuICAgICAgICBpZiAoZ2ZjLlZCUl9zZWVrX3RhYmxlLmJhZyA9PSBudWxsKSB7XG4gICAgICAgICAgICBnZmMuVkJSX3NlZWtfdGFibGUuYmFnID0gbmV3IGludFs0MDBdO1xuICAgICAgICAgICAgZ2ZjLlZCUl9zZWVrX3RhYmxlLnNpemUgPSA0MDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3cml0ZSBkdW1teSBWQlIgdGFnIG9mIGFsbCAwJ3MgaW50byBiaXRzdHJlYW1cbiAgICAgICAgdmFyIGJ1ZmZlciA9IG5ld19ieXRlKE1BWEZSQU1FU0laRSk7XG5cbiAgICAgICAgc2V0TGFtZVRhZ0ZyYW1lSGVhZGVyKGdmcCwgYnVmZmVyKTtcbiAgICAgICAgdmFyIG4gPSBnZmMuVkJSX3NlZWtfdGFibGUuVG90YWxGcmFtZVNpemU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBicy5hZGRfZHVtbXlfYnl0ZShnZnAsIGJ1ZmZlcltpXSAmIDB4ZmYsIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmFzdCBDUkMtMTYgY29tcHV0YXRpb24gKHVzZXMgdGFibGUgY3JjMTZMb29rdXApLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHBhcmFtIGNyY1xuICAgICAqIEByZXR1cm5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmNVcGRhdGVMb29rdXAodmFsdWUsIGNyYykge1xuICAgICAgICB2YXIgdG1wID0gY3JjIF4gdmFsdWU7XG4gICAgICAgIGNyYyA9IChjcmMgPj4gOCkgXiBjcmMxNkxvb2t1cFt0bXAgJiAweGZmXTtcbiAgICAgICAgcmV0dXJuIGNyYztcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZU11c2ljQ1JDID0gZnVuY3Rpb24gKGNyYywgYnVmZmVyLCBidWZmZXJQb3MsIHNpemUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpXG4gICAgICAgICAgICBjcmNbMF0gPSBjcmNVcGRhdGVMb29rdXAoYnVmZmVyW2J1ZmZlclBvcyArIGldLCBjcmNbMF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdyaXRlIExBTUUgaW5mbzogbWluaSB2ZXJzaW9uICsgaW5mbyBvbiB2YXJpb3VzIHN3aXRjaGVzIHVzZWQgKEpvbmF0aGFuXG4gICAgICogRGVlIDIwMDEvMDgvMzEpLlxuICAgICAqXG4gICAgICogQHBhcmFtIGdmcFxuICAgICAqICAgICAgICAgICAgZ2xvYmFsIGZsYWdzXG4gICAgICogQHBhcmFtIG11c2ljTGVuZ3RoXG4gICAgICogICAgICAgICAgICBtdXNpYyBsZW5ndGhcbiAgICAgKiBAcGFyYW0gc3RyZWFtQnVmZmVyXG4gICAgICogICAgICAgICAgICBwb2ludGVyIHRvIG91dHB1dCBidWZmZXJcbiAgICAgKiBAcGFyYW0gc3RyZWFtQnVmZmVyUG9zXG4gICAgICogICAgICAgICAgICBvZmZzZXQgaW50byB0aGUgb3V0cHV0IGJ1ZmZlclxuICAgICAqIEBwYXJhbSBjcmNcbiAgICAgKiAgICAgICAgICAgIGNvbXB1dGF0aW9uIG9mIENSQy0xNiBvZiBMYW1lIFRhZyBzbyBmYXIgKHN0YXJ0aW5nIGF0IGZyYW1lXG4gICAgICogICAgICAgICAgICBzeW5jKVxuICAgICAqIEByZXR1cm4gbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4gdG8gdGhlIHN0cmVhbVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1dExhbWVWQlIoZ2ZwLCBtdXNpY0xlbmd0aCwgc3RyZWFtQnVmZmVyLCBzdHJlYW1CdWZmZXJQb3MsIGNyYykge1xuICAgICAgICB2YXIgZ2ZjID0gZ2ZwLmludGVybmFsX2ZsYWdzO1xuICAgICAgICB2YXIgYnl0ZXNXcml0dGVuID0gMDtcblxuICAgICAgICAvKiBlbmNvZGVyIGRlbGF5ICovXG4gICAgICAgIHZhciBlbmNEZWxheSA9IGdmcC5lbmNvZGVyX2RlbGF5O1xuICAgICAgICAvKiBlbmNvZGVyIHBhZGRpbmcgKi9cbiAgICAgICAgdmFyIGVuY1BhZGRpbmcgPSBnZnAuZW5jb2Rlcl9wYWRkaW5nO1xuXG4gICAgICAgIC8qIHJlY2FsbDogZ2ZwLlZCUl9xIGlzIGZvciBleGFtcGxlIHNldCBieSB0aGUgc3dpdGNoIC1WICovXG4gICAgICAgIC8qIGdmcC5xdWFsaXR5IGJ5IC1xLCAtaCwgLWYsIGV0YyAqL1xuICAgICAgICB2YXIgcXVhbGl0eSA9ICgxMDAgLSAxMCAqIGdmcC5WQlJfcSAtIGdmcC5xdWFsaXR5KTtcblxuICAgICAgICB2YXIgdmVyc2lvbiA9IHYuZ2V0TGFtZVZlcnlTaG9ydFZlcnNpb24oKTtcbiAgICAgICAgdmFyIHZicjtcbiAgICAgICAgdmFyIHJldmlzaW9uID0gMHgwMDtcbiAgICAgICAgdmFyIHJldk1ldGhvZDtcbiAgICAgICAgLy8gbnVtYmVyaW5nIGRpZmZlcmVudCBpbiB2YnJfbW9kZSB2cy4gTGFtZSB0YWdcbiAgICAgICAgdmFyIHZiclR5cGVUcmFuc2xhdG9yID0gWzEsIDUsIDMsIDIsIDQsIDAsIDNdO1xuICAgICAgICB2YXIgbG93cGFzcyA9IDAgfCAoKChnZnAubG93cGFzc2ZyZXEgLyAxMDAuMCkgKyAuNSkgPiAyNTUgPyAyNTVcbiAgICAgICAgICAgICAgICA6IChnZnAubG93cGFzc2ZyZXEgLyAxMDAuMCkgKyAuNSk7XG4gICAgICAgIHZhciBwZWFrU2lnbmFsQW1wbGl0dWRlID0gMDtcbiAgICAgICAgdmFyIHJhZGlvUmVwbGF5R2FpbiA9IDA7XG4gICAgICAgIHZhciBhdWRpb3BoaWxlUmVwbGF5R2FpbiA9IDA7XG4gICAgICAgIHZhciBub2lzZVNoYXBpbmcgPSBnZnAuaW50ZXJuYWxfZmxhZ3Mubm9pc2Vfc2hhcGluZztcbiAgICAgICAgdmFyIHN0ZXJlb01vZGUgPSAwO1xuICAgICAgICB2YXIgbm9uT3B0aW1hbCA9IDA7XG4gICAgICAgIHZhciBzb3VyY2VGcmVxID0gMDtcbiAgICAgICAgdmFyIG1pc2MgPSAwO1xuICAgICAgICB2YXIgbXVzaWNDUkMgPSAwO1xuXG4gICAgICAgIC8vIHBzeSBtb2RlbCB0eXBlOiBHcHN5Y2hvIG9yIE5zUHN5dHVuZVxuICAgICAgICB2YXIgZXhwTlBzeVR1bmUgPSAoZ2ZwLmV4cF9uc3BzeXR1bmUgJiAxKSAhPSAwO1xuICAgICAgICB2YXIgc2FmZUpvaW50ID0gKGdmcC5leHBfbnNwc3l0dW5lICYgMikgIT0gMDtcbiAgICAgICAgdmFyIG5vR2FwTW9yZSA9IGZhbHNlO1xuICAgICAgICB2YXIgbm9HYXBQcmV2aW91cyA9IGZhbHNlO1xuICAgICAgICB2YXIgbm9HYXBDb3VudCA9IGdmcC5pbnRlcm5hbF9mbGFncy5ub2dhcF90b3RhbDtcbiAgICAgICAgdmFyIG5vR2FwQ3VyciA9IGdmcC5pbnRlcm5hbF9mbGFncy5ub2dhcF9jdXJyZW50O1xuXG4gICAgICAgIC8vIDQgYml0c1xuICAgICAgICB2YXIgYXRoVHlwZSA9IGdmcC5BVEh0eXBlO1xuICAgICAgICB2YXIgZmxhZ3MgPSAwO1xuXG4gICAgICAgIC8vIHZiciBtb2Rlc1xuICAgICAgICB2YXIgYWJyQml0cmF0ZTtcbiAgICAgICAgc3dpdGNoIChnZnAuVkJSKSB7XG4gICAgICAgICAgICBjYXNlIHZicl9hYnI6XG4gICAgICAgICAgICAgICAgYWJyQml0cmF0ZSA9IGdmcC5WQlJfbWVhbl9iaXRyYXRlX2ticHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHZicl9vZmY6XG4gICAgICAgICAgICAgICAgYWJyQml0cmF0ZSA9IGdmcC5icmF0ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYWJyQml0cmF0ZSA9IGdmcC5WQlJfbWluX2JpdHJhdGVfa2JwcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJldmlzaW9uIGFuZCB2YnIgbWV0aG9kXG4gICAgICAgIGlmIChnZnAuVkJSLm9yZGluYWwoKSA8IHZiclR5cGVUcmFuc2xhdG9yLmxlbmd0aClcbiAgICAgICAgICAgIHZiciA9IHZiclR5cGVUcmFuc2xhdG9yW2dmcC5WQlIub3JkaW5hbCgpXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdmJyID0gMHgwMDsgLy8gdW5rbm93blxuXG4gICAgICAgIHJldk1ldGhvZCA9IDB4MTAgKiByZXZpc2lvbiArIHZicjtcblxuICAgICAgICAvLyBSZXBsYXlHYWluXG4gICAgICAgIGlmIChnZmMuZmluZFJlcGxheUdhaW4pIHtcbiAgICAgICAgICAgIGlmIChnZmMuUmFkaW9HYWluID4gMHgxRkUpXG4gICAgICAgICAgICAgICAgZ2ZjLlJhZGlvR2FpbiA9IDB4MUZFO1xuICAgICAgICAgICAgaWYgKGdmYy5SYWRpb0dhaW4gPCAtMHgxRkUpXG4gICAgICAgICAgICAgICAgZ2ZjLlJhZGlvR2FpbiA9IC0weDFGRTtcblxuICAgICAgICAgICAgLy8gc2V0IG5hbWUgY29kZVxuICAgICAgICAgICAgcmFkaW9SZXBsYXlHYWluID0gMHgyMDAwO1xuICAgICAgICAgICAgLy8gc2V0IG9yaWdpbmF0b3IgY29kZSB0byBgZGV0ZXJtaW5lZCBhdXRvbWF0aWNhbGx5J1xuICAgICAgICAgICAgcmFkaW9SZXBsYXlHYWluIHw9IDB4QzAwO1xuXG4gICAgICAgICAgICBpZiAoZ2ZjLlJhZGlvR2FpbiA+PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gc2V0IGdhaW4gYWRqdXN0bWVudFxuICAgICAgICAgICAgICAgIHJhZGlvUmVwbGF5R2FpbiB8PSBnZmMuUmFkaW9HYWluO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzZXQgdGhlIHNpZ24gYml0XG4gICAgICAgICAgICAgICAgcmFkaW9SZXBsYXlHYWluIHw9IDB4MjAwO1xuICAgICAgICAgICAgICAgIC8vIHNldCBnYWluIGFkanVzdG1lbnRcbiAgICAgICAgICAgICAgICByYWRpb1JlcGxheUdhaW4gfD0gLWdmYy5SYWRpb0dhaW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwZWFrIHNhbXBsZVxuICAgICAgICBpZiAoZ2ZjLmZpbmRQZWFrU2FtcGxlKVxuICAgICAgICAgICAgcGVha1NpZ25hbEFtcGxpdHVkZSA9IE1hdGhcbiAgICAgICAgICAgICAgICAuYWJzKDAgfCAoKCggZ2ZjLlBlYWtTYW1wbGUpIC8gMzI3NjcuMCkgKiBNYXRoLnBvdygyLCAyMykgKyAuNSkpO1xuXG4gICAgICAgIC8vIG5vZ2FwXG4gICAgICAgIGlmIChub0dhcENvdW50ICE9IC0xKSB7XG4gICAgICAgICAgICBpZiAobm9HYXBDdXJyID4gMClcbiAgICAgICAgICAgICAgICBub0dhcFByZXZpb3VzID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKG5vR2FwQ3VyciA8IG5vR2FwQ291bnQgLSAxKVxuICAgICAgICAgICAgICAgIG5vR2FwTW9yZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmbGFnc1xuICAgICAgICBmbGFncyA9IGF0aFR5cGUgKyAoKGV4cE5Qc3lUdW5lID8gMSA6IDApIDw8IDQpXG4gICAgICAgICAgICArICgoc2FmZUpvaW50ID8gMSA6IDApIDw8IDUpICsgKChub0dhcE1vcmUgPyAxIDogMCkgPDwgNilcbiAgICAgICAgICAgICsgKChub0dhcFByZXZpb3VzID8gMSA6IDApIDw8IDcpO1xuXG4gICAgICAgIGlmIChxdWFsaXR5IDwgMClcbiAgICAgICAgICAgIHF1YWxpdHkgPSAwO1xuXG4gICAgICAgIC8vIHN0ZXJlbyBtb2RlIGZpZWxkIChJbnRlbnNpdHkgc3RlcmVvIGlzIG5vdCBpbXBsZW1lbnRlZClcbiAgICAgICAgc3dpdGNoIChnZnAubW9kZSkge1xuICAgICAgICAgICAgY2FzZSBNT05POlxuICAgICAgICAgICAgICAgIHN0ZXJlb01vZGUgPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTVEVSRU86XG4gICAgICAgICAgICAgICAgc3RlcmVvTW9kZSA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERVQUxfQ0hBTk5FTDpcbiAgICAgICAgICAgICAgICBzdGVyZW9Nb2RlID0gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgSk9JTlRfU1RFUkVPOlxuICAgICAgICAgICAgICAgIGlmIChnZnAuZm9yY2VfbXMpXG4gICAgICAgICAgICAgICAgICAgIHN0ZXJlb01vZGUgPSA0O1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgc3RlcmVvTW9kZSA9IDM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE5PVF9TRVQ6XG4gICAgICAgICAgICAvLyRGQUxMLVRIUk9VR0gkXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHN0ZXJlb01vZGUgPSA3O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdmcC5pbl9zYW1wbGVyYXRlIDw9IDMyMDAwKVxuICAgICAgICAgICAgc291cmNlRnJlcSA9IDB4MDA7XG4gICAgICAgIGVsc2UgaWYgKGdmcC5pbl9zYW1wbGVyYXRlID09IDQ4MDAwKVxuICAgICAgICAgICAgc291cmNlRnJlcSA9IDB4MDI7XG4gICAgICAgIGVsc2UgaWYgKGdmcC5pbl9zYW1wbGVyYXRlID4gNDgwMDApXG4gICAgICAgICAgICBzb3VyY2VGcmVxID0gMHgwMztcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBkZWZhdWx0IGlzIDQ0MTAwSHpcbiAgICAgICAgICAgIHNvdXJjZUZyZXEgPSAweDAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHVzZXIgb3ZlcnJpZGVkIHRoZSBkZWZhdWx0IExBTUUgYmVoYXZpb3Igd2l0aCBzb21lXG4gICAgICAgIC8vIG5hc3R5IG9wdGlvbnNcbiAgICAgICAgaWYgKGdmcC5zaG9ydF9ibG9ja3MgPT0gU2hvcnRCbG9jay5zaG9ydF9ibG9ja19mb3JjZWRcbiAgICAgICAgICAgIHx8IGdmcC5zaG9ydF9ibG9ja3MgPT0gU2hvcnRCbG9jay5zaG9ydF9ibG9ja19kaXNwZW5zZWRcbiAgICAgICAgICAgIHx8ICgoZ2ZwLmxvd3Bhc3NmcmVxID09IC0xKSAmJiAoZ2ZwLmhpZ2hwYXNzZnJlcSA9PSAtMSkpIHx8IC8qIFwiLWtcIiAqL1xuICAgICAgICAgICAgKGdmcC5zY2FsZV9sZWZ0IDwgZ2ZwLnNjYWxlX3JpZ2h0KVxuICAgICAgICAgICAgfHwgKGdmcC5zY2FsZV9sZWZ0ID4gZ2ZwLnNjYWxlX3JpZ2h0KVxuICAgICAgICAgICAgfHwgKGdmcC5kaXNhYmxlX3Jlc2Vydm9pciAmJiBnZnAuYnJhdGUgPCAzMjApIHx8IGdmcC5ub0FUSFxuICAgICAgICAgICAgfHwgZ2ZwLkFUSG9ubHkgfHwgKGF0aFR5cGUgPT0gMCkgfHwgZ2ZwLmluX3NhbXBsZXJhdGUgPD0gMzIwMDApXG4gICAgICAgICAgICBub25PcHRpbWFsID0gMTtcblxuICAgICAgICBtaXNjID0gbm9pc2VTaGFwaW5nICsgKHN0ZXJlb01vZGUgPDwgMikgKyAobm9uT3B0aW1hbCA8PCA1KVxuICAgICAgICAgICAgKyAoc291cmNlRnJlcSA8PCA2KTtcblxuICAgICAgICBtdXNpY0NSQyA9IGdmYy5uTXVzaWNDUkM7XG5cbiAgICAgICAgLy8gV3JpdGUgYWxsIHRoaXMgaW5mb3JtYXRpb24gaW50byB0aGUgc3RyZWFtXG5cbiAgICAgICAgY3JlYXRlSW50ZWdlcihzdHJlYW1CdWZmZXIsIHN0cmVhbUJ1ZmZlclBvcyArIGJ5dGVzV3JpdHRlbiwgcXVhbGl0eSk7XG4gICAgICAgIGJ5dGVzV3JpdHRlbiArPSA0O1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgOTsgaisrKSB7XG4gICAgICAgICAgICBzdHJlYW1CdWZmZXJbc3RyZWFtQnVmZmVyUG9zICsgYnl0ZXNXcml0dGVuICsgal0gPSAweGZmICYgdmVyc2lvbiAuY2hhckF0KGopO1xuICAgICAgICB9XG4gICAgICAgIGJ5dGVzV3JpdHRlbiArPSA5O1xuXG4gICAgICAgIHN0cmVhbUJ1ZmZlcltzdHJlYW1CdWZmZXJQb3MgKyBieXRlc1dyaXR0ZW5dID0gMHhmZiAmIHJldk1ldGhvZDtcbiAgICAgICAgYnl0ZXNXcml0dGVuKys7XG5cbiAgICAgICAgc3RyZWFtQnVmZmVyW3N0cmVhbUJ1ZmZlclBvcyArIGJ5dGVzV3JpdHRlbl0gPSAweGZmICYgbG93cGFzcztcbiAgICAgICAgYnl0ZXNXcml0dGVuKys7XG5cbiAgICAgICAgY3JlYXRlSW50ZWdlcihzdHJlYW1CdWZmZXIsIHN0cmVhbUJ1ZmZlclBvcyArIGJ5dGVzV3JpdHRlbixcbiAgICAgICAgICAgIHBlYWtTaWduYWxBbXBsaXR1ZGUpO1xuICAgICAgICBieXRlc1dyaXR0ZW4gKz0gNDtcblxuICAgICAgICBjcmVhdGVTaG9ydChzdHJlYW1CdWZmZXIsIHN0cmVhbUJ1ZmZlclBvcyArIGJ5dGVzV3JpdHRlbixcbiAgICAgICAgICAgIHJhZGlvUmVwbGF5R2Fpbik7XG4gICAgICAgIGJ5dGVzV3JpdHRlbiArPSAyO1xuXG4gICAgICAgIGNyZWF0ZVNob3J0KHN0cmVhbUJ1ZmZlciwgc3RyZWFtQnVmZmVyUG9zICsgYnl0ZXNXcml0dGVuLFxuICAgICAgICAgICAgYXVkaW9waGlsZVJlcGxheUdhaW4pO1xuICAgICAgICBieXRlc1dyaXR0ZW4gKz0gMjtcblxuICAgICAgICBzdHJlYW1CdWZmZXJbc3RyZWFtQnVmZmVyUG9zICsgYnl0ZXNXcml0dGVuXSA9IDB4ZmYgJiBmbGFncztcbiAgICAgICAgYnl0ZXNXcml0dGVuKys7XG5cbiAgICAgICAgaWYgKGFickJpdHJhdGUgPj0gMjU1KVxuICAgICAgICAgICAgc3RyZWFtQnVmZmVyW3N0cmVhbUJ1ZmZlclBvcyArIGJ5dGVzV3JpdHRlbl0gPSAweEZGO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBzdHJlYW1CdWZmZXJbc3RyZWFtQnVmZmVyUG9zICsgYnl0ZXNXcml0dGVuXSA9IDB4ZmYgJiBhYnJCaXRyYXRlO1xuICAgICAgICBieXRlc1dyaXR0ZW4rKztcblxuICAgICAgICBzdHJlYW1CdWZmZXJbc3RyZWFtQnVmZmVyUG9zICsgYnl0ZXNXcml0dGVuXSA9IDB4ZmYgJiAoZW5jRGVsYXkgPj4gNCk7XG4gICAgICAgIHN0cmVhbUJ1ZmZlcltzdHJlYW1CdWZmZXJQb3MgKyBieXRlc1dyaXR0ZW4gKyAxXSA9IDB4ZmYgJiAoKGVuY0RlbGF5IDw8IDQpICsgKGVuY1BhZGRpbmcgPj4gOCkpO1xuICAgICAgICBzdHJlYW1CdWZmZXJbc3RyZWFtQnVmZmVyUG9zICsgYnl0ZXNXcml0dGVuICsgMl0gPSAweGZmICYgZW5jUGFkZGluZztcblxuICAgICAgICBieXRlc1dyaXR0ZW4gKz0gMztcblxuICAgICAgICBzdHJlYW1CdWZmZXJbc3RyZWFtQnVmZmVyUG9zICsgYnl0ZXNXcml0dGVuXSA9IDB4ZmYgJiBtaXNjO1xuICAgICAgICBieXRlc1dyaXR0ZW4rKztcblxuICAgICAgICAvLyB1bnVzZWQgaW4gcmV2MFxuICAgICAgICBzdHJlYW1CdWZmZXJbc3RyZWFtQnVmZmVyUG9zICsgYnl0ZXNXcml0dGVuKytdID0gMDtcblxuICAgICAgICBjcmVhdGVTaG9ydChzdHJlYW1CdWZmZXIsIHN0cmVhbUJ1ZmZlclBvcyArIGJ5dGVzV3JpdHRlbiwgZ2ZwLnByZXNldCk7XG4gICAgICAgIGJ5dGVzV3JpdHRlbiArPSAyO1xuXG4gICAgICAgIGNyZWF0ZUludGVnZXIoc3RyZWFtQnVmZmVyLCBzdHJlYW1CdWZmZXJQb3MgKyBieXRlc1dyaXR0ZW4sIG11c2ljTGVuZ3RoKTtcbiAgICAgICAgYnl0ZXNXcml0dGVuICs9IDQ7XG5cbiAgICAgICAgY3JlYXRlU2hvcnQoc3RyZWFtQnVmZmVyLCBzdHJlYW1CdWZmZXJQb3MgKyBieXRlc1dyaXR0ZW4sIG11c2ljQ1JDKTtcbiAgICAgICAgYnl0ZXNXcml0dGVuICs9IDI7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRhZyBDUkMuLi4uIG11c3QgYmUgZG9uZSBoZXJlLCBzaW5jZSBpdCBpbmNsdWRlcyBwcmV2aW91c1xuICAgICAgICAvLyBpbmZvcm1hdGlvblxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXNXcml0dGVuOyBpKyspXG4gICAgICAgICAgICBjcmMgPSBjcmNVcGRhdGVMb29rdXAoc3RyZWFtQnVmZmVyW3N0cmVhbUJ1ZmZlclBvcyArIGldLCBjcmMpO1xuXG4gICAgICAgIGNyZWF0ZVNob3J0KHN0cmVhbUJ1ZmZlciwgc3RyZWFtQnVmZmVyUG9zICsgYnl0ZXNXcml0dGVuLCBjcmMpO1xuICAgICAgICBieXRlc1dyaXR0ZW4gKz0gMjtcblxuICAgICAgICByZXR1cm4gYnl0ZXNXcml0dGVuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNraXBJZDN2MihmcFN0cmVhbSkge1xuICAgICAgICAvLyBzZWVrIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHN0cmVhbVxuICAgICAgICBmcFN0cmVhbS5zZWVrKDApO1xuICAgICAgICAvLyByZWFkIDEwIGJ5dGVzIGluIGNhc2UgdGhlcmUncyBhbiBJRDMgdmVyc2lvbiAyIGhlYWRlciBoZXJlXG4gICAgICAgIHZhciBpZDN2MkhlYWRlciA9IG5ld19ieXRlKDEwKTtcbiAgICAgICAgZnBTdHJlYW0ucmVhZEZ1bGx5KGlkM3YySGVhZGVyKTtcbiAgICAgICAgLyogZG9lcyB0aGUgc3RyZWFtIGJlZ2luIHdpdGggdGhlIElEMyB2ZXJzaW9uIDIgZmlsZSBpZGVudGlmaWVyPyAqL1xuICAgICAgICB2YXIgaWQzdjJUYWdTaXplO1xuICAgICAgICBpZiAoIW5ldyBTdHJpbmcoaWQzdjJIZWFkZXIsIFwiSVNPLTg4NTktMVwiKS5zdGFydHNXaXRoKFwiSUQzXCIpKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogdGhlIHRhZyBzaXplIChtaW51cyB0aGUgMTAtYnl0ZSBoZWFkZXIpIGlzIGVuY29kZWQgaW50byBmb3VyXG4gICAgICAgICAgICAgKiBieXRlcyB3aGVyZSB0aGUgbW9zdCBzaWduaWZpY2FudCBiaXQgaXMgY2xlYXIgaW4gZWFjaCBieXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlkM3YyVGFnU2l6ZSA9ICgoKGlkM3YySGVhZGVyWzZdICYgMHg3ZikgPDwgMjEpXG4gICAgICAgICAgICAgICAgfCAoKGlkM3YySGVhZGVyWzddICYgMHg3ZikgPDwgMTQpXG4gICAgICAgICAgICAgICAgfCAoKGlkM3YySGVhZGVyWzhdICYgMHg3ZikgPDwgNykgfCAoaWQzdjJIZWFkZXJbOV0gJiAweDdmKSlcbiAgICAgICAgICAgICAgICArIGlkM3YySGVhZGVyLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8qIG5vIElEMyB2ZXJzaW9uIDIgdGFnIGluIHRoaXMgc3RyZWFtICovXG4gICAgICAgICAgICBpZDN2MlRhZ1NpemUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZDN2MlRhZ1NpemU7XG4gICAgfVxuXG4gICAgdGhpcy5nZXRMYW1lVGFnRnJhbWUgPSBmdW5jdGlvbiAoZ2ZwLCBidWZmZXIpIHtcbiAgICAgICAgdmFyIGdmYyA9IGdmcC5pbnRlcm5hbF9mbGFncztcblxuICAgICAgICBpZiAoIWdmcC5iV3JpdGVWYnJUYWcpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZmMuQ2xhc3NfSUQgIT0gTGFtZS5MQU1FX0lEKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2ZjLlZCUl9zZWVrX3RhYmxlLnBvcyA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA8IGdmYy5WQlJfc2Vla190YWJsZS5Ub3RhbEZyYW1lU2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGdmYy5WQlJfc2Vla190YWJsZS5Ub3RhbEZyYW1lU2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIEFycmF5cy5maWxsKGJ1ZmZlciwgMCwgZ2ZjLlZCUl9zZWVrX3RhYmxlLlRvdGFsRnJhbWVTaXplLCAwKTtcblxuICAgICAgICAvLyA0IGJ5dGVzIGZyYW1lIGhlYWRlclxuICAgICAgICBzZXRMYW1lVGFnRnJhbWVIZWFkZXIoZ2ZwLCBidWZmZXIpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBUT0MgZW50cmllc1xuICAgICAgICB2YXIgdG9jID0gbmV3X2J5dGUoTlVNVE9DRU5UUklFUyk7XG5cbiAgICAgICAgaWYgKGdmcC5mcmVlX2Zvcm1hdCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBOVU1UT0NFTlRSSUVTOyArK2kpXG4gICAgICAgICAgICAgICAgdG9jW2ldID0gMHhmZiAmICgyNTUgKiBpIC8gMTAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHhpbmdTZWVrVGFibGUoZ2ZjLlZCUl9zZWVrX3RhYmxlLCB0b2MpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RhcnQgd3JpdGluZyB0aGUgdGFnIGFmdGVyIHRoZSB6ZXJvIGZyYW1lXG4gICAgICAgIHZhciBzdHJlYW1JbmRleCA9IGdmYy5zaWRlaW5mb19sZW47XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb3RlOiBYaW5nIGhlYWRlciBzcGVjaWZpZXMgdGhhdCBYaW5nIGRhdGEgZ29lcyBpbiB0aGUgYW5jaWxsYXJ5IGRhdGFcbiAgICAgICAgICogd2l0aCBOTyBFUlJPUiBQUk9URUNUSU9OLiBJZiBlcnJvciBwcm90ZWN0b24gaW4gZW5hYmxlZCwgdGhlIFhpbmdcbiAgICAgICAgICogZGF0YSBzdGlsbCBzdGFydHMgYXQgdGhlIHNhbWUgb2Zmc2V0LCBhbmQgbm93IGl0IGlzIGluIHNpZGVpbmZvIGRhdGFcbiAgICAgICAgICogYmxvY2ssIGFuZCB0aHVzIHdpbGwgbm90IGRlY29kZSBjb3JyZWN0bHkgYnkgbm9uLVhpbmcgdGFnIGF3YXJlXG4gICAgICAgICAqIHBsYXllcnNcbiAgICAgICAgICovXG4gICAgICAgIGlmIChnZnAuZXJyb3JfcHJvdGVjdGlvbilcbiAgICAgICAgICAgIHN0cmVhbUluZGV4IC09IDI7XG5cbiAgICAgICAgLy8gUHV0IFZiciB0YWdcbiAgICAgICAgaWYgKGdmcC5WQlIgPT0gVmJyTW9kZS52YnJfb2ZmKSB7XG4gICAgICAgICAgICBidWZmZXJbc3RyZWFtSW5kZXgrK10gPSAweGZmICYgVkJSVGFnMS5jaGFyQXQoMCk7XG4gICAgICAgICAgICBidWZmZXJbc3RyZWFtSW5kZXgrK10gPSAweGZmICYgVkJSVGFnMS5jaGFyQXQoMSk7XG4gICAgICAgICAgICBidWZmZXJbc3RyZWFtSW5kZXgrK10gPSAweGZmICYgVkJSVGFnMS5jaGFyQXQoMik7XG4gICAgICAgICAgICBidWZmZXJbc3RyZWFtSW5kZXgrK10gPSAweGZmICYgVkJSVGFnMS5jaGFyQXQoMyk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZmZlcltzdHJlYW1JbmRleCsrXSA9IDB4ZmYgJiBWQlJUYWcwLmNoYXJBdCgwKTtcbiAgICAgICAgICAgIGJ1ZmZlcltzdHJlYW1JbmRleCsrXSA9IDB4ZmYgJiBWQlJUYWcwLmNoYXJBdCgxKTtcbiAgICAgICAgICAgIGJ1ZmZlcltzdHJlYW1JbmRleCsrXSA9IDB4ZmYgJiBWQlJUYWcwLmNoYXJBdCgyKTtcbiAgICAgICAgICAgIGJ1ZmZlcltzdHJlYW1JbmRleCsrXSA9IDB4ZmYgJiBWQlJUYWcwLmNoYXJBdCgzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFB1dCBoZWFkZXIgZmxhZ3NcbiAgICAgICAgY3JlYXRlSW50ZWdlcihidWZmZXIsIHN0cmVhbUluZGV4LCBGUkFNRVNfRkxBRyArIEJZVEVTX0ZMQUcgKyBUT0NfRkxBR1xuICAgICAgICAgICAgKyBWQlJfU0NBTEVfRkxBRyk7XG4gICAgICAgIHN0cmVhbUluZGV4ICs9IDQ7XG5cbiAgICAgICAgLy8gUHV0IFRvdGFsIE51bWJlciBvZiBmcmFtZXNcbiAgICAgICAgY3JlYXRlSW50ZWdlcihidWZmZXIsIHN0cmVhbUluZGV4LCBnZmMuVkJSX3NlZWtfdGFibGUublZick51bUZyYW1lcyk7XG4gICAgICAgIHN0cmVhbUluZGV4ICs9IDQ7XG5cbiAgICAgICAgLy8gUHV0IHRvdGFsIGF1ZGlvIHN0cmVhbSBzaXplLCBpbmNsdWRpbmcgWGluZy9MQU1FIEhlYWRlclxuICAgICAgICB2YXIgc3RyZWFtU2l6ZSA9IChnZmMuVkJSX3NlZWtfdGFibGUubkJ5dGVzV3JpdHRlbiArIGdmYy5WQlJfc2Vla190YWJsZS5Ub3RhbEZyYW1lU2l6ZSk7XG4gICAgICAgIGNyZWF0ZUludGVnZXIoYnVmZmVyLCBzdHJlYW1JbmRleCwgMCB8IHN0cmVhbVNpemUpO1xuICAgICAgICBzdHJlYW1JbmRleCArPSA0O1xuXG4gICAgICAgIC8qIFB1dCBUT0MgKi9cbiAgICAgICAgU3lzdGVtLmFycmF5Y29weSh0b2MsIDAsIGJ1ZmZlciwgc3RyZWFtSW5kZXgsIHRvYy5sZW5ndGgpO1xuICAgICAgICBzdHJlYW1JbmRleCArPSB0b2MubGVuZ3RoO1xuXG4gICAgICAgIGlmIChnZnAuZXJyb3JfcHJvdGVjdGlvbikge1xuICAgICAgICAgICAgLy8gKGpvKSBlcnJvcl9wcm90ZWN0aW9uOiBhZGQgY3JjMTYgaW5mb3JtYXRpb24gdG8gaGVhZGVyXG4gICAgICAgICAgICBicy5DUkNfd3JpdGVoZWFkZXIoZ2ZjLCBidWZmZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd29yayBvdXQgQ1JDIHNvIGZhcjogaW5pdGlhbGx5IGNyYyA9IDBcbiAgICAgICAgdmFyIGNyYyA9IDB4MDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyZWFtSW5kZXg7IGkrKylcbiAgICAgICAgICAgIGNyYyA9IGNyY1VwZGF0ZUxvb2t1cChidWZmZXJbaV0sIGNyYyk7XG4gICAgICAgIC8vIFB1dCBMQU1FIFZCUiBpbmZvXG4gICAgICAgIHN0cmVhbUluZGV4ICs9IHB1dExhbWVWQlIoZ2ZwLCBzdHJlYW1TaXplLCBidWZmZXIsIHN0cmVhbUluZGV4LCBjcmMpO1xuXG4gICAgICAgIHJldHVybiBnZmMuVkJSX3NlZWtfdGFibGUuVG90YWxGcmFtZVNpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV3JpdGUgZmluYWwgVkJSIHRhZyB0byB0aGUgZmlsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBnZnBcbiAgICAgKiAgICAgICAgICAgIGdsb2JhbCBmbGFnc1xuICAgICAqIEBwYXJhbSBzdHJlYW1cbiAgICAgKiAgICAgICAgICAgIHN0cmVhbSB0byBhZGQgdGhlIFZCUiB0YWcgdG9cbiAgICAgKiBAcmV0dXJuIDAgKE9LKSwgLTEgZWxzZVxuICAgICAqIEB0aHJvd3MgSU9FeGNlcHRpb25cbiAgICAgKiAgICAgICAgICAgICBJL08gZXJyb3JcbiAgICAgKi9cbiAgICB0aGlzLnB1dFZiclRhZyA9IGZ1bmN0aW9uIChnZnAsIHN0cmVhbSkge1xuICAgICAgICB2YXIgZ2ZjID0gZ2ZwLmludGVybmFsX2ZsYWdzO1xuXG4gICAgICAgIGlmIChnZmMuVkJSX3NlZWtfdGFibGUucG9zIDw9IDApXG4gICAgICAgICAgICByZXR1cm4gLTE7XG5cbiAgICAgICAgLy8gU2VlayB0byBlbmQgb2YgZmlsZVxuICAgICAgICBzdHJlYW0uc2VlayhzdHJlYW0ubGVuZ3RoKCkpO1xuXG4gICAgICAgIC8vIEdldCBmaWxlIHNpemUsIGFib3J0IGlmIGZpbGUgaGFzIHplcm8gbGVuZ3RoLlxuICAgICAgICBpZiAoc3RyZWFtLmxlbmd0aCgpID09IDApXG4gICAgICAgICAgICByZXR1cm4gLTE7XG5cbiAgICAgICAgLy8gVGhlIFZCUiB0YWcgbWF5IE5PVCBiZSBsb2NhdGVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHN0cmVhbS4gSWYgYW5cbiAgICAgICAgLy8gSUQzIHZlcnNpb24gMiB0YWcgd2FzIGFkZGVkLCB0aGVuIGl0IG11c3QgYmUgc2tpcHBlZCB0byB3cml0ZSB0aGUgVkJSXG4gICAgICAgIC8vIHRhZyBkYXRhLlxuICAgICAgICB2YXIgaWQzdjJUYWdTaXplID0gc2tpcElkM3YyKHN0cmVhbSk7XG5cbiAgICAgICAgLy8gU2VlayB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzdHJlYW1cbiAgICAgICAgc3RyZWFtLnNlZWsoaWQzdjJUYWdTaXplKTtcblxuICAgICAgICB2YXIgYnVmZmVyID0gbmV3X2J5dGUoTUFYRlJBTUVTSVpFKTtcbiAgICAgICAgdmFyIGJ5dGVzID0gZ2V0TGFtZVRhZ0ZyYW1lKGdmcCwgYnVmZmVyKTtcbiAgICAgICAgaWYgKGJ5dGVzID4gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJ5dGVzIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQdXQgaXQgYWxsIHRvIGRpc2sgYWdhaW5cbiAgICAgICAgc3RyZWFtLndyaXRlKGJ1ZmZlciwgMCwgYnl0ZXMpO1xuICAgICAgICAvLyBzdWNjZXNzXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFZCUlRhZztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lamejs/src/js/VBRTag.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lamejs/src/js/Version.js":
/*!***********************************************!*\
  !*** ./node_modules/lamejs/src/js/Version.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function Version() {\n\n    /**\n     * URL for the LAME website.\n     */\n    var LAME_URL = \"http://www.mp3dev.org/\";\n\n    /**\n     * Major version number.\n     */\n    var LAME_MAJOR_VERSION = 3;\n    /**\n     * Minor version number.\n     */\n    var LAME_MINOR_VERSION = 98;\n    /**\n     * Patch level.\n     */\n    var LAME_PATCH_VERSION = 4;\n\n    /**\n     * Major version number.\n     */\n    var PSY_MAJOR_VERSION = 0;\n    /**\n     * Minor version number.\n     */\n    var PSY_MINOR_VERSION = 93;\n\n    /**\n     * A string which describes the version of LAME.\n     *\n     * @return string which describes the version of LAME\n     */\n    this.getLameVersion = function () {\n        // primary to write screen reports\n        return (LAME_MAJOR_VERSION + \".\" + LAME_MINOR_VERSION + \".\" + LAME_PATCH_VERSION);\n    }\n\n    /**\n     * The short version of the LAME version string.\n     *\n     * @return short version of the LAME version string\n     */\n    this.getLameShortVersion = function () {\n        // Adding date and time to version string makes it harder for output\n        // validation\n        return (LAME_MAJOR_VERSION + \".\" + LAME_MINOR_VERSION + \".\" + LAME_PATCH_VERSION);\n    }\n\n    /**\n     * The shortest version of the LAME version string.\n     *\n     * @return shortest version of the LAME version string\n     */\n    this.getLameVeryShortVersion = function () {\n        // Adding date and time to version string makes it harder for output\n        return (\"LAME\" + LAME_MAJOR_VERSION + \".\" + LAME_MINOR_VERSION + \"r\");\n    }\n\n    /**\n     * String which describes the version of GPSYCHO\n     *\n     * @return string which describes the version of GPSYCHO\n     */\n    this.getPsyVersion = function () {\n        return (PSY_MAJOR_VERSION + \".\" + PSY_MINOR_VERSION);\n    }\n\n    /**\n     * String which is a URL for the LAME website.\n     *\n     * @return string which is a URL for the LAME website\n     */\n    this.getLameUrl = function () {\n        return LAME_URL;\n    }\n\n    /**\n     * Quite useless for a java version, however we are compatible ;-)\n     *\n     * @return \"32bits\"\n     */\n    this.getLameOsBitness = function () {\n        return \"32bits\";\n    }\n\n}\n\nmodule.exports = Version;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL1ZlcnNpb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL1ZlcnNpb24uanM/NzI5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBWZXJzaW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogVVJMIGZvciB0aGUgTEFNRSB3ZWJzaXRlLlxuICAgICAqL1xuICAgIHZhciBMQU1FX1VSTCA9IFwiaHR0cDovL3d3dy5tcDNkZXYub3JnL1wiO1xuXG4gICAgLyoqXG4gICAgICogTWFqb3IgdmVyc2lvbiBudW1iZXIuXG4gICAgICovXG4gICAgdmFyIExBTUVfTUFKT1JfVkVSU0lPTiA9IDM7XG4gICAgLyoqXG4gICAgICogTWlub3IgdmVyc2lvbiBudW1iZXIuXG4gICAgICovXG4gICAgdmFyIExBTUVfTUlOT1JfVkVSU0lPTiA9IDk4O1xuICAgIC8qKlxuICAgICAqIFBhdGNoIGxldmVsLlxuICAgICAqL1xuICAgIHZhciBMQU1FX1BBVENIX1ZFUlNJT04gPSA0O1xuXG4gICAgLyoqXG4gICAgICogTWFqb3IgdmVyc2lvbiBudW1iZXIuXG4gICAgICovXG4gICAgdmFyIFBTWV9NQUpPUl9WRVJTSU9OID0gMDtcbiAgICAvKipcbiAgICAgKiBNaW5vciB2ZXJzaW9uIG51bWJlci5cbiAgICAgKi9cbiAgICB2YXIgUFNZX01JTk9SX1ZFUlNJT04gPSA5MztcblxuICAgIC8qKlxuICAgICAqIEEgc3RyaW5nIHdoaWNoIGRlc2NyaWJlcyB0aGUgdmVyc2lvbiBvZiBMQU1FLlxuICAgICAqXG4gICAgICogQHJldHVybiBzdHJpbmcgd2hpY2ggZGVzY3JpYmVzIHRoZSB2ZXJzaW9uIG9mIExBTUVcbiAgICAgKi9cbiAgICB0aGlzLmdldExhbWVWZXJzaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBwcmltYXJ5IHRvIHdyaXRlIHNjcmVlbiByZXBvcnRzXG4gICAgICAgIHJldHVybiAoTEFNRV9NQUpPUl9WRVJTSU9OICsgXCIuXCIgKyBMQU1FX01JTk9SX1ZFUlNJT04gKyBcIi5cIiArIExBTUVfUEFUQ0hfVkVSU0lPTik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHNob3J0IHZlcnNpb24gb2YgdGhlIExBTUUgdmVyc2lvbiBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHNob3J0IHZlcnNpb24gb2YgdGhlIExBTUUgdmVyc2lvbiBzdHJpbmdcbiAgICAgKi9cbiAgICB0aGlzLmdldExhbWVTaG9ydFZlcnNpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEFkZGluZyBkYXRlIGFuZCB0aW1lIHRvIHZlcnNpb24gc3RyaW5nIG1ha2VzIGl0IGhhcmRlciBmb3Igb3V0cHV0XG4gICAgICAgIC8vIHZhbGlkYXRpb25cbiAgICAgICAgcmV0dXJuIChMQU1FX01BSk9SX1ZFUlNJT04gKyBcIi5cIiArIExBTUVfTUlOT1JfVkVSU0lPTiArIFwiLlwiICsgTEFNRV9QQVRDSF9WRVJTSU9OKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2hvcnRlc3QgdmVyc2lvbiBvZiB0aGUgTEFNRSB2ZXJzaW9uIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gc2hvcnRlc3QgdmVyc2lvbiBvZiB0aGUgTEFNRSB2ZXJzaW9uIHN0cmluZ1xuICAgICAqL1xuICAgIHRoaXMuZ2V0TGFtZVZlcnlTaG9ydFZlcnNpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEFkZGluZyBkYXRlIGFuZCB0aW1lIHRvIHZlcnNpb24gc3RyaW5nIG1ha2VzIGl0IGhhcmRlciBmb3Igb3V0cHV0XG4gICAgICAgIHJldHVybiAoXCJMQU1FXCIgKyBMQU1FX01BSk9SX1ZFUlNJT04gKyBcIi5cIiArIExBTUVfTUlOT1JfVkVSU0lPTiArIFwiclwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdHJpbmcgd2hpY2ggZGVzY3JpYmVzIHRoZSB2ZXJzaW9uIG9mIEdQU1lDSE9cbiAgICAgKlxuICAgICAqIEByZXR1cm4gc3RyaW5nIHdoaWNoIGRlc2NyaWJlcyB0aGUgdmVyc2lvbiBvZiBHUFNZQ0hPXG4gICAgICovXG4gICAgdGhpcy5nZXRQc3lWZXJzaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKFBTWV9NQUpPUl9WRVJTSU9OICsgXCIuXCIgKyBQU1lfTUlOT1JfVkVSU0lPTik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RyaW5nIHdoaWNoIGlzIGEgVVJMIGZvciB0aGUgTEFNRSB3ZWJzaXRlLlxuICAgICAqXG4gICAgICogQHJldHVybiBzdHJpbmcgd2hpY2ggaXMgYSBVUkwgZm9yIHRoZSBMQU1FIHdlYnNpdGVcbiAgICAgKi9cbiAgICB0aGlzLmdldExhbWVVcmwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBMQU1FX1VSTDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBRdWl0ZSB1c2VsZXNzIGZvciBhIGphdmEgdmVyc2lvbiwgaG93ZXZlciB3ZSBhcmUgY29tcGF0aWJsZSA7LSlcbiAgICAgKlxuICAgICAqIEByZXR1cm4gXCIzMmJpdHNcIlxuICAgICAqL1xuICAgIHRoaXMuZ2V0TGFtZU9zQml0bmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiMzJiaXRzXCI7XG4gICAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gVmVyc2lvbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lamejs/src/js/Version.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lamejs/src/js/common.js":
/*!**********************************************!*\
  !*** ./node_modules/lamejs/src/js/common.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function new_byte(count) {\n    return new Int8Array(count);\n}\n\nfunction new_short(count) {\n    return new Int16Array(count);\n}\n\nfunction new_int(count) {\n    return new Int32Array(count);\n}\n\nfunction new_float(count) {\n    return new Float32Array(count);\n}\n\nfunction new_double(count) {\n    return new Float64Array(count);\n}\n\nfunction new_float_n(args) {\n    if (args.length == 1) {\n        return new_float(args[0]);\n    }\n    var sz = args[0];\n    args = args.slice(1);\n    var A = [];\n    for (var i = 0; i < sz; i++) {\n        A.push(new_float_n(args));\n    }\n    return A;\n}\nfunction new_int_n(args) {\n    if (args.length == 1) {\n        return new_int(args[0]);\n    }\n    var sz = args[0];\n    args = args.slice(1);\n    var A = [];\n    for (var i = 0; i < sz; i++) {\n        A.push(new_int_n(args));\n    }\n    return A;\n}\n\nfunction new_short_n(args) {\n    if (args.length == 1) {\n        return new_short(args[0]);\n    }\n    var sz = args[0];\n    args = args.slice(1);\n    var A = [];\n    for (var i = 0; i < sz; i++) {\n        A.push(new_short_n(args));\n    }\n    return A;\n}\n\nfunction new_array_n(args) {\n    if (args.length == 1) {\n        return new Array(args[0]);\n    }\n    var sz = args[0];\n    args = args.slice(1);\n    var A = [];\n    for (var i = 0; i < sz; i++) {\n        A.push(new_array_n(args));\n    }\n    return A;\n}\n\n\nvar Arrays = {};\n\nArrays.fill = function (a, fromIndex, toIndex, val) {\n    if (arguments.length == 2) {\n        for (var i = 0; i < a.length; i++) {\n            a[i] = arguments[1];\n        }\n    } else {\n        for (var i = fromIndex; i < toIndex; i++) {\n            a[i] = val;\n        }\n    }\n};\n\nvar System = {};\n\nSystem.arraycopy = function (src, srcPos, dest, destPos, length) {\n    var srcEnd = srcPos + length;\n    while (srcPos < srcEnd)\n        dest[destPos++] = src[srcPos++];\n};\n\nSystem.out = {};\nSystem.out.println = function (message) {\n    console.log(message);\n}\n\nSystem.out.printf = function () {\n    console.log.apply(console, arguments);\n}\n\n\nvar Util = {};\nUtil.SQRT2 = 1.41421356237309504880;\nUtil.FAST_LOG10 = function (x) {\n    return Math.log10(x);\n};\n\nUtil.FAST_LOG10_X = function (x, y) {\n    return Math.log10(x) * y;\n};\n\nfunction ShortBlock(ordinal) {\n    this.ordinal = ordinal;\n}\n/**\n * LAME may use them, even different block types for L/R.\n */\nShortBlock.short_block_allowed = new ShortBlock(0);\n/**\n * LAME may use them, but always same block types in L/R.\n */\nShortBlock.short_block_coupled = new ShortBlock(1);\n/**\n * LAME will not use short blocks, long blocks only.\n */\nShortBlock.short_block_dispensed = new ShortBlock(2);\n/**\n * LAME will not use long blocks, short blocks only.\n */\nShortBlock.short_block_forced = new ShortBlock(3);\n\nvar Float = {};\nFloat.MAX_VALUE = 3.4028235e+38;\n\nfunction VbrMode(ordinal) {\n    this.ordinal = ordinal;\n}\nVbrMode.vbr_off = new VbrMode(0);\nVbrMode.vbr_mt = new VbrMode(1);\nVbrMode.vbr_rh = new VbrMode(2);\nVbrMode.vbr_abr = new VbrMode(3);\nVbrMode.vbr_mtrh = new VbrMode(4);\nVbrMode.vbr_default = VbrMode.vbr_mtrh;\n\nvar assert = function (x) {\n    //console.assert(x);\n};\n\nmodule.exports = {\n    \"System\": System,\n    \"VbrMode\": VbrMode,\n    \"Float\": Float,\n    \"ShortBlock\": ShortBlock,\n    \"Util\": Util,\n    \"Arrays\": Arrays,\n    \"new_array_n\": new_array_n,\n    \"new_byte\": new_byte,\n    \"new_double\": new_double,\n    \"new_float\": new_float,\n    \"new_float_n\": new_float_n,\n    \"new_int\": new_int,\n    \"new_int_n\": new_int_n,\n    \"new_short\": new_short,\n    \"new_short_n\": new_short_n,\n    \"assert\": assert\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL2NvbW1vbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQSxNQUFNO0FBQ04sZ0NBQWdDLGFBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xhbWVqcy9zcmMvanMvY29tbW9uLmpzP2JlMDIiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gbmV3X2J5dGUoY291bnQpIHtcbiAgICByZXR1cm4gbmV3IEludDhBcnJheShjb3VudCk7XG59XG5cbmZ1bmN0aW9uIG5ld19zaG9ydChjb3VudCkge1xuICAgIHJldHVybiBuZXcgSW50MTZBcnJheShjb3VudCk7XG59XG5cbmZ1bmN0aW9uIG5ld19pbnQoY291bnQpIHtcbiAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoY291bnQpO1xufVxuXG5mdW5jdGlvbiBuZXdfZmxvYXQoY291bnQpIHtcbiAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShjb3VudCk7XG59XG5cbmZ1bmN0aW9uIG5ld19kb3VibGUoY291bnQpIHtcbiAgICByZXR1cm4gbmV3IEZsb2F0NjRBcnJheShjb3VudCk7XG59XG5cbmZ1bmN0aW9uIG5ld19mbG9hdF9uKGFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT0gMSkge1xuICAgICAgICByZXR1cm4gbmV3X2Zsb2F0KGFyZ3NbMF0pO1xuICAgIH1cbiAgICB2YXIgc3ogPSBhcmdzWzBdO1xuICAgIGFyZ3MgPSBhcmdzLnNsaWNlKDEpO1xuICAgIHZhciBBID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzejsgaSsrKSB7XG4gICAgICAgIEEucHVzaChuZXdfZmxvYXRfbihhcmdzKSk7XG4gICAgfVxuICAgIHJldHVybiBBO1xufVxuZnVuY3Rpb24gbmV3X2ludF9uKGFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT0gMSkge1xuICAgICAgICByZXR1cm4gbmV3X2ludChhcmdzWzBdKTtcbiAgICB9XG4gICAgdmFyIHN6ID0gYXJnc1swXTtcbiAgICBhcmdzID0gYXJncy5zbGljZSgxKTtcbiAgICB2YXIgQSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3o7IGkrKykge1xuICAgICAgICBBLnB1c2gobmV3X2ludF9uKGFyZ3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIEE7XG59XG5cbmZ1bmN0aW9uIG5ld19zaG9ydF9uKGFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT0gMSkge1xuICAgICAgICByZXR1cm4gbmV3X3Nob3J0KGFyZ3NbMF0pO1xuICAgIH1cbiAgICB2YXIgc3ogPSBhcmdzWzBdO1xuICAgIGFyZ3MgPSBhcmdzLnNsaWNlKDEpO1xuICAgIHZhciBBID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzejsgaSsrKSB7XG4gICAgICAgIEEucHVzaChuZXdfc2hvcnRfbihhcmdzKSk7XG4gICAgfVxuICAgIHJldHVybiBBO1xufVxuXG5mdW5jdGlvbiBuZXdfYXJyYXlfbihhcmdzKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09IDEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheShhcmdzWzBdKTtcbiAgICB9XG4gICAgdmFyIHN6ID0gYXJnc1swXTtcbiAgICBhcmdzID0gYXJncy5zbGljZSgxKTtcbiAgICB2YXIgQSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3o7IGkrKykge1xuICAgICAgICBBLnB1c2gobmV3X2FycmF5X24oYXJncykpO1xuICAgIH1cbiAgICByZXR1cm4gQTtcbn1cblxuXG52YXIgQXJyYXlzID0ge307XG5cbkFycmF5cy5maWxsID0gZnVuY3Rpb24gKGEsIGZyb21JbmRleCwgdG9JbmRleCwgdmFsKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFbaV0gPSBhcmd1bWVudHNbMV07XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gZnJvbUluZGV4OyBpIDwgdG9JbmRleDsgaSsrKSB7XG4gICAgICAgICAgICBhW2ldID0gdmFsO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIFN5c3RlbSA9IHt9O1xuXG5TeXN0ZW0uYXJyYXljb3B5ID0gZnVuY3Rpb24gKHNyYywgc3JjUG9zLCBkZXN0LCBkZXN0UG9zLCBsZW5ndGgpIHtcbiAgICB2YXIgc3JjRW5kID0gc3JjUG9zICsgbGVuZ3RoO1xuICAgIHdoaWxlIChzcmNQb3MgPCBzcmNFbmQpXG4gICAgICAgIGRlc3RbZGVzdFBvcysrXSA9IHNyY1tzcmNQb3MrK107XG59O1xuXG5TeXN0ZW0ub3V0ID0ge307XG5TeXN0ZW0ub3V0LnByaW50bG4gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xufVxuXG5TeXN0ZW0ub3V0LnByaW50ZiA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG5cbnZhciBVdGlsID0ge307XG5VdGlsLlNRUlQyID0gMS40MTQyMTM1NjIzNzMwOTUwNDg4MDtcblV0aWwuRkFTVF9MT0cxMCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIE1hdGgubG9nMTAoeCk7XG59O1xuXG5VdGlsLkZBU1RfTE9HMTBfWCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgcmV0dXJuIE1hdGgubG9nMTAoeCkgKiB5O1xufTtcblxuZnVuY3Rpb24gU2hvcnRCbG9jayhvcmRpbmFsKSB7XG4gICAgdGhpcy5vcmRpbmFsID0gb3JkaW5hbDtcbn1cbi8qKlxuICogTEFNRSBtYXkgdXNlIHRoZW0sIGV2ZW4gZGlmZmVyZW50IGJsb2NrIHR5cGVzIGZvciBML1IuXG4gKi9cblNob3J0QmxvY2suc2hvcnRfYmxvY2tfYWxsb3dlZCA9IG5ldyBTaG9ydEJsb2NrKDApO1xuLyoqXG4gKiBMQU1FIG1heSB1c2UgdGhlbSwgYnV0IGFsd2F5cyBzYW1lIGJsb2NrIHR5cGVzIGluIEwvUi5cbiAqL1xuU2hvcnRCbG9jay5zaG9ydF9ibG9ja19jb3VwbGVkID0gbmV3IFNob3J0QmxvY2soMSk7XG4vKipcbiAqIExBTUUgd2lsbCBub3QgdXNlIHNob3J0IGJsb2NrcywgbG9uZyBibG9ja3Mgb25seS5cbiAqL1xuU2hvcnRCbG9jay5zaG9ydF9ibG9ja19kaXNwZW5zZWQgPSBuZXcgU2hvcnRCbG9jaygyKTtcbi8qKlxuICogTEFNRSB3aWxsIG5vdCB1c2UgbG9uZyBibG9ja3MsIHNob3J0IGJsb2NrcyBvbmx5LlxuICovXG5TaG9ydEJsb2NrLnNob3J0X2Jsb2NrX2ZvcmNlZCA9IG5ldyBTaG9ydEJsb2NrKDMpO1xuXG52YXIgRmxvYXQgPSB7fTtcbkZsb2F0Lk1BWF9WQUxVRSA9IDMuNDAyODIzNWUrMzg7XG5cbmZ1bmN0aW9uIFZick1vZGUob3JkaW5hbCkge1xuICAgIHRoaXMub3JkaW5hbCA9IG9yZGluYWw7XG59XG5WYnJNb2RlLnZicl9vZmYgPSBuZXcgVmJyTW9kZSgwKTtcblZick1vZGUudmJyX210ID0gbmV3IFZick1vZGUoMSk7XG5WYnJNb2RlLnZicl9yaCA9IG5ldyBWYnJNb2RlKDIpO1xuVmJyTW9kZS52YnJfYWJyID0gbmV3IFZick1vZGUoMyk7XG5WYnJNb2RlLnZicl9tdHJoID0gbmV3IFZick1vZGUoNCk7XG5WYnJNb2RlLnZicl9kZWZhdWx0ID0gVmJyTW9kZS52YnJfbXRyaDtcblxudmFyIGFzc2VydCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgLy9jb25zb2xlLmFzc2VydCh4KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIFwiU3lzdGVtXCI6IFN5c3RlbSxcbiAgICBcIlZick1vZGVcIjogVmJyTW9kZSxcbiAgICBcIkZsb2F0XCI6IEZsb2F0LFxuICAgIFwiU2hvcnRCbG9ja1wiOiBTaG9ydEJsb2NrLFxuICAgIFwiVXRpbFwiOiBVdGlsLFxuICAgIFwiQXJyYXlzXCI6IEFycmF5cyxcbiAgICBcIm5ld19hcnJheV9uXCI6IG5ld19hcnJheV9uLFxuICAgIFwibmV3X2J5dGVcIjogbmV3X2J5dGUsXG4gICAgXCJuZXdfZG91YmxlXCI6IG5ld19kb3VibGUsXG4gICAgXCJuZXdfZmxvYXRcIjogbmV3X2Zsb2F0LFxuICAgIFwibmV3X2Zsb2F0X25cIjogbmV3X2Zsb2F0X24sXG4gICAgXCJuZXdfaW50XCI6IG5ld19pbnQsXG4gICAgXCJuZXdfaW50X25cIjogbmV3X2ludF9uLFxuICAgIFwibmV3X3Nob3J0XCI6IG5ld19zaG9ydCxcbiAgICBcIm5ld19zaG9ydF9uXCI6IG5ld19zaG9ydF9uLFxuICAgIFwiYXNzZXJ0XCI6IGFzc2VydFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lamejs/src/js/common.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lamejs/src/js/index.js":
/*!*********************************************!*\
  !*** ./node_modules/lamejs/src/js/index.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var common = __webpack_require__(/*! ./common.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/common.js\");\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\nvar Lame = __webpack_require__(/*! ./Lame.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/Lame.js\");\nvar Presets = __webpack_require__(/*! ./Presets.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/Presets.js\");\nvar GainAnalysis = __webpack_require__(/*! ./GainAnalysis.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/GainAnalysis.js\");\nvar QuantizePVT = __webpack_require__(/*! ./QuantizePVT.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/QuantizePVT.js\");\nvar Quantize = __webpack_require__(/*! ./Quantize.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/Quantize.js\");\nvar Takehiro = __webpack_require__(/*! ./Takehiro.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/Takehiro.js\");\nvar Reservoir = __webpack_require__(/*! ./Reservoir.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/Reservoir.js\");\nvar MPEGMode = __webpack_require__(/*! ./MPEGMode.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/MPEGMode.js\");\nvar BitStream = __webpack_require__(/*! ./BitStream.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/BitStream.js\");\nvar Encoder = __webpack_require__(/*! ./Encoder.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/Encoder.js\");\nvar Version = __webpack_require__(/*! ./Version.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/Version.js\");\nvar VBRTag = __webpack_require__(/*! ./VBRTag.js */ \"(app-pages-browser)/./node_modules/lamejs/src/js/VBRTag.js\");\n\nfunction GetAudio() {\n    var parse;\n    var mpg;\n\n    this.setModules = function (parse2, mpg2) {\n        parse = parse2;\n        mpg = mpg2;\n    }\n}\n\n\nfunction Parse() {\n    var ver;\n    var id3;\n    var pre;\n\n    this.setModules = function (ver2, id32, pre2) {\n        ver = ver2;\n        id3 = id32;\n        pre = pre2;\n    }\n}\n\nfunction MPGLib() {\n}\n\nfunction ID3Tag() {\n    var bits;\n    var ver;\n\n    this.setModules = function (_bits, _ver) {\n        bits = _bits;\n        ver = _ver;\n    }\n}\n\nfunction Mp3Encoder(channels, samplerate, kbps) {\n    if (arguments.length != 3) {\n        console.error('WARN: Mp3Encoder(channels, samplerate, kbps) not specified');\n        channels = 1;\n        samplerate = 44100;\n        kbps = 128;\n    }\n    var lame = new Lame();\n    var gaud = new GetAudio();\n    var ga = new GainAnalysis();\n    var bs = new BitStream();\n    var p = new Presets();\n    var qupvt = new QuantizePVT();\n    var qu = new Quantize();\n    var vbr = new VBRTag();\n    var ver = new Version();\n    var id3 = new ID3Tag();\n    var rv = new Reservoir();\n    var tak = new Takehiro();\n    var parse = new Parse();\n    var mpg = new MPGLib();\n\n    lame.setModules(ga, bs, p, qupvt, qu, vbr, ver, id3, mpg);\n    bs.setModules(ga, mpg, ver, vbr);\n    id3.setModules(bs, ver);\n    p.setModules(lame);\n    qu.setModules(bs, rv, qupvt, tak);\n    qupvt.setModules(tak, rv, lame.enc.psy);\n    rv.setModules(bs);\n    tak.setModules(qupvt);\n    vbr.setModules(lame, bs, ver);\n    gaud.setModules(parse, mpg);\n    parse.setModules(ver, id3, p);\n\n    var gfp = lame.lame_init();\n\n    gfp.num_channels = channels;\n    gfp.in_samplerate = samplerate;\n    gfp.brate = kbps;\n    gfp.mode = MPEGMode.STEREO;\n    gfp.quality = 3;\n    gfp.bWriteVbrTag = false;\n    gfp.disable_reservoir = true;\n    gfp.write_id3tag_automatic = false;\n\n    var retcode = lame.lame_init_params(gfp);\n    assert(0 == retcode);\n    var maxSamples = 1152;\n    var mp3buf_size = 0 | (1.25 * maxSamples + 7200);\n    var mp3buf = new_byte(mp3buf_size);\n\n    this.encodeBuffer = function (left, right) {\n        if (channels == 1) {\n            right = left;\n        }\n        assert(left.length == right.length);\n        if (left.length > maxSamples) {\n            maxSamples = left.length;\n            mp3buf_size = 0 | (1.25 * maxSamples + 7200);\n            mp3buf = new_byte(mp3buf_size);\n        }\n\n        var _sz = lame.lame_encode_buffer(gfp, left, right, left.length, mp3buf, 0, mp3buf_size);\n        return new Int8Array(mp3buf.subarray(0, _sz));\n    };\n\n    this.flush = function () {\n        var _sz = lame.lame_encode_flush(gfp, mp3buf, 0, mp3buf_size);\n        return new Int8Array(mp3buf.subarray(0, _sz));\n    };\n}\n\nfunction WavHeader() {\n    this.dataOffset = 0;\n    this.dataLen = 0;\n    this.channels = 0;\n    this.sampleRate = 0;\n}\n\nfunction fourccToInt(fourcc) {\n    return fourcc.charCodeAt(0) << 24 | fourcc.charCodeAt(1) << 16 | fourcc.charCodeAt(2) << 8 | fourcc.charCodeAt(3);\n}\n\nWavHeader.RIFF = fourccToInt(\"RIFF\");\nWavHeader.WAVE = fourccToInt(\"WAVE\");\nWavHeader.fmt_ = fourccToInt(\"fmt \");\nWavHeader.data = fourccToInt(\"data\");\n\nWavHeader.readHeader = function (dataView) {\n    var w = new WavHeader();\n\n    var header = dataView.getUint32(0, false);\n    if (WavHeader.RIFF != header) {\n        return;\n    }\n    var fileLen = dataView.getUint32(4, true);\n    if (WavHeader.WAVE != dataView.getUint32(8, false)) {\n        return;\n    }\n    if (WavHeader.fmt_ != dataView.getUint32(12, false)) {\n        return;\n    }\n    var fmtLen = dataView.getUint32(16, true);\n    var pos = 16 + 4;\n    switch (fmtLen) {\n        case 16:\n        case 18:\n            w.channels = dataView.getUint16(pos + 2, true);\n            w.sampleRate = dataView.getUint32(pos + 4, true);\n            break;\n        default:\n            throw 'extended fmt chunk not implemented';\n    }\n    pos += fmtLen;\n    var data = WavHeader.data;\n    var len = 0;\n    while (data != header) {\n        header = dataView.getUint32(pos, false);\n        len = dataView.getUint32(pos + 4, true);\n        if (data == header) {\n            break;\n        }\n        pos += (len + 8);\n    }\n    w.dataLen = len;\n    w.dataOffset = pos + 8;\n    return w;\n};\n\nmodule.exports.Mp3Encoder = Mp3Encoder;\nmodule.exports.WavHeader = WavHeader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLGFBQWEsbUJBQU8sQ0FBQywrRUFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsbUJBQU8sQ0FBQywyRUFBVztBQUM5QixjQUFjLG1CQUFPLENBQUMsaUZBQWM7QUFDcEMsbUJBQW1CLG1CQUFPLENBQUMsMkZBQW1CO0FBQzlDLGtCQUFrQixtQkFBTyxDQUFDLHlGQUFrQjtBQUM1QyxlQUFlLG1CQUFPLENBQUMsbUZBQWU7QUFDdEMsZUFBZSxtQkFBTyxDQUFDLG1GQUFlO0FBQ3RDLGdCQUFnQixtQkFBTyxDQUFDLHFGQUFnQjtBQUN4QyxlQUFlLG1CQUFPLENBQUMsbUZBQWU7QUFDdEMsZ0JBQWdCLG1CQUFPLENBQUMscUZBQWdCO0FBQ3hDLGNBQWMsbUJBQU8sQ0FBQyxpRkFBYztBQUNwQyxjQUFjLG1CQUFPLENBQUMsaUZBQWM7QUFDcEMsYUFBYSxtQkFBTyxDQUFDLCtFQUFhOztBQUVsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekIsd0JBQXdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sYW1lanMvc3JjL2pzL2luZGV4LmpzP2ExNDUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uLmpzJyk7XG52YXIgU3lzdGVtID0gY29tbW9uLlN5c3RlbTtcbnZhciBWYnJNb2RlID0gY29tbW9uLlZick1vZGU7XG52YXIgRmxvYXQgPSBjb21tb24uRmxvYXQ7XG52YXIgU2hvcnRCbG9jayA9IGNvbW1vbi5TaG9ydEJsb2NrO1xudmFyIFV0aWwgPSBjb21tb24uVXRpbDtcbnZhciBBcnJheXMgPSBjb21tb24uQXJyYXlzO1xudmFyIG5ld19hcnJheV9uID0gY29tbW9uLm5ld19hcnJheV9uO1xudmFyIG5ld19ieXRlID0gY29tbW9uLm5ld19ieXRlO1xudmFyIG5ld19kb3VibGUgPSBjb21tb24ubmV3X2RvdWJsZTtcbnZhciBuZXdfZmxvYXQgPSBjb21tb24ubmV3X2Zsb2F0O1xudmFyIG5ld19mbG9hdF9uID0gY29tbW9uLm5ld19mbG9hdF9uO1xudmFyIG5ld19pbnQgPSBjb21tb24ubmV3X2ludDtcbnZhciBuZXdfaW50X24gPSBjb21tb24ubmV3X2ludF9uO1xudmFyIGFzc2VydCA9IGNvbW1vbi5hc3NlcnQ7XG5cbnZhciBMYW1lID0gcmVxdWlyZSgnLi9MYW1lLmpzJyk7XG52YXIgUHJlc2V0cyA9IHJlcXVpcmUoJy4vUHJlc2V0cy5qcycpO1xudmFyIEdhaW5BbmFseXNpcyA9IHJlcXVpcmUoJy4vR2FpbkFuYWx5c2lzLmpzJyk7XG52YXIgUXVhbnRpemVQVlQgPSByZXF1aXJlKCcuL1F1YW50aXplUFZULmpzJyk7XG52YXIgUXVhbnRpemUgPSByZXF1aXJlKCcuL1F1YW50aXplLmpzJyk7XG52YXIgVGFrZWhpcm8gPSByZXF1aXJlKCcuL1Rha2VoaXJvLmpzJyk7XG52YXIgUmVzZXJ2b2lyID0gcmVxdWlyZSgnLi9SZXNlcnZvaXIuanMnKTtcbnZhciBNUEVHTW9kZSA9IHJlcXVpcmUoJy4vTVBFR01vZGUuanMnKTtcbnZhciBCaXRTdHJlYW0gPSByZXF1aXJlKCcuL0JpdFN0cmVhbS5qcycpO1xudmFyIEVuY29kZXIgPSByZXF1aXJlKCcuL0VuY29kZXIuanMnKTtcbnZhciBWZXJzaW9uID0gcmVxdWlyZSgnLi9WZXJzaW9uLmpzJyk7XG52YXIgVkJSVGFnID0gcmVxdWlyZSgnLi9WQlJUYWcuanMnKTtcblxuZnVuY3Rpb24gR2V0QXVkaW8oKSB7XG4gICAgdmFyIHBhcnNlO1xuICAgIHZhciBtcGc7XG5cbiAgICB0aGlzLnNldE1vZHVsZXMgPSBmdW5jdGlvbiAocGFyc2UyLCBtcGcyKSB7XG4gICAgICAgIHBhcnNlID0gcGFyc2UyO1xuICAgICAgICBtcGcgPSBtcGcyO1xuICAgIH1cbn1cblxuXG5mdW5jdGlvbiBQYXJzZSgpIHtcbiAgICB2YXIgdmVyO1xuICAgIHZhciBpZDM7XG4gICAgdmFyIHByZTtcblxuICAgIHRoaXMuc2V0TW9kdWxlcyA9IGZ1bmN0aW9uICh2ZXIyLCBpZDMyLCBwcmUyKSB7XG4gICAgICAgIHZlciA9IHZlcjI7XG4gICAgICAgIGlkMyA9IGlkMzI7XG4gICAgICAgIHByZSA9IHByZTI7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBNUEdMaWIoKSB7XG59XG5cbmZ1bmN0aW9uIElEM1RhZygpIHtcbiAgICB2YXIgYml0cztcbiAgICB2YXIgdmVyO1xuXG4gICAgdGhpcy5zZXRNb2R1bGVzID0gZnVuY3Rpb24gKF9iaXRzLCBfdmVyKSB7XG4gICAgICAgIGJpdHMgPSBfYml0cztcbiAgICAgICAgdmVyID0gX3ZlcjtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIE1wM0VuY29kZXIoY2hhbm5lbHMsIHNhbXBsZXJhdGUsIGticHMpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAzKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1dBUk46IE1wM0VuY29kZXIoY2hhbm5lbHMsIHNhbXBsZXJhdGUsIGticHMpIG5vdCBzcGVjaWZpZWQnKTtcbiAgICAgICAgY2hhbm5lbHMgPSAxO1xuICAgICAgICBzYW1wbGVyYXRlID0gNDQxMDA7XG4gICAgICAgIGticHMgPSAxMjg7XG4gICAgfVxuICAgIHZhciBsYW1lID0gbmV3IExhbWUoKTtcbiAgICB2YXIgZ2F1ZCA9IG5ldyBHZXRBdWRpbygpO1xuICAgIHZhciBnYSA9IG5ldyBHYWluQW5hbHlzaXMoKTtcbiAgICB2YXIgYnMgPSBuZXcgQml0U3RyZWFtKCk7XG4gICAgdmFyIHAgPSBuZXcgUHJlc2V0cygpO1xuICAgIHZhciBxdXB2dCA9IG5ldyBRdWFudGl6ZVBWVCgpO1xuICAgIHZhciBxdSA9IG5ldyBRdWFudGl6ZSgpO1xuICAgIHZhciB2YnIgPSBuZXcgVkJSVGFnKCk7XG4gICAgdmFyIHZlciA9IG5ldyBWZXJzaW9uKCk7XG4gICAgdmFyIGlkMyA9IG5ldyBJRDNUYWcoKTtcbiAgICB2YXIgcnYgPSBuZXcgUmVzZXJ2b2lyKCk7XG4gICAgdmFyIHRhayA9IG5ldyBUYWtlaGlybygpO1xuICAgIHZhciBwYXJzZSA9IG5ldyBQYXJzZSgpO1xuICAgIHZhciBtcGcgPSBuZXcgTVBHTGliKCk7XG5cbiAgICBsYW1lLnNldE1vZHVsZXMoZ2EsIGJzLCBwLCBxdXB2dCwgcXUsIHZiciwgdmVyLCBpZDMsIG1wZyk7XG4gICAgYnMuc2V0TW9kdWxlcyhnYSwgbXBnLCB2ZXIsIHZicik7XG4gICAgaWQzLnNldE1vZHVsZXMoYnMsIHZlcik7XG4gICAgcC5zZXRNb2R1bGVzKGxhbWUpO1xuICAgIHF1LnNldE1vZHVsZXMoYnMsIHJ2LCBxdXB2dCwgdGFrKTtcbiAgICBxdXB2dC5zZXRNb2R1bGVzKHRhaywgcnYsIGxhbWUuZW5jLnBzeSk7XG4gICAgcnYuc2V0TW9kdWxlcyhicyk7XG4gICAgdGFrLnNldE1vZHVsZXMocXVwdnQpO1xuICAgIHZici5zZXRNb2R1bGVzKGxhbWUsIGJzLCB2ZXIpO1xuICAgIGdhdWQuc2V0TW9kdWxlcyhwYXJzZSwgbXBnKTtcbiAgICBwYXJzZS5zZXRNb2R1bGVzKHZlciwgaWQzLCBwKTtcblxuICAgIHZhciBnZnAgPSBsYW1lLmxhbWVfaW5pdCgpO1xuXG4gICAgZ2ZwLm51bV9jaGFubmVscyA9IGNoYW5uZWxzO1xuICAgIGdmcC5pbl9zYW1wbGVyYXRlID0gc2FtcGxlcmF0ZTtcbiAgICBnZnAuYnJhdGUgPSBrYnBzO1xuICAgIGdmcC5tb2RlID0gTVBFR01vZGUuU1RFUkVPO1xuICAgIGdmcC5xdWFsaXR5ID0gMztcbiAgICBnZnAuYldyaXRlVmJyVGFnID0gZmFsc2U7XG4gICAgZ2ZwLmRpc2FibGVfcmVzZXJ2b2lyID0gdHJ1ZTtcbiAgICBnZnAud3JpdGVfaWQzdGFnX2F1dG9tYXRpYyA9IGZhbHNlO1xuXG4gICAgdmFyIHJldGNvZGUgPSBsYW1lLmxhbWVfaW5pdF9wYXJhbXMoZ2ZwKTtcbiAgICBhc3NlcnQoMCA9PSByZXRjb2RlKTtcbiAgICB2YXIgbWF4U2FtcGxlcyA9IDExNTI7XG4gICAgdmFyIG1wM2J1Zl9zaXplID0gMCB8ICgxLjI1ICogbWF4U2FtcGxlcyArIDcyMDApO1xuICAgIHZhciBtcDNidWYgPSBuZXdfYnl0ZShtcDNidWZfc2l6ZSk7XG5cbiAgICB0aGlzLmVuY29kZUJ1ZmZlciA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoY2hhbm5lbHMgPT0gMSkge1xuICAgICAgICAgICAgcmlnaHQgPSBsZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChsZWZ0Lmxlbmd0aCA9PSByaWdodC5sZW5ndGgpO1xuICAgICAgICBpZiAobGVmdC5sZW5ndGggPiBtYXhTYW1wbGVzKSB7XG4gICAgICAgICAgICBtYXhTYW1wbGVzID0gbGVmdC5sZW5ndGg7XG4gICAgICAgICAgICBtcDNidWZfc2l6ZSA9IDAgfCAoMS4yNSAqIG1heFNhbXBsZXMgKyA3MjAwKTtcbiAgICAgICAgICAgIG1wM2J1ZiA9IG5ld19ieXRlKG1wM2J1Zl9zaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfc3ogPSBsYW1lLmxhbWVfZW5jb2RlX2J1ZmZlcihnZnAsIGxlZnQsIHJpZ2h0LCBsZWZ0Lmxlbmd0aCwgbXAzYnVmLCAwLCBtcDNidWZfc2l6ZSk7XG4gICAgICAgIHJldHVybiBuZXcgSW50OEFycmF5KG1wM2J1Zi5zdWJhcnJheSgwLCBfc3opKTtcbiAgICB9O1xuXG4gICAgdGhpcy5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9zeiA9IGxhbWUubGFtZV9lbmNvZGVfZmx1c2goZ2ZwLCBtcDNidWYsIDAsIG1wM2J1Zl9zaXplKTtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnQ4QXJyYXkobXAzYnVmLnN1YmFycmF5KDAsIF9zeikpO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIFdhdkhlYWRlcigpIHtcbiAgICB0aGlzLmRhdGFPZmZzZXQgPSAwO1xuICAgIHRoaXMuZGF0YUxlbiA9IDA7XG4gICAgdGhpcy5jaGFubmVscyA9IDA7XG4gICAgdGhpcy5zYW1wbGVSYXRlID0gMDtcbn1cblxuZnVuY3Rpb24gZm91cmNjVG9JbnQoZm91cmNjKSB7XG4gICAgcmV0dXJuIGZvdXJjYy5jaGFyQ29kZUF0KDApIDw8IDI0IHwgZm91cmNjLmNoYXJDb2RlQXQoMSkgPDwgMTYgfCBmb3VyY2MuY2hhckNvZGVBdCgyKSA8PCA4IHwgZm91cmNjLmNoYXJDb2RlQXQoMyk7XG59XG5cbldhdkhlYWRlci5SSUZGID0gZm91cmNjVG9JbnQoXCJSSUZGXCIpO1xuV2F2SGVhZGVyLldBVkUgPSBmb3VyY2NUb0ludChcIldBVkVcIik7XG5XYXZIZWFkZXIuZm10XyA9IGZvdXJjY1RvSW50KFwiZm10IFwiKTtcbldhdkhlYWRlci5kYXRhID0gZm91cmNjVG9JbnQoXCJkYXRhXCIpO1xuXG5XYXZIZWFkZXIucmVhZEhlYWRlciA9IGZ1bmN0aW9uIChkYXRhVmlldykge1xuICAgIHZhciB3ID0gbmV3IFdhdkhlYWRlcigpO1xuXG4gICAgdmFyIGhlYWRlciA9IGRhdGFWaWV3LmdldFVpbnQzMigwLCBmYWxzZSk7XG4gICAgaWYgKFdhdkhlYWRlci5SSUZGICE9IGhlYWRlcikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBmaWxlTGVuID0gZGF0YVZpZXcuZ2V0VWludDMyKDQsIHRydWUpO1xuICAgIGlmIChXYXZIZWFkZXIuV0FWRSAhPSBkYXRhVmlldy5nZXRVaW50MzIoOCwgZmFsc2UpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKFdhdkhlYWRlci5mbXRfICE9IGRhdGFWaWV3LmdldFVpbnQzMigxMiwgZmFsc2UpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGZtdExlbiA9IGRhdGFWaWV3LmdldFVpbnQzMigxNiwgdHJ1ZSk7XG4gICAgdmFyIHBvcyA9IDE2ICsgNDtcbiAgICBzd2l0Y2ggKGZtdExlbikge1xuICAgICAgICBjYXNlIDE2OlxuICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgdy5jaGFubmVscyA9IGRhdGFWaWV3LmdldFVpbnQxNihwb3MgKyAyLCB0cnVlKTtcbiAgICAgICAgICAgIHcuc2FtcGxlUmF0ZSA9IGRhdGFWaWV3LmdldFVpbnQzMihwb3MgKyA0LCB0cnVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgJ2V4dGVuZGVkIGZtdCBjaHVuayBub3QgaW1wbGVtZW50ZWQnO1xuICAgIH1cbiAgICBwb3MgKz0gZm10TGVuO1xuICAgIHZhciBkYXRhID0gV2F2SGVhZGVyLmRhdGE7XG4gICAgdmFyIGxlbiA9IDA7XG4gICAgd2hpbGUgKGRhdGEgIT0gaGVhZGVyKSB7XG4gICAgICAgIGhlYWRlciA9IGRhdGFWaWV3LmdldFVpbnQzMihwb3MsIGZhbHNlKTtcbiAgICAgICAgbGVuID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvcyArIDQsIHRydWUpO1xuICAgICAgICBpZiAoZGF0YSA9PSBoZWFkZXIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHBvcyArPSAobGVuICsgOCk7XG4gICAgfVxuICAgIHcuZGF0YUxlbiA9IGxlbjtcbiAgICB3LmRhdGFPZmZzZXQgPSBwb3MgKyA4O1xuICAgIHJldHVybiB3O1xufTtcblxubW9kdWxlLmV4cG9ydHMuTXAzRW5jb2RlciA9IE1wM0VuY29kZXI7XG5tb2R1bGUuZXhwb3J0cy5XYXZIZWFkZXIgPSBXYXZIZWFkZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lamejs/src/js/index.js\n"));

/***/ })

}]);